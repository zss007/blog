{"meta":{"title":"青松的博客","subtitle":"天行健，君子以自强不息；地势坤，君子以厚德载物。","description":"知识分享 & 总结","author":"张松松","url":"http://blog.master-ss.cn"},"pages":[{"title":"categories","date":"2018-12-21T06:36:09.000Z","updated":"2018-12-21T06:36:28.931Z","comments":false,"path":"categories/index.html","permalink":"http://blog.master-ss.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"网络之 https 协议","slug":"essay/https","date":"2019-01-22T01:58:29.765Z","updated":"2019-01-22T02:59:11.710Z","comments":true,"path":"essay/https/","link":"","permalink":"http://blog.master-ss.cn/essay/https/","excerpt":"https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。","text":"https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。 一、http 困境http 协议是明文传递内容，一旦在网络被人监控，数据可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使被截取和窃听，窃听者也无法知道数据的真实内容是什么。 二、加密让我们设想这样一个情景：海绵宝宝想和蟹老板秘密协商新的蟹黄堡配方，如果让你来设计加密过程，你有几种方法呢？ 2.1、对称加密海绵宝宝和蟹老板约定一个密钥，传输和解读都通过这个密钥解密，这个密钥称为公钥。 2.2、非对称加密小心谨慎的蟹老板有一个只有自己知道的密钥(称为私钥)和公钥，他把公钥发给海绵宝宝，海绵宝宝可以通过公钥解密私钥加密的消息，但是公钥加密的消息只有私钥能解开，这在一定程度上做到了单向安全。 2.3、协商那么HTTPS中用的哪种加密方式呢？如果采用对称加密，那么蟹老板和所有人都拥有同一个密钥，这无异于没有加密！！！所以蟹老板需要和每个人协商一个密钥，每个人互不相同，这样就能保证加密了。在HTTPS中，这个协商的过程一般是用非对称加密来进行的。客户端一旦得到了真的服务器公钥，往服务端传消息就是安全的。因为只有服务端的私钥才能解密公钥加密的数据。但是，客户端可没那么容易得到真正的公钥，因为发送公钥的过程存在被别人调包的可能性，这就是传说中的中间人攻击。 2.4、中间人攻击让我们回到情景中。痞老板听闻消息，企图在协商过程通过中间人的方式截取蟹黄包配方。如图，蟹老板想告诉海绵宝宝自己的公钥，此时痞老板出现，替换了蟹老板的公钥，海绵宝宝收到一个来自痞老板的公钥并以为是蟹老板的，由此在之后的传输中痞老板便可以轻松的浏览蟹老板和海绵宝宝的所有沟通内容了。为了防止痞老板窃听，那这个协商的过程也必须加密，这样下去协商加密也要加密，……问题没有穷尽。那怎么办呢？ 2.5、HTTPS 数字证书现在美人鱼战士和企鹅男孩登场了，他们保证作为一个权威中间机构为大家提供认证服务，负责为大家发放统一的公钥。蟹老板先将自己要传输的公钥给美人鱼战士，美人鱼战士用自己的私钥加密后返回给蟹老板。这样大家只要能通过这个公钥解密蟹老板发来的密文，提取蟹老板的公钥，就能保证这个公钥不是来自痞老板。这个时候即便痞老板想替换公钥，伪造的公钥也不能用美人鱼战士的公钥解开了。这就是数字证书。服务器通过CA认证得到证书，这个证书包含CA的私钥加密后的服务器公钥，客户端用预先存储在本地的CA公钥即可解密得到服务器的公钥，从而避免公钥被替换。 2.6、HTTPS 数字签名如果你是痞老板，你有什么方法可以再次窃取消息呢？显然不能通过简单替换公钥来窃取了，海绵宝宝只能解开美人鱼战士颁发的证书，那我也去申请一个证书，直接替换整个证书不就可以从而替换掉公钥了吗？企鹅男孩发现了这个问题，他决定在证书里面添加一些额外的信息以供验证。现在企鹅男孩颁发的证书格式如下：123来自：蟹堡王加密算法：MD5公钥：xxxx（已通过私钥加密，可通过公钥解密） 海绵宝宝只要通过企鹅男孩的公钥提取到“蟹堡王”+“MD5” 计算出一个公钥，与证书内的公钥进行对比，就可以验证证书是否经过替换，如下图。带有签名的证书对比发现证书被替换虽然痞老板依旧可以截取证书，但是他却不能替换其中任何的信息，如下：123来自：痞老板工厂加密算法：MD5公钥：djawdn888 此时海绵宝宝可以发现来自不是蟹堡王而拒绝信任，并且1痞老板工厂 + MD5 !== djawdn888 现在假设蟹堡王+ MD4 = aaaa，那只要修改公钥为aaaa不就可以通过海绵宝宝的验证了吗？痞老板的证书修改如下：123来自：蟹堡王加密算法：MD4公钥：aaaa 实际上并不能，尽管可以修改公钥，但是前面提到，公钥经过企鹅男孩的私钥加密，现在海绵宝宝发现用企鹅男孩的公钥打不开了！于是发现证书已经被篡改了，从而结束通讯。 这便是数字签名的意义。 2.7、小结综上，用一句话总结https：在https协议下，服务器与客户端通过非对称加密的方式协商出一个对称加密的密钥完成加密过程。其中数字证书的作用是避免公钥被替换，而数字签名的作用是校验公钥的合法性。ps：权威机构的公钥是由操作系统和浏览器共同维护，预先存储在本地的。并由上可知 https 具有使用密文，安全性高的优点，同样的，存在协商过程低效，影响用户访问速度的缺点。 三、握手过程明白了HTTPS的原理，握手过程就十分简单，总结如下： 客户端：发送 random1 + 支持的加密算法 + SSL Version 等信息 服务端：发送 random2 + 选择的加密算法 A + 证书 客户端：验证证书 + 公钥加密的 random3 服务端：解密 random3，此时两端共有 random1，random2，random3，使用这3个随机数通过加密算法计算对称密钥即可。 以上只有 random3 是加密的，所以用 random1 + 2 + 3 这3个随机数加密生成密钥。 四、https 服务器4.1、搭建这里以腾讯云为例，首先申请 SSL 证书：企业型、企业型专业版、域名型、域名型免费版、增强型、增强型专业版。如果对安全性要求不是那么高的话，则使用域名型免费版。审批通过后下载证书压缩包（对于中小型企业，如果服务器厂商不提供免费版，也可以在自己服务器上自建 CA 机构）。获取到证书后，将Nginx文件夹目录下的证书文件1_www.domain.com_bundle.crt、私钥文件2_www.domain.com.key保存到同一个目录，如 /etc/nginx/conf.d/ssl 目录下，修改 nginx 配置如下：1234567891011121314server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate /etc/nginx/conf.d/ssl/1_www.domain.com_bundle.crt; ssl_certificate_key /etc/nginx/conf.d/2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; ... &#125;&#125; 配置完成后，请先执行命令 nginx –t 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用https://www.domain.com来访问。 4.2、自动跳转对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。nginx 配置如下：12345server &#123; listen 80; server_name www.domain.com; rewrite ^(.*) https://$host$1 permanent;&#125; 五、参考 海绵宝宝也懂的HTTPS","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"clipboard 之源码","slug":"essay/clipboard3","date":"2019-01-10T08:40:20.171Z","updated":"2019-01-10T09:24:22.664Z","comments":true,"path":"essay/clipboard3/","link":"","permalink":"http://blog.master-ss.cn/essay/clipboard3/","excerpt":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。","text":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。 一、clipboard.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import ClipboardAction from &apos;./clipboard-action&apos;;import Emitter from &apos;tiny-emitter&apos;;import listen from &apos;good-listener&apos;;// 继承 tiny-emitter，存在 on、once、emit、off 方法class Clipboard extends Emitter &#123; /** * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; trigger * @param &#123;Object&#125; options */ constructor(trigger, options) &#123; super(); this.resolveOptions(options); this.listenClick(trigger); &#125; // 定义选项 resolveOptions(options = &#123;&#125;) &#123; this.action = (typeof options.action === &apos;function&apos;) ? options.action : this.defaultAction; this.target = (typeof options.target === &apos;function&apos;) ? options.target : this.defaultTarget; this.text = (typeof options.text === &apos;function&apos;) ? options.text : this.defaultText; this.container = (typeof options.container === &apos;object&apos;) ? options.container : document.body; &#125; // 对触发器添加监听函数 listenClick(trigger) &#123; this.listener = listen(trigger, &apos;click&apos;, (e) =&gt; this.onClick(e)); &#125; // 触发器点击时触发 onClick(e) &#123; const trigger = e.delegateTarget || e.currentTarget; if (this.clipboardAction) &#123; this.clipboardAction = null; &#125; this.clipboardAction = new ClipboardAction(&#123; action : this.action(trigger), target : this.target(trigger), text : this.text(trigger), container : this.container, trigger : trigger, emitter : this &#125;); &#125; // 默认 action defaultAction(trigger) &#123; return getAttributeValue(&apos;action&apos;, trigger); &#125; // 默认 target defaultTarget(trigger) &#123; const selector = getAttributeValue(&apos;target&apos;, trigger); if (selector) &#123; return document.querySelector(selector); &#125; &#125; // 判断是否支持 execCommand 命令 static isSupported(action = [&apos;copy&apos;, &apos;cut&apos;]) &#123; const actions = (typeof action === &apos;string&apos;) ? [action] : action; let support = !!document.queryCommandSupported; actions.forEach((action) =&gt; &#123; support = support &amp;&amp; !!document.queryCommandSupported(action); &#125;); return support; &#125; // 默认 Text defaultText(trigger) &#123; return getAttributeValue(&apos;text&apos;, trigger); &#125; // 调用 destroy 移除事件监听，并调用 clipboardAction 的 destroy 方法 destroy() &#123; this.listener.destroy(); if (this.clipboardAction) &#123; this.clipboardAction.destroy(); this.clipboardAction = null; &#125; &#125;&#125;// 获取 data-clipboard-xxx 属性值function getAttributeValue(suffix, element) &#123; const attribute = `data-clipboard-$&#123;suffix&#125;`; if (!element.hasAttribute(attribute)) &#123; return; &#125; return element.getAttribute(attribute);&#125;module.exports = Clipboard; 二、clipboard-action.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import select from &apos;select&apos;;// 执行 copy 或 cut 操作class ClipboardAction &#123; /** * @param &#123;Object&#125; options */ constructor(options) &#123; this.resolveOptions(options); this.initSelection(); &#125; // 获取属性 resolveOptions(options = &#123;&#125;) &#123; this.action = options.action; this.container = options.container; this.emitter = options.emitter; this.target = options.target; this.text = options.text; this.trigger = options.trigger; this.selectedText = &apos;&apos;; &#125; // 根据 text 和 target 选择不同的策略 initSelection() &#123; if (this.text) &#123; this.selectFake(); &#125; else if (this.target) &#123; this.selectTarget(); &#125; &#125; // 创建一个 textarea 元素，为它设置值，并选中 selectFake() &#123; const isRTL = document.documentElement.getAttribute(&apos;dir&apos;) == &apos;rtl&apos;; this.removeFake(); this.fakeHandlerCallback = () =&gt; this.removeFake(); this.fakeHandler = this.container.addEventListener(&apos;click&apos;, this.fakeHandlerCallback) || true; this.fakeElem = document.createElement(&apos;textarea&apos;); // Prevent zooming on iOS this.fakeElem.style.fontSize = &apos;12pt&apos;; // Reset box model this.fakeElem.style.border = &apos;0&apos;; this.fakeElem.style.padding = &apos;0&apos;; this.fakeElem.style.margin = &apos;0&apos;; // Move element out of screen horizontally this.fakeElem.style.position = &apos;absolute&apos;; this.fakeElem.style[ isRTL ? &apos;right&apos; : &apos;left&apos; ] = &apos;-9999px&apos;; // Move element to the same position vertically let yPosition = window.pageYOffset || document.documentElement.scrollTop; this.fakeElem.style.top = `$&#123;yPosition&#125;px`; this.fakeElem.setAttribute(&apos;readonly&apos;, &apos;&apos;); this.fakeElem.value = this.text; this.container.appendChild(this.fakeElem); this.selectedText = select(this.fakeElem); this.copyText(); &#125; // 移除添加的元素，只在点击后才移除，因为用户可能使用 `Ctrl+C` 来赋值当前选中的值 removeFake() &#123; if (this.fakeHandler) &#123; this.container.removeEventListener(&apos;click&apos;, this.fakeHandlerCallback); this.fakeHandler = null; this.fakeHandlerCallback = null; &#125; if (this.fakeElem) &#123; this.container.removeChild(this.fakeElem); this.fakeElem = null; &#125; &#125; // 选中目标元素 selectTarget() &#123; this.selectedText = select(this.target); this.copyText(); &#125; // 在当前选中的元素上执行 copy 操作 copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand(this.action); &#125; catch (err) &#123; succeeded = false; &#125; this.handleResult(succeeded); &#125; // 触发 copy 操作的回调函数 handleResult(succeeded) &#123; this.emitter.emit(succeeded ? &apos;success&apos; : &apos;error&apos;, &#123; action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) &#125;); &#125; // 将焦点从目标元素移动到触发器，并移除 selection clearSelection() &#123; if (this.trigger) &#123; this.trigger.focus(); &#125; window.getSelection().removeAllRanges(); &#125; // 设置 action，并检测操作 set action(action = &apos;copy&apos;) &#123; this._action = action; if (this._action !== &apos;copy&apos; &amp;&amp; this._action !== &apos;cut&apos;) &#123; throw new Error(&apos;Invalid &quot;action&quot; value, use either &quot;copy&quot; or &quot;cut&quot;&apos;); &#125; &#125; get action() &#123; return this._action; &#125; // 设置 target 并判断 set target(target) &#123; if (target !== undefined) &#123; if (target &amp;&amp; typeof target === &apos;object&apos; &amp;&amp; target.nodeType === 1) &#123; if (this.action === &apos;copy&apos; &amp;&amp; target.hasAttribute(&apos;disabled&apos;)) &#123; throw new Error(&apos;Invalid &quot;target&quot; attribute. Please use &quot;readonly&quot; instead of &quot;disabled&quot; attribute&apos;); &#125; if (this.action === &apos;cut&apos; &amp;&amp; (target.hasAttribute(&apos;readonly&apos;) || target.hasAttribute(&apos;disabled&apos;))) &#123; throw new Error(&apos;Invalid &quot;target&quot; attribute. You can\\&apos;t cut text from elements with &quot;readonly&quot; or &quot;disabled&quot; attributes&apos;); &#125; this._target = target; &#125; else &#123; throw new Error(&apos;Invalid &quot;target&quot; value, use a valid Element&apos;); &#125; &#125; &#125; get target() &#123; return this._target; &#125; // 销毁 destroy() &#123; this.removeFake(); &#125;&#125;module.exports = ClipboardAction;","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"clipboard 之依赖","slug":"essay/clipboard2","date":"2019-01-10T07:41:18.150Z","updated":"2019-01-10T08:05:45.219Z","comments":true,"path":"essay/clipboard2/","link":"","permalink":"http://blog.master-ss.cn/essay/clipboard2/","excerpt":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。","text":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。 一、select12345678910111213141516171819202122232425262728293031323334353637383940414243444546function select(element) &#123; var selectedText; &lt;!-- 表单元素下拉框 --&gt; if (element.nodeName === &apos;SELECT&apos;) &#123; element.focus(); selectedText = element.value; &#125; &lt;!-- input 或者 textarea --&gt; else if (element.nodeName === &apos;INPUT&apos; || element.nodeName === &apos;TEXTAREA&apos;) &#123; var isReadOnly = element.hasAttribute(&apos;readonly&apos;); if (!isReadOnly) &#123; element.setAttribute(&apos;readonly&apos;, &apos;&apos;); &#125; element.select(); element.setSelectionRange(0, element.value.length); if (!isReadOnly) &#123; element.removeAttribute(&apos;readonly&apos;); &#125; selectedText = element.value; &#125; &lt;!-- 其他 DOM 元素 --&gt; else &#123; if (element.hasAttribute(&apos;contenteditable&apos;)) &#123; element.focus(); &#125; var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(element); selection.removeAllRanges(); selection.addRange(range); selectedText = selection.toString(); &#125; return selectedText;&#125;module.exports = select; 可以看到select包非常精简，主要用来选中元素，并复制元素值。其中有以下知识点： 如果元素是 input 或者 textarea，则调用 select api 选中元素，其中 select 方法是选中所有文本，而 setSelectionRange 这个方法可以接收起始位置，终止位置，和方向要看到选择的文本； contenteditable 属性规定元素内容是否可编辑，可以使&lt;p&gt;等标签变成可编辑状态； getSelection 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置； createRange 返回一个 Range 对象，Range 表示包含节点和部分文本节点的文档片段； selection().toString() 获取选中的内容 二、tiny-emitter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function E () &#123; // Keep this empty so it&apos;s easier to inherit from // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)&#125;E.prototype = &#123; on: function (name, callback, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); (e[name] || (e[name] = [])).push(&#123; fn: callback, ctx: ctx &#125;); return this; &#125;, once: function (name, callback, ctx) &#123; var self = this; function listener () &#123; self.off(name, listener); callback.apply(ctx, arguments); &#125;; listener._ = callback return this.on(name, listener, ctx); &#125;, emit: function (name) &#123; var data = [].slice.call(arguments, 1); var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice(); var i = 0; var len = evtArr.length; for (i; i &lt; len; i++) &#123; evtArr[i].fn.apply(evtArr[i].ctx, data); &#125; return this; &#125;, off: function (name, callback) &#123; var e = this.e || (this.e = &#123;&#125;); var evts = e[name]; var liveEvents = []; if (evts &amp;&amp; callback) &#123; for (var i = 0, len = evts.length; i &lt; len; i++) &#123; // 为了兼容 once if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback) liveEvents.push(evts[i]); &#125; &#125; // Remove event from queue to prevent memory leak // Suggested by https://github.com/lazd // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910 (liveEvents.length) ? e[name] = liveEvents : delete e[name]; return this; &#125;&#125;;module.exports = E; 事件管理模型主要由 4 个函数构成： on 用于订阅事件，一个事件订阅多个触发函数 emit 用于发布事件，发布时会以此触发事件订阅的函数 once 订阅的事件只触发一次 off 取消订阅事件，支持指定取消，批量取消和全部取消 三、good-listener12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!-- 类型判断，不展开说明 --&gt;var is = require(&apos;./is&apos;);&lt;!-- 事件委托，不展开说明 --&gt;var delegate = require(&apos;delegate&apos;);/** * Validates all params and calls the right * listener function based on its target type. * * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; target * @param &#123;String&#125; type * @param &#123;Function&#125; callback * @return &#123;Object&#125; */function listen(target, type, callback) &#123; if (!target &amp;&amp; !type &amp;&amp; !callback) &#123; throw new Error(&apos;Missing required arguments&apos;); &#125; if (!is.string(type)) &#123; throw new TypeError(&apos;Second argument must be a String&apos;); &#125; if (!is.fn(callback)) &#123; throw new TypeError(&apos;Third argument must be a Function&apos;); &#125; if (is.node(target)) &#123; return listenNode(target, type, callback); &#125; else if (is.nodeList(target)) &#123; return listenNodeList(target, type, callback); &#125; else if (is.string(target)) &#123; return listenSelector(target, type, callback); &#125; else &#123; throw new TypeError(&apos;First argument must be a String, HTMLElement, HTMLCollection, or NodeList&apos;); &#125;&#125;/** * Adds an event listener to a HTML element * and returns a remove listener function. * * @param &#123;HTMLElement&#125; node * @param &#123;String&#125; type * @param &#123;Function&#125; callback * @return &#123;Object&#125; */function listenNode(node, type, callback) &#123; node.addEventListener(type, callback); return &#123; destroy: function() &#123; node.removeEventListener(type, callback); &#125; &#125;&#125;/** * Add an event listener to a list of HTML elements * and returns a remove listener function. * * @param &#123;NodeList|HTMLCollection&#125; nodeList * @param &#123;String&#125; type * @param &#123;Function&#125; callback * @return &#123;Object&#125; */function listenNodeList(nodeList, type, callback) &#123; Array.prototype.forEach.call(nodeList, function(node) &#123; node.addEventListener(type, callback); &#125;); return &#123; destroy: function() &#123; Array.prototype.forEach.call(nodeList, function(node) &#123; node.removeEventListener(type, callback); &#125;); &#125; &#125;&#125;/** * Add an event listener to a selector * and returns a remove listener function. * * @param &#123;String&#125; selector * @param &#123;String&#125; type * @param &#123;Function&#125; callback * @return &#123;Object&#125; */function listenSelector(selector, type, callback) &#123; return delegate(document.body, selector, type, callback);&#125;module.exports = listen; 可以看到good-listener包就是在元素上添加事件监听，并且返回对象，其含 destroy 属性，即移除事件的函数。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"clipboard 之介绍","slug":"essay/clipboard1","date":"2019-01-10T06:10:00.969Z","updated":"2019-01-10T07:38:01.415Z","comments":true,"path":"essay/clipboard1/","link":"","permalink":"http://blog.master-ss.cn/essay/clipboard1/","excerpt":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。","text":"最近有用到粘贴复制功能，调用了clipboard.js库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。 一、为什么使用它复制文字到剪切板不应该很难去实现。它不需要配置几十个步骤或者加载几百 KB 的文件。最重要的是，它不应该依赖 Flash 或其他臃肿的框架。这是 clipboard.js 诞生的原因。 二、开始1npm install clipboard --save 可以通过 npm 来安装它，如果你不使用包管理，仅需要下载一个 ZIP 文件。首先，引入位于 dist 目录下的脚本文件，或者引入一个第三方CDN。1&lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt; 然后，你需要通过传入一个DOM 选择器, HTML 元素, 或者 HTML 元素数组作为参数，来实例化对象。1new Clipboard(&apos;.btn&apos;); 本质上，我们需要获取所有选择器匹配到的元素，并为每一个选择器设置监听事件。但仔细想想，如果有成百上千个匹配到的元素，这样做会耗费大量内存。因此，我们使用事件代理，通过一个事件监听器来取代多个事件监听。毕竟，性能是问题。 三、使用我们正在经历一场声明式的复兴，这就是为什么我们决定利用 HTML5 data 属性 来提高可用性的原因。 3.1、从另一个元素复制文本一个很常见的用例是从另一个元素复制内容。你可以给目标元素添加一个data-clipboard-target属性来实现这个功能。这个属性的值就是能匹配到另一个元素的选择器。1234567&lt;!-- Target --&gt;&lt;input id=&quot;foo&quot; value=&quot;https://github.com/zenorocha/clipboard.js.git&quot;&gt;&lt;!-- Trigger --&gt;&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#foo&quot;&gt; &lt;img src=&quot;assets/clippy.svg&quot; alt=&quot;Copy to clipboard&quot;&gt;&lt;/button&gt; 3.2、从另一个元素剪切文本此外，你可以定义一个data-clipboard-action属性来指明你想要复制（copy）还是剪切（cut）内容。如果你省略这个属性，则默认为复制（copy）。正如你所预料的，剪切（cut）动作只在&lt;input&gt;或&lt;textarea&gt;元素起作用。1234567&lt;!-- Target --&gt;&lt;textarea id=&quot;bar&quot;&gt;Mussum ipsum cacilds...&lt;/textarea&gt;&lt;!-- Trigger --&gt;&lt;button class=&quot;btn&quot; data-clipboard-action=&quot;cut&quot; data-clipboard-target=&quot;#bar&quot;&gt; Cut to clipboard&lt;/button&gt; 3.3、从属性复制文本事实上，你甚至不需要从另一个元素来复制内容。你仅需要给目标元素设置一个data-clipboard-text属性就可以了。1234&lt;!-- Trigger --&gt;&lt;button class=&quot;btn&quot; data-clipboard-text=&quot;Just because you can doesn&apos;t mean you should — clipboard.js&quot;&gt; Copy to clipboard&lt;/button&gt; 四、事件如果你想要展示一些用户反馈，或者在用户复制/剪切后获取已经选择的文字，这里有个示例供你参考。我们通过触发自定义事件，例如success和error，让你可以设置监听并实现自定义逻辑。1234567891011121314var clipboard = new Clipboard(&apos;.btn&apos;);clipboard.on(&apos;success&apos;, function(e) &#123; console.info(&apos;Action:&apos;, e.action); console.info(&apos;Text:&apos;, e.text); console.info(&apos;Trigger:&apos;, e.trigger); e.clearSelection();&#125;);clipboard.on(&apos;error&apos;, function(e) &#123; console.error(&apos;Action:&apos;, e.action); console.error(&apos;Trigger:&apos;, e.trigger);&#125;); 五、高级选项如果你不想修改 HTML，我们提供了一个非常方面的命令式的 API 给你使用。你需要做的就是声明一个函数，做一些处理，并返回一个值。例如，如果你希望动态设置 target，你需要返回一个节点（Node）.12345new Clipboard(&apos;.btn&apos;, &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125;&#125;); 如果你希望动态设置 text，你需要返回一个字符串。12345new Clipboard(&apos;.btn&apos;, &#123; text: function(trigger) &#123; return trigger.getAttribute(&apos;aria-label&apos;); &#125;&#125;); 如果在 Bootstrap 模态框（Modals）中使用，或是在其他修改焦点的类库中使用，你会希望将获得焦点的元素设置为 container 属性的值。123new Clipboard(&apos;.btn&apos;, &#123; container: document.getElementById(&apos;modal&apos;)&#125;); 同样地，如果你使用单页应用，你可能想要更加精确地管理 DOM 的生命周期。你可以清理事件以及创建的对象。12var clipboard = new Clipboard(&apos;.btn&apos;);clipboard.destroy(); 六、浏览器支持这个库依赖于 Selection 和 execCommand 的 API。前者 兼容所有的浏览器，后者兼容以下浏览器。好消息是，如果你需要支持旧浏览器，clipboard.js 可以优雅降级。你所要做的就是在success事件触发时提示用户“已复制！”，error事件触发时提示用户“按 Ctrl+C 复制文字”（此时用户要复制的文字已经选择了）。你也可以通过运行Clipboard.isSupported()来检查浏览器是否支持 clipboard.js，如果不支持，你可以隐藏复制/剪切按钮。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"hexo 之博客建站","slug":"essay/hexo","date":"2018-12-23T02:37:39.539Z","updated":"2018-12-23T03:16:02.853Z","comments":true,"path":"essay/hexo/","link":"","permalink":"http://blog.master-ss.cn/essay/hexo/","excerpt":"主要总结分享下我用 hexo 建站的过程。","text":"主要总结分享下我用 hexo 建站的过程。 一、基础1.1、概述Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.2、建站1234567891011121314151617181920&lt;!-- 安装全局依赖 --&gt;npm install -g hexo-cli&lt;!-- 初始化工程项目 --&gt;hexo init blog&lt;!-- 进入目录 --&gt;cd blog&lt;!-- 安装依赖 --&gt;npm i&lt;!-- 开启本地服务 --&gt;hexo s&lt;!-- 编译生成静态文件 --&gt;hexo g&lt;!-- 清除缓存 --&gt;hexo clean 二、进阶2.1、安装主题默认主题是 landscape，这里选择 indigo 主题。12345678910111213141516&lt;!-- 安装主题 --&gt;git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo&lt;!-- 安装主题依赖包 --&gt;npm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-json-content --savenpm install hexo-helper-qrcode --save&lt;!-- 开启分类页 --&gt;hexo new page categories&lt;!-- 修改 hexo/source/categories/index.md 数据 --&gt;layout: categoriescomments: false--- 2.2、配置主题更详细配置信息参考官方主题文档1234567891011121314151617&lt;!-- 编辑站点配置文件，/_config.yml，启用主题，且配置基础信息 --&gt;theme: indigo&lt;!-- 修改访问链接和目录格式 --&gt;url: http://blog.master-ss.cnpermalink: :title/&lt;!-- 配置主题 /themes/indigo/_config.yml --&gt;1、配置菜单2、配置 favicon3、配置头像4、配置 email5、替换打赏图片6、配置 ‘ICP 备案号’7、修改留言信息 postMessage8、修改版权起始年份 since_year9、启用 valine 评论插件 2.3、部署截止目前我们就可以在本地进行文档的书写了，但是想要 hexo d 就部署到 git 上还是不够，需要进行以下操作。12345678&lt;!-- 编辑站点配置文件，/_config.yml，配置部署仓库、类型和分支 --&gt;deploy: type: git repo: https://github.com/zss007/blog.git branch: gh-pages&lt;!-- 安装部署依赖包 --&gt;npm install hexo-deployer-git –save 2.4、注意事项由于我们是使用 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 方式进行主题安装，所以我们在提交代码到 git 时 /themes/indigo 文件夹中的所有文件均不会被提交。所以如果想刚才修改配置的主题信息同样提交到 git 上的话，可以 cd /themes/indigo，如果移除主题的仓库信息，即 rm -rf .git。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"css 之 H5 终端适配","slug":"css/flexible","date":"2018-12-22T08:58:39.151Z","updated":"2018-12-22T14:21:24.023Z","comments":true,"path":"css/flexible/","link":"","permalink":"http://blog.master-ss.cn/css/flexible/","excerpt":"这节主要是研究手淘团队的适配方案 amfe-flexible，及源码解析。","text":"这节主要是研究手淘团队的适配方案 amfe-flexible，及源码解析。 一、基础1.1、css 中的 1px 并不等于设备的 1px在 css 中我们一般使用 px 作为单位，在桌面浏览器中 css 的 1 个像素往往都是对应着电脑屏幕的 1 个物理像素，这可能会造成我们的一个错觉，那就是 css 中的像素就是设备的物理像素。但实际情况却并非如此，css 中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css 中的 1px 所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如 iphone3，它的分辨率为 320x480，在 iphone3 上，一个 css 像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从 iphone4 开始，苹果公司便推出了所谓的 Retina 屏，分辨率提高了一倍，变成 640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个 css 像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为 ldpi、mdpi、hdpi、xhdpi 等不同的等级，分辨率也是五花八门，安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。 1.2、devicePixelRatio在移动端浏览器中以及某些桌面浏览器中，window 对象有一个 devicePixelRatio 属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css 中的 px 就可以看做是设备的独立像素，所以通过 devicePixelRatio，我们可以知道该设备上一个 css 像素代表多少个物理像素。例如，在 Retina 屏的iphone上，devicePixelRatio 的值为 2，也就是说 1 个 css 像素相当于 2 个物理像素。 二、源码分析2.1、源码1234567891011121314151617181920212223242526272829303132333435363738394041424344(function flexible (window, document) &#123; var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 // adjust body font size function setBodyFontSize () &#123; if (document.body) &#123; document.body.style.fontSize = (12 * dpr) + &apos;px&apos; &#125; else &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize) &#125; &#125; setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + &apos;px&apos; &#125; setRemUnit() // reset rem unit on page resize window.addEventListener(&apos;resize&apos;, setRemUnit) window.addEventListener(&apos;pageshow&apos;, function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125; &#125;) // detect 0.5px supports if (dpr &gt;= 2) &#123; var fakeBody = document.createElement(&apos;body&apos;) var testElement = document.createElement(&apos;div&apos;) testElement.style.border = &apos;.5px solid transparent&apos; fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) &#123; docEl.classList.add(&apos;hairlines&apos;) &#125; docEl.removeChild(fakeBody) &#125;&#125;(window, document)) 2.2、源码分析 setBodyFontSize 用来设置 body 的 fontSize，值为 (12 * dpr) + ‘px’ setRemUnit 用来设置 document.documentElement 即 html 标签的 fontSize，值为 clientWidth 的 1/10 resize、pageshow 在窗口大小调整或从缓存中载入页面时，重新调用 setRemUnit 2.3、.5px 方案2014 年的 WWDC 大会中，Ted O’Conor 在分享 “设计响应的Web体验” 主题时提到关于 Retina Hairlines 一词，也就是 Retina 极细的线：在 Retina 屏上仅仅显示 1 物理像素的边框。amfe-flexible 的源码中，在页面上添加 div 元素，设置边框为 0.5px，并判断 offsetHeight 是否为 1 来判断是否支持 .5px，即如果支持 .5px 的话，那么在其 html 标签上添加 hairlines 类。这样就可以在写样式时进行 ”渐进增强“，即在支持 .5px 时使用其来显示极细的线。","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"js 之面对对象","slug":"js/extend","date":"2018-10-14T14:06:31.000Z","updated":"2018-10-14T14:13:59.000Z","comments":true,"path":"js/extend/","link":"","permalink":"http://blog.master-ss.cn/js/extend/","excerpt":"本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。","text":"本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。 一、类的声明和实例化1234567891011121314// 类的声明function Animal() &#123; this.name = &apos;name&apos;&#125;// ES6 中的 class 声明class Animal2 &#123; constructor() &#123; this.name = &apos;name&apos; &#125;&#125;// 类的实例化console.log(new Animal(), new Animal2()) 二、构造函数继承1234567891011121314function Parent1() &#123; this.name = &apos;parent1&apos;;&#125;Parent1.prototype.say = function () &#123;&#125;;function Child1() &#123; Parent1.call(this); this.type = &apos;child1&apos;;&#125;console.log(new Child1()); // Child1 &#123;name: &quot;parent1&quot;, type: &quot;child1&quot;&#125;console.log(new Child1().say()); // Uncaught TypeError: xxx say is not a function 优点：继承了 Parent1 的 name 属性；缺点：没有继承 Parent1 原型链上的方法。 二、原型链方法继承123456789101112131415161718192021function Parent2() &#123; this.name = &apos;parent2&apos;; this.play = [1, 2, 3];&#125;Parent2.prototype.say = function () &#123; console.log(&apos;Parent2 say&apos;);&#125;;function Child2() &#123; this.type = &apos;child2&apos;;&#125;Child2.prototype = new Parent2();var s1 = new Child2();s1.say(); //P arent2 sayconsole.log(s1.name, s1.type); // parent2 child2var s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play); // [1, 2, 3, 4]、[1, 2, 3, 4] 优点：不仅继承了 Parent2 的 name、play 属性而且继承了其原型链上的方法；缺点：由于将 Parent2 的实例作为 Child2 的原型，导致所有 Child2 实例共享 Parent2 的属性方法，其中一个 Child2 实例改变了原型链上 Parent2 的实例属性，其他实例会受到影响跟着改变。 三、组合方法继承12345678910111213141516function Parent3 () &#123; this.name = &apos;parent3&apos;; this.play = [1, 2, 3];&#125;function Child3 () &#123; Parent3.call(this); this.type = &apos;child3&apos;;&#125;Child3.prototype = new Parent3();var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play); // [1, 2, 3, 4]、[1, 2, 3] 优点：避免了原型链方法中出现的实例间相互影响(调用 Parent3.call(this) 使得 Child3 实例上有 play 属性，不必找到原型链上)；缺点：每次得到一个 Child3 实例，都会调用两次 Parent3 函数。 四、组合方法(优化一)123456789101112131415161718function Parent4 () &#123; this.name = &apos;parent4&apos;; this.play = [1, 2, 3];&#125;function Child4 () &#123; Parent4.call(this); this.type = &apos;child4&apos;;&#125;Child4.prototype = Parent4.prototype;var s5 = new Child4();var s6 = new Child4();console.log(s5); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;console.log(s6); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;console.log(s5 instanceof Child4, s5 instanceof Parent4); // true trueconsole.log(s5.constructor); // Parent4() &#123;this.name = &apos;parent4&apos;;this.play = [1, 2, 3];&#125; 优点：避免了 Parent4 重复调用问题；缺点：Child4 实例的构造函数不是 Child4，而是 Parent4(其实这不是优化带来的问题，优化前同样存在这个问题,赋值后 child 上的 constructor 只能在原型链上查找) 五、组合方法(优化二)12345678910111213141516function Parent5 () &#123; this.name = &apos;parent5&apos;; this.play = [1, 2, 3];&#125;function Child5 () &#123; Parent5.call(this); this.type = &apos;child5&apos;;&#125;Child5.prototype = Object.create(Parent5.prototype);Child5.prototype.constructor = Child5;var s7 = new Child5();console.log(s7 instanceof Child5, s7 instanceof Parent5); //true trueconsole.log(s7.constructor); //Child5() &#123;Parent5.call(this);this.type = &apos;child5&apos;;&#125; 优点：Child5 实例的构造函数是 Child5(这里采用 Object.create 方法而不是直接 Parent4.prototype 赋值，直接赋值会影响到 Parent5 实例的构造函数)。","categories":[{"name":"js","slug":"js","permalink":"http://blog.master-ss.cn/categories/js/"}],"tags":[]},{"title":"js 之原型链","slug":"js/prototype","date":"2018-10-14T07:42:12.000Z","updated":"2018-10-14T15:11:05.000Z","comments":true,"path":"js/prototype/","link":"","permalink":"http://blog.master-ss.cn/js/prototype/","excerpt":"JavaScript 的原型有好好的研究过，现在重新捡起来整理下。","text":"JavaScript 的原型有好好的研究过，现在重新捡起来整理下。 一、创建对象1.1、对面字向量 | new Object12var o1 = &#123;name:&apos;o1&apos;&#125;var o11 = new Object(&#123;name:&apos;o11&apos;&#125;) 1.2、new 创建12var M = function()&#123;this.name=&apos;o2&apos;&#125;var o2 = new M() 1.3、Object.create()12var P = &#123;name:&apos;o3&apos;&#125;var o3 = Object.create(P) 二、protoJS 的原始数据类型有六种：undefined、null、boolean、string、number、Symbol。引用类型通常叫做类，常见有：array、object 等。引用类型 object 的每个实例称之为对象，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则__proto__，通过它可以从中继承原型对象的属性，原型是 JavaScript 中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的__proto__可以访问到他所继承的原型对象。12var a = new Array();console.log(&apos;prototype&apos;, a.__proto__ === Array.prototype); // true Array.prototype 本身也是一个对象，也有继承的原型：123a.__proto__.__proto__ === Object.prototype // true// 等同于 Array.prototype.__proto__ === Object.prototype // true 这就说明，array 本身也是继承自 object，而 object 的原型则是指向原始类型 null。123a.__proto__.__proto__.__proto__ === null // true// 等同于 Object.prototype.__proto__ === null // true 除了使用__proto__方法访问对象的原型，还可以通过 Object.getPrototypeOf 方法来获取对象的原型，以及通过Object.setPrototypeOf 方法来重写对象的原型。值得注意的是，按照语言的标准，__proto__属性只有浏览器才能部署，其他环境可以没有这个属性，而且前后的两根下划线表示它本地是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 Object.getPrototypeOf 和 Object.setPrototypeOf，进行原型对象的读写操作。这里用__proto__属性来描述对象中的原型，是因为这样来的更加形象，而且容易理解。 三、prototype函数作为 JavaScript 中的一等公民，它既是函数又是对象，函数的原型指向 Function.prototype。12var Foo = function() &#123;&#125;Foo.__proto__ === Function.prototype // true 函数实例除了拥有__proto__属性之外，还拥有 prototype 属性。通过该函数构造的实例对象，其原型指针__proto__会指向该函数的 prototype 属性。12var a = new Foo();a.__proto__ === Foo.prototype; // true 而函数的 prototype 属性，本身是一个由 object 构造的实例对象。12345Foo.prototype.__proto__ === Object.prototype; // true// prototype 属性很特殊，它还有一个隐式的 constructor，指向了构造函数本身。Foo.prototype.constructor === Foo; // truea.constructor === Foo; // truea.constructor === Foo.prototype.constructor; // true 四、原型链原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，如此就构造了原型链的基本概念。“原型链”的作用在于，当读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的 Object.prototype 还是找不到，则返回 undefined。 五、判断方法原始数据类型一般使用 typeof 来判断（两种情况下回返回 undefined：1、变量没有声明；2、变量为 undefined）。 typeof null 返回 object，其他引用类型均返回 object。 instanceof 判断是否由某个构造函数创建，返回 boolean 类型值（只要处在原型链上就返回 true，可使用 __proto__.constructor准确返回构造函数）。 Object.isPrototypeOf() 只要某个对象处在原型链上，isProtypeOf 都返回 true 1234567var Bar = function() &#123;&#125;var b = new Bar();b instanceof Bar // trueb instanceof Object // trueb.__proto__.constructor // ƒ Bar() &#123;&#125;Bar.prototype.isPrototypeOf(b) // trueObject.prototype.isPrototypeOf(Bar) // true 要注意，实例 b 的原型是 Bar.prototype 而不是 Bar。从上图中，能看到一个有趣的地方。Function.prototype.__proto__指向了 Object.prototype，这说明Function.prototype 是一个 Object 实例，那么应当是先有的 Object 再有 Function。但是Object.prototype.constructor.__proto__又指向了 Function.prototype。这样看来，没有 Function，Object 也不能创建实例。 这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的 Object 还是先有的 Function 呢？ 六、Object.create1234function Point()&#123;&#125;;var Circle = Object.create(Point);console.log(Circle.__proto__ === Point); // trueconsole.log(Circle.__proto__ === Point.prototype); // false 使用指定的原型对象和其属性创建了一个新的对象，在例子中实例 Circle 的原型指向 Point。 七、new 运算符使用 new 运算符创建对象过程如下： 7.1、一个新对象被创建，他继承自 foo.prototype 7.2、构造函数 foo 被执行，执行的时候相应的传参会被传入，同时上下文（this）会被指定为这个新实例，new foo 等同于 new foo()，只能用在不传递任何参数的情况 7.3、如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果，如果构造函数没有返回对象，那么 new 出来的结果是步骤 7.1 创建的对象 123456789var new2 = function (func) &#123; var o = Object.create(func.prototype) var k = func.call(o) if (typeof k === &apos;object&apos;) &#123; return k &#125; else &#123; return o &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://blog.master-ss.cn/categories/js/"}],"tags":[]},{"title":"网络之 http 协议","slug":"essay/http","date":"2018-10-14T06:44:09.000Z","updated":"2019-01-10T06:04:38.979Z","comments":true,"path":"essay/http/","link":"","permalink":"http://blog.master-ss.cn/essay/http/","excerpt":"HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。","text":"HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。 一、http 协议特点 简单快速 灵活 无状态 无连接 二、报文组成部分2.1、请求报文 请求行：http 方法、页面地址、http 协议以及版本； 请求头 空行：隔开请求头和请求体； 请求体 2.2、响应报文 状态行：http 协议以及版本号、http 状态码； 响应头 空行：隔开响应头和响应体； 响应体 三、方法 GET：获取资源 POST：传输资源 PUT：更新资源 DELETE：删除资源 HEAD：获取报文首部 四、GET &amp; POST GET 在浏览器回退时是无害的，而 POST 会再次提交请求 GET 产生的 URL 地址可以被收藏，而 POST 不可以 GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置 GET 请求只能进行 url 编码，而 POST 支持多种编码方式 GET 请求参数会被完整的保留在浏览器历史记录里，而 POST 中的参数不会被保留 GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制 GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息 GET 参数通过 URL 传递，POST 放在 Request body 中 五、状态码 1XX：信息相关 2XX：成功 204 no content 3XX：重定向 301 304 4XX：客户端错误 401 403 404 5XX：服务器错误 500 持久链接 &amp; 管线化 持久链接使用 keep-alive，不用每次都重新建立一次连接，需要 http 1.1 通常 keep-alive 是 Q1 -&gt; R1 -&gt; Q2 -&gt; R2，而管线化后是 Q1 -&gt; Q2 -&gt; R1 -&gt; R2，需要通过持久连接完成且要求服务端支持","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"js 之类型转换","slug":"js/type","date":"2018-10-13T03:13:41.000Z","updated":"2018-10-13T03:26:21.000Z","comments":true,"path":"js/type/","link":"","permalink":"http://blog.master-ss.cn/js/type/","excerpt":"JS 基础常考内容，一定要融会贯通。","text":"JS 基础常考内容，一定要融会贯通。 一、数据类型JS 中有 7 中数据类型：原始数据类型： Null、Boolean、String、Number、Symbol、Undefined复合数据类型： Object 二、显式类型转换先说明下面几个函数：valueOf(): 将该对象原始值返回toString(): 将该对象原始值以字符串返回 Number 转换 12345678// 基本数据转换Number(1) // 数字： 数字 -&gt; 数字Number(&apos;123&apos;) // 字符串： 纯数字 -&gt; 数字，不是纯数字 -&gt; NaN，空字符串 -&gt; 0Number(true) // 布尔值： true -&gt; 1，false -&gt; 0Number(undefined) // NaNNumber(null) // 0// 复合类型数据转换// 先调用 valueOf，如果输出为基本类型，则调用 Number，如果为复合类型，继续调用 toString，如果还不是基本数据类型就报错，如果是则调用 Number String 转换 1234567// String() 很简单，就是将这些基本类型都变成字符串：// 123 -&gt; &apos;123&apos;// true -&gt; &apos;true&apos;// undefined -&gt; &apos;undefined&apos;// null -&gt; &apos;null&apos;// 复合类型转换// 先调用 toString，如果输出为基本类型，则调用 String，如果为复合类型，继续调用 valueOf，如果还不是基本数据类型就报错，如果是则调用 String Boolean 转换+0、-0、undefined、null、’’、NaN -&gt; false，其余都为 true 三、显式类型转换 四则运算 判断语句 Native 调用: 比如说 console.log()、alert() 1234567891011// Boolean()![] // false!![] // true!&#123;&#125; // false!!&#123;&#125; // true[]+[] // &quot;&quot;，调用 String 处理 [][]+1 // &quot;1&quot;，调用 String 处理 []&#123;&#125;+&#123;&#125; // &quot;[object Object][object Object]&quot;，这里 chrome 和 firefox 解释不同&#123;&#125;+[] // 0，这里 &#123;&#125; 被当前代码块，不做任何处理，然后调用 Number 处理 [][]+&#123;&#125; // &quot;[object Object]&quot;，调用 String 处理 [] 和 &#123;&#125;1+&#123;&#125; // &quot;1[object Object]&quot;，调用 &#123;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://blog.master-ss.cn/categories/js/"}],"tags":[]},{"title":"js 之 DOM 事件","slug":"js/dom","date":"2018-10-13T02:16:29.000Z","updated":"2018-10-13T02:31:21.000Z","comments":true,"path":"js/dom/","link":"","permalink":"http://blog.master-ss.cn/js/dom/","excerpt":"HTML DOM 允许 JavaScript 对 HTML 事件作出反应。","text":"HTML DOM 允许 JavaScript 对 HTML 事件作出反应。 一、DOM 事件级别 DOM0 级：DOM0 级事件就是将一个函数赋值给一个事件处理属性，element.onclick=function(){} DOM1 级：没有与事件相关的东西 DOM2 级：DOM2 级事件定义了 addEventListener 和 removeEventListener 两个方法，分别用来绑定和解绑事件，element.addEventListener(‘click’,function(){},false) DOM3 级：DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，element.addEventListener(‘keyup’,function(){},false) 二、DOM 事件模型 &amp; 事件流 冒泡：从当前元素到最外层元素 捕获：从最外层元素到目标元素 事件流：捕获 -&gt; 目标阶段 -&gt; 冒泡 三、描述 Dom 事件流捕获的具体流程 window - document - html - body - … - 目标元素 获取 html 标签：document.documentElement 四、Event 对象常见应用 e.preventDefault() e.stopPropagation() e.target: 获取触发事件的元素 e.currentTarget: 指的是绑定事件的元素 e.stopImmediatePropagation: 事件响应优先级 五、自定义事件12345678910111213const eve = new Event(&apos;custom&apos;);ev.addEventListener(&apos;custom&apos;, () =&gt; &#123; ...&#125;);ev.dispathEvent(eve);// Event 不足，只能指定事件名，如果要传参数，可以使用 CustomEvent，如：var obj = document// 添加一个适当的事件监听器obj.addEventListener(&quot;cat&quot;, function (e) &#123; console.log(e.detail) &#125;)// 创建并分发事件var event = new CustomEvent(&quot;cat&quot;, &#123; &quot;detail&quot;: &#123; &quot;hazcheeseburger&quot;: true &#125; &#125;)obj.dispatchEvent(event)","categories":[{"name":"js","slug":"js","permalink":"http://blog.master-ss.cn/categories/js/"}],"tags":[]},{"title":"css 之盒模型及 BFC","slug":"css/boxer","date":"2018-10-13T01:55:58.000Z","updated":"2018-10-13T02:11:49.000Z","comments":true,"path":"css/boxer/","link":"","permalink":"http://blog.master-ss.cn/css/boxer/","excerpt":"CSS 盒模型是 CSS 的基石，非常重要的一块内容。","text":"CSS 盒模型是 CSS 的基石，非常重要的一块内容。 一、盒模型基本概念 margin + border + padding + content 标准模型： 计算内容宽度时 width = content width，高度计算相同 IE 模型： 计算内容宽度时 width = content + padding + border box-sizing: border-box（IE 模型）、content-box（标准模型） 二、JS 获取盒模型的宽高 dom.style.width/height: 只能取到内联样式 dom.currentStyle.width/height: 拿到计算后的宽高，但只有 IE 支持 window.getComputedStyle(dom).width/height: 拿到计算后的宽高，兼容所有浏览器 dom.getBoundingClientRect().width/height: 拿到四条边相对左边上边的距离，然后获取宽高 三、边距重叠父子边距重叠、兄弟边距重叠、空元素边距重叠(自身上下边距重叠)，取最大值 四、BFC4.1、块级格式化上下文，其原理 在同一个 BFC 元素内部垂直方向发生边距重叠 BFC 区域不会与浮动元素 box 重叠 独立容器，内外互不影响 计算 BFC 高度，浮动元素参与计算 4.2、创建 BFC position的值不为 static 或者 relative float 不为 none display 为 table 相关 overflow 不为 visible 4.3、BFC 实例123456789101112131415&lt;section id=&quot;sec&quot;&gt; &lt;style&gt; #sec &#123; overflow: hidden; background: #f00; &#125; .child &#123; height: 100px; margin-top: 10px; background: yellow; &#125; &lt;/style&gt; &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;&lt;/section&gt; 4.4、BFC 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- BFC 垂直方向边距重叠 --&gt;&lt;section id=&quot;margin&quot;&gt; &lt;style&gt; #margin &#123; background: pink; overflow: hidden; &#125; #margin&gt;p &#123; margin: 5px auto 25px; background: red; &#125; &lt;/style&gt; &lt;p&gt;垂直 1&lt;/p&gt; &lt;!-- 创建一个 BFC 来消除边距重合 --&gt; &lt;div style=&quot;overflow: hidden;&quot;&gt; &lt;p&gt;垂直 2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;垂直 3&lt;/p&gt;&lt;/section&gt;&lt;!-- BFC 不与 float 重叠 --&gt;&lt;section id=&quot;layout&quot;&gt; &lt;style&gt; #layout .left &#123; float: left; width: 100px; height: 100px; background: pink; &#125; #layout .right &#123; height: 110px; background: #ccc; overflow: hidden; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;float left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;float right&lt;/div&gt;&lt;/section&gt;&lt;!-- BFC 子元素即使是 float 也会参与高度计算 --&gt;&lt;section id=&quot;float&quot;&gt; &lt;style&gt; #float &#123; background: red; overflow: auto; &#125; #float .float &#123; float: left; font-size: 25px; &#125; &lt;/style&gt; &lt;div class=&quot;float&quot;&gt;我是浮动元素&lt;/div&gt;&lt;/section&gt;","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"css 之页面布局二","slug":"css/layout2","date":"2018-10-13T01:43:17.000Z","updated":"2018-10-13T01:50:31.000Z","comments":true,"path":"css/layout2/","link":"","permalink":"http://blog.master-ss.cn/css/layout2/","excerpt":"上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。","text":"上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。 一、场景三栏布局：要求：上下高度固定，中间自适应。先设置初始化样式：12345678910111213141516171819 * &#123; padding: 0; margin: 0;&#125;html,body,section &#123; height: 100%;&#125;section &#123; float: left; margin-left: 15px;&#125;.container div &#123; width: 200px;&#125; 二、绝对定位布局1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绝对定位解决方案 --&gt;&lt;section class=&quot;container absolute&quot;&gt; &lt;style&gt; .absolute &#123; position: relative; width: 200px; &#125; .absolute div &#123; position: absolute; &#125; .absolute .top &#123; top: 0; height: 100px; background: aquamarine; &#125; .absolute .bottom &#123; bottom: 0; height: 100px; background: azure; &#125; .absolute .middle &#123; overflow: scroll; top: 100px; bottom: 100px; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; &lt;p&gt;简单快捷，可拓展性差&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; 三、flex 布局12345678910111213141516171819202122232425262728293031&lt;!-- flex 解决方案 --&gt;&lt;section class=&quot;container flex&quot;&gt; &lt;style&gt; .flex &#123; display: flex; flex-direction: column; &#125; .flex .top &#123; height: 100px; background: aquamarine; &#125; .flex .bottom &#123; height: 100px; background: azure; &#125; .flex .middle &#123; flex: 1; overflow: scroll; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h1&gt;flex解决方案&lt;/h1&gt; &lt;p&gt;简单快捷，兼容性差&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;&lt;/section&gt; 四、table 布局123456789101112131415161718192021222324252627282930313233343536&lt;!-- table 解决方案 --&gt;&lt;section class=&quot;container table&quot;&gt; &lt;style&gt; .table &#123; display: table; width: 200px; &#125; .table div &#123; display: table-row; &#125; .table .top &#123; height: 100px; background: aquamarine; &#125; .table .middle &#123; display: block; overflow: scroll; height: 100%; background: beige; &#125; .table .bottom &#123; height: 100px; background: azure; &#125; &lt;/style&gt; &lt;div class=&quot;top&quot;&gt;&amp;nbsp;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h1&gt;table 解决方案&lt;/h1&gt; &lt;p&gt;兼容性非常好，但是不太推荐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;/section&gt; 五、grid 布局1234567891011121314151617181920212223242526272829&lt;!-- grid 解决方案 --&gt;&lt;section class=&quot;container grid&quot;&gt; &lt;style&gt; .grid &#123; display: grid; grid-template-columns: 200px; grid-template-rows: 100px auto 100px; &#125; .grid .top &#123; background: aquamarine; &#125; .grid .bottom &#123; background: azure; &#125; .grid .middle &#123; overflow: scroll; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h1&gt;grid 解决方案&lt;/h1&gt; &lt;p&gt;功能强大，兼容性不好&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;&lt;/section&gt;","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"css 之页面布局一","slug":"css/layout","date":"2018-10-13T01:19:20.000Z","updated":"2018-10-13T01:43:07.000Z","comments":true,"path":"css/layout/","link":"","permalink":"http://blog.master-ss.cn/css/layout/","excerpt":"页面布局主要考察 HTML 以及 CSS 的功底，对页面布局的把控能力。","text":"页面布局主要考察 HTML 以及 CSS 的功底，对页面布局的把控能力。 一、场景三栏布局：要求：高度已知，左右固定，中间自适应。先设置初始化样式：123456789101112* &#123; padding: 0; margin: 0;&#125;section &#123; margin-top: 15px;&#125;.container div &#123; min-height: 100px;&#125; 二、float 布局12345678910111213141516171819202122232425262728293031&lt;!-- 浮动解决方案 --&gt;&lt;section class=&quot;container float&quot;&gt; &lt;style&gt; .float &#123; clear: both; &#125; .float .left &#123; float: left; width: 100px; background: aquamarine; &#125; .float .right &#123; float: right; width: 100px; background: azure; &#125; .float .center &#123; overflow: hidden; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;浮动解决方案&lt;/h1&gt; &lt;p&gt;兼容性好，但是要处理浮动关系&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; 三、绝对定位布局12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 绝对定位解决方案 --&gt;&lt;section class=&quot;container absolute&quot;&gt; &lt;style&gt; .absolute &#123; position: relative; height: 100px; &#125; .absolute div &#123; position: absolute; &#125; .absolute .left &#123; width: 100px; left: 0; background: aquamarine; &#125; .absolute .right &#123; width: 100px; right: 0; background: azure; &#125; .absolute .center &#123; right: 100px; left: 100px; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; &lt;p&gt;简单，快捷，可扩展性差&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; 四、flex 布局1234567891011121314151617181920212223242526272829&lt;!-- flex 解决方案 --&gt;&lt;section class=&quot;container flex&quot;&gt; &lt;style&gt; .flex &#123; display: flex; &#125; .flex .left &#123; width: 100px; background: aquamarine; &#125; .flex .right &#123; width: 100px; background: azure; &#125; .flex .center &#123; flex: 1; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;flex 解决方案&lt;/h1&gt; &lt;p&gt;简单，快捷，兼容性差&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt; 五、table 布局12345678910111213141516171819202122232425262728293031323334&lt;!-- table 解决方案 --&gt;&lt;section class=&quot;container table&quot;&gt; &lt;style&gt; .table &#123; display: table; width: 100%; height: 100px; &#125; .table div &#123; display: table-cell; &#125; .table .left &#123; width: 100px; background: aquamarine; &#125; .table .right &#123; width: 100px; background: azure; &#125; .table .center &#123; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;table 解决方案&lt;/h1&gt; &lt;p&gt;兼容性非常好，但是三栏等高，可能不合适&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt; 六、grid 布局1234567891011121314151617181920212223242526272829&lt;!-- grid 解决方案 --&gt;&lt;section class=&quot;container grid&quot;&gt; &lt;style&gt; .grid &#123; display: grid; height: 100%; grid-template-rows: 100px; grid-template-columns: 100px auto 100px; &#125; .grid .left &#123; background: aquamarine; &#125; .grid .right &#123; background: azure; &#125; .grid .center &#123; background: beige; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;grid 解决方案&lt;/h1&gt; &lt;p&gt;功能强大，兼容性不好&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/section&gt;","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"vuex 之辅助方法","slug":"vuex/vuex-helper","date":"2018-10-05T07:15:04.000Z","updated":"2018-10-05T08:01:02.000Z","comments":true,"path":"vuex/vuex-helper/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-helper/","excerpt":"看完 vuex 的 api 后，我们来到最后一节 vuex 的辅助方法。","text":"看完 vuex 的 api 后，我们来到最后一节 vuex 的辅助方法。 一、mapState1234567891011121314151617181920212223242526272829303132/** * Reduce the code which written in Vue.js for getting the state.（减少获取 state 代码的重复和冗余） * @param &#123;String&#125; [namespace] - Module&apos;s namespace * @param &#123;Object|Array&#125; states # Object&apos;s item can be a function which accept state and getters for param, you can do something for state and getters in it. * @param &#123;Object&#125; */export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState () &#123; let state = this.$store.state let getters = this.$store.getters // 传入 namespace if (namespace) &#123; // 获取相应命名空间的模块 const module = getModuleByNamespace(this.$store, &apos;mapState&apos;, namespace) if (!module) &#123; return &#125; // 赋值子模块的 state、getters state = module.context.state getters = module.context.getters &#125; return typeof val === &apos;function&apos; ? val.call(this, state, getters) : state[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) return res&#125;) 可以看到我们调用 normalizeNamespace 方法，其实现如下：1234567891011121314151617/** * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param&apos;s function will handle the new namespace and the map. * @param &#123;Function&#125; fn * @return &#123;Function&#125; * 命名空间格式化（namespace 表示命名空间，map 表示具体的对象，namespace 可不传） */function normalizeNamespace (fn) &#123; return (namespace, map) =&gt; &#123; if (typeof namespace !== &apos;string&apos;) &#123; map = namespace namespace = &apos;&apos; &#125; else if (namespace.charAt(namespace.length - 1) !== &apos;/&apos;) &#123; namespace += &apos;/&apos; &#125; return fn(namespace, map) &#125;&#125; 该方法主要是格式化传入参数。继续回到 mapState，可以看到调用了 normalizeMap，其实现如下：123456789101112/** * Normalize the map（map 格式化） * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ] * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: &apos;a&apos;, val: 1 &#125;, &#123; key: &apos;b&apos;, val: 2 &#125;, &#123; key: &apos;c&apos;, val: 3 &#125; ] * @param &#123;Array|Object&#125; map * @return &#123;Object&#125; */function normalizeMap (map) &#123; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))&#125; 可以看出我们将传入的第二个参数进行格式化。回到 mapState，调用 forEach 进行遍历。如果没有传入 namespace，则判断 val 是否为 function，如果是，则调用，否则直接返回 state[val]。如果传入了 namespace，则调用 getModuleByNamespace 获取子模块，然后获取子模块的 state、getters。也就是 mapState 返回的是一个对象，然后将这个对象传给 computed：123computed: mapState([ &apos;count&apos;]) 那么 this.count 访问的就是 store.state.count 了。继续来看 getModuleByNamespace 实现：12345678910111213141516/** * Search a special module from store by namespace. if module not exist, print error message. * @param &#123;Object&#125; store * @param &#123;String&#125; helper 工具方法名，如 mapState * @param &#123;String&#125; namespace * @return &#123;Object&#125; */function getModuleByNamespace (store, helper, namespace) &#123; // 查找相应命名空间的 module const module = store._modulesNamespaceMap[namespace] // 非生产环境下，如果不存在相应命名空间模块，则给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !module) &#123; console.error(`[vuex] module namespace not found in $&#123;helper&#125;(): $&#123;namespace&#125;`) &#125; return module&#125; 主要是通过 _modulesNamespaceMap 来获取子模块。 二、mapMutations1234567891011121314151617181920212223242526272829/** * Reduce the code which written in Vue.js for committing the mutation（减少获取 mutations 代码的重复和冗余） * @param &#123;String&#125; [namespace] - Module&apos;s namespace * @param &#123;Object|Array&#125; mutations # Object&apos;s item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function. * @return &#123;Object&#125; * 将组件中的 methods 映射为 store.commit 调用 */export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; &#123; const res = &#123;&#125; normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123; // 支持传入额外的参数 args，作为提交 mutation 的 payload，如：`this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)` res[key] = function mappedMutation (...args) &#123; // Get the commit method from store let commit = this.$store.commit if (namespace) &#123; const module = getModuleByNamespace(this.$store, &apos;mapMutations&apos;, namespace) if (!module) &#123; return &#125; // 获取子模块的 commit commit = module.context.commit &#125; return typeof val === &apos;function&apos; ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) 遍历传入的 mutations，并支持传入额外的参数 args。然后获取 commit，如果传入了 namespace，则获取子模块的 commit。 三、mapGetters12345678910111213141516171819202122232425262728/** * Reduce the code which written in Vue.js for getting the getters（减少获取 getters 代码的重复和冗余） * @param &#123;String&#125; [namespace] - Module&apos;s namespace * @param &#123;Object|Array&#125; getters * @return &#123;Object&#125; */export const mapGetters = normalizeNamespace((namespace, getters) =&gt; &#123; const res = &#123;&#125; normalizeMap(getters).forEach((&#123; key, val &#125;) =&gt; &#123; // thie namespace has been mutate by normalizeNamespace（namespace 已经被 normalizeNamespace 方法处理好了） val = namespace + val res[key] = function mappedGetter () &#123; // 如果存在命名空间，但是没能在该命名空间下找到相应 module，则返回 if (namespace &amp;&amp; !getModuleByNamespace(this.$store, &apos;mapGetters&apos;, namespace)) &#123; return &#125; // 非生产环境下，如果没有相应 getter，给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(val in this.$store.getters)) &#123; console.error(`[vuex] unknown getter: $&#123;val&#125;`) return &#125; return this.$store.getters[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) return res&#125;) 遍历 getters，拼接上 namespace，然后从 this.$store.getters 取值返回。 四、mapActions123456789101112131415161718192021222324252627282930/** * Reduce the code which written in Vue.js for dispatch the action（减少获取 actions 代码的重复和冗余） * @param &#123;String&#125; [namespace] - Module&apos;s namespace * @param &#123;Object|Array&#125; actions # Object&apos;s item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function. * @return &#123;Object&#125; */export const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123; const res = &#123;&#125; normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123; // 支持传入额外的参数 args，作为提交 action 的 payload，如：`this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` res[key] = function mappedAction (...args) &#123; // get dispatch function from store let dispatch = this.$store.dispatch // 带命名空间参数 if (namespace) &#123; // 获取相应命名空间下的 moudle const module = getModuleByNamespace(this.$store, &apos;mapActions&apos;, namespace) if (!module) &#123; return &#125; // 获取子模块的 dispatch 函数 dispatch = module.context.dispatch &#125; return typeof val === &apos;function&apos; ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args)) &#125; &#125;) return res&#125;) 遍历 actions，如果传入命名空间则获取子模块下的 dispatch 函数。 五、createNamespacedHelpers123456789101112/** * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object * 创建基于某个命名空间辅助函数，返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数 * @param &#123;String&#125; namespace * @return &#123;Object&#125; */export const createNamespacedHelpers = (namespace) =&gt; (&#123; mapState: mapState.bind(null, namespace), mapGetters: mapGetters.bind(null, namespace), mapMutations: mapMutations.bind(null, namespace), mapActions: mapActions.bind(null, namespace)&#125;) 返回一个对象，其 mapState、mapGetters、mapMutations、mapActions 属性都已经绑定在了给定的命名空间上。","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之 api","slug":"vuex/vuex-api","date":"2018-10-04T09:34:01.000Z","updated":"2018-10-05T07:13:51.000Z","comments":true,"path":"vuex/vuex-api/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-api/","excerpt":"看完 vuex 的构造器，相信大家对 vuex 的原理都有了个基础的认识，现在我们来看下 vuex 对外暴露的 api","text":"看完 vuex 的构造器，相信大家对 vuex 的原理都有了个基础的认识，现在我们来看下 vuex 对外暴露的 api 一、commit12345678910111213141516171819202122232425262728293031323334353637// 提交 mutation，子模块的 commit 已在 makeLocalContext 中拼装好前缀commit (_type, _payload, _options) &#123; // check object-style commit const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; const entry = this._mutations[type] // 非生产环境下给出提示信息，不存在相应的 mutation if (!entry) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) // 触发 commit 的订阅回调函数 this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) // 非生产环境下给出提示信息，silent 选项已被移除 if ( process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + &apos;Use the filter functionality in the vue-devtools&apos; ) &#125;&#125; 首先使用 unifyObjectStyle 格式化对象风格，然后通过 type 获取相应 mutations，注意拿到的是数组，而且 commit 方法执行需要嵌套在 _withCommit 中，原因前面章节有介绍。然后我们遍历执行 mutations，并传入 payload。最后我们遍历 _subscribers，触发 commit 的订阅回调函数。 二、dispatch12345678910111213141516171819202122232425// 提交 action，子模块的 dispatch 已在 makeLocalContext 中拼装好前缀dispatch (_type, _payload) &#123; // check object-style dispatch const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload) const action = &#123; type, payload &#125; const entry = this._actions[type] // // 非生产环境下给出提示信息，不存在相应的 action if (!entry) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`) &#125; return &#125; // 触发 dispatch 的订阅回调函数 this._actionSubscribers.forEach(sub =&gt; sub(action, this.state)) return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload)&#125; 首先使用 unifyObjectStyle 格式化对象风格，然后通过 type 获取相应 actions，注意拿到的是数组，如果数组长度大于 1，则调用 Promise.all。最后我们遍历 _actionSubscribers，触发 dispatch 的订阅回调函数。 三、subscribe1234// 订阅 store 的 mutationsubscribe (fn) &#123; return genericSubscribe(fn, this._subscribers)&#125; 直接调用 genericSubscribe 方法，其实现如下：1234567891011121314// 通用订阅函数function genericSubscribe (fn, subs) &#123; // 如果是新的回调函数，则添加 if (subs.indexOf(fn) &lt; 0) &#123; subs.push(fn) &#125; // 返回函数，调用即可停止订阅 return () =&gt; &#123; const i = subs.indexOf(fn) if (i &gt; -1) &#123; subs.splice(i, 1) &#125; &#125;&#125; 也就是说调用 subscribe 方法时，我们将传入的 fn 添加到 _subscribers 中，然后在每个 mutation 完成后调用。要停止订阅，调用此方法返回的函数即可停止订阅。 四、subscribeAction1234// 订阅 store 的 actionsubscribeAction (fn) &#123; return genericSubscribe(fn, this._actionSubscribers)&#125; 调用 subscribeAction 方法时，我们将传入的 fn 添加到 _actionSubscribers 中，然后在每个 action 分发的时候调用。要停止订阅，调用此方法返回的函数即可停止订阅。 五、watch12345678// 响应式地侦听 getter 的返回值，当值改变时调用回调函数watch (getter, cb, options) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(typeof getter === &apos;function&apos;, `store.watch only accepts a function.`) &#125; // fn 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。要停止侦听，调用此方法返回的函数即可停止侦听 return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)&#125; 调用 watch 时，我们将监听 getter 的返回值，如果值发生改变则调用回调函数 cb 六、replaceState12345replaceState (state) &#123; this._withCommit(() =&gt; &#123; this._vm._data.$$state = state &#125;)&#125; 替换 store 的根状态，仅用状态合并或时光旅行调试。 七、registerModule1234567891011121314151617// 模块动态注册registerModule (path, rawModule, options = &#123;&#125;) &#123; if (typeof path === &apos;string&apos;) path = [path] // 非生产环境下给出 path 参数校验提示信息 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(Array.isArray(path), `module path must be a string or an Array.`) assert(path.length &gt; 0, &apos;cannot register the root module by using registerModule.&apos;) &#125; // 注册模块 this._modules.register(path, rawModule) // 初始化模块 installModule(this, this.state, path, this._modules.get(path), options.preserveState) // reset store to update getters...（重新实例化 store._vm，并销毁旧的 store_vm） resetStoreVM(this, this.state)&#125; 首先做参数格式化和校验，然后调用 register 方法注册模块，然后调用 installModule 初始化模块，其中 _modules.get 实现见 ‘src/module/module-collection.js’ 中：123456// 获取路径上的子模块get (path) &#123; return path.reduce((module, key) =&gt; &#123; return module.getChild(key) &#125;, this.root)&#125; options 可以包含 preserveState: true 以允许保留之前的 state，也就是说如果设置 options.preserveState，那么 state 保持不变。然后调用 resetStoreVM 方法重新实例化 store._vm，并销毁旧的 store_vm，这样做主要是为了更新 store 的 getters。 八、unregisterModule123456789101112131415161718// 模块动态卸载（只会移除我们运行时动态创建的模块）unregisterModule (path) &#123; if (typeof path === &apos;string&apos;) path = [path] if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(Array.isArray(path), `module path must be a string or an Array.`) &#125; // 执行 unregister 方法去修剪我们的模块树 this._modules.unregister(path) // 删除 state 在该路径下的引用 this._withCommit(() =&gt; &#123; const parentState = getNestedState(this.state, path.slice(0, -1)) Vue.delete(parentState, path[path.length - 1]) &#125;) // 把 store 下的对应存储的 _actions、_mutations、_wrappedGetters 和 _modulesNamespaceMap 都清空，然后重新执行 installModule 安装所有模块以及 resetStoreVM 重置 store._vm resetStore(this)&#125; 首先进行参数格式化和校验，然后调用 _modules.unregister 方法，具体实现见 ‘src/module/module-collection.js’ 中：123456789// 卸载模块unregister (path) &#123; const parent = this.get(path.slice(0, -1)) const key = path[path.length - 1] // 只会移除我们运行时动态创建的模块 if (!parent.getChild(key).runtime) return parent.removeChild(key)&#125; 注意我们只会移除运行时动态创建的模块。首先获取父模块和当前模块名称，然后调用 removeChild 移除子模块，removeChild 具体实现见 ‘src/module/module.js’ 中：1234// 移除子模块removeChild (key) &#123; delete this._children[key]&#125; 回到 unregisterModule 中， 我们继续删除 state 在当前模块路径下的引用，并调用 resetStore 方法，其实现如下：123456789101112// 重置 _actions、_mutations、_wrappedGetters、_modulesNamespaceMap，并重新执行 installModule、resetStoreVMfunction resetStore (store, hot) &#123; store._actions = Object.create(null) store._mutations = Object.create(null) store._wrappedGetters = Object.create(null) store._modulesNamespaceMap = Object.create(null) const state = store.state // init all modules installModule(store, state, [], store._modules.root, true) // reset vm resetStoreVM(store, state, hot)&#125; 该方法主要是清空 _actions、_mutations、_wrappedGetters、_modulesNamespaceMap，并重新初始化模块和重置 store._vm 九、hotUpdate123456// 热替换新的 action 和 mutationhotUpdate (newOptions) &#123; this._modules.update(newOptions) // 把 store 下的对应存储的 _actions、_mutations、_wrappedGetters 和 _modulesNamespaceMap 都清空，然后重新执行 installModule 安装所有模块以及 resetStoreVM 重置 store._vm resetStore(this, true)&#125; 首先看到调用了 _modules.update 方法，其实现见 ‘src/module/module-collection.js’ 中：12345// 更新模块，执行 update (path, targetModule, newModule)update (rawRootModule) &#123; // 更新根模块 update([], this.root, rawRootModule)&#125; 调用了该文件自身的 update 方法：1234567891011121314151617181920212223242526272829303132// 更新模块具体实现function update (path, targetModule, newModule) &#123; // 非生产环境下做类型检测 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assertRawModule(path, newModule) &#125; // update target module（更新 targetModule 的 namespaced、actions、mutations、getters） targetModule.update(newModule) // update nested modules if (newModule.modules) &#123; for (const key in newModule.modules) &#123; // 如果 newModule 存在 targetModule 没有的子模块，则给出 reload 提示信息 if (!targetModule.getChild(key)) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.warn( `[vuex] trying to add a new module &apos;$&#123;key&#125;&apos; on hot reloading, ` + &apos;manual reload is needed&apos; ) &#125; return &#125; // 递归更新子模块 update( path.concat(key), targetModule.getChild(key), newModule.modules[key] ) &#125; &#125;&#125; 然后 targetModule.update 方法见 ‘src/module/module.js’ 中：123456789101112update (rawModule) &#123; this._rawModule.namespaced = rawModule.namespaced if (rawModule.actions) &#123; this._rawModule.actions = rawModule.actions &#125; if (rawModule.mutations) &#123; this._rawModule.mutations = rawModule.mutations &#125; if (rawModule.getters) &#123; this._rawModule.getters = rawModule.getters &#125;&#125; 主要是更新当前 module 的 namespaced、actions、mutations、getters","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之初始化 store._vm","slug":"vuex/vuex-vm","date":"2018-10-04T08:13:36.000Z","updated":"2018-10-04T09:23:29.000Z","comments":true,"path":"vuex/vuex-vm/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-vm/","excerpt":"模块初始化看完后，我们继续来看初始化 store._vm","text":"模块初始化看完后，我们继续来看初始化 store._vm 一、resetStoreVM我们回到 Store 的构造器函数，看到在执行 installModule 后，我们紧接着执行了：123// initialize the store vm, which is responsible for the reactivity// (also registers _wrappedGetters as computed properties)resetStoreVM(this, state) resetStoreVM 定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 建立 getters 和 state 的联系function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm // bind store public getters store.getters = &#123;&#125; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // use computed to leverage its lazy-caching mechanism（使用 computed 的懒加载机制） // 根据 key 访问 store.getters 的某一个 getter 的时候，实际上就是访问了 store._vm[key]，也就是 computed[key] // 在执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state // 进而访问到 store._vm_data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。 computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) &#125;) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent Vue.config.silent = true store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) Vue.config.silent = silent // enable strict mode for new vm if (store.strict) &#123; enableStrictMode(store) &#125; if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; // 销毁旧的 vue 实例 Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; 首先我们获取 root store 上的 _vm 和 _wrappedGetters 属性，上节我们讲到 _wrappedGetters 存储用户定义的所有 getters。接着我们遍历 _wrappedGetters，为 computed 的 key 属性赋值，并为 store.getters 的 key 属性设置拦截器。 继续往下看，我们修改 Vue.config.silent，然后为 store._vm 赋值，并将 Vue.config.silent 改回原先值。这里 Vue.config.silent 的修改主要是为了防止用户配置了全局的 mixins 而打印出警告信息。 我们注意到如果访问 store.getters[key]，实际上访问的是 store._vm[key]，也就是 computed[key]，在执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,…) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。这样做的主要目的是为了使用计算属性的懒加载机制。 注意，我们访问 store.state 时其实访问的是：1234567891011// 访问 store.state 的时候，实际上会访问 Store 类上定义的 state 的 get 方法get state () &#123; return this._vm._data.$$state&#125;// 给出提示信息，不能设置 state 值set state (v) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(false, `use store.replaceState() to explicit replace store state.`) &#125;&#125; 回到 resetStoreVM 方法，如果存在 oldVm，那么需要调用 $destroy 销毁这个实例。如果是热更新的话，同时设置 oldVm._data.$$state 为 null，来促使所有的监听函数重新计算。 二、enableStrictMode()我们注意到 resetStoreVM 有这样一段代码：1234// enable strict mode for new vmif (store.strict) &#123; enableStrictMode(store)&#125; 如果传入的 options.strict 为 true，那么执行 enableStrictMode 方法。enableStrictMode 的实现如下：12345678910// 开启严格模式（在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误，这能保证所有的状态变更都能被调试工具跟踪到）function enableStrictMode (store) &#123; // store._vm 添加一个 wathcer 来观测 this._data.$$state 的变化 store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123; // 非生产环境下，当 store.state 被修改的时候, store._committing 必须为 true，否则给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(store._committing, `do not mutate vuex store state outside mutation handlers.`) &#125; &#125;, &#123; deep: true, sync: true &#125;)&#125; 可以看到我们在 store._vm 添加了一个监听器，在 this._data.$$state 发生改变时触发回调函数。回调函数中判断 state 改变时，_committing 是否为 true，如果不是，则给出提示信息。 三、plugins我们回到构造器函数中继续往下看：123456// apply pluginsplugins.forEach(plugin =&gt; plugin(this))if (Vue.config.devtools) &#123; devtoolPlugin(this)&#125; 我们首先遍历配置中的 plugins，并传入 store 实例执行 plugin 方法，所以我们传入的 plugins 选项能够在 new Vuex.Store() 执行时得到 store 实例并执行。然后判断 Vue.config.devtools（是否允许 vue-devtools 检查代码）是否为 true，如果是执行 devtoolPlugin 方法，devtoolPlugin 代码见 ‘src/plugins/devtool.js’ 中：12345678910111213141516171819const devtoolHook = typeof window !== &apos;undefined&apos; &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__export default function devtoolPlugin (store) &#123; if (!devtoolHook) return store._devtoolHook = devtoolHook devtoolHook.emit(&apos;vuex:init&apos;, store) devtoolHook.on(&apos;vuex:travel-to-state&apos;, targetState =&gt; &#123; store.replaceState(targetState) &#125;) store.subscribe((mutation, state) =&gt; &#123; devtoolHook.emit(&apos;vuex:mutation&apos;, mutation, state) &#125;)&#125; 可以看到我们在 store 上添加了 _devtoolHook 属性，这就是上节我们说到的 store._devtoolHook 来源。","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之模块初始化","slug":"vuex/vuex-module-install","date":"2018-09-30T06:58:43.000Z","updated":"2018-10-04T08:05:22.000Z","comments":true,"path":"vuex/vuex-module-install/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-module-install/","excerpt":"现在我们来看下 vuex 的模块初始化。","text":"现在我们来看下 vuex 的模块初始化。 一、installModule()我们接着来看 ‘src/store.js’ 中的构造器：12345678910export class Store &#123; constructor (options = &#123;&#125;) &#123; const state = this._modules.root.state // init root module. 初始化根模块 // this also recursively registers all sub-modules 并递归注册所有子模块 // and collects all module getters inside this._wrappedGetters installModule(this, state, [], this._modules.root) &#125;&#125; 经过上节的分析，我们知道 this._modules.root 为根模块，因此从根模块上获取 state 属性。然后执行的是 installModule：12345678910111213141516171819202122232425// 对模块中的 state、getters、mutations、actions 做初始化工作// store 表示 root store；state 表示 root state；path 表示模块的访问路径；module 表示当前的模块；hot 表示是否是热更新function installModule (store, rootState, path, module, hot) &#123; // 判断是否是根模块 const isRoot = !path.length // 获取 path 路径下的命名空间 const namespace = store._modules.getNamespace(path) // register in namespace map（把 namespace 对应的模块保存下来，为了方便以后能根据 namespace 查找模块） if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; // state 初始化 if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;) &#125; const local = module.context = makeLocalContext(store, namespace, path) ...&#125; 我们一步步来分析下，先看 getNamespace 方法实现，见 ‘src/module/module-collection.js’ 中：12345678// 获取相应路径下模块的命名空间（从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串）getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + &apos;/&apos; : &apos;&apos;) &#125;, &apos;&apos;)&#125; this.root 表示根模块，namespaced 实现见 ‘src/module/module.js’ 中：1234// 该模块是否带有命名空间get namespaced () &#123; return !!this._rawModule.namespaced&#125; getChild 实现见 ‘src/module/module.js’ 中：1234// 获取相应 key 的子模块getChild (key) &#123; return this._children[key]&#125; 即如果 vuex 的子模块配置中出现了 namespaced，那么 module.namespaced 返回 true。然后我们使用 _modulesNamespaceMap 存储命名空间的模块，以便后续可根据 namespace 查找模块。 二、makeLocalContext()我们接着来看 installModule 中的 makeLocalContext：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * make localized dispatch, commit, getters and state * if there is no namespace, just use root ones * store 表示 root store；namespace 表示模块的命名空间，path 表示模块的 path */function makeLocalContext (store, namespace, path) &#123; const noNamespace = namespace === &apos;&apos; // 如果没有命名空间，则使用 root store 的 dispatch 和 commit 方法，options 为 &#123; root: true &#125; 时，在全局命名空间内分发 action 或提交 mutation const local = &#123; dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; // 把 type 自动拼接上 namespace type = namespace + type // 非生产环境下给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._actions[type]) &#123; console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; return store.dispatch(type, payload) &#125;, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; // 把 type 自动拼接上 namespace type = namespace + type // 非生产环境下给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._mutations[type]) &#123; console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; store.commit(type, payload, options) &#125; &#125; // getters and state object must be gotten lazily // because they will be changed by vm update Object.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, state: &#123; get: () =&gt; getNestedState(store.state, path) &#125; &#125;) return local&#125; 可以看到我们主要是为 local 对象的 getters 和 state 属性定义 getter 拦截器。然后让我们继续往下看，然后再回过头来分析这段代码。 三、module.forEach***123456789101112131415161718192021222324// 遍历模块下的 mutations，并注册module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local)&#125;)// 遍历模块下的 actions，并注册module.forEachAction((action, key) =&gt; &#123; // root 为 true 时，表示在带命名空间的模块注册全局 action const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local)&#125;)// 遍历模块下的 getters，并注册module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local)&#125;)// 遍历模块中的所有子 modules，递归执行 installModule 方法module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot)&#125;) 可以看到我们调用了 module 的 forEachMutation、forEachAction、forEachGetter、forEachChild 方法，其具体实现代码见 ‘src/module/module.js’ 中：12345678910111213141516171819202122232425// 遍历子模块，将键值对传入 fnforEachChild (fn) &#123; forEachValue(this._children, fn)&#125;// 遍历当前模块 getters，将键值对传入 fnforEachGetter (fn) &#123; if (this._rawModule.getters) &#123; forEachValue(this._rawModule.getters, fn) &#125;&#125;// 遍历当前模块 actions，将键值对传入 fnforEachAction (fn) &#123; if (this._rawModule.actions) &#123; forEachValue(this._rawModule.actions, fn) &#125;&#125;// 遍历当前模块 mutations，将键值对传入 fnforEachMutation (fn) &#123; if (this._rawModule.mutations) &#123; forEachValue(this._rawModule.mutations, fn) &#125;&#125; 可以看到我们分别遍历当前模块下的 mutations、actions、getters、modules 并注册，然后递归调用 installModule 方法遍历当前模块的子模块。 四、registerMutation()我们继续回到 installModule 方法中：12345// 遍历模块下的 mutations，并注册module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local)&#125;) 首先使用当前模块的命名空间 namespace 和模块名 key 拼接，然后调用 registerMutation 方法：1234567// 给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法（注意，同一 type 的 _mutations 可以对应多个方法）function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; handler.call(store, local.state, payload) &#125;)&#125; 首先获取或初始化 _mutations 相应命名空间下数组，然后我们在 _mutations 中添加 wrappedMutationHandler 方法。注意 handle 即配置中的 mutations 方法，this 绑定为 root store，payload 为载荷，然后我们回到 makeLocalContext 中查看 local.state 拿到的数据：123456Object.defineProperties(local, &#123; ... state: &#123; get: () =&gt; getNestedState(store.state, path) &#125; &#125;) getNestedState 的实现如下：123456// 从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 statefunction getNestedState (state, path) &#123; return path.length ? path.reduce((state, key) =&gt; state[key], state) : state&#125; 看到这里，我们应该理解原来 local.state 获取的就是当前模块的 state。不过还有个问题，就是 state[key] 为什么就是相应 key 子模块的 state，这时候我们就要回到 installModule 方法看这段代码：12345678// state 初始化if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;)&#125; 我们可以看到如果不是根模块而且不是热更新，那么我们先拿到父模块的 state，然后获取当前模块名，最后调用 _withCommit 方法，并在方法参数内调用 Vue.set 为父模块 state 访问子模块建立联系，即 parentState[moduleName] = module.state。然后我们来看下 _withCommit 方法的实现：1234567// 内置提交修改 state，防止被捕获_withCommit (fn) &#123; const committing = this._committing this._committing = true fn() this._committing = committing&#125; 我们之所以要这么做是因为要保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中。 五、registerAction()我们继续回到 installModule 方法中：1234567// 遍历模块下的 actions，并注册module.forEachAction((action, key) =&gt; &#123; // root 为 true 时，表示在带命名空间的模块注册全局 action const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local)&#125;) 注意在 vuex 配置中，action 可设置 root 为 true，表示在带命名空间的模块注册全局 action，如下：123456789101112131415&#123; ... modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction: &#123; root: true, handler (namespacedContext, payload) &#123; ... &#125; // -&gt; &apos;someAction&apos; &#125; &#125; &#125; &#125;&#125; 而 action.handler || action 为 action 的两种配置格式，我们接着看 registerAction：12345678910111213141516171819202122232425// 给 root store 上的 _actions[types] 添加 wrappedActionHandler 方法function registerAction (store, type, handler, local) &#123; const entry = store._actions[type] || (store._actions[type] = []) entry.push(function wrappedActionHandler (payload, cb) &#123; let res = handler.call(store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload, cb) if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit(&apos;vuex:error&apos;, err) throw err &#125;) &#125; else &#123; return res &#125; &#125;)&#125; 首先获取或初始化 _actions 对应命名空间下的数组，然后添加 wrappedActionHandler 方法。可以看到我们 action 调用时，this 绑定为 root store，context 对象存在 dispatch、commit、getters、state、rootGetters 和 rootState 属性，并且将 action 执行返回结果处理为 Promise 对象。我们刚才已经讲过 local.state，现在我们来看下 local.dispatch、local.commit 和 local.getters：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 如果没有命名空间，则使用 root store 的 dispatch 和 commit 方法，options 为 &#123; root: true &#125; 时，在全局命名空间内分发 action 或提交 mutationconst local = &#123; dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; // 把 type 自动拼接上 namespace type = namespace + type // 非生产环境下给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._actions[type]) &#123; console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; return store.dispatch(type, payload) &#125;, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; // 把 type 自动拼接上 namespace type = namespace + type // 非生产环境下给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._mutations[type]) &#123; console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; store.commit(type, payload, options) &#125;&#125;// getters and state object must be gotten lazily// because they will be changed by vm updateObject.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, ...&#125;) 先看 local.getters，我们注意到，如果没有命名空间，那么返回 root store 的 getters，否则执行 makeLocalGetters：123456789101112131415161718192021222324// 获取子模块的 gettersfunction makeLocalGetters (store, namespace) &#123; const gettersProxy = &#123;&#125; const splitPos = namespace.length // 遍历 root store 下的所有 getters Object.keys(store.getters).forEach(type =&gt; &#123; // skip if the target getter is not match this namespace（判断是否匹配命名空间） if (type.slice(0, splitPos) !== namespace) return // extract local getter type（只有匹配的时候从 namespace 的位置截取后面的字符串得到 localType） const localType = type.slice(splitPos) // Add a port to the getters proxy. // Define as getter property because // we do not want to evaluate the getters in this time. Object.defineProperty(gettersProxy, localType, &#123; get: () =&gt; store.getters[type], enumerable: true &#125;) &#125;) return gettersProxy&#125; 再来看下 local.dispatch，如果没有命名空间，则使用 root store 的 dispatch 方法，否则调用封装方法。首先我们来看 unifyObjectStyle 方法实现：123456789101112131415// 统一对象风格 store.commit(&#123; type: &apos;increment&apos;, amount: 10 &#125;) | store.commit(&apos;increment&apos;, &#123; amount: 10 &#125;)function unifyObjectStyle (type, payload, options) &#123; if (isObject(type) &amp;&amp; type.type) &#123; options = payload payload = type type = type.type &#125; // 非生产环境下给出提示信息 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(typeof type === &apos;string&apos;, `expects string as the type, but found $&#123;typeof type&#125;.`) &#125; return &#123; type, payload, options &#125;&#125; 可以看到 unifyObjectStyle 是用来统一对象风格的。然后继续看 local.dispatch 方法，我们判断 options 是否存在而且 root 属性是否为 true。如果 if 语句执行失败，则直接调用 root store 的 dispatch 方法，否则我们为 type 拼接上命名空间，然后调用 dispatch 方法。local.commit 基本同 local.dispatch，我们就不讨论了。最后我们来看这段代码：123456if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit(&apos;vuex:error&apos;, err) throw err &#125;)&#125; 如果 store 存在 _devtoolHook，即我们使用 devtool 插件时，我们为 Promise 对象 res 添加 catch 方法捕获错误。 六、registerGetter()我们现在回到 installModule 方法：12345// 遍历模块下的 getters，并注册module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local)&#125;) 我们首先拼接出命名空间路径，然后调用 registerGetter 方法：123456789101112131415161718// root store 上的 _wrappedGetters[key] 指定 wrappedGetter 方法function registerGetter (store, type, rawGetter, local) &#123; // 注意，同一 type 的 _wrappedGetters 只能定义一个，非生产环境下给出提示信息 if (store._wrappedGetters[type]) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] duplicate getter key: $&#123;type&#125;`) &#125; return &#125; store._wrappedGetters[type] = function wrappedGetter (store) &#123; return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) &#125;&#125; 我们判断在 _wrappedGetters 是否已经存在相应命名空间路径的 getter，如果存在直接返回并给出提示，即同一 type 的 _wrappedGetters 只能定义一个。如果并未定义，我们将 wrappedGetter 赋值给 store._wrappedGetters[type]。","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之模块注册","slug":"vuex/vuex-module-register","date":"2018-09-30T03:54:36.000Z","updated":"2018-09-30T06:56:39.000Z","comments":true,"path":"vuex/vuex-module-register/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-module-register/","excerpt":"看完初始化和工具方法后，我们来看下 vuex 的模块注册。","text":"看完初始化和工具方法后，我们来看下 vuex 的模块注册。 一、new Vuex.Store()123456const store = new Vuex.Store(&#123; state, getters, actions, mutations&#125;) 相信大家对这段代码都非常熟悉，在之前的分析中，我们可得知 Store 来自 ‘src/store.js’ 中，也就是：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859export class Store &#123; constructor (options = &#123;&#125;) &#123; // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 // 某些场合自动执行 install，比如 &lt;script&gt; 引入 if (!Vue &amp;&amp; typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123; install(window.Vue) &#125; // 非生产环境下给出调试信息 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `store must be called with the new operator.`) &#125; const &#123; plugins = [], strict = false &#125; = options // 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state this._committing = false // 用来存储用户定义的所有的 actions this._actions = Object.create(null) // 存储 dispatch 的订阅回调函数 this._actionSubscribers = [] // 用来存储用户定义所有的 mutatins this._mutations = Object.create(null) // 用来存储用户定义的所有 getters this._wrappedGetters = Object.create(null) // 注册模块 this._modules = new ModuleCollection(options) // 存储命名空间的模块 this._modulesNamespaceMap = Object.create(null) // 用来存储所有对 mutation 变化的订阅者 this._subscribers = [] // 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化 this._watcherVM = new Vue() // bind commit and dispatch to self const store = this const &#123; dispatch, commit &#125; = this // 提交 action，并且绑定 store this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; // 提交 mutation，并且绑定 store this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; // this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销 this.strict = strict ... &#125; ...&#125; 我们在 new Vuex.Store() 执行时运行的是 class Store 的构造器，主要是一些变量的初始化，作用见注释。如果还是不太清楚，也没关系，后面我会详细介绍到。 二、new ModuleCollection()现在让我们看下 this._modules = new ModuleCollection(options)，然后由开头的 import ModuleCollection from &#39;./module/module-collection&#39; 得知，代码在 ‘src/module/module-collection.js’ 中：1234567export default class ModuleCollection &#123; constructor (rawRootModule) &#123; // 注册根模块 (Vuex.Store options) this.register([], rawRootModule, false) &#125; ...&#125; 我们在初始化 this._modules 变量时执行了 class ModuleCollection 的构造器，里面执行的是 register：12345678910// 注册模块register (path, rawModule, runtime = true) &#123; // 非生产环境下对选项参数做检测 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assertRawModule(path, rawModule) &#125; const newModule = new Module(rawModule, runtime) ...&#125; assertRawModule 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 函数类型判断const functionAssert = &#123; assert: value =&gt; typeof value === &apos;function&apos;, expected: &apos;function&apos;&#125;// 函数或含 handler 函数属性的对象类型判断const objectAssert = &#123; assert: value =&gt; typeof value === &apos;function&apos; || (typeof value === &apos;object&apos; &amp;&amp; typeof value.handler === &apos;function&apos;), expected: &apos;function or object with &quot;handler&quot; function&apos;&#125;// 对 getters、mutations、actions 分别做类型判断const assertTypes = &#123; getters: functionAssert, mutations: functionAssert, actions: objectAssert&#125;// Vuex.Store options 类型检测function assertRawModule (path, rawModule) &#123; Object.keys(assertTypes).forEach(key =&gt; &#123; // 如果 options 中没有该选项则跳过 if (!rawModule[key]) return // 获取类型检测对象 functionAssert | objectAssert const assertOptions = assertTypes[key] // 遍历 options 中的选项进行类型检测 forEachValue(rawModule[key], (value, type) =&gt; &#123; assert( assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected) ) &#125;) &#125;)&#125;// 获取断言信息，用于失败时输出提示信息给开发者function makeAssertionMessage (path, key, type, value, expected) &#123; let buf = `$&#123;key&#125; should be $&#123;expected&#125; but &quot;$&#123;key&#125;.$&#123;type&#125;&quot;` if (path.length &gt; 0) &#123; buf += ` in module &quot;$&#123;path.join(&apos;.&apos;)&#125;&quot;` &#125; buf += ` is $&#123;JSON.stringify(value)&#125;.` return buf&#125; 我们注意到 const newModule = new Module(rawModule, runtime)，所以我们来到 ‘src/module/module.js’ 中：123456789101112131415// Base data struct for store&apos;s module, package with some attribute and method（store 模块的基础数据结构，含一些属性和方法）export default class Module &#123; constructor (rawModule, runtime) &#123; // 表示是否是一个运行时创建的模块 this.runtime = runtime // 存储所有子模块 this._children = Object.create(null) // 模块的配置 this._rawModule = rawModule const rawState = rawModule.state // 模块定义的 state this.state = (typeof rawState === &apos;function&apos; ? rawState() : rawState) || &#123;&#125; &#125;&#125; 现在让我们回到 register 方法中：123456789101112131415161718// 注册模块register (path, rawModule, runtime = true) &#123; ... if (path.length === 0) &#123; // 根模块 this.root = newModule &#125; else &#123; // 子模块 // 调用父模块的 addChild 方法建立父子关系 const parent = this.get(path.slice(0, -1)) parent.addChild(path[path.length - 1], newModule) &#125; // register nested modules（递归注册子模块，建立父子关系） if (rawModule.modules) &#123; forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; this.register(path.concat(key), rawChildModule, runtime) &#125;) &#125;&#125; 可以发现，这段代码根据配置中的 modules 递归执行 register 注册子模块，至于 addChild 方法见 ‘src/module/module.js’ 中：1234// 添加子模块addChild (key, module) &#123; this._children[key] = module&#125; 此时我们发现 new ModuleCollection() 执行后，我们就建立了一个模块树。","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之工具函数","slug":"vuex/vuex.util","date":"2018-09-30T03:27:26.000Z","updated":"2018-09-30T03:37:25.000Z","comments":true,"path":"vuex/vuex.util/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex.util/","excerpt":"我们按照先易后难的原则，先把容易看懂的部分研究完，这节我们来看 ‘src/util.js’。","text":"我们按照先易后难的原则，先把容易看懂的部分研究完，这节我们来看 ‘src/util.js’。 一、find获取 list 执行 f 过滤后的第一个元素12345678910/** * Get the first item that pass the test * by second argument function * @param &#123;Array&#125; list * @param &#123;Function&#125; f * @return &#123;*&#125; */export function find (list, f) &#123; return list.filter(f)[0]&#125; 二、deepCopy递归调用深拷贝对象，cache 数组会缓存所有拷贝对象和嵌套对象，避免无限循环1234567891011121314151617181920212223242526272829303132333435/** * Deep copy the given object considering circular structure. * This function caches all nested objects and its copies. * If it detects circular structure, use cached copy to avoid infinite loop. * @param &#123;*&#125; obj * @param &#123;Array&lt;Object&gt;&#125; cache * @return &#123;*&#125; */export function deepCopy (obj, cache = []) &#123; // 如果 obj 是 null 或者基本数据类型，则直接返回 obj if (obj === null || typeof obj !== &apos;object&apos;) &#123; return obj &#125; // if obj is hit, it is in circular(递归) structure const hit = find(cache, c =&gt; c.original === obj) if (hit) &#123; return hit.copy &#125; const copy = Array.isArray(obj) ? [] : &#123;&#125; // put the copy into cache at first // because we want to refer it in recursive deepCopy cache.push(&#123; original: obj, copy &#125;) // 递归调用 Object.keys(obj).forEach(key =&gt; &#123; copy[key] = deepCopy(obj[key], cache) &#125;) return copy&#125; 三、forEachValue遍历 obj，将键值对传入 fn 调用123456/** * forEach for object */export function forEachValue (obj, fn) &#123; Object.keys(obj).forEach(key =&gt; fn(obj[key], key))&#125; 四、isObject判断是否为 Object123export function isObject (obj) &#123; return obj !== null &amp;&amp; typeof obj === &apos;object&apos;&#125; 五、isPromise判断是否为 isPromise123export function isPromise (val) &#123; return val &amp;&amp; typeof val.then === &apos;function&apos;&#125; 六、assert断言，如果不满足 condition，则抛出 [vuex] ${msg} 错误 123export function assert (condition, msg) &#123; if (!condition) throw new Error(`[vuex] $&#123;msg&#125;`)&#125;","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"vuex 之初始化","slug":"vuex/vuex-init","date":"2018-09-30T02:33:00.000Z","updated":"2018-09-30T03:25:51.000Z","comments":true,"path":"vuex/vuex-init/","link":"","permalink":"http://blog.master-ss.cn/vuex/vuex-init/","excerpt":"最近终于挤出一段时间把 vuex 源码看完了，现在开始总结一波，先从初始化开始逐行分析。","text":"最近终于挤出一段时间把 vuex 源码看完了，现在开始总结一波，先从初始化开始逐行分析。 一、入口访问 https://github.com/vuejs/vuex ，然后 clone 下工程。拿到项目后，我们先来看下 package.json。123456789&#123; &quot;name&quot;: &quot;vuex&quot;, &quot;version&quot;: &quot;3.0.1&quot;, &quot;description&quot;: &quot;state management for Vue.js&quot;, &quot;main&quot;: &quot;dist/vuex.common.js&quot;, &quot;module&quot;: &quot;dist/vuex.esm.js&quot;, &quot;unpkg&quot;: &quot;dist/vuex.js&quot;, ...&#125; 我们重点观察入口文件 “dist/vuex.common.js”、”dist/vuex.esm.js”、”dist/vuex.js”，分别用于 node、es6、browser 环境。注意这些文件都是编译后的文件，而不是源代码。这个时候我们来看 configs.js 部分代码：1234567891011121314151617181920212223242526...const configs = &#123; umdDev: &#123; input: resolve(&apos;src/index.js&apos;), file: resolve(&apos;dist/vuex.js&apos;), format: &apos;umd&apos;, env: &apos;development&apos; &#125;, umdProd: &#123; input: resolve(&apos;src/index.js&apos;), file: resolve(&apos;dist/vuex.min.js&apos;), format: &apos;umd&apos;, env: &apos;production&apos; &#125;, commonjs: &#123; input: resolve(&apos;src/index.js&apos;), file: resolve(&apos;dist/vuex.common.js&apos;), format: &apos;cjs&apos; &#125;, esm: &#123; input: resolve(&apos;src/index.esm.js&apos;), file: resolve(&apos;dist/vuex.esm.js&apos;), format: &apos;es&apos; &#125;&#125;... 可以能清晰的看到配置文件中，不同配置分别对应不同环境，但是入口文件都是 ‘src/index.js’ 或 ‘src/index.esm.js’，我们就从 ‘src/index.js’ 开始。 二、Vue.use(Vuex)相信用过 vuex 的人对 ‘Vue.use(Vuex)’ 这段代码非常熟悉，我们就不绕圈子了，直接说明下他的作用。先来到 vue 的源码片段：1234567891011121314151617Vue.use = function (plugin: Function | Object) &#123; const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this &#125; // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === &apos;function&apos;) &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === &apos;function&apos;) &#123; plugin.apply(null, args) &#125; installedPlugins.push(plugin) return this&#125; 可以看到在 vue 源码中先获取 _installedPlugins 变量，然后判断是否已经存在。后面是获取 Vue.use 方法其他参数，然后如果存在 install 方法的话，调用 install 方法，并传入其他参数，如果不存在 install，则直接调用 plugin。 那么我们现在回到 Vuex 源码中，来看下 ‘src/index.js’ 代码：12345678910111213import &#123; Store, install &#125; from &apos;./store&apos;import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;export default &#123; Store, install, version: &apos;__VERSION__&apos;, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers&#125; 可以发现 install 方法存在于 ‘src/store.js’ 中，我们来看下 install 方法实现：123456789101112131415import applyMixin from &apos;./mixin&apos;...export function install (_Vue) &#123; // 保证反复调用只执行一次 if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error( &apos;[vuex] already installed. Vue.use(Vuex) should be called only once.&apos; ) &#125; return &#125; Vue = _Vue applyMixin(Vue)&#125; 我们发现传入参数 _Vue 被赋值给 Vue 变量，这样我们就能够在插件中使用 Vue 而不用 import 了。你可能好奇 _Vue 什么时候被传入的，可以往上翻一下 args.unshift(this) 这里将 this 也就是 Vue 放入 args 中，然后在 plugin.install.apply(plugin, args) 中传入。 我们继续往下看，来到 ‘src/mixin.js’ 中：123456789101112131415161718export default function (Vue) &#123; const version = Number(Vue.version.split(&apos;.&apos;)[0]) if (version &gt;= 2) &#123; // 全局混入 beforeCreate 钩子函数 Vue.mixin(&#123; beforeCreate: vuexInit &#125;) &#125; else &#123; // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) &#125; &#125;&#125; 可以看到，我们在 mixin.js 中主要就是注入 before 钩子函数。如果 vue 版本 &gt;=2 的话，就全局混入 beforeCreate 钩子函数，1.x 的版本我们就不研究了。 然后我们来看 vuexInit 函数，看下在 beforeCreate 的时候到底做啥了：12345678910111213141516/** * Vuex init hook, injected into each instances init hooks list. * 给 Vue 的实例注入一个 $store 的属性 */function vuexInit () &#123; const options = this.$options // 把 options.store 保存在所有组件的 this.$store 中 if (options.store) &#123; this.$store = typeof options.store === &apos;function&apos; ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; // 如果 $options 没有 store，则向其 parent 向上查找并赋值 this.$store = options.parent.$store &#125;&#125; 可以看到，我们通过 options.store 获取 vuex 的实例对象，并赋值给 this.$store。而且注意，如果是子组件，我们则在父组件上找，将父组件上的 $store 赋值给子组件。这样我们所有的 vue 组件实例就都能够通过 this.$store 拿到 vuex 的实例对象，而且他们是共享的。","categories":[{"name":"vuex","slug":"vuex","permalink":"http://blog.master-ss.cn/categories/vuex/"}],"tags":[]},{"title":"blockchain 之 eth 钱包实战","slug":"essay/eth","date":"2018-09-27T15:05:52.000Z","updated":"2018-12-21T05:46:57.760Z","comments":true,"path":"essay/eth/","link":"","permalink":"http://blog.master-ss.cn/essay/eth/","excerpt":"这章介绍 eth（以太坊）区块链钱包实战。","text":"这章介绍 eth（以太坊）区块链钱包实战。 一、实战之账号生成1.1、生成助记词1234const bip39 = require(&apos;bip39&apos;)&lt;!-- 如：that flock okay rubber promote right lift sell grow turtle camp shoulder --&gt;bip39.generateMnemonic() 1.2、助记词生成私钥123456789const bip39 = require(&apos;bip39&apos;)const HDKey = require(&apos;hdkey&apos;)// 在 imtoken 中使用助记词地址路径是 &quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;let path = &quot;m/44&apos;/60&apos;/0&apos;/0/0&quot;const seed = bip39.mnemonicToSeed(mnemonic)const hdWallet = HDKey.fromMasterSeed(seed)const keyPair = hdWallet.derivePath(path)const privateKey = &apos;0x&apos; + keyPair.privateKey.toString(&apos;hex&apos;) 1.3、私钥生成账号12345const Web3 = require(&apos;web3&apos;)&lt;!-- 可在 infura 申请免费连接节点 --&gt;const web3 = new Web3(new Web3.providers.HttpProvider(&quot;https://mainnet.infura.io/v3/f06735caf2964f6881c7a219b8196471&quot;))const account = web3.eth.accounts.privateKeyToAccount(privateKey) 1.4、随机创建账号12&lt;!-- web3 配置同私钥生成账号 --&gt;const account = web3.eth.accounts.create() 1.5、生成备份 keystore12&lt;!-- web3 配置同私钥生成账号，privateKey 为私钥，password 为加密密码 --&gt;const keyStore = JSON.stringify(web3.eth.accounts.encrypt(privateKey, password)) 1.6、keyStore 导入12&lt;!-- web3 配置同私钥生成账号，password 为加密密码 --&gt;const account = web3.eth.accounts.decrypt(keyStore, password) 二、实战之交易2.1、获取账户余额12345678910111213141516171819202122232425const BigNumber = require(&apos;bignumber.js&apos;)&lt;!-- 获取比特币余额 --&gt;const balance = await web3.eth.getBalance(address)const res = web3.utils.fromWei(balance, &apos;ether&apos;)&lt;!-- 获取代币余额，contractAddress 为合约地址，contractAbi 为以太坊 erc20 标准的 abi --&gt;const contractAbi = [ &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;name&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;symbol&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;decimals&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint8&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;totalSupply&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [&#123; &quot;name&quot;: &quot;_owner&quot;, &quot;type&quot;: &quot;address&quot; &#125;], &quot;name&quot;: &quot;balanceOf&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;balance&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [&#123; &quot;name&quot;: &quot;_to&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;name&quot;: &quot;transfer&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [&#123; &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;name&quot;: &quot;approve&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [&#123; &quot;name&quot;: &quot;_from&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;name&quot;: &quot;_to&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;name&quot;: &quot;_value&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;name&quot;: &quot;transferFrom&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;bool&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [&#123; &quot;name&quot;: &quot;_owner&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;name&quot;: &quot;_spender&quot;, &quot;type&quot;: &quot;address&quot; &#125;], &quot;name&quot;: &quot;allowance&quot;, &quot;outputs&quot;: [&#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;constructor&quot; &#125;, &#123; &quot;anonymous&quot;: false, &quot;inputs&quot;: [&#123; &quot;indexed&quot;: true, &quot;name&quot;: &quot;owner&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;indexed&quot;: true, &quot;name&quot;: &quot;spender&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;indexed&quot;: false, &quot;name&quot;: &quot;value&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;name&quot;: &quot;Approval&quot;, &quot;type&quot;: &quot;event&quot; &#125;, &#123; &quot;anonymous&quot;: false, &quot;inputs&quot;: [&#123; &quot;indexed&quot;: true, &quot;name&quot;: &quot;from&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;indexed&quot;: true, &quot;name&quot;: &quot;to&quot;, &quot;type&quot;: &quot;address&quot; &#125;, &#123; &quot;indexed&quot;: false, &quot;name&quot;: &quot;value&quot;, &quot;type&quot;: &quot;uint256&quot; &#125;], &quot;name&quot;: &quot;Transfer&quot;, &quot;type&quot;: &quot;event&quot; &#125;]const contract = new web3.eth.Contract(contractAbi, contractAddress)const balance = await contract.methods.balanceOf(address).call()const decimals = await contract.methods.decimals().call()const res = BigNumber(balance).div(Math.pow(10, decimals)).decimalPlaces(4) 2.2、获取推荐 GasPrice12const gasPrice = await web3.eth.getGasPrice()const res = web3.utils.fromWei(gasPrice, &apos;gwei&apos;) 2.3、获取推荐 GasLimit12345678910111213141516171819&lt;!-- 如果是以太币交易直接返回 21000，payeeAddress 为收款人地址，address 为转账人地址，contractAddress 为合约地址 --&gt;let formatPayeeAddress = _addPreZero(payeeAddress.substr(2))let formatAmount = _addPreZero(web3.utils.toHex(web3.utils.toWei(amount, &apos;ether&apos;)).substr(2))const gasLimit = await web3.eth.estimateGas(&#123; from: address, to: contractAddress, &lt;!-- &apos;0xa9059cbb&apos; 为固定前缀；formatPayeeAddress 先去掉 &apos;0x&apos;，再补全 64 位；formatAmount 先转为 wei 单位，然后转成 hex 格式，去掉前面 &apos;0x&apos;，再补全 64 位 --&gt; data: `0xa9059cbb$&#123;formatPayeeAddress&#125;$&#123;formatAmount&#125;`&#125;)// 补齐64位，不够前面用0补齐function _addPreZero(num) &#123; var t = (num + &apos;&apos;).length, s = &apos;&apos; for (var i = 0; i &lt; 64 - t; i++) &#123; s += &apos;0&apos; &#125; return s + num&#125; 三、实战之查询通过自建 mongodb 数据库，读取整个 eth 链上的数据到库中，实现代币查询和交易历史查询功能。具体实现可参考 https://github.com/TrustWallet/trust-ray/ 。 3.1、遇到的问题 web3.js 版本问题带来的解析错误，解决方法： 12345678// 兼容性处理，新版本 web3 报错，换一种写法if (abi.name.toLowerCase() == &apos;decimals&apos;) &#123; const value = await web3.eth.call(&#123; to: contractAddress, data: contractInstance.methods[abi.name]().encodeABI() &#125;) return web3.utils.hexToNumber(value)&#125; 特殊数据报错，解决方法： 12345678// 0xe065f822c8184971ab2598663f5db8d4cce72ca7bd8f3b69666129eaea32af26let decodedLogstry &#123; decodedLogs = abiDecoder.decodeLogs(transaction.receipt.logs).filter((log) =&gt; log)&#125; catch(error) &#123; logger.info(`Could not parse transaction with error: $&#123;transaction._id&#125;`); decodedLogs = []&#125; 部分合约不规范，导致无法解析，拟手动修复。或在代币搜索页面用户提交未覆盖的代币，然后进行修改 内存溢出，默认 v8 内存固定，当超出内存时导致溢出。手动修改内存空间，解决方案如下： 12&lt;!--添加 --max_old_space_size=4096 参数配置--&gt;&quot;dev&quot;: &quot;cross-env EGG_SERVER_ENV=prod NODE_ENV=prod node --max_old_space_size=4096 dispatch.js&quot; mongodb 空间不足，预计需要六七百 G 测试过不同并发量，最终确定最佳并发量为 10。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"blockchain 之 eth 发币、映射、钱包","slug":"essay/token","date":"2018-09-26T14:58:55.000Z","updated":"2019-01-10T06:03:17.491Z","comments":true,"path":"essay/token/","link":"","permalink":"http://blog.master-ss.cn/essay/token/","excerpt":"这章介绍以太坊发币，映射 eos 公链和钱包开发价值。","text":"这章介绍以太坊发币，映射 eos 公链和钱包开发价值。 一、发币1.1、简介ERC20 是以太坊代币的标准，以太坊 token （即代币）就是基于 ERC20 标准的数字货币，token 兼容以太坊钱包。通俗上我们可以把以太坊当成一条大街，然后街上有很多店。为了经营，每个店都发布了自己的会员卡，这个会员卡就是 token。 1.2、ERC20 内容12345678910111213141516171819202122// 返回 string 类型的 ERC20 代币的名字name// 返回 string 类型的 ERC20 代币的符号，也就是代币的简称symbol// 支持几位小数点后几位，如果设置为 3，也就是支持 0.001 表示decimals// 发行代币的总量totalSupply// 获取该地址代币的余额balanceOf// 调用 transfer 函数将 token 转账给 _to 地址，_value 为转账个数transfer// 批准账户从自己的账户转移 _value 个 token，可以分多次转移approve// 与 approve 搭配使用，approve 批准之后，调用 transferFrom 函数来转移 tokentransferForm// 返回其他账户还能提取 token 的个数allowance// 当成功转移 token 时，一定要触发 Transfer 事件Transfer// 当调用 approval 函数成功时，一定要触发 Approval 事件Approval 1.3、ERC20 实现案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192pragma solidity ^0.4.16;contract TokenERC20 &#123; // token 的共有变量 string public name; string public symbol; // 强烈建议使用 18 位小数 uint8 public decimals = 18; uint256 public totalSupply; // 创建一个地址的余额映射 mapping (address =&gt; uint256) public balanceOf; // 创建一个地址的授权映射 mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // 生成一个公共事件用来提醒客户端 event Transfer(address indexed from, address indexed to, uint256 value); // 提醒客户端销毁多少token event Burn(address indexed from, uint256 value); // 构造函数 function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes &#125; // 内部转换，只能被合约内容调用 function _transfer(address _from, address _to, uint _value) internal &#123; // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows （检查溢出） require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; // 从账户转移 token 到其他账户 function transfer(address _to, uint256 _value) public &#123; _transfer(msg.sender, _to, _value); &#125; // 从 _from 转移 token 到 _to 上，代替 _from 账户 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; // 授权 _spender 使用账户 token function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; // 销毁 token function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; &#125; // 销毁其他账户的 token function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&apos;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; &#125;&#125; 1.4、自定义合约虽然我们可以一行代码都不敲，直接粘贴复制合约代码发币，但是往往这样满足不了我们自定义的需求。现在来添加以下自定义功能：权限控制、添加token、资源冻结、交易和购买。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178pragma solidity ^0.4.16;// 权限控制contract owned &#123; address public owner; function owned() public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address newOwner) onlyOwner public &#123; owner = newOwner; &#125;&#125;contract TokenERC20 &#123; // token 的共有变量 string public name; string public symbol; // 强烈建议使用 18 位小数 uint8 public decimals = 18; uint256 public totalSupply; // 创建一个地址的余额映射 mapping (address =&gt; uint256) public balanceOf; // 创建一个地址的授权映射 mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; // 生成一个公共事件用来提醒客户端 event Transfer(address indexed from, address indexed to, uint256 value); // 提醒客户端销毁多少token event Burn(address indexed from, uint256 value); // 构造函数 function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes &#125; // 内部转换，只能被合约内容调用 function _transfer(address _from, address _to, uint _value) internal &#123; // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] &gt;= _value); // Check for overflows （检查溢出） require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; // 从账户转移 token 到其他账户 function transfer(address _to, uint256 _value) public &#123; _transfer(msg.sender, _to, _value); &#125; // 从 _from 转移 token 到 _to 上，代替 _from 账户 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; // 授权 _spender 使用账户 token function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; // 销毁 token function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); // Check if the sender has enough balanceOf[msg.sender] -= _value; // Subtract from the sender totalSupply -= _value; // Updates totalSupply emit Burn(msg.sender, _value); return true; &#125; // 销毁其他账户的 token function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); // Check if the targeted balance is enough require(_value &lt;= allowance[_from][msg.sender]); // Check allowance balanceOf[_from] -= _value; // Subtract from the targeted balance allowance[_from][msg.sender] -= _value; // Subtract from the sender&apos;s allowance totalSupply -= _value; // Update totalSupply emit Burn(_from, _value); return true; &#125;&#125;/******************************************//* 高级自定义 *//******************************************/contract MyAdvancedToken is owned, TokenERC20 &#123; uint256 public sellPrice; uint256 public buyPrice; mapping (address =&gt; bool) public frozenAccount; // 触发一个公共事件提醒客户端 event FrozenFunds(address target, bool frozen); // 合约初始化 function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public &#123;&#125; // 内部传输，只在合约内部被调用 function _transfer(address _from, address _to, uint _value) internal &#123; require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] &gt;= _value); // Check if the sender has enough require (balanceOf[_to] + _value &gt;= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]); // Check if sender is frozen require(!frozenAccount[_to]); // Check if recipient is frozen balanceOf[_from] -= _value; // Subtract from the sender balanceOf[_to] += _value; // Add the same to the recipient emit Transfer(_from, _to, _value); &#125; // 铸币给 target 账户 function mintToken(address target, uint256 mintedAmount) onlyOwner public &#123; balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); &#125; // 冻结账户 function freezeAccount(address target, bool freeze) onlyOwner public &#123; frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); &#125; // 设置价格 function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public &#123; sellPrice = newSellPrice; buyPrice = newBuyPrice; &#125; // 购买 token function buy() payable public &#123; uint amount = msg.value / buyPrice; // calculates the amount _transfer(this, msg.sender, amount); // makes the transfers &#125; // 售卖 token function sell(uint256 amount) public &#123; address myAddress = this; require(myAddress.balance &gt;= amount * sellPrice); // checks if the contract has enough ether to buy _transfer(msg.sender, this, amount); // makes the transfers msg.sender.transfer(amount * sellPrice); // sends ether to the seller. It&apos;s important to do this last to avoid recursion attacks &#125;&#125; 二、映射EOS 首先是在以太坊上发布代币众筹，后面 EOS 有了自己独立的公链。等众筹结束后，将以太坊上的代币放到 EOS 公链上转成真正的 EOS 币种，用户需要自己做映射。 2.1、映射教程（https://www.zhihu.com/question/265707806 ）2.1.1、到EOS公链上生成EOS密钥对生成密钥对的网址: https://nadejde.github.io/eos-token-sale/密钥对生成网站代码在: https://github.com/Nadejde/eos-token-sale/EOS官方的完整代码在: https://github.com/EOSIO/eos-token-distribution/ 2.1.2、注册一个 myetherwallet 的钱包，并进行映射2.2、映射部分代码映射合约源代码： https://etherscan.io/address/0xd0a6e6c54dbc68db5db3a091b171a77407ff7ccf#code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177contract EOSSale is DSAuth, DSExec, DSMath &#123; DSToken public EOS; // 详情见源代码 uint128 public totalSupply; // Token 总量 uint128 public foundersAllocation; // 开发团队保留份额 string public foundersKey; // 保留份额 Holder Address uint public openTime; // window 0 开始时间 uint public createFirstDay; // window 0 供应量 uint public startTime; // window 1 开始时间 uint public numberOfDays; // window 总数 uint public createPerDay; // 每日供应量 /** * EOS 的 ICO 规则为：前五天为一个 window 总共发行 2 亿 Token。五天之后，每23个小时为一个window，发行 2 百万 Token。总共发行 10 亿 Token */ mapping (uint =&gt; uint) public dailyTotals; mapping (uint =&gt; mapping (address =&gt; uint)) public userBuys; mapping (uint =&gt; mapping (address =&gt; bool)) public claimed; mapping (address =&gt; string) public keys; event LogBuy (uint window, address user, uint amount); event LogClaim (uint window, address user, uint amount); event LogRegister (address user, string key); event LogCollect (uint amount); event LogFreeze (); function EOSSale( uint _numberOfDays, uint128 _totalSupply, uint _openTime, uint _startTime, uint128 _foundersAllocation, string _foundersKey ) &#123; numberOfDays = _numberOfDays; totalSupply = _totalSupply; openTime = _openTime; startTime = _startTime; foundersAllocation = _foundersAllocation; foundersKey = _foundersKey; // // window 0 Token 供应量 (由于 solidity 里面没有 float 类型，想要乘以 0.2 可以通过 乘以 0.2 ether 实现) createFirstDay = wmul(totalSupply, 0.2 ether); // // window 1 以及以后的每天 Token 供应量 createPerDay = div( sub(sub(totalSupply, foundersAllocation), createFirstDay), numberOfDays ); assert(numberOfDays &gt; 0); assert(totalSupply &gt; foundersAllocation); assert(openTime &lt; startTime); &#125; function initialize(DSToken eos) auth &#123; assert(address(EOS) == address(0)); assert(eos.owner() == address(this)); assert(eos.authority() == DSAuthority(0)); assert(eos.totalSupply() == 0); EOS = eos; // mint 方法是 dapp_token 提供，用来设置 Token 供应总量 EOS.mint(totalSupply); // 开发团队保留的份额被发送到 0xb1 。这个地址是无人可用的，等于丢掉此数量的 Token ，但是又保证 Token 总供应量不变。EOS 团队不需要这个代币，因为在 EOS 上线之后，现在的 Token 会兑换为 EOS 链上的 Token。 EOS.push(0xb1, foundersAllocation); keys[0xb1] = foundersKey; LogRegister(0xb1, foundersKey); &#125; function time() constant returns (uint) &#123; return block.timestamp; &#125; function today() constant returns (uint) &#123; return dayFor(time()); &#125; // 前五天都是 window 0 。之后每23小时为一个 window 。这么做的好处是让每个 window 的开始时间是滚动的，不同时区的投资者更方便参与。 function dayFor(uint timestamp) constant returns (uint) &#123; return timestamp &lt; startTime ? 0 : sub(timestamp, startTime) / 23 hours + 1; &#125; function createOnDay(uint day) constant returns (uint) &#123; return day == 0 ? createFirstDay : createPerDay; &#125; // This method provides the buyer some protections regarding which // day the buy order is submitted and the maximum price prior to // applying this payment that will be allowed. function buyWithLimit(uint day, uint limit) payable &#123; // 限制时间 assert(time() &gt;= openTime &amp;&amp; today() &lt;= numberOfDays); assert(msg.value &gt;= 0.01 ether); assert(day &gt;= today()); assert(day &lt;= numberOfDays); // 购买记录 userBuys[day][msg.sender] += msg.value; dailyTotals[day] += msg.value; if (limit != 0) &#123; assert(dailyTotals[day] &lt;= limit); &#125; LogBuy(day, msg.sender, msg.value); &#125; function buy() payable &#123; buyWithLimit(today(), 0); &#125; function () payable &#123; buy(); &#125; function claim(uint day) &#123; assert(today() &gt; day); // 防止重复兑换 if (claimed[day][msg.sender] || dailyTotals[day] == 0) &#123; return; &#125; // This will have small rounding errors, but the token is // going to be truncated to 8 decimal places or less anyway // when launched on its own chain. var dailyTotal = cast(dailyTotals[day]); var userTotal = cast(userBuys[day][msg.sender]); // 指定 window 的 Token 供应量除以此 window 的 eth 总量，得到兑换比例 var price = wdiv(cast(createOnDay(day)), dailyTotal); // 兑换比例乘以指定 window 中此用户支付的 eth 数量得到兑换总量 var reward = wmul(price, userTotal); // 记录兑换标志 claimed[day][msg.sender] = true; // 执行转账 EOS.push(msg.sender, reward); LogClaim(day, msg.sender, reward); &#125; function claimAll() &#123; for (uint i = 0; i &lt; today(); i++) &#123; claim(i); &#125; &#125; // 注册 EOS 共钥，EOS 团队要求投资者在众筹结束之前自行生成 EOS 公私钥，并将生成的共钥注册在合约中。这样在 EOS 正式上线之后，用户可以兑换 EOS 上的 Token 。 function register(string key) &#123; assert(today() &lt;= numberOfDays + 1); assert(bytes(key).length &lt;= 64); keys[msg.sender] = key; LogRegister(msg.sender, key); &#125; // ETH 转移（auth 是 dapp_auth 提供的权限控制方法，保证 collect 函数只能被合约 owner 执行） function collect() auth &#123; assert(today() &gt; 0); // window 0 不能转移 exec(msg.sender, this.balance); // 将 eth 转移给调用者 LogCollect(this.balance); &#125; // Anyone can freeze the token 1 day after the sale ends function freeze() &#123; assert(today() &gt; numberOfDays + 1); EOS.stop(); LogFreeze(); &#125;&#125; 三、钱包3.1、钱包简介区块链钱包目前很多人的认识就是数字资产的管理软件，用来转账和收款。由于区块链只要私钥丢失，就意味着所有的数字资产很容易就可以被人盗走，所以私钥通常都是保存在本地。私钥保存在本地的代价就是任何区块链交易都需要在本地完成私钥签名，才能将整个交易流程走通，这就使得现有的很多 DAPP 无法做到无缝地体验，换言之区块链钱包之于 DAPP，就如同支付宝之于各种电商 APP。 支付宝占据了人民币交易的大部分市场份额，于是支付宝就成了很多交易场景无法绕过去的支付工具，我们熟悉的电商、旅游订票、知识服务等平台，都会在手机端唤起支付宝APP完成最终的支付流程。同样的，区块链上的数字资产未来极有可能也会因为大规模 DAPP 的出现而使得交易更加频繁，于是方便快捷的钱包产品就显得非常有必要了。 3.2、钱包之应用分发中心有人调研了国内外很多区块链钱包产品，很多钱包已经开始集成有限的 DAPP 了，用户在使用 DAPP 时，只要有需要支付交易的场景，都会唤起本地钱包完成私钥签名和支付，这就像很多第三方电商 APP 会在需要交易的时候唤起支付宝。区块链钱包的价值就在于给各种第三方 DAPP 提供了一套完整的支付体验流程，基于此，我们有理由相信未来的钱包很有可能会是一个应用分发中心。 过往很多商业模式都是基于流量思维，对于线下零售来说，好地段永远都是最重要的选址标准，因为好地段就意味着大流量。同样的，对于互联网应用来说，流量依然是大家极其看重的指标，微信垄断了社交流量、阿里垄断了电商流量、百度垄断了搜索流量、抖音垄断了短视频流量等等，对于一家手握大量流量的公司来说，商业变现都是迟早的事情。 3.3、钱包拓展背景在区块链领域，过去很多人都觉得中心化的交易所未来极有可能是流量入口，但是从过往交易所监守自盗的劣迹来看，人们极有可能会最终抛弃中心化交易所。数字资产交易所和传统的股票交易所本质上并没有太大的区别，数字资产交易所今天上演的各种行为，在很多人看来完全是在复制早期股票交易所，所不同的是，数字资产交易所未来是否会引入监管还存在极大的不确定性。于是各种内幕交易、操盘价格走势，再加上做空和期货的引入，交易所既可以成倍放大收益，也可以成倍放大市场的恐慌情绪。 最重要的一点是人们在交易所上存放的数字资产本质上并不掌握所有权，人们只是把数字资产转到了交易所指定的账号上，由交易所代为管理。所以交易所完全有可能直接用这些数字资产去做短期套利，而只需要在个人账户界面上显示原来的余额即可。对于刚刚过去的 EOS 投票上线主网，由于散户的投票热情很低，EOS 因为投票率低迟迟无法上线主网，最后是交易所推高了投票率，才使得 EOS 主网最终上线主网，那么我们就有理由相信交易所私自动用了未经用户授权的 EOS，强行代用户进行了投票。 最后最为致命的一点就是交易所由于缺乏监管，理论上完全有可能携款跑路，至少目前国家法律并不保护用户的数字资产，所以散户们除了道德谴责好像也找不到更好的维权途径，不要以为我在危言耸听，很多小规模的交易所已经开始无法提现了。 3.4、DAPP 的价值钱包由于满足了用户管理数字资产的刚需，所以用户量可以做到很高，今天中国币圈投资者基本上没有人不知道 imToken 钱包的。随着去中心化交易所技术的不断改善和提高，我们有理由相信钱包内置去中心化交易平台会是一个大趋势，一旦人们的交易需求被满足，那么人们极有可能会抛弃中心化交易所。 除了交易需求，未来更大的想象空间应该来自 DAPP 的大爆发，互联网以及随后的移动互联网最为火热的阶段都是大量应用层出不穷的时候，诞生了很多世界级的大公司，人们也因此享受到了更加便捷的生活方式。我们有理由相信随着区块链基础设施的不断完善，未来基于区块链的去中心化应用（DAPP）会开始呈现爆发的态势。 Token 可以让区块链上的信息以极低的成本在用户之间完成交易，智能合约则可以通过代码编程的方式定制利益分配规则，促成更多的分工合作。当越来越多的 DAPP 爆发时，所有的交易都需要私钥签名，出于安全性考虑，私钥又不得不放在钱包 APP 中，所以就需要钱包充当媒介为 DAPP 提供最终的支付解决方案。如果钱包本身就是一个应用分发中心的话，那么就意味着人们可以在钱包中使用完成从 DAPP 体验到支付的所有环节。 3.5、多链资产和跨链交易如果未来钱包真的要充当应用分发中心和支付媒介，那么就肯定会有多链资产和跨链交易的需求，目前我们看到的很多钱包都还是只支持单一区块链平台，随着区块链开始在各个行业渗透，未来的钱包大概率会出现多条链并存，DAPP 横跨多条链的场景。 想象一下，如果一款钱包可以同时支持比特币、以太坊以及各种 ERC20 代币、EOS、IOTA 等，是不是会觉得非常方便，如果还能在钱包中完成这几种资产的比例自由配置，估计币圈的投资者会有一种相见恨晚的感觉。 我们不妨再想象一下，如果今天的加密猫游戏不仅仅是基于以太坊的 ERC721 代币，还包括其他区块链数字货币，那么游戏体验会不会更好，用户可以通过比特币充值，然后用以太币完成交易，还可以换成某条侧链上的资产去玩其他周边游戏，比如说给猫买一顶帽子等。一旦跨链交易成为可能，游戏的扩展性和可玩性都会得到极大的提高。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"blockchain 之 eos 钱包实战","slug":"essay/eos","date":"2018-09-25T14:25:16.000Z","updated":"2018-12-21T05:46:54.638Z","comments":true,"path":"essay/eos/","link":"","permalink":"http://blog.master-ss.cn/essay/eos/","excerpt":"这章介绍 eos（Enterprise Operation System）区块链钱包实战。","text":"这章介绍 eos（Enterprise Operation System）区块链钱包实战。 一、基础知识点 EOS 带着免费的口号来，不过事实上注册一个账号就要 100 多人民币， DAPP 的开销就更大了。但是确实也有一些好东西是免费的，一是消耗的 CPU 和 NET 以一天为周期自动清零，二是不涉及到 table 的数据是免费的 去中心化和高 TPS 其实是一对矛盾体，越去中心化，效率越低，TPS 自然就低。因此 DPOS 应运而生，投票选出 21 个代表，决策者只有 21 个代表，而不是 POW 的全民运动，自然决策效率高 账号执行的 action 需要写数据时就需要消耗 ram staked 是自己的 EOS 量，delegated 是别人帮忙垫付的 EOS 量，这两部分都是抵押的 EOS，用来预购买 cpu bandwidth 和 net bandwidth 的。可以把 staked 中的 EOS 提现到 balance 里，让这些 EOS 恢复自由。提现是有时间延时的，3 天后才能退回到 balance 里，同时已经花掉的 eos 没法立马提现，必须随着系统总带宽增加慢慢提现 balance: 和网上所说的 unstaked eos 是一个东西，即用户可以自由转账的 EOS 数值 memory: 就是 ram， 新建账号时，账号数据会写到数据库里，因而需要购买 ram。但是先有账号才能购买 ram, 而创建账号又必须要有 ram，所以这里存在一个先有鸡还是先有蛋的问题，一般需要有账号的人帮忙创建 stake 抵押原理: 当我们抵押一部分 EOS 时，其实会引发一次转账。会从当前账号转走对应的 EOS 至 eosio.stake 账号(可认为是往 eosio.stake 账号充值)，同时记录来源，方便后期从 eosio.stake 提现，提现相当于充值一个负值 ram 购买: 扣除 0.5% 手续费后的 EOS 转到购买 ram 的账号 eosio.ram，根据 ram 市场里的 EOS 和 ram 实时汇率计算出能够购买的 ram 量，然后更新该账号的 ram 拥有量。ram 购买的量是一个绝对值，是根据购买时市场内 EOS 和 ram 的汇率计算出来的。一般来说在 ram 总量不增加的情况下，ram 会越来越贵。所以如果早期你购买了 ram，然后过段时间后卖掉 ram 可能还能挣钱 cpu、net 收费逻辑: cpu，net 的消耗量是绝对值，以 kb 计量，而 cpu， net 的拥有量不是以 kb 计量的，而是以抵押的 EOS 计量保存，在余额检测时才实时转为具体的绝对 kb 值进行比较。全网的网络抵押的 EOS 越多，账号能用的网络带宽就越少，即和抵押的 EOS 总量相关，而不是和全部发行的 EOS 量相关。首先获取窗口时间内的全网网络流量总量、该账号的网络 EOS 抵押量、全网所有用户的网络总 EOS 抵押量，根据占据 EOS 抵押量的比例，获取窗口时间内账号可用最大网络量 cpu、net 购买: 购买 cpu、 net 资源是通过抵押 EOS 实现的 cpu，net 的消耗量是临时的，过一段时间可以清空，可以继续使用。间隔的时间越长，上次的消耗量占比越低；历史消耗量要乘上一个衰减系数，即总消耗量不是直接历史消耗量 + 本次消耗量；超过一个窗口时间后，历史消耗量清零，也就相当于未曾消耗过；源码窗口时间是 1 天。有可能执行一次转账后，cpu used 反而变小了，就是因为衰减 存在账号 ram，cpu 资源用尽了，无法执行如何操作，比如创建新账号失败，因为 cpu 不够。然后想着购买 cpu，然后因为 ram、net 不够失败。那购买 ram、net 仍旧失败，因为没有足够的 cpu。所以进入一个死循环，没有 ram 没法购买 cpu，没有 cpu 没法购买 ram。要解决这个问题，只能再找一个账号，让别人给你购买一些 ram 或 cpu 存在突发事件导致账号冻结。2018.7.22 的 23 点到 24 点短短 1 个小时，全网 CPU 抵押的 EOS 快速激增了一倍，导致每个人可以用的 CPU 减少了一半，进而很多账号的 CPU 都超支了，就是已使用的 CPU 超过了用户拥有的 CPU 量，进而处于僵死状态，啥都不能做。因为用户的可用 CPU 量是动态变化的，按用户的 CPU 抵押量占全网的总抵押量的比例来分配可使用的 CPU 量，而用户的 CPU 已使用量(used)是不变的，所以当用户的 CPU 可使用量(limit)动态下降到一定程度就出现超支了。全网 CPU 抵押量激增主要是 TPS 大增导致，但是短时间的激增是因为突发事件导致每个账号的 CPU 可使用量快速下降，进而导致很多账号失活，然后解决失活的 CPU 抵押操作进一步增加全网 CPU 的抵押量，进一步降低了账号的 CPU 可使用量，从而更多账号失活，因而这是一个恶性循环。但是这个恶性循环有它的截止点，因为大部分用户在账号失活后(当前账号没法抵押 EOS 换取更多 CPU)，没有渠道快速抵押 EOS 换取 CPU 来重新激活。不着急操作的账号就等，等一天或者两天不操作，哪怕你 CPU 超支了，超支的再多也不用怕，你只需执行很小的 CPU 抵押操作，系统就会帮你清零已使用的 CPU EOS 钱包天生就是多签钱包，每一个账户都有两个以上的私钥与之对应, 但是多把私钥, 可以是相同的。比如, 一个 EOS 账号为 imtokensimon, 这个账户的 owner 私钥是 123, active 的私钥可以设定为 123, 也可以是 456。Owner 私钥代表着一个 EOS 账户的最高权限, 它可以用来分配并重置 Active 私钥的权限。Active 私钥可以做除了修改 Owner 以外所有的事, 基本来说, 用户的转账授权等操作, 都是通过 Active 私钥来完成的 用户可以使用冷存储的方式, 存储 Owner 私钥, 这样如果你的 Active 私钥泄露了, 可以使用 Owner 私钥重置你的 Active 私钥, 但需要注意的是, 如果你的 Active 私钥泄露了, 黑客也能够转移你的资产 memo（备注）最多存 256 字节,可以放中文 抵押/赎回 CPU 和 NET 资源: A 以租借的形式为 B 抵押资源，A 可以赎回，B 无法赎回； A 以赠送的方式为 B 抵押资源，A 无法赎回，B 可以赎回； B 自己抵押资源并且可以赎回。赎回资源时，EOS 不会马上到账，而是会在三天后到账。你无法赎回已经使用的资源，需要在该资源自动释放后才可赎回。CPU 和 NET 资源是系统自动释放的，也就是已使用的这部分资源会在一段时间后恢复并可以再次使用。抵押和赎回也是通过 eosio.token 的 transfer 方法，与系统账户 eosio.stake 相互转账，系统不会收取手续费 购买/出售内存: 内存资源是通过使用 EOS Token 购买获得的，可以由其他账户为你购买，也可以自己购买。不管是前面哪种形式为你购买的内存，都是属于你的，可以出售，获得的 EOS Token 也都会立刻打入到你的账户。本质上，购买和出售内存，都是通过 eosio.token 的transfer 方法，与系统账户 eosio.ram 相互转账。同时，系统会在每次交易中(包括购买和出售)收取本次交易中 EOS 总额的 5% 作为手续费，也就是向 eosio.ramfee 转账。需要注意的是，内存资源是不可自动恢复的 其实只需要为新账户购买内存资源，否则会创建失败。而抵押 CPU 和 NET 资源可以不在创建账户时同时进行。但一般来说，为了使新账户可以操作一些事情，例如转账，都会在创建时同时为其抵押 CPU 和 NET 资源。这时就会出现一笔 transaction 中包含多个 action 的情况 二、测试网络 JungleTestnet 是一条 eos 的备用链，用于开发测试的使用。测试用币从现实币中隔离区分开来，并且没有任何实际价值，仅作为开发的实验使用，不用担心在这条链上的交易会影响甚至使现实链崩溃。 可在 http://jungle.cryptolions.io/#faucet 上免费领取到测试币 可在 http://jungle.cryptolions.io/#account 上免费创建新账号 可在 http://jungle.cryptolions.io/#apiendpoints 上获取免费的测试节点 三、实战之账号1、种子生成秘钥对123456const EOS = require(&apos;eosjs&apos;)const &#123; ecc &#125; = EOS.modules&lt;!-- seed 为生成账号种子，相同种子生成的私钥相同，可借助助记词 --&gt;let privateKey = ecc.seedPrivate(seed)let publicKey = ecc.privateToPublic(privateKey) 2、私钥导入1234const EOS = require(&apos;eosjs&apos;)const &#123; ecc &#125; = EOS.moduleslet publicKey = ecc.privateToPublic(privateKey) 3、判断公钥是否有效1234const EOS = require(&apos;eosjs&apos;)const &#123; ecc &#125; = EOS.modulesecc.isValidPublic(publicKey) 4、判断私钥是否有效1234const EOS = require(&apos;eosjs&apos;)const &#123; ecc &#125; = EOS.modulesecc.isValidPrivate(privateKey) 5、根据公钥获取账号名12345678910111213141516171819let config = &#123; httpEndpoint: &apos;http://jungle.cryptolions.io:18888&apos;, // eos 测试网络节点 expireInSeconds: 60, chainId: &apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;, // 节点的 chainId 信息，可通过 eos.getInfo(&#123;&#125;) 获取 broadcast: true, debug: false, sign: true&#125;let eos = EOS(config)eos.getKeyAccounts(publicKey).then(res =&gt; &#123; if (res.account_names.length &gt; 0) &#123; console.log(res.account_names) // 账号名，一个公钥可对应多个账号 &#125; else &#123; console.log(&apos;该地址在网络中无账号，请先注册账号！&apos;) &#125;&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 6、根据账号名获取账号信息12345678&lt;!-- config 同根据公钥获取账号名 --&gt;let eos = EOS(config)eos.getAccount(&#123; account_name: name &#125;).then(res =&gt; &#123; cosnole.log(res)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 7、创建账号1234567891011121314151617181920212223242526272829303132333435let config = &#123; httpEndpoint: &apos;http://jungle.cryptolions.io:18888&apos;, // eos 测试网络节点 expireInSeconds: 60, chainId: &apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;, keyProvider: privateKey, // 创建者账户私钥 broadcast: true, debug: false, sign: true&#125;let eos = EOS(config)eos.transaction(tr =&gt; &#123; tr.newaccount(&#123; creator: creator, // 创建者账户名称 name: accountName, // 新账户名称 owner: owner, // owner 权限公钥 active: active // active 权限公钥 &#125;) tr.buyrambytes(&#123; payer: creator, receiver: accountName, bytes: Number(bytes)// 购买存储空间字节数，如 8192 &#125;) tr.delegatebw(&#123; from: creator, receiver: accountName, stake_net_quantity: stake_net_quantity, // 抵押 net 数 stake_cpu_quantity: stake_cpu_quantity, // 抵押 cpu 数 transfer: transfer // transfer 设置为 1 时，抵押的 EOS，会转到新账户 &#125;)&#125;).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 四、实战之资源1、抵押带宽12345678910111213141516&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)let form = &#123; from, // 账户名称 receiver, // 抵押接收人 stake_net_quantity, // 抵押 net 数量，如 10.0000 EOS stake_cpu_quantity, // 抵押 cpu 数量，如 10.0000 EOS transfer, // transfer 设置为 1 时，抵押的 EOS，会转到新账户（如果自己给自己抵押，不能设置为 1）&#125;eos.delegatebw(form).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 2、赎回带宽123456789101112131415&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)let form = &#123; from, // 账户名称 receiver, // 赎回接收人 unstake_net_quantity, // 赎回 net 数量，如 10.0000 EOS unstake_cpu_quantity, // 赎回 cpu 数量，如 10.0000 EOS&#125;eos.undelegatebw(form).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 3、手动赎回123456789&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)&lt;!-- owner: 账户名称，用于 undelegatebw 操作三天后仍未被赎回，手动触发 --&gt;eos.refund(&#123; owner &#125;).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 4、购买 ram1234567891011121314&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)let form = &#123; payer, // 付款账户名称 receiver, // 接收人 quant, // 购买数量，如 1.0000 EOS&#125;eos.buyram(form).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 5、出售 ram12345678910111213&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)let form = &#123; account, // 账户名称 bytes, // 出售大小，必须为整数&#125;eos.sellram(form).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 五、实战之交易1、获取某种资源详情123456789&lt;!-- config 同根据公钥获取账号名 --&gt;let eos = EOS(config)&lt;!-- code: 代币合约; symbol: 代币符号 --&gt;eos.getCurrencyStats(code, symbol).then(res =&gt; &#123; console.log(res)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 2、获取账号的某种资源1234567891011121314&lt;!-- config 同根据公钥获取账号名 --&gt;let eos = EOS(config)let form = &#123; code, // 代币合约 account, // 账号名称 symbol, // 代币符合&#125;eos.getCurrencyBalance(form).then(res =&gt; &#123; console.log(res)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 3、获取交易详情测试网络 JungleTestnet 的 eos.getTransaction 接口存在 bug，不能正常返回，可使用 eospark 浏览器的接口。123456789&lt;!-- config 同根据公钥获取账号名 --&gt;let eos = EOS(config)&lt;!-- id: 交易 id --&gt;eos.getTransaction(id).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 4、获取交易列表测试网络 JungleTestnet 的 eos.getActions 接口存在 bug，不能正常返回，可使用 eospark 浏览器的接口。123456789101112131415161718192021&lt;!-- config 同根据公钥获取账号名 --&gt;let eos = EOS(config)&lt;!-- account_name: 账号名称 --&gt;eos.getTransaction(&#123; account_name &#125;).then(res =&gt; &#123; res.actions = res.actions.filter(action =&gt; &#123; let action_trace = action.action_trace || &#123;&#125; // 去重（如果是转账操作，则可能出现多笔相同交易 id 的 action，因为可能存在多个 inline_action） if (action_trace.act &amp;&amp; action_trace.act.name == &apos;transfer&apos;) &#123; if (action_trace.receipt &amp;&amp; action.action_trace.receipt.receiver == account_name) &#123; return action &#125; &#125; else &#123; return action &#125; &#125;) console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 5、发起交易12345678910111213141516&lt;!-- config 同账号创建 --&gt;let eos = EOS(config)let form = &#123; from, // 转账人名称 to, // 收款人名称 quantity, // 转账数量 例: 2.0000 EOS memo, // 备注（可选）&#125;&lt;!-- account_name: 账号名称 --&gt;eos.transfer(form, &#123; broadcast: true &#125;).then(res =&gt; &#123; console.log(res.transaction_id)&#125;).catch(err =&gt; &#123; console.log(err)&#125;)","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"blockchain 之比特币钱包实战","slug":"essay/btc","date":"2018-09-24T14:17:08.000Z","updated":"2018-12-21T05:46:51.289Z","comments":true,"path":"essay/btc/","link":"","permalink":"http://blog.master-ss.cn/essay/btc/","excerpt":"最近几个月都在搞区块链，是时候总结一波了，这章介绍比特币区块链钱包实战。","text":"最近几个月都在搞区块链，是时候总结一波了，这章介绍比特币区块链钱包实战。 一、基础知识点 矿工关心每字节的费用（或千字节）。这是总费用除以事务中的字节数，例如 40 satoshis / byte 或 0.0004 bitcoins / kilobyte。这是矿工最重要的衡量标准。原因是他们使用它来决定是否将您的事务包含在他们尝试生成的块中，因为它们只能在其块中包含大约 100 万字节的事务。因此，他们更愿意包括每字节支付更多费用的交易 1 bitcoin (BTC 比特币) = 1000 millibitcoins (mBTC 毫比特) = 1000000 microbitcoins (uBTC 微比特) = 100000000 Satoshi （satoshi 聪） 如果一个人持有私钥，他就可以使用私钥对任意的消息进行签名。即通过私钥 sk 对消息 message 进行签名，得到 signature： sign(message, sk) imtoken 普通地址和隔离见证地址路径不同。普通地址： “m/44’/0’/0’/0/0”，隔离见证地址： “m/49’/0’/0’/0/0” testnet 测试网络环境下，助记词生成 btc 私钥，需要显性设置网络才能通过后面的签名，如：HDKey.fromMasterSeed(seed, network) 私钥可以表示为 64 位 16 进制串、Base58、WIF、WIF-compressed。64 位 16 进制串就是把私钥直接转换；Base58 编码就是对 64 位 16 进制串直接编码；WIF(Wallet Import Format) 就是在 64 位 16 进制串对应的字节串前加上前缀 0x80， 并用 Base58Check 编码；WIF-compressed 就是在 64 位 16 进制串对应的字节串前加上前缀 0x80，并加上后缀 0x01， 并用 Base58Check 编码 二、测试网络 testnet 是一条比特币的备用链，用于开发测试的使用。测试用币从现实币中隔离区分开来，并且没有任何实际价值，仅作为开发的实验使用，不用担心在这条链上的交易会影响甚至使现实链崩溃。 Faucets 网站是一类免费分享测试用币的网站，在这上面你可以按需获取一定数量的测试用币，但是为了网站的长期使用，所以希望各位开发者们在使用完以后，能够将测试用币归还到给定的收集地址。 测试网查询浏览器 https://test-insight.bitpay.com Faucets类网站 https://testnet.manu.backend.hamburg/faucet (最大方，给很多，推荐) 三、实战之账号生成1、生成助记词1234const bip39 = require(&apos;bip39&apos;)&lt;!-- 如：that flock okay rubber promote right lift sell grow turtle camp shoulder --&gt;bip39.generateMnemonic() 2、生成私钥123456789101112131415161718const bitcoin = require(&apos;bitcoinjs-lib&apos;)const bip39 = require(&apos;bip39&apos;)const bip32 = require(&apos;bip32&apos;)// 在 imtoken 中使用助记词生成一般地址路径是 &quot;m/44&apos;/0&apos;/0&apos;/0/0&quot;，隔离见证地址路径是 &quot;m/49&apos;/0&apos;/0&apos;/0/0&quot;let path = &quot;m/44&apos;/0&apos;/0&apos;/0/0&quot;const seed = bip39.mnemonicToSeed(mnemonic)&lt;!-- 测试网络 --&gt;const testnet = bitcoin.networks.testnetconst hdWallet = bip32.fromSeed(seed, testnet)const keyPair = hdWallet.derivePath(path)const privateKey = keyPair.toWIF()&lt;!-- 正式网络 --&gt;const hdWallet = bip32.fromSeed(seed)const keyPair = hdWallet.derivePath(path)const privateKey = keyPair.toWIF() 3、私钥生成地址123456789101112131415161718192021222324const bitcoin = require(&apos;bitcoinjs-lib&apos;)const testnet = bitcoin.networks.testnet&lt;!-- 测试网络一般地址 --&gt;const keyPair = bitcoin.ECPair.fromWIF(privateKey, testnet)const address = bitcoin.payments.p2pkh(&#123; pubkey: keyPair.publicKey, network: testnet &#125;).address&lt;!-- 测试网络隔离见证地址 --&gt;const keyPair = bitcoin.ECPair.fromWIF(privateKey, testnet)const address = bitcoin.payments.p2sh(&#123; redeem: bitcoin.payments.p2wpkh(&#123; pubkey: keyPair.publicKey, network: testnet &#125;), network: testnet&#125;).address&lt;!-- 正式网络一般地址 --&gt;const keyPair = bitcoin.ECPair.fromWIF(privateKey)const address = bitcoin.payments.p2pkh(&#123; pubkey: keyPair.publicKey &#125;).address&lt;!-- 正式网络隔离见证地址 --&gt;const keyPair = bitcoin.ECPair.fromWIF(privateKey, testnet)const address = bitcoin.payments.p2sh(&#123; redeem: bitcoin.payments.p2wpkh(&#123; pubkey: keyPair.publicKey &#125;)&#125;).address 四、实战之交易查询如果是个人研究学习，可以直接使用 insight 的 api，如果是企业级应用，可以使用解决方案 https://bitcore.io/guides/full-node ，源码及文档见 https://github.com/bitpay/insight-api 测试网络 insight 地址：https://test-insight.bitpay.com 正式网络 insight 地址：https://insight.bitpay.com 五、实战之发起交易这里主要给交易签名，交易数据的广播用到的是 insight 的 api，这里就不介绍了。值得注意的是，如果 unspent 的交易未被确认或者确认次数过少，是存在风险的，但是确认次数过多会很影响交易速度，导致交易无法进行。 1、获取转账矿工费和转账所需 upsents12345678910111213141516171819202122232425262728293031const BigNumber = require(&apos;bignumber.js&apos;)// 注意 txrefs 是 unspent 的交易数据，最好从大到小排序，减少转账手续费；amount 为转账金额；rate 是 satoshi/byte 值function getFee(txrefs, amount, rate) &#123; let total = 0, inputsNum = 0, txs = [], fee for (let ref of txrefs) &#123; total += ref.value txs.push(ref) inputsNum++ // 如果总额大于要转账金额 if (total &gt; amount) &#123; fee = satoshi2Btc((148 * inputsNum + 34 * 1 + 10) * rate) // 148 * inputsNum + 34 * 1 + 10 为 size 的估算公式 if (total == (amount + fee)) &#123; // 如果总额等于矿工费加转账金额 return &#123; fee, txs, change: 0 &#125; &#125; else if (total &gt; (amount + fee)) &#123; // 如果总额大于矿工费加转账金额 // 更新旷工费用，设置找零地址 fee = satoshi2Btc((148 * inputsNum + 34 * 2 + 10) * rate) if (total &gt;= (amount + fee)) &#123; return &#123; fee, txs, change: total - amount - fee &#125; &#125; &#125; &#125; &#125; return -1&#125;function satoshi2Btc(amount) &#123; return Number(BigNumber(amount).div(Math.pow(10, 8)).toString())&#125; 2、交易签名123456789101112131415161718192021222324252627282930313233const bitcoin = require(&apos;bitcoinjs-lib&apos;)let feeObj = getFee(txrefs, amount, rate)&lt;!-- 测试网络一般地址 --&gt;const fromObj = bitcoin.ECPair.fromWIF(privateKey, testnet)const txb = new bitcoin.TransactionBuilder(testnet)for (let tx of feeObj.txs) &#123; // 添加输入 unspent 交易 txb.addInput(tx.tx_hash, tx.tx_output_n)&#125;txb.addOutput(to, btc2Satoshi(amount)) // 添加收款人feeObj.change != 0 ? txb.addOutput(from, btc2Satoshi(feeObj.change)) : &apos;&apos; // 如果有余额，设置找零地址为付款人for (let flag = 0; flag &lt; feeObj.txs.length; flag++) &#123; // 签名交易 txb.sign(flag, fromObj)&#125;const rawtransaction = txb.build().toHex() // 得到签名交易数据&lt;!-- 测试网络隔离见证地址 --&gt;const fromObj = bitcoin.ECPair.fromWIF(privateKey, testnet)const txb = new bitcoin.TransactionBuilder(testnet)const fromObjP2SH = bitcoin.payments.p2sh(&#123; redeem: bitcoin.payments.p2wpkh(&#123; pubkey: fromObj.publicKey, network: testnet &#125;), network: testnet&#125;)txb.addOutput(to, btc2Satoshi(amount)) // 添加收款人feeObj.change != 0 ? txb.addOutput(from, btc2Satoshi(feeObj.change)) : &apos;&apos; // 如果有余额，设置找零地址为付款人for (let flag = 0; flag &lt; feeObj.txs.length; flag++) &#123; // 签名交易 txb.sign(flag, fromObj, fromObjP2SH.redeem.output, null, btc2Satoshi(feeObj.txs[flag].value))&#125;const rawtransaction = txb.build().toHex() // 得到签名交易数据&lt;!-- 正式网络 --&gt;// 将测试网络对应地址方法中的 testnet 删除即可。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"koa 之 context","slug":"node/koa-context","date":"2018-04-26T15:34:12.000Z","updated":"2019-01-22T09:08:52.058Z","comments":true,"path":"node/koa-context/","link":"","permalink":"http://blog.master-ss.cn/node/koa-context/","excerpt":"Koa Context 将 node 的 request 和 response 对象封装到单个对象中，为编写 Web 应用程序和 API 提供了许多有用的方法。每个请求都将创建一个 Context，并在中间件中作为接收器引用，或者 ctx 标识符。","text":"Koa Context 将 node 的 request 和 response 对象封装到单个对象中，为编写 Web 应用程序和 API 提供了许多有用的方法。每个请求都将创建一个 Context，并在中间件中作为接收器引用，或者 ctx 标识符。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137const util = require('util');const createError = require('http-errors'); // 对错误的处理const httpAssert = require('http-assert'); // 断言const delegate = require('delegates'); // 委托const statuses = require('statuses'); // 状态码// Context 的原型对象const proto = module.exports = &#123; // util.inspect 实现 inspect() &#123; if (this === proto) return this; // 如果是原型对象调用，则返回 return this.toJSON(); // 如果是实例调用，则调用 toJSON 方法 &#125;, // 返回 JSON 对象 toJSON() &#123; return &#123; request: this.request.toJSON(), response: this.response.toJSON(), app: this.app.toJSON(), originalUrl: this.originalUrl, req: '&lt;original node req&gt;', res: '&lt;original node res&gt;', socket: '&lt;original node socket&gt;' &#125;; &#125;, // 添加断言，如果不满足条件，则抛出封装的 Error 对象，比如：this.assert(this.user, 401, 'Please login!'); assert: httpAssert, // 抛出带有状态码和报错信息的 Error 对象：this.throw(403) | this.throw('name required', 400) | this.throw(400, 'name required') | this.throw('something exploded') | this.throw(new Error('invalid'), 400) | this.throw(400, new Error('invalid')); throw(...args) &#123; throw createError(...args); // 根据参数生成相应的 Error 对象 &#125;, // 默认错误处理函数（私有方法） onerror(err) &#123; // 如果没有 error，则不做任何处理（可作为 node 风格的回调函数） if (null == err) return; // 如果不是 Error 实例，则抛出相应提示信息的 Error 对象 if (!(err instanceof Error)) err = new Error(util.format('non-error thrown: %j', err)); let headerSent = false; // this.headerSent：来自 response 模块，如果响应头已被发送则为 true，否则为 false // this.writable：来自 response 模块，当传递数据时允许写入 socket，否则忽略。默认 false if (this.headerSent || !this.writable) &#123; headerSent = err.headerSent = true; &#125; // 将 context 的错误处理委托到 application 上 this.app.emit('error', err, this); // 如果响应头已被发送，那么只能委托到 app 层面处理并记录日志 if (headerSent) &#123; return; &#125; const &#123; res &#125; = this; // 首先移除所有响应头 if (typeof res.getHeaderNames === 'function') &#123; // res.getHeaderNames：返回一个包含当前响应唯一名称的 http 头信息名称数组. 名称均为小写 res.getHeaderNames().forEach(name =&gt; res.removeHeader(name)); // 移除一个已经在 headers 对象里面的 header &#125; else &#123; res._headers = &#123;&#125;; // Node &lt; 7.7 &#125; // 然后将错误对象的 headers 属性设置为 response 相应属性 this.set(err.headers); // 强制响应头 Content-Type 为 text/plain this.type = 'text'; // ENOENT 类型支持，一般是 'No such file or directory' if ('ENOENT' == err.code) err.status = 404; // 默认设置状态码为 500 if ('number' != typeof err.status || !statuses[err.status]) err.status = 500; // respond const code = statuses[err.status]; const msg = err.expose ? err.message : code; // 如果 expose 为 true，那么显示 err.message 错误描述信息，否则显示状态码描述信息 this.status = err.status; // 设置 response 的状态码 this.length = Buffer.byteLength(msg); // 设置响应头 Content-Length 为 msg 字节长度 this.res.end(msg); // 发送数据并告知服务器所有数据都已被发送 &#125;&#125;;// 响应委托delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') .method('vary') .method('set') .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable');// 请求委托delegate(proto, 'request') .method('acceptsLanguages') .method('acceptsEncodings') .method('acceptsCharsets') .method('accepts') .method('get') .method('is') .access('querystring') .access('idempotent') .access('socket') .access('search') .access('method') .access('query') .access('path') .access('url') .getter('origin') .getter('href') .getter('subdomains') .getter('protocol') .getter('host') .getter('hostname') .getter('URL') .getter('header') .getter('headers') .getter('secure') .getter('stale') .getter('fresh') .getter('ips') .getter('ip'); 二、分析 1、为方便起见许多上下文的访问器和方法使用 delegates 直接委托给它们的 ctx.request 或 ctx.response，不然的话它们是相同的。例如 ctx.type 和 ctx.length 委托给 response 对象，ctx.path 和 ctx.method 委托给 request。 2、绕过 Koa 的 response 处理是不被支持的，除非显式设置 ctx.respond = false，从而使用原生 res api：res.statusCode、res.writeHead()、res.write()、res.end()，代码实现于 application.js。 3、ctx.state 是推荐的命名空间，用于通过中间件传递信息。 4、ctx.throw 抛出根据参数自定义的错误对象。","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"node 之 http-errors","slug":"node/http-errors","date":"2018-04-26T14:52:26.000Z","updated":"2019-01-22T09:07:07.765Z","comments":true,"path":"node/http-errors/","link":"","permalink":"http://blog.master-ss.cn/node/http-errors/","excerpt":"为 Express、Koa 或 Connect 生成相关 error 对象。","text":"为 Express、Koa 或 Connect 生成相关 error 对象。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242/** * Module dependencies. * @private */var deprecate = require('depd')('http-errors')var setPrototypeOf = require('setprototypeof')var statuses = require('statuses')var inherits = require('inherits')/** * Module exports. * @public */module.exports = createErrormodule.exports.HttpError = createHttpErrorConstructor()// Populate exports for all constructorspopulateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)/** * Get the code class of a status code. * @private */function codeClass (status) &#123; return Number(String(status).charAt(0) + '00')&#125;/** * Create a new HTTP Error. * * @returns &#123;Error&#125; * @public */function createError () &#123; // so much arity going on ~_~ var err var msg var status = 500 var props = &#123;&#125; for (var i = 0; i &lt; arguments.length; i++) &#123; var arg = arguments[i] if (arg instanceof Error) &#123; err = arg status = err.status || err.statusCode || status continue &#125; switch (typeof arg) &#123; case 'string': msg = arg break case 'number': status = arg if (i !== 0) &#123; deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)') &#125; break case 'object': props = arg break &#125; &#125; if (typeof status === 'number' &amp;&amp; (status &lt; 400 || status &gt;= 600)) &#123; deprecate('non-error status code; use only 4xx or 5xx status codes') &#125; if (typeof status !== 'number' || (!statuses[status] &amp;&amp; (status &lt; 400 || status &gt;= 600))) &#123; status = 500 &#125; // constructor var HttpError = createError[status] || createError[codeClass(status)] if (!err) &#123; // create error err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]) Error.captureStackTrace(err, createError) &#125; if (!HttpError || !(err instanceof HttpError) || err.status !== status) &#123; // add properties to generic error err.expose = status &lt; 500 err.status = err.statusCode = status &#125; for (var key in props) &#123; if (key !== 'status' &amp;&amp; key !== 'statusCode') &#123; err[key] = props[key] &#125; &#125; return err&#125;/** * Create HTTP error abstract base class. * @private */function createHttpErrorConstructor () &#123; function HttpError () &#123; throw new TypeError('cannot construct abstract class') &#125; inherits(HttpError, Error) return HttpError&#125;/** * Create a constructor for a client error. * @private */function createClientErrorConstructor (HttpError, name, code) &#123; var className = name.match(/Error$/) ? name : name + 'Error' function ClientError (message) &#123; // create the error object var msg = message != null ? message : statuses[code] var err = new Error(msg) // capture a stack trace to the construction point Error.captureStackTrace(err, ClientError) // adjust the [[Prototype]] setPrototypeOf(err, ClientError.prototype) // redefine the error message Object.defineProperty(err, 'message', &#123; enumerable: true, configurable: true, value: msg, writable: true &#125;) // redefine the error name Object.defineProperty(err, 'name', &#123; enumerable: false, configurable: true, value: className, writable: true &#125;) return err &#125; inherits(ClientError, HttpError) ClientError.prototype.status = code ClientError.prototype.statusCode = code ClientError.prototype.expose = true return ClientError&#125;/** * Create a constructor for a server error. * @private */function createServerErrorConstructor (HttpError, name, code) &#123; var className = name.match(/Error$/) ? name : name + 'Error' function ServerError (message) &#123; // create the error object var msg = message != null ? message : statuses[code] var err = new Error(msg) // capture a stack trace to the construction point Error.captureStackTrace(err, ServerError) // adjust the [[Prototype]] setPrototypeOf(err, ServerError.prototype) // redefine the error message Object.defineProperty(err, 'message', &#123; enumerable: true, configurable: true, value: msg, writable: true &#125;) // redefine the error name Object.defineProperty(err, 'name', &#123; enumerable: false, configurable: true, value: className, writable: true &#125;) return err &#125; inherits(ServerError, HttpError) ServerError.prototype.status = code ServerError.prototype.statusCode = code ServerError.prototype.expose = false return ServerError&#125;/** * Populate the exports object with constructors for every error class. * @private */function populateConstructorExports (exports, codes, HttpError) &#123; codes.forEach(function forEachCode (code) &#123; var CodeError var name = toIdentifier(statuses[code]) switch (codeClass(code)) &#123; case 400: CodeError = createClientErrorConstructor(HttpError, name, code) break case 500: CodeError = createServerErrorConstructor(HttpError, name, code) break &#125; if (CodeError) &#123; // export the constructor exports[code] = CodeError exports[name] = CodeError &#125; &#125;) // backwards-compatibility exports[\"I'mateapot\"] = deprecate.function(exports.ImATeapot, '\"I\\'mateapot\"; use \"ImATeapot\" instead')&#125;/** * Convert a string of words to a JavaScript identifier. * @private */function toIdentifier (str) &#123; return str.split(' ').map(function (token) &#123; return token.slice(0, 1).toUpperCase() + token.slice(1) &#125;).join('').replace(/[^ _0-9a-z]/gi, '')&#125; 二、分析 1、执行 populateConstructorExports 方法，遍历常用状态码，具体根据状态码执行 createClientErrorConstructor 或 createServerErrorConstructor，返回自定义错误对象，并赋值给 exports，即 createError。 2、导出 createError，根据传入自定义错误对象，允许不同组合：createError(400) | createError(400, ‘name required’) | createError(400, ‘name required’, { user: user }) | this.throw(400, new Error(‘invalid’)) 等。 3、错误对象的属性 expose = true 时，application 的 onerror 回调对其不输出错误信息，context 的 onerror 回调让 res 发送错误对象的 message 属性，否则 context 发送状态码。 三、拓展1、调用栈的工作机制函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数，这种数据结构的关键在于后进先出，即大家所熟知的 LIFO。比如，当我们在函数 y 内部调用函数 x 的时候，调用栈从下往上的顺序就是 y -&gt; x 。1234567891011121314151617181920212223242526272829function c() &#123; console.log('c');&#125;function b() &#123; console.log('b'); c(); console.trace(); // 使用 console.trace 来把当前的调用栈输出到 console 中&#125;function a() &#123; console.log('a'); b();&#125;a();// 得到如下的结果：调用函数的时候，会被推到调用栈的顶部，而执行完毕之后，就会从调用栈移除。Trace at b (repl:4:9) at a (repl:3:1) at repl:1:1 // &lt;-- 从这行往下的内容可以忽略，因为这些都是 Node 内部的东西 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12) at REPLServer.onLine (repl.js:513:10) 2、Error 对象及错误处理当代码中发生错误时，我们通常会抛出一个 Error 对象。Error 对象可以作为扩展和创建自定义错误类型的原型。Error 对象的 prototype 具有以下属性：constructor 负责该实例的原型构造函数；message 错误信息；name 错误的名字。上面都是标准属性，有些 JS 运行环境还提供了标准属性之外的属性，如 Node.js、Firefox、Chrome、Edge、IE 10、Opera 和 Safari 6+ 中会有 stack 属性，它包含了错误代码的调用栈，接下来我们简称错误堆栈。错误堆栈包含了产生该错误时完整的调用栈信息。抛出错误时，你必须使用 throw 关键字。为了捕获抛出的错误，则必须使用 try catch 语句把可能出错的代码块包起来，catch 的时候可以接收一个参数，该参数就是被抛出的错误。与 Java 中类似，JS 中也可以在 try catch 语句之后有 finally，不论前面代码是否抛出错误 finally 里面的代码都会执行，这种语言的常见用途有：在 finally 中做些清理的工作。此外，你可以使用没有 catch 的 try 语句，但是后面必须跟上 finally，这意味着我们可以使用三种不同形式的 try 语句：try … catch、try … finally、try … catch … finally12345678910try &#123; console.log('The try block is running...');&#125; finally &#123; try &#123; // 强烈建议抛出 Error 对象，否则在需要处理错误的调用栈信息和其他有意义的元数据，抛出非 Error 对象的错误会让你的处境很尴尬 throw new Error('Error inside finally.'); &#125; catch (err) &#123; console.log('Caught an error inside the finally block.'); &#125;&#125; 3、错误堆栈的裁剪Node.js 才支持这个特性，通过 Error.captureStackTrace 来实现，Error.captureStackTrace 接收一个 object 作为第 1 个参数，以及可选的 function 作为第 2 个参数。其作用是捕获当前的调用栈并对其进行裁剪，捕获到的调用栈会记录在第 1 个参数的 stack 属性上，裁剪的参照点是第 2 个参数，也就是说，此函数之前的调用会被记录到调用栈上面，而之后的不会。123456789101112131415161718192021222324252627282930313233// 让我们用代码来说明，首先，把当前的调用栈捕获并放到 myObj 上：const myObj = &#123;&#125;;function c() &#123;&#125;function b() &#123; // 把当前调用栈写到 myObj 上 Error.captureStackTrace(myObj); c();&#125;function a() &#123; b();&#125;// 调用函数 aa();// 打印 myObj.stackconsole.log(myObj.stack);// 输出会是这样// at b (repl:3:7) &lt;-- Since it was called inside B, the B call is the last entry in the stack// at a (repl:2:1)// at repl:1:1 &lt;-- Node internals below this line// at realRunInThisContextScript (vm.js:22:35)// at sigintHandlersWrap (vm.js:98:12)// at ContextifyScript.Script.runInThisContext (vm.js:24:12)// at REPLServer.defaultEval (repl.js:313:29)// at bound (domain.js:280:14)// at REPLServer.runBound [as eval] (domain.js:293:12)// at REPLServer.onLine (repl.js:513:10) 上面的调用栈中只有 a -&gt; b，因为我们在 b 调用 c 之前就捕获了调用栈。现在对上面的代码稍作修改，然后看看会发生什么：123456789101112131415161718192021222324252627282930313233343536const myObj = &#123;&#125;;function d() &#123; // 我们把当前调用栈存储到 myObj 上，但是会去掉 b 和 b 之后的部分 Error.captureStackTrace(myObj, b);&#125;function c() &#123; d();&#125;function b() &#123; c();&#125;function a() &#123; b();&#125;// 执行代码a();// 打印 myObj.stackconsole.log(myObj.stack);// 输出如下// at a (repl:2:1) &lt;-- As you can see here we only get frames before `b` was called// at repl:1:1 &lt;-- Node internals below this line// at realRunInThisContextScript (vm.js:22:35)// at sigintHandlersWrap (vm.js:98:12)// at ContextifyScript.Script.runInThisContext (vm.js:24:12)// at REPLServer.defaultEval (repl.js:313:29)// at bound (domain.js:280:14)// at REPLServer.runBound [as eval] (domain.js:293:12)// at REPLServer.onLine (repl.js:513:10)// at emitOne (events.js:101:20) 在这段代码里面，因为我们在调用 Error.captureStackTrace 的时候传入了 b，这样 b 之后的调用栈都会被隐藏。可以在想对用户隐藏跟他业务无关的错误堆栈（比如某个库的内部实现）试用这个技巧。","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"node 之 delegates","slug":"node/delegates","date":"2018-04-26T07:48:45.000Z","updated":"2019-01-22T09:05:03.028Z","comments":true,"path":"node/delegates/","link":"","permalink":"http://blog.master-ss.cn/node/delegates/","excerpt":"node 代理访问工具方法。","text":"node 代理访问工具方法。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * Expose `Delegator`. */module.exports = Delegator;/** * Initialize a delegator. * * @param &#123;Object&#125; proto * @param &#123;String&#125; target * @api public */function Delegator(proto, target) &#123; if (!(this instanceof Delegator)) return new Delegator(proto, target); this.proto = proto; this.target = target; this.methods = []; this.getters = []; this.setters = []; this.fluents = [];&#125;/** * Delegate method `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.method = function(name)&#123; var proto = this.proto; var target = this.target; this.methods.push(name); proto[name] = function()&#123; return this[target][name].apply(this[target], arguments); &#125;; return this;&#125;;/** * Delegator accessor `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.access = function(name)&#123; return this.getter(name).setter(name);&#125;;/** * Delegator getter `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.getter = function(name)&#123; var proto = this.proto; var target = this.target; this.getters.push(name); proto.__defineGetter__(name, function()&#123; return this[target][name]; &#125;); return this;&#125;;/** * Delegator setter `name`. * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.setter = function(name)&#123; var proto = this.proto; var target = this.target; this.setters.push(name); proto.__defineSetter__(name, function(val)&#123; return this[target][name] = val; &#125;); return this;&#125;;/** * Delegator fluent accessor * * @param &#123;String&#125; name * @return &#123;Delegator&#125; self * @api public */Delegator.prototype.fluent = function (name) &#123; var proto = this.proto; var target = this.target; this.fluents.push(name); proto[name] = function(val)&#123; if ('undefined' != typeof val) &#123; this[target][name] = val; return this; &#125; else &#123; return this[target][name]; &#125; &#125;; return this;&#125;; 二、分析 1、Delegator 判断 this 是否是 Delegator 实例，如果不是返回初始化的 Delegator 实例对象，方便链式调用。 2、Delegator 原型上的 method 调用时，给proto[name]赋值，其调用时实际上执行的是this[target][name]，并通过 apply 绑定上下文。 3、Delegator 原型上的 getter 调用时，给 proto 添加 name 属性，调用时实际返回的this[target][name]。 4、Delegator 原型上的 setter 调用时，给 proto 添加 name 属性，调用时实际赋值的是this[target][name]。 5、Delegator 原型上的 access 调用时，其实是同时调用了 getter、setter 方法。 6、Delegator 原型上的 fluent 调用时，判断是否传入参数，如果无参，则返回this[target][name]，否则给this[target][name]赋值。 三、案例123456789101112131415161718192021222324252627282930var delegate = require('delegates');...delegate(proto, 'request') .method('acceptsLanguages') .method('acceptsEncodings') .method('acceptsCharsets') .method('accepts') .method('is') .access('querystring') .access('idempotent') .access('socket') .access('length') .access('query') .access('search') .access('status') .access('method') .access('path') .access('body') .access('host') .access('url') .getter('subdomains') .getter('protocol') .getter('header') .getter('stale') .getter('fresh') .getter('secure') .getter('ips') .getter('ip')","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"koa 之 response","slug":"node/koa-response","date":"2018-04-26T06:25:04.000Z","updated":"2018-12-21T05:36:48.809Z","comments":true,"path":"node/koa-response/","link":"","permalink":"http://blog.master-ss.cn/node/koa-response/","excerpt":"Koa Response 对象是在 node 的响应对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。","text":"Koa Response 对象是在 node 的响应对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304const contentDisposition = require('content-disposition'); // 解析 HTTP 的 Content-Dispositionconst ensureErrorHandler = require('error-inject'); // 注入失败回调函数到 streamconst getType = require('mime-types').contentType; // 根据字符串或文件扩展名等获取相应 Content-Typeconst onFinish = require('on-finished'); // 当 http 请求关闭、完成或报错时执行回调函数const isJSON = require('koa-is-json'); // 判断参数是否为 JSON 数据，排除法const escape = require('escape-html'); // 转换 html 字符串const typeis = require('type-is').is; // 推断请求的 Content-Type 属性const statuses = require('statuses'); // 状态码const destroy = require('destroy'); // 销毁流const assert = require('assert'); // 断言const extname = require('path').extname; // 返回 path 的扩展名const vary = require('vary'); // 设置 http 的 Vary 头部属性const only = require('only'); // 返回指定属性的对象// Response 的原型对象module.exports = &#123; // 获取请求 socket get socket() &#123; return this.ctx.req.socket; &#125;, // 获取响应标头对象 get header() &#123; const &#123; res &#125; = this; return typeof res.getHeaders === 'function' ? res.getHeaders() : res._headers || &#123;&#125;; // Node &lt; 7.7 &#125;, // 获取响应标头对象，别名是 response.header get headers() &#123; return this.header; &#125;, // 获取响应状态 get status() &#123; return this.res.statusCode; &#125;, // 通过数字代码设置响应状态 set status(code) &#123; if (this.headerSent) return; // 如果响应头已被发送，则不作任何操作 assert('number' == typeof code, 'status code must be a number'); assert(statuses[code], `invalid status code: $&#123;code&#125;`); this._explicitStatus = true; this.res.statusCode = code; // this.req.httpVersionMajor：返回客户端发送的 HTTP 版本 if (this.req.httpVersionMajor &lt; 2) this.res.statusMessage = statuses[code]; if (this.body &amp;&amp; statuses.empty[code]) this.body = null; &#125;, // 获取响应的状态消息 get message() &#123; return this.res.statusMessage || statuses[this.status]; &#125;, // 将响应的状态消息设置为给定值 set message(msg) &#123; this.res.statusMessage = msg; &#125;, // 获取响应主体 get body() &#123; return this._body; &#125;, // 设置响应体（val: String | Buffer| Object | Stream） set body(val) &#123; const original = this._body; this._body = val; // no content if (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove('Content-Type'); this.remove('Content-Length'); this.remove('Transfer-Encoding'); return; &#125; // set the status if (!this._explicitStatus) this.status = 200; // set the content-type only if not yet set const setType = !this.header['content-type']; // string if ('string' == typeof val) &#123; if (setType) this.type = /^\\s*&lt;/.test(val) ? 'html' : 'text'; this.length = Buffer.byteLength(val); return; &#125; // buffer if (Buffer.isBuffer(val)) &#123; if (setType) this.type = 'bin'; this.length = val.length; return; &#125; // stream if ('function' == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove('Content-Length'); if (setType) this.type = 'bin'; return; &#125; // json this.remove('Content-Length'); this.type = 'json'; &#125;, // 将响应的 Content-Length 设置为给定值 set length(n) &#123; this.set('Content-Length', n); &#125;, // 以数字返回响应的 Content-Length，或者从 ctx.body 推导出来，或者 undefined get length() &#123; const len = this.header['content-length']; const body = this.body; if (null == len) &#123; if (!body) return; if ('string' == typeof body) return Buffer.byteLength(body); if (Buffer.isBuffer(body)) return body.length; if (isJSON(body)) return Buffer.byteLength(JSON.stringify(body)); return; &#125; // 转为数字，并去掉小数部分 return ~~len; &#125;, // 返回一个布尔值（只读）。如果响应头已被发送则为 true，否则为 false get headerSent() &#123; return this.res.headersSent; &#125;, // 在 field 上的 Vary vary(field) &#123; if (this.headerSent) return; vary(this.res, field); &#125;, // 执行 302 重定向到 url，如：this.redirect('back'); | this.redirect('back', '/index.html'); // | this.redirect('/login'); | this.redirect('http://google.com'); redirect(url, alt) &#123; // location if ('back' == url) url = this.ctx.get('Referrer') || alt || '/'; this.set('Location', url); // status if (!statuses.redirect[this.status]) this.status = 302; // html if (this.ctx.accepts('html')) &#123; url = escape(url); this.type = 'text/html; charset=utf-8'; this.body = `Redirecting to &lt;a href=\"$&#123;url&#125;\"&gt;$&#123;url&#125;&lt;/a&gt;.`; return; &#125; // text this.type = 'text/plain; charset=utf-8'; this.body = `Redirecting to $&#123;url&#125;.`; &#125;, // 将 Content-Disposition 设置为 \"附件\" 以指示客户端提示下载，参数 filename 可选 attachment(filename) &#123; if (filename) this.type = extname(filename); // 获取文件拓展名 this.set('Content-Disposition', contentDisposition(filename)); &#125;, // 通过 mime 字符串或文件扩展名设置响应 Content-Type set type(type) &#123; type = getType(type); // 根据字符串或文件扩展名等获取相应 Content-Type，如：.html、html、json、application/json、png if (type) &#123; this.set('Content-Type', type); &#125; else &#123; this.remove('Content-Type'); &#125; &#125;, // 将 Last-Modified 标头设置为适当的 UTC 字符串。参数可以是 Date 或日期字符串 set lastModified(val) &#123; if ('string' == typeof val) val = new Date(val); this.set('Last-Modified', val.toUTCString()); &#125;, // 如果存在 Last-Modified，则将其返回为 Date, get lastModified() &#123; const date = this.get('last-modified'); if (date) return new Date(date); &#125;, // 设置包含 \" 包裹的 ETag 响应 set etag(val) &#123; if (!/^(W\\/)?\"/.test(val)) val = `\"$&#123;val&#125;\"`; this.set('ETag', val); &#125;, // 获取响应对象的 ETag 属性 get etag() &#123; return this.get('ETag'); &#125;, // 获取响应 Content-Type 不含参数 \"charset\" get type() &#123; const type = this.get('Content-Type'); if (!type) return ''; return type.split(';')[0]; &#125;, // 非常类似 ctx.request.is()。检查响应类型是否是所提供的类型之一，这对于创建操纵响应的中间件特别有用 is(types) &#123; const type = this.type; if (!types) return type || false; if (!Array.isArray(types)) types = [].slice.call(arguments); return typeis(type, types); &#125;, // 不区分大小写获取响应标头字段值 field，如： this.get('content-type') =&gt; \"text/plain\" get(field) &#123; return this.header[field.toLowerCase()] || ''; &#125;, // 设置响应标头 field 到 value，如：this.set('Foo', ['bar', 'baz']); | this.set('Accept', 'application/json'); | this.set(&#123; Accept: 'text/plain', 'X-API-Key': 'tobi' &#125;); set(field, val) &#123; if (this.headerSent) return; if (2 == arguments.length) &#123; if (Array.isArray(val)) val = val.map(String); else val = String(val); this.res.setHeader(field, val); &#125; else &#123; for (const key in field) &#123; this.set(key, field[key]); &#125; &#125; &#125;, // 用值 val 附加额外的标头 field，比如：this.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;']); | // this.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly'); | this.append('Warning', '199 Miscellaneous warning'); append(field, val) &#123; const prev = this.get(field); if (prev) &#123; val = Array.isArray(prev) ? prev.concat(val) : [prev].concat(val); &#125; return this.set(field, val); &#125;, // 删除标头 field remove(field) &#123; if (this.headerSent) return; this.res.removeHeader(field); &#125;, // 检查请求是否 writable（需检查 socket 是否存在） get writable() &#123; // can't write any more after response finished if (this.res.finished) return false; // 表示响应是否已完成，如果已完成则返回 false const socket = this.res.socket; // There are already pending outgoing res, but still writable // https://github.com/nodejs/node/blob/v4.4.7/lib/_http_server.js#L486 if (!socket) return true; // 如果不存在 socket，则返回 true return socket.writable; &#125;, // 为特定属性的对象添加 body 属性 inspect() &#123; if (!this.res) return; const o = this.toJSON(); o.body = this.body; return o; &#125;, // 返回只有特定属性的对象 toJSON() &#123; return only(this, [ 'status', 'message', 'header' ]); &#125;, // 刷新任何设置的标头，并开始主体 flushHeaders() &#123; this.res.flushHeaders(); &#125;&#125;;","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"koa 之 request","slug":"node/koa-request","date":"2018-04-26T03:59:15.000Z","updated":"2019-01-22T09:02:28.509Z","comments":true,"path":"node/koa-request/","link":"","permalink":"http://blog.master-ss.cn/node/koa-request/","excerpt":"Koa Request 对象是在 node 的请求对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。","text":"Koa Request 对象是在 node 的请求对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344const URL = require('url').URL; // 获取 URL 构造函数const net = require('net'); // 网络const contentType = require('content-type'); // 根据 RFC 协议解析 HTTP 的 Content-Type 头部const stringify = require('url').format; // url 的格式化方法const parse = require('parseurl'); // 基本上跟 url.parse 相同，不过使用同一个 req 对象解析时，直接用缓存中取，不再解析const qs = require('querystring'); // 查询字符串const typeis = require('type-is'); // 推断请求的 Content-Type 属性const fresh = require('fresh'); // 根据请求头和响应头判断是否缓存const only = require('only'); // 筛选对象的属性// Request 的原型对象module.exports = &#123; // 返回请求头 get header() &#123; return this.req.headers; &#125;, // 设置请求头 set header(val) &#123; this.req.headers = val; &#125;, // 返回请求头，别名为 request.header get headers() &#123; return this.req.headers; &#125;, // 设置请求头，别名为 request.header set headers(val) &#123; this.req.headers = val; &#125;, // 获取请求的 URL get url() &#123; return this.req.url; &#125;, // 设置请求的 URL set url(val) &#123; this.req.url = val; &#125;, // 获取请求原始 URL，调用自身的 get protocol() 和 get host() 方法 get origin() &#123; return `$&#123;this.protocol&#125;://$&#123;this.host&#125;`; &#125;, // 获取完整的请求URL，包括 protocol，host 和 url get href() &#123; // this.originalUrl 在 application.js 中 被赋值为 req.url，即请求的 URL 字符串 if (/^https?:\\/\\//i.test(this.originalUrl)) return this.originalUrl; // 如果 originalUrl 含有协议和主机信息，那么直接返回，如 http://example.com/foo return this.origin + this.originalUrl; // 否则加上请求原始 URL &#125;, // 获取请求方法 get method() &#123; return this.req.method; &#125;, // 设置请求方法 set method(val) &#123; this.req.method = val; &#125;, // 获取请求路径名 get path() &#123; return parse(this.req).pathname; &#125;, // 设置请求路径名 pathname，并在存在时保留查询字符串 set path(path) &#123; const url = parse(this.req); if (url.pathname === path) return; url.pathname = path; url.path = null; this.url = stringify(url); &#125;, // 获取解析的查询字符串（有缓存处理） get query() &#123; const str = this.querystring; const c = this._querycache = this._querycache || &#123;&#125;; return c[str] || (c[str] = qs.parse(str)); &#125;, // 将查询字符串设置为给定对象 set query(obj) &#123; this.querystring = qs.stringify(obj); &#125;, // 获取原始查询字符串 get querystring() &#123; if (!this.req) return ''; return parse(this.req).query || ''; &#125;, // 设置原始查询字符串 set querystring(str) &#123; const url = parse(this.req); if (url.search === `?$&#123;str&#125;`) return; url.search = str; url.path = null; this.url = stringify(url); &#125;, // 使用 ? 获取原始查询字符串 get search() &#123; if (!this.querystring) return ''; return `?$&#123;this.querystring&#125;`; &#125;, // 设置原始查询字符串 set search(str) &#123; this.querystring = str; &#125;, // 获取主机（host）部分 get host() &#123; const proxy = this.app.proxy; // 当代理时，使用 X-Forwarded-Host // 反向代理（如负载均衡服务器、CDN 等）的域名或端口号可能会与处理请求的源头服务器有所不同，在这种情况下，X-Forwarded-Host 可以用来确定哪一个域名是最初被用来访问的 let host = proxy &amp;&amp; this.get('X-Forwarded-Host'); host = host || this.get('Host'); // 从请求的 headers 中拿到 host if (!host) return ''; return host.split(/\\s*,\\s*/)[0]; &#125;, // 获取主机名，不含端口号 get hostname() &#123; const host = this.host; if (!host) return ''; if ('[' == host[0]) return this.URL.hostname || ''; // IPv6 return host.split(':')[0]; &#125;, // 获取 WHATWG 解析的 URL 对象 get URL() &#123; if (!this.memoizedURL) &#123; const protocol = this.protocol; const host = this.host; const originalUrl = this.originalUrl || ''; // avoid undefined in template string try &#123; this.memoizedURL = new URL(`$&#123;protocol&#125;://$&#123;host&#125;$&#123;originalUrl&#125;`); &#125; catch (err) &#123; this.memoizedURL = Object.create(null); &#125; &#125; return this.memoizedURL; &#125;, // 检查请求缓存是否 \"新鲜\"，也就是内容没有改变，用于 If-None-Match / ETag, 和 If-Modified-Since 和 Last-Modified 之间的缓存协商 get fresh() &#123; const method = this.method; const s = this.ctx.status; // GET or HEAD for weak freshness validation only if ('GET' != method &amp;&amp; 'HEAD' != method) return false; // 2xx or 304 as per rfc2616 14.26 if ((s &gt;= 200 &amp;&amp; s &lt; 300) || 304 == s) &#123; return fresh(this.header, this.ctx.response.header); &#125; return false; &#125;, // 与 request.fresh 相反 get stale() &#123; return !this.fresh; &#125;, // 判断方法是否在 methods 中 get idempotent() &#123; const methods = ['GET', 'HEAD', 'PUT', 'DELETE', 'OPTIONS', 'TRACE']; return !!~methods.indexOf(this.method); &#125;, // 返回与连接关联的 net.Socket 对象 get socket() &#123; return this.req.socket; &#125;, // 在存在时获取请求字符集，或者 undefined get charset() &#123; let type = this.get('Content-Type'); if (!type) return ''; try &#123; type = contentType.parse(type); &#125; catch (e) &#123; return ''; &#125; return type.parameters.charset || ''; &#125;, // 返回以数字返回请求的 Content-Length，或 undefined get length() &#123; const len = this.get('Content-Length'); if (len == '') return; return ~~len; // ~~：利用符号进行的类型转换，转换成数字类型 &#125;, // 获取请求协议：当用 TLS 请求时返回协议字符串 http 或者 https，当 proxy 为 true 时返回 X-Forwarded-Proto 头部属性对应的值 get protocol() &#123; const proxy = this.app.proxy; if (this.socket.encrypted) return 'https'; if (!proxy) return 'http'; const proto = this.get('X-Forwarded-Proto') || 'http'; return proto.split(/\\s*,\\s*/)[0]; &#125;, // this.protocol == 'https' 的简称 get secure() &#123; return 'https' == this.protocol; &#125;, // 当 X-Forwarded-For 存在并且 app.proxy 被启用时，这些 ips 的数组被返回。禁用时返回一个空数组 get ips() &#123; const proxy = this.app.proxy; // X-Forwarded-For（XFF）在客户端访问服务器的过程中如果需要经过 HTTP 代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的 IP 地址 // 例如值为 \"client, proxy1, proxy2\"，返回 [\"client\", \"proxy1\", \"proxy2\"]，从上游 -&gt; 下游排序 const val = this.get('X-Forwarded-For'); return proxy &amp;&amp; val ? val.split(/\\s*,\\s*/) : []; &#125;, // 将子域返回为数组 get subdomains() &#123; const offset = this.app.subdomainOffset; const hostname = this.hostname; if (net.isIP(hostname)) return []; // 如果主机名是 ip 地址，则返回空数组 // tobi.ferrets.example.com =&gt; subdomainOffset 为 2 时，返回 [\"ferrets\", \"tobi\"]；subdomainOffset 为 3 时，返回 [\"tobi\"] return hostname .split('.') .reverse() .slice(offset); &#125;, // Koa 的 request 对象包括由 accepts 和 negotiator 提供的有用的内容协商实体 // 检查给定的 type(s) 是否可以接受，如果 true，返回最佳匹配，否则为 false /** * // Accept: text/html * this.accepts('html'); * // =&gt; \"html\" * * // Accept: text/*, application/json * this.accepts('html'); * // =&gt; \"html\" * this.accepts('text/html'); * // =&gt; \"text/html\" * this.accepts('json', 'text'); * // =&gt; \"json\" * this.accepts('application/json'); * // =&gt; \"application/json\" * * // Accept: text/*, application/json * this.accepts('image/png'); * this.accepts('png'); * // =&gt; false * * // Accept: text/*;q=.5, application/json * this.accepts(['html', 'json']); * this.accepts('html', 'json'); * // =&gt; \"json\" */ accepts(...args) &#123; return this.accept.types(...args); &#125;, // 检查 encodings 是否可以接受，返回最佳匹配为 true，否则为 false。Accept-Encoding: gzip, deflate -&gt; ['gzip', 'deflate'] acceptsEncodings(...args) &#123; return this.accept.encodings(...args); &#125;, // 检查 charsets 是否可以接受，在 true 时返回最佳匹配，否则为 false。Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5 -&gt; ['utf-8', 'utf-7', 'iso-8859-1'] acceptsCharsets(...args) &#123; return this.accept.charsets(...args); &#125;, // 检查 langs 是否可以接受，如果为 true，返回最佳匹配，否则为 false。Accept-Language: en;q=0.8, es, pt -&gt; ['es', 'pt', 'en'] acceptsLanguages(...args) &#123; return this.accept.languages(...args); &#125;, // 检查传入请求是否包含 Content-Type 头字段， 并且包含任意的 mime type。 如果没有请求主体，返回 null。 如果没有内容类型，或者匹配失败，则返回 false。 反之则返回匹配的 content-type /** * // With Content-Type: text/html; charset=utf-8 * this.is('html'); // =&gt; 'html' * this.is('text/html'); // =&gt; 'text/html' * this.is('text/*', 'application/json'); // =&gt; 'text/html' * * // When Content-Type is application/json * this.is('json', 'urlencoded'); // =&gt; 'json' * this.is('application/json'); // =&gt; 'application/json' * this.is('html', 'application/*'); // =&gt; 'application/json' * * this.is('html'); // =&gt; false */ is(types) &#123; if (!types) return typeis(this.req); if (!Array.isArray(types)) types = [].slice.call(arguments); return typeis(this.req, types); &#125;, // 返回请求的 Content-Type，不含参数 charset get type() &#123; const type = this.get('Content-Type'); if (!type) return ''; return type.split(';')[0]; &#125;, // 返回请求头部，如：this.get('Content-Type'); =&gt; \"text/plain\" | this.get('content-type'); =&gt; \"text/plain\" | this.get('Something'); =&gt; undefined // Referrer 头部属性是特例，Referrer 和 Referer 可互换，历史遗留问题，http 协议命令为 Referer，实际上是 Referrer（主要用于重定向） get(field) &#123; const req = this.req; switch (field = field.toLowerCase()) &#123; case 'referer': case 'referrer': return req.headers.referrer || req.headers.referer || ''; default: return req.headers[field] || ''; &#125; &#125;, // 监听 toJSON 实现 inspect() &#123; if (!this.req) return; return this.toJSON(); &#125;, // 返回只有特定属性的对象 toJSON() &#123; return only(this, [ 'method', 'url', 'header' ]); &#125;&#125;; 二、分析这里主要讲下node 对 URL 的处理：一个是 Node.js 遗留的特有的 API，另一个则是通常使用在 web 浏览器中 实现了 WHATWG URL Standard 的 API。虽然 Node.js 遗留的特有的 API 并没有被弃用，但是保留的目的是用于向后兼容已有应用程序。因此新的应用程序请使用 WHATWG API。WHATWG 与Node.js 遗留的特有的 API 的比较如上。网址http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash上方是由遗留的 url.parse() 返回的对象属性，下方的则是 WHATWG URL 对象的属性。1234567// 利用 WHATWG API 解析一个 URL 字符串const &#123; URL &#125; = require('url');const myURL = new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');// 通过 Node.js 提供的 API 解析一个 URLconst url = require('url');const myURL = url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'); 在浏览器中，WHATWG URL 在全局总是可用的，而在 Node.js 中，任何情况下打开或使用一个链接都必须事先引用 ‘url’ 模块：require(‘url’).URL。","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"koa 之 koa-convert","slug":"node/koa-convert","date":"2018-04-26T01:35:32.000Z","updated":"2019-01-22T09:00:21.879Z","comments":true,"path":"node/koa-convert/","link":"","permalink":"http://blog.master-ss.cn/node/koa-convert/","excerpt":"转换 0.x 和 1.x 版本的 koa generator 中间件到 2.x 版本 promise 包裹的中间件，也可以转换现今版本 promise 包括的中间件回之前的 generator 中间件，这里主要分析 convert。","text":"转换 0.x 和 1.x 版本的 koa generator 中间件到 2.x 版本 promise 包裹的中间件，也可以转换现今版本 promise 包括的中间件回之前的 generator 中间件，这里主要分析 convert。 一、源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const co = require(&apos;co&apos;)const compose = require(&apos;koa-compose&apos;)module.exports = convertfunction convert (mw) &#123; if (typeof mw !== &apos;function&apos;) &#123; throw new TypeError(&apos;middleware must be a function&apos;) &#125; if (mw.constructor.name !== &apos;GeneratorFunction&apos;) &#123; // assume it&apos;s Promise-based middleware return mw &#125; const converted = function (ctx, next) &#123; return co.call(ctx, mw.call(ctx, createGenerator(next))) &#125; converted._name = mw._name || mw.name return converted&#125;function * createGenerator (next) &#123; return yield next()&#125;// convert.compose(mw, mw, mw)// convert.compose([mw, mw, mw])convert.compose = function (arr) &#123; if (!Array.isArray(arr)) &#123; arr = Array.from(arguments) &#125; return compose(arr.map(convert))&#125;convert.back = function (mw) &#123; if (typeof mw !== &apos;function&apos;) &#123; throw new TypeError(&apos;middleware must be a function&apos;) &#125; if (mw.constructor.name === &apos;GeneratorFunction&apos;) &#123; // assume it&apos;s generator middleware return mw &#125; const converted = function * (next) &#123; let ctx = this let called = false // no need try...catch here, it&apos;s ok even `mw()` throw exception yield Promise.resolve(mw(ctx, function () &#123; if (called) &#123; // guard against multiple next() calls // https://github.com/koajs/compose/blob/4e3e96baf58b817d71bd44a8c0d78bb42623aa95/index.js#L36 return Promise.reject(new Error(&apos;next() called multiple times&apos;)) &#125; called = true return co.call(ctx, next) &#125;)) &#125; converted._name = mw._name || mw.name return converted&#125; 二、分析 1、首先做类型判断，只能转换 Generator 函数。 2、convert 执行后返回 converted 函数，其接受 2.x 版本中间件参数 context &amp; next，并赋值 _name 属性，执行完成后返回 promise。 3、converted 中先调用 createGenerator，返回一个迭代器，然后传入 mw 中，再次执行 mw 返回迭代器作为 co 模块的参数。 4、co 模块先调用 mw 返回的迭代器的 next 方法，然后继续执行直到执行到 yield next 方法，next 会被 co 模块再次调用，然后执行到下一中间件。 三、应用12345678910111213141516171819202122const Koa = require(&apos;koa&apos;) // koa v2.xconst convert = require(&apos;koa-convert&apos;)const app = new Koa()app.use(modernMiddleware)app.use(convert(legacyMiddleware))app.use(convert.compose(legacyMiddleware, modernMiddleware))function * legacyMiddleware (next) &#123; // before yield next // after&#125;function modernMiddleware (ctx, next) &#123; // before return next().then(() =&gt; &#123; // after &#125;)&#125;","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"node 之 on-finished","slug":"node/on-finished","date":"2018-04-24T12:06:30.000Z","updated":"2019-01-22T08:59:16.226Z","comments":true,"path":"node/on-finished/","link":"","permalink":"http://blog.master-ss.cn/node/on-finished/","excerpt":"当 http 请求关闭、完成或报错执行回调。","text":"当 http 请求关闭、完成或报错执行回调。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * Module exports. * @public */module.exports = onFinishedmodule.exports.isFinished = isFinished/** * Module dependencies. * @private */var first = require('ee-first')/** * Variables. * @private *//* istanbul ignore next */var defer = typeof setImmediate === 'function' ? setImmediate : function(fn)&#123; process.nextTick(fn.bind.apply(fn, arguments)) &#125;/** * Invoke callback when the response has finished, useful for * cleaning up resources afterwards. * * @param &#123;object&#125; msg * @param &#123;function&#125; listener * @return &#123;object&#125; * @public */function onFinished(msg, listener) &#123; if (isFinished(msg) !== false) &#123; defer(listener, null, msg) return msg &#125; // attach the listener to the message attachListener(msg, listener) return msg&#125;/** * Determine if message is already finished. * * @param &#123;object&#125; msg * @return &#123;boolean&#125; * @public */function isFinished(msg) &#123; var socket = msg.socket if (typeof msg.finished === 'boolean') &#123; // OutgoingMessage return Boolean(msg.finished || (socket &amp;&amp; !socket.writable)) &#125; if (typeof msg.complete === 'boolean') &#123; // IncomingMessage return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete &amp;&amp; !msg.readable)) &#125; // don't know return undefined&#125;/** * Attach a finished listener to the message. * * @param &#123;object&#125; msg * @param &#123;function&#125; callback * @private */function attachFinishedListener(msg, callback) &#123; var eeMsg var eeSocket var finished = false function onFinish(error) &#123; eeMsg.cancel() eeSocket.cancel() finished = true callback(error) &#125; // finished on first message event eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish) function onSocket(socket) &#123; // remove listener msg.removeListener('socket', onSocket) if (finished) return if (eeMsg !== eeSocket) return // finished on first socket event eeSocket = first([[socket, 'error', 'close']], onFinish) &#125; if (msg.socket) &#123; // socket already assigned onSocket(msg.socket) return &#125; // wait for socket to be assigned msg.on('socket', onSocket) if (msg.socket === undefined) &#123; // node.js 0.8 patch patchAssignSocket(msg, onSocket) &#125;&#125;/** * Attach the listener to the message. * * @param &#123;object&#125; msg * @return &#123;function&#125; * @private */function attachListener(msg, listener) &#123; var attached = msg.__onFinished // create a private single listener with queue if (!attached || !attached.queue) &#123; attached = msg.__onFinished = createListener(msg) attachFinishedListener(msg, attached) &#125; attached.queue.push(listener)&#125;/** * Create listener on message. * * @param &#123;object&#125; msg * @return &#123;function&#125; * @private */function createListener(msg) &#123; function listener(err) &#123; if (msg.__onFinished === listener) msg.__onFinished = null if (!listener.queue) return var queue = listener.queue listener.queue = null for (var i = 0; i &lt; queue.length; i++) &#123; queue[i](err, msg) &#125; &#125; listener.queue = [] return listener&#125;/** * Patch ServerResponse.prototype.assignSocket for node.js 0.8. * * @param &#123;ServerResponse&#125; res * @param &#123;function&#125; callback * @private */function patchAssignSocket(res, callback) &#123; var assignSocket = res.assignSocket if (typeof assignSocket !== 'function') return // res.on('socket', callback) is broken in 0.8 res.assignSocket = function _assignSocket(socket) &#123; assignSocket.call(this, socket) callback(socket) &#125;&#125; 二、分析 1、传入 msg，如果 msg 已经完成，则使用 setImmediate 或 process.nextTick 执行回调函数，否则执行 attachListener。 2、如果 msg 内部没有 __onFinished 属性及其 queue 属性，则重新初始化，并将回调函数添加到 queue 数组中。 3、createListener 返回一个回调函数，并在回调函数上挂载 queue 数组，回调函数执行时清空属性值并调用所有 queue 数组中的回调。 4、attachFinishedListener 在 msg 触发 end、finish 事件时执行 onFinish，清空挂载在 msg 上的监听函数，并执行 createListener 返回的回调函数。 三、案例123456789101112131415161718192021// 监听 requestvar data = ''req.setEncoding('utf8')req.on('data', function (str) &#123; data += str&#125;)onFinished(req, function (err, req) &#123; // data is read unless there is err&#125;)// 监听 responsevar destroy = require('destroy')var http = require('http')var onFinished = require('on-finished')http.createServer(function onRequest(req, res) &#123; var stream = fs.createReadStream('package.json') stream.pipe(res) onFinished(res, function (err) &#123; destroy(stream) &#125;)&#125;)","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"node 之 ee-first","slug":"node/ee-first","date":"2018-04-24T09:56:44.000Z","updated":"2019-01-22T08:58:20.735Z","comments":true,"path":"node/ee-first/","link":"","permalink":"http://blog.master-ss.cn/node/ee-first/","excerpt":"捕获多个 event emitter 的多个事件触发，一旦某个事件被触发，则清除所有的回调函数。","text":"捕获多个 event emitter 的多个事件触发，一旦某个事件被触发，则清除所有的回调函数。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Module exports. * @public */module.exports = first/** * Get the first event in a set of event emitters and event pairs. * * @param &#123;array&#125; stuff * @param &#123;function&#125; done * @public */function first(stuff, done) &#123; if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays') var cleanups = [] for (var i = 0; i &lt; stuff.length; i++) &#123; var arr = stuff[i] if (!Array.isArray(arr) || arr.length &lt; 2) throw new TypeError('each array member must be [ee, events...]') var ee = arr[0] for (var j = 1; j &lt; arr.length; j++) &#123; var event = arr[j] var fn = listener(event, callback) // listen to the event ee.on(event, fn) // push this listener to the list of cleanups cleanups.push(&#123; ee: ee, event: event, fn: fn, &#125;) &#125; &#125; function callback() &#123; cleanup() done.apply(null, arguments) &#125; function cleanup() &#123; var x for (var i = 0; i &lt; cleanups.length; i++) &#123; x = cleanups[i] x.ee.removeListener(x.event, x.fn) &#125; &#125; function thunk(fn) &#123; done = fn &#125; thunk.cancel = cleanup return thunk&#125;/** * Create the event listener. * @private */function listener(event, done) &#123; return function onevent(arg1) &#123; var args = new Array(arguments.length) var ee = this var err = event === 'error' ? arg1 : null // copy args to prevent arguments escaping scope for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i] &#125; done(err, ee, event, args) &#125;&#125; 二、分析 1、stuff 是一个二维数组，是[ee, ...event]的数组形式，done 只会被调用一次。 2、让 ee 监听相应的时间，并添加到 cleanups 数组中。 3、done 调用时参数为 err、ee、event、args，在 listener 中返回的 onevent 函数执行，并同时清空所有 event emitter 挂载的回调函数。 4、返回函数 thunk，挂载 cleanup 函数，调用时清空所有 event emitter 挂载的回调函数。 三、案例123456789101112var ee1 = new EventEmitter()var ee2 = new EventEmitter()var thunk = first([ [ee1, 'close', 'end', 'error'], [ee2, 'error']], function (err, ee, event, args) &#123; // listener invoked&#125;)// cancel and clean upthunk.cancel()","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"koa 之 koa-compose","slug":"node/koa-compose","date":"2018-04-24T02:58:10.000Z","updated":"2019-01-22T08:59:36.121Z","comments":true,"path":"node/koa-compose/","link":"","permalink":"http://blog.master-ss.cn/node/koa-compose/","excerpt":"koa-compose 模块可以将多个中间件合成为一个。","text":"koa-compose 模块可以将多个中间件合成为一个。 一、源码12345678910111213141516171819202122232425262728293031function compose (middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;) for (const fn of middleware) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;) &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, function next () &#123; return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 二、分析 1、首先进行类型判断，middleware 参数必须是函数数组。 2、index 为上次调用 middleware 数组的索引值，dispatch 采用递归方法调用。 3、如果 i &lt;= index，那么 next() 被调用多次，返回 Promise.reject。 4、如果 i === middleware.length，说明是最后一个中间件，则将 next 参数赋值给 fn，如果 next 不存在，返回 Promise.resolve，否则继续调用 next，将结果返回。 5、Promise.resolve(Promise.resolve(Promise.resolve(‘resolved’))).then(success, error) 执行 success，Promise.resolve(Promise.resolve(Promise.reject(‘rejected’))).then(success, error) 执行 error。 6、这就是洋葱模型的来由了： 三、应用12345678910111213141516// test.js（将多个中间件合成为一个）const compose = require(&apos;koa-compose&apos;);const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = &apos;Hello World&apos;;&#125;;const middlewares = compose([logger, main]);app.use(middlewares);$ node test.js 访问 http://127.0.0.1:3000 ，就可以在命令行窗口看到日志信息。","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"koa 之 application","slug":"node/koa-application","date":"2018-04-24T02:17:49.000Z","updated":"2018-12-21T05:36:28.386Z","comments":true,"path":"node/koa-application/","link":"","permalink":"http://blog.master-ss.cn/node/koa-application/","excerpt":"打开 koa 的源码，核心文件共四个在 lib 目录下：application.js、context.js、request.js、response.js，我们先来看看 application.js。","text":"打开 koa 的源码，核心文件共四个在 lib 目录下：application.js、context.js、request.js、response.js，我们先来看看 application.js。 一、模块依赖首先看看依赖的模块和文件。123456789101112131415161718const isGeneratorFunction = require('is-generator-function'); // 判断当前传入函数是否为 generator 函数const debug = require('debug')('koa:application'); // 轻量级 js debug 调试工具const onFinished = require('on-finished'); // 事件监听，监听 http 完成或者关闭const response = require('./response'); // response 模块const compose = require('koa-compose'); // 使用 koa-compose 将多个中间件 \"组合\" 成一个单一的中间件，便于重用或导出const isJSON = require('koa-is-json'); // 判断数据为否为 json 格式const context = require('./context'); // context 模块const request = require('./request'); // request 模块const statuses = require('statuses'); // http 状态码const Cookies = require('cookies'); // 记录用户信息const accepts = require('accepts'); // 内容协商const Emitter = require('events'); // 事件模块const assert = require('assert'); // 断言，判断是否符合预期const Stream = require('stream'); // 流const http = require('http'); // http 模块，nodejs 核心模块const only = require('only'); // 返回指定属性的对象const convert = require('koa-convert'); // 兼容旧的 koa，转换 generator 中间件const deprecate = require('depd')('koa'); // 判断 api 是否过期 二、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// 暴露 Application 类，继承 Emittermodule.exports = class Application extends Emitter &#123; constructor() &#123; super(); this.proxy = false; this.middleware = []; // 中间件数组 this.subdomainOffset = 2; // 子域返回偏移量，用于 request 中的 get subdomains() this.env = process.env.NODE_ENV || 'development'; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; // 监听函数，全写：http.createServer(app.callback()).listen(...) listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args); &#125; // 只输出可能含 subdomainOffset、proxy、env 属性的对象，属性值对应 this 相应属性值 toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]); &#125; // 调用 toJSON 方法 inspect() &#123; return this.toJSON(); &#125; // 处理给出的中间件 fn，旧格式的中间件将会被转换，返回实例对象 use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; // 判断中间件是否是 generator 函数 deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this; &#125; // 返回请求处理回调 callback() &#123; const fn = compose(this.middleware); // this.middleware 必须是函数数组 if (!this.listeners('error').length) this.on('error', this.onerror); // 添加错误默认处理函数（this.listeners('error'): 返回名为 error 的事件的监听器数组的副本） const handleRequest = (req, res) =&gt; &#123; // 返回 requestListener 函数 const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; // 处理请求（私有方法） handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; // 初始化一个新的 context 对象（私有方法） createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context; &#125; // 默认的错误处理函数 onerror(err) &#123; assert(err instanceof Error, `non-error thrown: $&#123;err&#125;`); // 类型检查，确认 err 是 Error 对象 if (404 == err.status || err.expose) return; // 如果 err.status 是 404 或者 err.expose 是 true，则不输出错误信息 if (this.silent) return; // 如果 silent 是 true，则不输出错误信息 const msg = err.stack || err.toString(); console.error(); console.error(msg.replace(/^/gm, ' ')); console.error(); &#125;&#125;;// 响应方法function respond(ctx) &#123; // 显式设置 ctx.respond = false 来绕过 koa response 封装，使用原生 res api if (false === ctx.respond) return; const res = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // 处理空状态码 if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; // HEAD 方法与 GET 类似，但是 HEAD 并不返回消息体 if ('HEAD' == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // 处理空回复 if (null == body) &#123; body = ctx.message || String(code); if (!res.headersSent) &#123; ctx.type = 'text'; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // 三种处理 buffer 字符串 流 if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json（字符串序列化） body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; 三、分析1、constructorkoa 核心代码在 lib 目录下的四个文件中，其中 application.js 为入口文件。其暴露 Application 类，这个类继承 Emitter。当引入 koa 且执行 new 操作时初始化 Application 实例并在实例上初始化一些配置，并挂载 context、request、response 实例。 2、use往 Application 实例上的 middleware 数组上添加中间件，generator 函数会被转换并警告。 3、listen调用 callback 方法获取返回函数作为 createServer 的参数，并监听相应端口。 4、callback调用 compose 将 middleware 数组组合在一起，添加错误默认处理函数，调用 createContext、handleRequest，返回 handleRequest。 5、createContext初始化一个新的 context 对象，并在对象上挂载 Application 实例、req &amp; res 原生请求对象、request &amp; response 类实例及一些属性。 6、handleRequest为请求添加失败回调函数，并使用中间件处理请求，后执行成功回调。","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"es6 之 Reflect","slug":"es6/reflect","date":"2018-04-23T03:28:09.000Z","updated":"2018-04-23T06:14:24.000Z","comments":true,"path":"es6/reflect/","link":"","permalink":"http://blog.master-ss.cn/es6/reflect/","excerpt":"Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。","text":"Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。 一、概述Reflect 对象的设计目的有这样几个: 1、将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty ），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。2、修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc) 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。3、让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。4、Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。12345678910111213141516171819202122232425262728293031// 修改某些 Object 方法的返回结果，让其变得更合理try &#123; // 老写法 Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;if (Reflect.defineProperty(target, property, attributes)) &#123; // 新写法 // success&#125; else &#123; // failure&#125;// 让 Object 操作变成函数行为&apos;assign&apos; in Object // 老写法，trueReflect.has(Object, &apos;assign&apos;) // 新写法，true// Reflect 对象的方法与 Proxy 对象的方法一一对应Proxy(target, &#123; set: function(target, name, value, receiver) &#123; // Proxy 方法拦截 target 对象的属性赋值行为 var success = Reflect.set(target,name, value, receiver); // 采用 Reflect.set 方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能 if (success) &#123; log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value); &#125; return success; &#125;&#125;);// 有了 Reflect 对象以后，很多操作会更易读Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 老写法，1Reflect.apply(Math.floor, undefined, [1.75]) // 新写法，1 二、静态方法Reflect对象一共有 13 个静态方法：Reflect.apply(target, thisArg, args)Reflect.construct(target, args)Reflect.get(target, name, receiver)Reflect.set(target, name, value, receiver)Reflect.defineProperty(target, name, desc)Reflect.deleteProperty(target, name)Reflect.has(target, name)Reflect.ownKeys(target)Reflect.isExtensible(target)Reflect.preventExtensions(target)Reflect.getOwnPropertyDescriptor(target, name)Reflect.getPrototypeOf(target)Reflect.setPrototypeOf(target, prototype)上面这些方法的作用，大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。下面是对它们的解释。 1、Reflect.get(target, name, receiver)Reflect.get 方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined。12345678910111213141516171819202122232425262728var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, &apos;foo&apos;) // 1Reflect.get(myObject, &apos;bar&apos;) // 2Reflect.get(myObject, &apos;baz&apos;) // 3// 如果 name 属性部署了读取函数（getter），则读取函数的 this 绑定 receivervar myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;Reflect.get(myObject, &apos;baz&apos;, myReceiverObject) // 8// 如果第一个参数不是对象，Reflect.get 方法会报错Reflect.get(1, &apos;foo&apos;) // 报错Reflect.get(false, &apos;foo&apos;) // 报错 2、Reflect.set(target, name, value, receiver)Reflect.set 方法设置 target 对象的 name 属性等于 value。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var myObject = &#123; foo: 1, set bar(value) &#123; return this.foo = value; &#125;,&#125;myObject.foo // 1Reflect.set(myObject, &apos;foo&apos;, 2);myObject.foo // 2Reflect.set(myObject, &apos;bar&apos;, 3)myObject.foo // 3// 如果 name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver。var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, &apos;bar&apos;, 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1// 注意，如果 Proxy 对象和 Reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 receiver，那么 Reflect.set 会触发 Proxy.defineProperty 拦截。let p = &#123; a: &apos;a&apos;&#125;;let handler = &#123; set(target, key, value, receiver) &#123; // Proxy.set 的 receiver 参数总是指向当前的 Proxy 实例 console.log(&apos;set&apos;); Reflect.set(target, key, value, receiver) // Reflect.set 一旦传入 receiver，就会将属性赋值到 receiver 上面，导致触发 defineProperty 拦截 &#125;, defineProperty(target, key, attribute) &#123; console.log(&apos;defineProperty&apos;); Reflect.defineProperty(target, key, attribute); &#125;&#125;;let obj = new Proxy(p, handler);obj.a = &apos;A&apos;;// set// defineProperty// 如果 Reflect.set 没有传入 receiver，那么就不会触发 defineProperty 拦截let p = &#123; a: &apos;a&apos;&#125;;let handler = &#123; set(target, key, value, receiver) &#123; console.log(&apos;set&apos;); Reflect.set(target, key, value) &#125;, defineProperty(target, key, attribute) &#123; console.log(&apos;defineProperty&apos;); Reflect.defineProperty(target, key, attribute); &#125;&#125;;let obj = new Proxy(p, handler);obj.a = &apos;A&apos;;// set// 如果第一个参数不是对象，Reflect.set 会报错Reflect.set(1, &apos;foo&apos;, &#123;&#125;) // 报错Reflect.set(false, &apos;foo&apos;, &#123;&#125;) // 报错 3、Reflect.has(obj, name)Reflect.has 方法对应 name in obj 里面的 in 运算符。如果第一个参数不是对象，Reflect.has 和 in 运算符都会报错。1234567var myObject = &#123; foo: 1,&#125;;// 旧写法&apos;foo&apos; in myObject // true// 新写法Reflect.has(myObject, &apos;foo&apos;) // true 4、Reflect.deleteProperty(obj, name)Reflect.deleteProperty 方法等同于 delete obj[name]，用于删除对象的属性。该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回 true；删除失败，被删除的属性依然存在，返回 false。12345const myObj = &#123; foo: &apos;bar&apos; &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, &apos;foo&apos;); 5、Reflect.construct(target, args)Reflect.construct 方法等同于 new target(…args)，这提供了一种不使用 new，来调用构造函数的方法。1234567function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting(&apos;张三&apos;);// Reflect.construct 的写法const instance = Reflect.construct(Greeting, [&apos;张三&apos;]); 6、Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf 方法用于读取对象的__proto__属性，对应 Object.getPrototypeOf(obj)。123456789const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype;// Reflect.getPrototypeOf 和 Object.getPrototypeOf 的一个区别是，如果参数不是对象，Object.getPrototypeOf 会将这个参数转为对象，然后再运行，而 Reflect.getPrototypeOf 会报错Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;Reflect.getPrototypeOf(1) // 报错 7、Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf 方法用于设置对象的__proto__属性，返回第一个参数对象，对应 Object.setPrototypeOf(obj, newProto)。1234567891011121314151617const myObj = new FancyThing();// 旧写法Object.setPrototypeOf(myObj, OtherThing.prototype);// 新写法Reflect.setPrototypeOf(myObj, OtherThing.prototype);// 如果第一个参数不是对象，Object.setPrototypeOf 会返回第一个参数本身，而 Reflect.setPrototypeOf 会报错Object.setPrototypeOf(1, &#123;&#125;)// 1Reflect.setPrototypeOf(1, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object// 如果第一个参数是 undefined 或 null，Object.setPrototypeOf 和 Reflect.setPrototypeOf 都会报错Object.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedReflect.setPrototypeOf(null, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object 8、Reflect.apply(func, thisArg, args)Reflect.apply 方法等同于 Function.prototype.apply.call(func, thisArg, args)，用于绑定 this 对象后执行给定函数。一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args)，但是如果函数定义了自己的 apply 方法，就只能写成 Function.prototype.apply.call(fn, obj, args)，采用 Reflect 对象可以简化这种操作。1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); 9、Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty 方法基本等同于 Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用 Reflect.defineProperty 代替它。12345678910111213141516171819202122232425function MyDate() &#123; /*…*/&#125;// 旧写法Object.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; Date.now()&#125;);// 如果 Reflect.defineProperty 的第一个参数不是对象，就会抛出错误Reflect.defineProperty(1, &apos;foo&apos;) // 报错// 这个方法可以与 Proxy.defineProperty 配合使用const p = new Proxy(&#123;&#125;, &#123; defineProperty(target, prop, descriptor) &#123; console.log(descriptor); return Reflect.defineProperty(target, prop, descriptor); &#125;&#125;);p.foo = &apos;bar&apos;;// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;p.foo // &quot;bar&quot; 10、Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor 基本等同于 Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。Reflect.getOwnPropertyDescriptor 和 Object.getOwnPropertyDescriptor 的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, ‘foo’) 不报错，返回undefined，而 Reflect.getOwnPropertyDescriptor(1, ‘foo’) 会抛出错误，表示参数非法。1234567891011var myObject = &#123;&#125;;Object.defineProperty(myObject, &apos;hidden&apos;, &#123; value: true, enumerable: false,&#125;);// 旧写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;);// 新写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;); 11、Reflect.isExtensible (target)Reflect.isExtensible 方法对应 Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。123456789const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true// 如果参数不是对象，Object.isExtensible 会返回 false，因为非对象本来就是不可扩展的，而 Reflect.isExtensible 会报错Object.isExtensible(1) // falseReflect.isExtensible(1) // 报错 12、Reflect.preventExtensions(target)Reflect.preventExtensions 对应 Object.preventExtensions 方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。如果参数不是对象，Object.preventExtensions 在 ES5 环境报错，在 ES6 环境返回传入的参数，而 Reflect.preventExtensions 会报错。123456789101112var myObject = &#123;&#125;;// 旧写法Object.preventExtensions(myObject) // Object &#123;&#125;// 新写法Reflect.preventExtensions(myObject) // true// ES5 环境Object.preventExtensions(1) // 报错// ES6 环境Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错 13、Reflect.ownKeys(target)Reflect.ownKeys 方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和。1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for(&apos;baz&apos;)]: 3, [Symbol.for(&apos;bing&apos;)]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// [&apos;foo&apos;, &apos;bar&apos;]Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// [&apos;foo&apos;, &apos;bar&apos;, Symbol(baz), Symbol(bing)] 三、实例：使用 Proxy 实现观察者模式12345678910111213141516171819202122// 数据对象 person 是观察目标，函数 print 是观察者。一旦数据对象发生变化，print 就会自动执行const person = observable(&#123; name: &apos;张三&apos;, age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = &apos;李四&apos;;// 输出// 李四, 20// 使用 Proxy 写一个观察者模式的最简单实现，即实现 observable 和 observe 这两个函数const queuedObservers = new Set(); // 先定义了一个 Set 集合，所有观察者函数都放进这个集合const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;); // observable 函数返回原始对象的代理，拦截赋值操作function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); // 拦截函数 set 之中，会自动执行所有观察者 return result;&#125; 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行，实现如上。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 Proxy","slug":"es6/proxy","date":"2018-04-22T14:12:03.000Z","updated":"2018-04-23T03:26:45.000Z","comments":true,"path":"es6/proxy/","link":"","permalink":"http://blog.master-ss.cn/es6/proxy/","excerpt":"Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。","text":"Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 一、概述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);// 对设置了拦截行为的对象 obj，去读写它的属性，就会得到下面的结果（实际上重载了点运算符，即用自己的定义覆盖了语言的原始定义）obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2// ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例（target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为）var proxy = new Proxy(target, handler);// 拦截读取属性行为（get 方法的两个参数分别是目标对象和所要访问的属性）var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35// 如果 handler 没有设置任何拦截，那就等同于直接通向原对象var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = &apos;b&apos;;target.a // &quot;b&quot;// 一个技巧是将 Proxy 对象，设置到 object.proxy 属性，从而可以在 object 对象上调用var object = &#123; proxy: new Proxy(target, handler) &#125;;// Proxy 实例也可以作为其他对象的原型对象（obj 对象本身并没有 time 属性，所以根据原型链，会在 proxy 对象上读取该属性，导致被拦截）var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35// 同一个拦截器函数，可以设置拦截多个操作（对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果）var handler = &#123; get: function(target, name) &#123; if (name === &apos;prototype&apos;) &#123; return Object.prototype; &#125; return &apos;Hello, &apos; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === &quot;Hello, foo&quot; // true 下面是 Proxy 支持的拦截操作一览，一共 13 种：1.1、get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。1.2、set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。1.3、has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。1.4、deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。1.5、ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。1.6、getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。1.7、defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。1.8、preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。1.9、getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。1.10、isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。1.11、setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。1.12、apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。1.13、construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。二、Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 2.1、get()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 拦截读取操作（访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined）var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误// get 方法可以继承（拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效）let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(&apos;GET &apos; + propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.foo // &quot;GET foo&quot;// 使用 get 拦截，实现数组读取负数的索引（数组的位置参数是 -1，就会输出数组的倒数第一个成员）function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target = []; target.push(...elements); return new Proxy(target, handler);&#125;let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);arr[-1] // c// 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作var pipe = (function () &#123; return function (value) &#123; var funcStack = []; var oproxy = new Proxy(&#123;&#125; , &#123; get : function (pipeObject, fnName) &#123; if (fnName === &apos;get&apos;) &#123; return funcStack.reduce(function (val, fn) &#123; return fn(val); &#125;,value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125;); return oproxy; &#125;&#125;());var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;pipe(3).double.pow.reverseInt.get; // 63// 利用 get 拦截实现一个生成各种 DOM 节点的通用函数 domconst dom = new Proxy(&#123;&#125;, &#123; get(target, property) &#123; return function(attrs = &#123;&#125;, ...children) &#123; const el = document.createElement(property); for (let prop of Object.keys(attrs)) &#123; el.setAttribute(prop, attrs[prop]); &#125; for (let child of children) &#123; if (typeof child === &apos;string&apos;) &#123; child = document.createTextNode(child); &#125; el.appendChild(child); &#125; return el; &#125; &#125;&#125;);const el = dom.div(&#123;&#125;, &apos;Hello, my name is &apos;, dom.a(&#123;href: &apos;//example.com&apos;&#125;, &apos;Mark&apos;), &apos;. I like:&apos;, dom.ul(&#123;&#125;, dom.li(&#123;&#125;, &apos;The web&apos;), dom.li(&#123;&#125;, &apos;Food&apos;), dom.li(&#123;&#125;, &apos;…actually that\\&apos;s it&apos;) ));document.body.appendChild(el);// get 方法的第三个参数（get 方法的第三个参数 receiver，总是为当前的 Proxy 实例）const proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property, receiver) &#123; return receiver; &#125;&#125;);proxy.getReceiver === proxy // true// 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错const target = Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;,&#125;);const handler = &#123; get(target, propKey) &#123; return &apos;abc&apos;; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo // TypeError: Invariant check failed 2.2、set()set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 数据验证的一种实现方法。利用 set 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &apos;age&apos;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&apos;The age is not an integer&apos;); &#125; if (value &gt; 200) &#123; throw new RangeError(&apos;The age seems invalid&apos;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &apos;young&apos; // 报错person.age = 300 // 报错// 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写const handler = &#123; get (target, key) &#123; invariant(key, &apos;get&apos;); return target[key]; &#125;, set (target, key, value) &#123; invariant(key, &apos;set&apos;); target[key] = value; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === &apos;_&apos;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop // Error: Invalid attempt to get private &quot;_prop&quot; propertyproxy._prop = &apos;c&apos; // Error: Invalid attempt to set private &quot;_prop&quot; property// set 方法第四个参数const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.foo = &apos;bar&apos;;proxy.foo === proxy // true// set 方法的第四个参数 receiver，指的是操作行为所在的那个对象，一般情况下是 proxy 实例本身// 设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。// 正常情况下，如果 myObj 存在 foo 属性，则不会去原型链找 foo 属性；如果 handler 的 set 方法是默认行为 Reflect.set(obj, prop, value, receiver)，那么 myObj 的原型上不会有任何改变，在 myObj 新建 foo 属性并赋值const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = &apos;bar&apos;;myObj.foo === myObj // true// 如果目标对象自身的某个属性，不可写或不可配置，那么 set 方法将不起作用（obj.foo 属性不可写，Proxy 对这个属性的 set 代理将不会生效）const obj = &#123;&#125;;Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;bar&apos;, writable: false,&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = &apos;baz&apos;; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = &apos;baz&apos;;proxy.foo // &quot;bar&quot; 2.3、apply()apply 方法拦截函数的调用、call 和 apply 操作。123456789101112131415161718192021222324252627282930313233// apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组var handler = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments); &#125;&#125;;// 变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串var target = function () &#123; return &apos;I am the target&apos;; &#125;;var handler = &#123; apply: function () &#123; return &apos;I am the proxy&apos;; &#125;&#125;;var p = new Proxy(target, handler);p() // &quot;I am the proxy&quot;// 每当执行 proxy 函数（直接调用或 call 和 apply 调用），就会被 apply 方法拦截var twice = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum (left, right) &#123; return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30// 直接调用 Reflect.apply 方法，也会被拦截Reflect.apply(proxy, null, [9, 10]) // 38 2.4、has()has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 使用 has 方法隐藏某些属性，不被 in 运算符发现var handler = &#123; has (target, key) &#123; if (key[0] === &apos;_&apos;) &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;var proxy = new Proxy(target, handler);&apos;_prop&apos; in proxy // false// 原对象不可配置或者禁止扩展，has 拦截会报错（has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性）var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);&apos;a&apos; in p // TypeError is thrown// 虽然 for...in 循环也用到了 in 运算符，但是 has 拦截对 for...in 循环不生效let stu1 = &#123;name: &apos;张三&apos;, score: 59&#125;;let stu2 = &#123;name: &apos;李四&apos;, score: 99&#125;;let handler = &#123; has(target, prop) &#123; if (prop === &apos;score&apos; &amp;&amp; target[prop] &lt; 60) &#123; console.log(`$&#123;target.name&#125; 不及格`); return false; &#125; return prop in target; &#125;&#125;let oproxy1 = new Proxy(stu1, handler);let oproxy2 = new Proxy(stu2, handler);&apos;score&apos; in oproxy1// 张三 不及格// false&apos;score&apos; in oproxy2// truefor (let a in oproxy1) &#123; console.log(oproxy1[a]);&#125;// 张三// 59for (let b in oproxy2) &#123; console.log(oproxy2[b]);&#125;// 李四// 99 2.5、construct()construct 方法用于拦截 new 命令。12345678910111213141516171819202122232425// construct 方法可以接受两个参数: target 目标对象，args 构建函数的参数对象var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args); &#125;&#125;;// 例子var p = new Proxy(function () &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(&apos;called: &apos; + args.join(&apos;, &apos;)); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);(new p(1)).value// &quot;called: 1&quot;// 10// construct 方法返回的必须是一个对象，否则会报错var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p() // 报错 2.6、deleteProperty()deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。1234567891011121314var handler = &#123; deleteProperty (target, key) &#123; invariant(key, &apos;delete&apos;); return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === &apos;_&apos;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;var target = &#123; _prop: &apos;foo&apos; &#125;;var proxy = new Proxy(target, handler);delete proxy._prop // Error: Invalid attempt to delete private &quot;_prop&quot; property 2.7、defineProperty()defineProperty 方法拦截了 Object.defineProperty 操作。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty 方法不得改变这两个设置。12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; // 返回 false，导致添加新属性会抛出错误 &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = &apos;bar&apos; // TypeError: proxy defineProperty handler returned false for property &apos;&quot;foo&quot;&apos; 2.8、getOwnPropertyDescriptor()getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。1234567891011121314151617// handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名返回 undefinedvar handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === &apos;_&apos;) &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: &apos;bar&apos;, baz: &apos;tar&apos; &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, &apos;wat&apos;)// undefinedObject.getOwnPropertyDescriptor(proxy, &apos;_foo&apos;)// undefinedObject.getOwnPropertyDescriptor(proxy, &apos;baz&apos;)// &#123; value: &apos;tar&apos;, writable: true, enumerable: true, configurable: true &#125; 2.9、getPrototypeOf()getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作：Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Object.getPrototypeOf()、Reflect.getPrototypeOf()、instanceof。注意，getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。12345678// getPrototypeOf 方法拦截 Object.getPrototypeOf()，返回 proto 对象var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true 2.10、isExtensible()isExtensible 方法拦截 Object.isExtensible 操作。注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。123456789101112131415161718192021// 设置 isExtensible 方法，在调用 Object.isExtensible 时会输出 calledvar p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(&quot;called&quot;); return true; &#125;&#125;);Object.isExtensible(p)// &quot;called&quot;// true// 这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误Object.isExtensible(proxy) === Object.isExtensible(target)// 例子var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125;&#125;);Object.isExtensible(p) // 报错 2.11、ownKeys()ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截这些操作：Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.keys()、for…in 循环。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 拦截对于 target 对象的 Object.keys() 操作，只返回 a、b、c 三个属性之中的 a 属性let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [&apos;a&apos;]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [ &apos;a&apos; ]// 拦截第一个字符为下划线的属性名let target = &#123; _bar: &apos;foo&apos;, _prop: &apos;bar&apos;, prop: &apos;baz&apos;&#125;;let handler = &#123; ownKeys (target) &#123; return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;); &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123; console.log(target[key]);&#125;// &quot;baz&quot;// 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回: 目标对象上不存在的属性、属性名为 Symbol 值、不可遍历（enumerable）的属性let target = &#123; a: 1, b: 2, c: 3, [Symbol.for(&apos;secret&apos;)]: &apos;4&apos;,&#125;;Object.defineProperty(target, &apos;key&apos;, &#123; enumerable: false, configurable: true, writable: true, value: &apos;static&apos;&#125;);let handler = &#123; ownKeys(target) &#123; // 显式返回不存在的属性（d）、Symbol 值（Symbol.for(&apos;secret&apos;)）、不可遍历的属性（key），结果都被自动过滤掉 return [&apos;a&apos;, &apos;d&apos;, Symbol.for(&apos;secret&apos;), &apos;key&apos;]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [&apos;a&apos;]// ownKeys 方法还可以拦截 Object.getOwnPropertyNames()var p = new Proxy(&#123;&#125;, &#123; ownKeys: function(target) &#123; return [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; &#125;&#125;);Object.getOwnPropertyNames(p)// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]// for...in 循环也受到 ownKeys 方法的拦截const obj = &#123; hello: &apos;world&apos; &#125;;const proxy = new Proxy(obj, &#123; ownKeys: function () &#123; // 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for...in 循环不会有任何输出 return [&apos;a&apos;, &apos;b&apos;]; &#125;&#125;);for (let key in proxy) &#123; console.log(key); // 没有任何输出&#125;// ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错var obj = &#123;&#125;;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [123, true, undefined, null, &#123;&#125;, []]; &#125;&#125;);Object.getOwnPropertyNames(p) // Uncaught TypeError: 123 is not a valid property name// 目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错var obj = &#123;&#125;;Object.defineProperty(obj, &apos;a&apos;, &#123; configurable: false, enumerable: true, value: 10 &#125;);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [&apos;b&apos;]; &#125;&#125;);Object.getOwnPropertyNames(p) // Uncaught TypeError: &apos;ownKeys&apos; on proxy: trap result did not include &apos;a&apos;// 目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错var obj = &#123; a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [&apos;a&apos;, &apos;b&apos;]; &#125;&#125;);Object.getOwnPropertyNames(p) // Uncaught TypeError: &apos;ownKeys&apos; on proxy: trap returned extra keys but proxy target is non-extensible 2.12、preventExtensions()preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。12345678910111213141516171819// 这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false），proxy.preventExtensions 才能返回true，否则会报错。var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(p) // 报错// 为了防止出现这个问题，通常要在 proxy.preventExtensions 方法里面，调用一次 Object.preventExtensionsvar p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(&apos;called&apos;); Object.preventExtensions(target); return true; &#125;&#125;);Object.preventExtensions(p)// &quot;called&quot;// true 2.13、setPrototypeOf()setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。12345678910// 例子: 只要修改 target 的原型对象，就会报错var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error(&apos;Changing the prototype is forbidden&apos;); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto); // Error: Changing the prototype is forbidden 三、Proxy.revocableProxy.revocable 方法返回一个可取消的 Proxy 实例。Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。1234567let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke(); // 执行之后，再访问 Proxy 实例，就会抛出一个错误proxy.foo // TypeError: Revoked 四、this虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。1234567891011121314151617181920212223242526272829303132333435363738394041424344// 一旦 proxy 代理 target.m，后者内部的 this 就是指向 proxy，而不是 targetconst target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true// 由于 this 指向的变化，导致 Proxy 无法代理目标对象const _name = new WeakMap();class Person &#123; constructor(name) &#123; _name.set(this, name); &#125; get name() &#123; return _name.get(this); &#125;&#125;const jane = new Person(&apos;Jane&apos;);jane.name // &apos;Jane&apos;const proxy = new Proxy(jane, &#123;&#125;);proxy.name // undefined// 有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate(); // TypeError: this is not a Date object.// getDate 方法只能在 Date 对象实例上面拿到，如果 this 不是Date对象实例就会报错。这时，this 绑定原始对象，就可以解决这个问题const target = new Date(&apos;2015-01-01&apos;);const handler = &#123; get(target, prop) &#123; if (prop === &apos;getDate&apos;) &#123; return target.getDate.bind(target); &#125; return Reflect.get(target, prop); &#125;&#125;;const proxy = new Proxy(target, handler);proxy.getDate() // 1 五、实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。123456789101112131415// 新建了一个 Web 服务的接口，这个接口返回各种数据const service = createWebService(&apos;http://example.com/data&apos;);service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);// Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+&apos;/&apos; + propKey); &#125; &#125;);&#125; 同理，Proxy 也可以用来实现数据库的 ORM 层。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"tools 之 source-map","slug":"tools/source-map","date":"2018-04-01T14:24:22.000Z","updated":"2018-04-19T07:25:43.000Z","comments":true,"path":"tools/source-map/","link":"","permalink":"http://blog.master-ss.cn/tools/source-map/","excerpt":"一个最简单的优化网站方法就是合并、压缩 JS 和 CSS 文件。但是如果需要在这些压缩后的文件中进行调试，这个时候实际运行的代码不同于开发代码，debug 会变得很困难，这就是 Source Map 想要解决的问题。","text":"一个最简单的优化网站方法就是合并、压缩 JS 和 CSS 文件。但是如果需要在这些压缩后的文件中进行调试，这个时候实际运行的代码不同于开发代码，debug 会变得很困难，这就是 Source Map 想要解决的问题。 一、什么是 Source MapSource Map 提供了一个映射压缩文件到原文件初始位置的方法。这就意味着，使用浏览器或者其他软件可以轻松调试文件，即使是在资源文件以及被压缩后。Chrome 和 Firefox 开发工具都已经内置支持 Source Map 了。当代码出错的时候，调试工具将直接显示原文件代码，而不是压缩后的，给开发者带来了很大方便。 二、Source Map 如何生效只要在转换后的代码尾部，加上一行就可以启用 Source Map 了，map 文件可以放在网络上，也可以放在本地文件系统。1//@ sourceMappingURL=/path/to/file.js.map 可以使用 UglifyJS 等工具生成 Source Map。 三、Source Map 原理3.1 打开 Source map 文件，它大概是这个样子：12345678&#123; version : 3, file: &quot;out.js&quot;, sourceRoot : &quot;&quot;, sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], mappings: &quot;AAgBC,SAAQ,CAAEA&quot;&#125; 3.2 整个文件就是一个 JavaScript 对象，可以被解释器读取。它主要有以下几个属性：1234567891011- version：Source map 的版本规范，目前为3。 - file：转换后的文件名。 - sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。 - sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。 - names：转换前的所有变量名和属性名。 - mappings：记录位置信息的字符串。 3.3 两个文件的各个位置一一对应的关键就是 map 文件的 mappings 属性。这是一个很长的字符串，它分成三层。12345第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。 第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。 第三层是位置转换，以 VLQ 编码表示，代表该位置对应的转换前的源码位置。 3.4 举例来说，假定 mappings 属性的内容如下：12// 表示转换后的源码分成两行，第一行有两个位置，第二行有一个位mappings:&quot;AAAAA,BBBBB;CCCCC&quot; 3.5 每个位置使用五位，表示五个字段。从左边算起：123456789- 第一位，表示这个位置在（转换后的代码的）的第几列。 - 第二位，表示这个位置属于 sources 属性中的哪一个文件。 - 第三位，表示这个位置属于转换前代码的第几行。 - 第四位，表示这个位置属于转换前代码的第几列。 - 第五位，表示这个位置属于names属性中的哪一个变量。 有几点需要说明。首先，所有的值都是以 0 作为基数的。其次，第五位不是必需的，如果该位置没有对应 names 属性中的变量，可以省略第五位。再次，每一位都采用 VLQ 编码表示；由于 VLQ 编码是变长的，所以每一位可以由多个字符构成。如果某个位置是 AAAAA，由于 A 在 VLQ 编码中表示 0，因此这个位置的五个位实际上都是 0。它的意思是，该位置在转换后代码的第 0 列，对应 sources 属性中第 0 个文件，属于转换前代码的第 0 行第 0 列，对应 names 属性中的第 0 个变量。","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.master-ss.cn/categories/tools/"}],"tags":[]},{"title":"es6 之 Decorator","slug":"es6/decorator","date":"2018-04-01T08:44:44.000Z","updated":"2018-04-22T13:13:18.000Z","comments":true,"path":"es6/decorator/","link":"","permalink":"http://blog.master-ss.cn/es6/decorator/","excerpt":"许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。","text":"许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。 一、简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// @testable 就是一个修饰器，修改了 MyTestableClass 这个类的行为，为它加上了静态属性 isTestable@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; // testable 函数的参数 target 是 MyTestableClass 类本身 target.isTestable = true;&#125;MyTestableClass.isTestable // true // 修饰器的行为: 修饰器是一个对类进行处理的函数，修饰器函数的第一个参数，就是所要修饰的目标类@decoratorclass A &#123;&#125;class A &#123;&#125; // 等同于A = decorator(A) || A; // 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数（修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时）function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false // 添加实例属性可以通过目标类的 prototype 对象操作function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true // 通过修饰器 mixins，把 Foo 对象的方法添加到了 MyClass 的实例上面export function mixins(...list) &#123; // mixins.js return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;import &#123; mixins &#125; from &apos;./mixins&apos; // main.jsconst Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &apos;foo&apos; // 用 Object.assign() 模拟上面的功能const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; // React 与 Redux 库结合使用时，常常需要写成下面这样class MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); // 使用装饰器改写，看上去更容易理解@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125; 二、方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 修饰器 readonly 用来修饰 &quot;类&quot; 的 name 方法class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; // 修饰器函数 readonly 可接受三个参数，分别是: 类的原型对象、所要修饰的属性名、该属性的描述对象function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; // 修饰器会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性 return descriptor;&#125;readonly(Person.prototype, &apos;name&apos;, descriptor);Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor); // 类似于 // 修改属性描述对象的 enumerable 属性，使得该属性不可遍历class Person &#123; @nonenumerable get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123; descriptor.enumerable = false; return descriptor;&#125; // @log修饰器，起到输出日志的作用: 在执行原始的操作之前执行一次 console.log，从而达到输出日志的目的class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(null, arguments); &#125;; return descriptor;&#125;const math = new Math();math.add(2, 4); // passed parameters should get logged now // 修饰器有注释的作用: 一眼就能看出 Person 类是可测试的，而 name 方法是只读和不可枚举的@testableclass Person &#123; @readonly @nonenumerable name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; // 使用 Decorator 写法的组件，看上去一目了然@Component(&#123; tag: &apos;my-component&apos;, styleUrl: &apos;my-component.scss&apos;&#125;)export class MyComponent &#123; @Prop() first: string; @Prop() last: string; @State() isVisible: boolean = true; render() &#123; return ( &lt;p&gt;Hello, my name is &#123;this.first&#125; &#123;this.last&#125;&lt;/p&gt; ); &#125;&#125; // 同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行function dec(id)&#123; console.log(&apos;evaluated&apos;, id); return (target, property, descriptor) =&gt; console.log(&apos;executed&apos;, id);&#125;class Example &#123; // 外层修饰器 @dec(1) 先进入，但是内层修饰器 @dec(2) 先执行 @dec(1) @dec(2) method()&#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 三、修饰器不能用于函数修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。而类是不会提升的，所以就没有这方面的问题。1234567891011121314151617181920212223242526272829303132// 意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; // 函数提升，使得实际执行顺序如下@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; // 另一个例子var readOnly = require(&quot;some-decorator&quot;);@readOnlyfunction foo() &#123;&#125; // 实际执行顺序var readOnly;@readOnlyfunction foo() &#123;&#125;readOnly = require(&quot;some-decorator&quot;); 四、使用修饰器实现自动发布事件我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。123456789101112131415161718192021222324252627282930313233343536373839404142// 定义了一个名为 publish 的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件const postal = require(&quot;postal/lib/postal.lodash&quot;); // 使用的事件“发布/订阅”库是 Postal.jsexport default function publish(topic, channel) &#123; const channelName = channel || &apos;/&apos;; const msgChannel = postal.channel(channelName); msgChannel.subscribe(topic, v =&gt; &#123; console.log(&apos;频道: &apos;, channelName); console.log(&apos;事件: &apos;, topic); console.log(&apos;数据: &apos;, v); &#125;); return function(target, name, descriptor) &#123; const fn = descriptor.value; descriptor.value = function() &#123; let value = fn.apply(this, arguments); msgChannel.publish(topic, value); &#125;; &#125;;&#125; // 用法如下import publish from &apos;./publish&apos;; // index.jsclass FooComponent &#123; @publish(&apos;foo.some.message&apos;, &apos;component&apos;) someMethod() &#123; return &#123; my: &apos;data&apos; &#125;; &#125; @publish(&apos;foo.some.other&apos;) anotherMethod() &#123; // ... &#125;&#125;let foo = new FooComponent();foo.someMethod(); // 只要调用 someMethod 或者 anotherMethod，就会自动发出一个事件foo.anotherMethod(); $ bash-node index.js频道: component事件: foo.some.message数据: &#123; my: &apos;data&apos; &#125;频道: /事件: foo.some.other数据: undefined 五、Mixin在修饰器的基础上，可以实现 Mixin 模式。所谓 Mixin 模式，就是对象继承的一种替代方案，中文译为 “混入”（mix in），意为在一个对象之中混入另外一个对象的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 简单实现const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo); // 将 foo 方法 &quot;混入&quot; MyClass 类，导致 MyClass 的实例 obj 对象都具有 foo 方法let obj = new MyClass();obj.foo() // &apos;foo&apos; // 部署一个通用脚本 mixins.js，将 Mixin 写成一个修饰器export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; // 使用上面这个修饰器，为类 &quot;混入&quot; 各种方法，会改写 MyClass 类的 prototype 对象import &#123; mixins &#125; from &apos;./mixins&apos;;const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &quot;foo&quot; // MyMixin 是一个混入类生成器，接受 superclass 作为参数，然后返回一个继承 superclass 的子类，该子类包含一个 foo 方法let MyMixin = (superclass) =&gt; class extends superclass &#123; foo() &#123; console.log(&apos;foo from MyMixin&apos;); &#125;&#125;; // 目标类再去继承这个混入类，就达到了 &quot;混入&quot; foo 方法的目的class MyClass extends MyMixin(MyBaseClass) &#123; /* ... */&#125;let c = new MyClass();c.foo(); // &quot;foo from MyMixin&quot; // 如果需要 &quot;混入&quot; 多个方法，就生成多个混入类class MyClass extends Mixin1(Mixin2(MyBaseClass)) &#123; /* ... */&#125; // 这种写法的一个好处，是可以调用 super，因此可以避免在 &quot;混入&quot; 过程中覆盖父类的同名方法let Mixin1 = (superclass) =&gt; class extends superclass &#123; foo() &#123; console.log(&apos;foo from Mixin1&apos;); if (super.foo) super.foo(); &#125;&#125;;let Mixin2 = (superclass) =&gt; class extends superclass &#123; foo() &#123; console.log(&apos;foo from Mixin2&apos;); if (super.foo) super.foo(); &#125;&#125;;class S &#123; foo() &#123; console.log(&apos;foo from S&apos;); &#125;&#125;class C extends Mixin1(Mixin2(S)) &#123; foo() &#123; console.log(&apos;foo from C&apos;); super.foo(); &#125;&#125; // 每一次混入发生时，都调用了父类的 super.foo 方法，导致父类的同名方法没有被覆盖，行为被保留了下来new C().foo()// foo from C// foo from Mixin1// foo from Mixin2// foo from S 六、TraitTrait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。下面采用 traits-decorator 这个第三方模块作为例子，这个模块提供的 traits 修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 通过 traits 修饰器，在 MyClass 类上面 &quot;混入&quot; 了 TFoo 类的 foo 方法和 TBar 对象的 bar 方法import &#123; traits &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar // Trait 不允许 &quot;混入&quot; 同名方法import &#123; traits &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123; &#125;// 报错// throw new Error(&apos;Method named: &apos; + methodName + &apos; is defined twice.&apos;);// ^// Error: Method named: foo is defined twice. // 一种解决方法是排除 TBar 的 foo 方法import &#123; traits, excludes &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::excludes(&apos;foo&apos;)) // 使用绑定运算符（::）在 TBar 上排除 foo 方法class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar // 另一种方法是为 TBar 的 foo 方法起一个别名import &#123; traits, alias &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::alias(&#123;foo: &apos;aliasFoo&apos;&#125;))class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.aliasFoo() // fooobj.bar() // bar // alias 和 excludes 方法，可以结合起来使用（排除了 TExample 的 foo 方法和 bar 方法，为 baz 方法起了别名 exampleBaz）@traits(TExample::excludes(&apos;foo&apos;,&apos;bar&apos;)::alias(&#123;baz:&apos;exampleBaz&apos;&#125;))class MyClass &#123;&#125; // as 方法则为上面的代码提供了另一种写法@traits(TExample::as(&#123;excludes:[&apos;foo&apos;, &apos;bar&apos;], alias: &#123;baz: &apos;exampleBaz&apos;&#125;&#125;))class MyClass &#123;&#125; 七、Babel 转码器的支持123456789$ npm install babel-core babel-plugin-transform-decorators // 设置配置文件 .babelrc&#123; &quot;plugins&quot;: [&quot;transform-decorators&quot;]&#125; // 脚本中打开的命令如下babel.transform(&quot;code&quot;, &#123;plugins: [&quot;transform-decorators&quot;]&#125;) 目前，Babel 转码器已经支持 Decorator。首先安装 babel-core 和 babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0 之中，所以改为安装 babel-preset-stage-0 亦可。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"node 之 event-loop","slug":"node/event-loop","date":"2018-03-25T10:36:10.000Z","updated":"2018-04-19T08:47:54.000Z","comments":true,"path":"node/event-loop/","link":"","permalink":"http://blog.master-ss.cn/node/event-loop/","excerpt":"我们都知道 JavaScript 是单线程运行，异步操作特别重要。只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行，这就是事件循环。","text":"我们都知道 JavaScript 是单线程运行，异步操作特别重要。只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行，这就是事件循环。 一、定时器为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行：setTimeout、setInterval、setImmediate、process.nextTick。前两个是语言的标准，后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别。举个例子：12345678910111213// test.jssetTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))(); $ node test.js53412 二、同步任务和异步任务首先，同步任务总是比异步任务更早执行。前面的那段代码，只有最后一行是同步任务，因此最早执行。1(() =&gt; console.log(5))(); 三、本轮循环和次轮循环异步任务可以分成两种：追加在本轮循环的异步任务、追加在次轮循环的异步任务。所谓 “循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，本轮循环一定早于次轮循环执行即可。Node 规定，process.nextTick 和 Promise 的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而 setTimeout、setInterval、setImmediate 的回调函数，追加在次轮循环。这就是说，上段代码的第三行和第四行，一定比第一行和第二行更早执行。123456// 下面两行，次轮循环执行setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));// 下面两行，本轮循环执行process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); 四、process.nextTick()process.nextTick 这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。Node 执行完所有同步任务，接下来就会执行 process.nextTick 的任务队列。所以，下面这行代码是第二个输出结果。基本上，如果你希望异步任务尽可能快地执行，那就使用process.nextTick。1process.nextTick(() =&gt; console.log(3)); 五、微任务根据语言规定，Promise 对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。微任务队列追加在 process.nextTick 队列的后面，也属于本轮循环。所以，下面的代码总是先输出 3，再输出 4。1234567891011121314process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));// 3// 4 // 注意，只有前一个队列全部清空以后，才会执行下一个队列。代码中，全部 process.nextTick 的回调函数，执行都会早于 Promiseprocess.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));// 1// 3// 2// 4 至此，本轮循环的执行顺序就讲完了：同步任务 =&gt; process.nextTick() =&gt; 微任务 六、事件循环执行顺序Node 只有一个主线程，事件循环是在主线程上完成的。开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情：同步任务、发出异步请求、规划定时器生效的时间、执行 process.nextTick() 等等。最后，上面这些事情都干完了，事件循环就正式开始了。事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。每一轮的事件循环，分成六个阶段，这些阶段会依次执行：1234561、timers2、I/O callbacks3、idle, prepare4、poll5、check6、close callbacks 每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。简单介绍一下每个阶段的含义：（1）timers：这个是定时器阶段，处理 setTimeout() 和 setInterval() 的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。（2）I/O callbacks：除了举出的这些操作回调函数，其他的回调函数都在这个阶段执行：setTimeout() 和 setInterval() 的回调函数、setImmediate() 的回调函数、用于关闭请求的回调函数，比如 socket.on(‘close’, …)。（3）idle, prepare：该阶段只供 libuv 内部调用，这里可以忽略。（4）Poll：这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。（5）check：该阶段执行 setImmediate() 的回调函数。（6）close callbacks：该阶段执行关闭请求的回调函数，比如 socket.on(‘close’, …)。 七、事件循环示例1234567891011121314151617const fs = require(&apos;fs&apos;);const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile(&apos;test.js&apos;, () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行 fs.readFile 的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是 200 多毫秒。 八、setTimeout 和 setImmediate由于 setTimeout 在 timers 阶段执行，而 setImmediate 在 check 阶段执行。所以，setTimeout 会早于 setImmediate 完成。12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出 1，再输出 2，但是实际执行的时候，结果却是不确定，有时还会先输出 2，再输出 1。这是因为 setTimeout 的第二个参数默认为 0。但是实际上，Node 做不到 0 毫秒，最少也需要 1 毫秒，根据官方文档，第二个参数的取值范围在 1 毫秒到 2147483647 毫秒之间。也就是说，setTimeout(f, 0) 等同于setTimeout(f, 1)。实际执行的时候，进入事件循环以后，有可能到了 1 毫秒，也可能还没到 1 毫秒，取决于系统当时的状况。如果没到 1 毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行 setImmediate 的回调函数。但是，下面的代码一定是先输出 2，再输出 1。123456const fs = require(&apos;fs&apos;);fs.readFile(&apos;test.js&apos;, () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); 上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate 才会早于 setTimeout 执行。 九、综合实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const &#123; readFile, readFileSync &#125; = require(&apos;fs&apos;)const &#123; resolve &#125; = require(&apos;path&apos;)setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] immediate 回调1&apos;))setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] immediate 回调2&apos;))setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] immediate 回调3&apos;))Promise.resolve().then(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] promise 回调1&apos;) setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] promise 回调1 增加的immediate 回调4&apos;))&#125;)readFile(&apos;../package.json&apos;, &apos;utf-8&apos;, data =&gt; &#123; console.log(&apos;[阶段2....IO回调] 读文件回调1&apos;) readFile(&apos;../video.mp4&apos;, &apos;utf-8&apos;, data =&gt; &#123; console.log(&apos;[阶段2....IO回调] 读文件回调2&apos;) setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] 读文件回调2 增加的immediate 回调4&apos;)) &#125;) setImmediate(() =&gt; &#123; console.log(&apos;[阶段3.immediate] immediate 回调4&apos;) Promise.resolve().then(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] promise 回调2&apos;) process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] promise 回调2 增加的 nextTick 回调5&apos;)) &#125;).then(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] promise 回调3&apos;) &#125;) &#125;) setImmediate(() =&gt; &#123; console.log(&apos;[阶段3.immediate] immediate 回调6&apos;) process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] immediate 回调6 增加的 nextTick 回调7&apos;)) console.log(&apos;[...待切入下一阶段] 这块正在同步阻塞的读一个大文件&apos;); const video = readFileSync(resolve(__dirname, &apos;../video.mp4&apos;), &apos;utf-8&apos;) process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] immediate 回调6 增加的 nextTick 回调8&apos;)) readFile(&apos;../package.json&apos;, &apos;utf-8&apos;, () =&gt; &#123; console.log(&apos;[阶段2....IO回调] 读文件回调3&apos;) setImmediate(() =&gt; console.log(&apos;[阶段3.immediate] 读文件回调3 增加的immediate 回调6&apos;)) setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 读文件回调3 增加的定时器回调8&apos;), 0); &#125;) &#125;) process.nextTick(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] 读文件回调 1 增加的 nextTick 回调6&apos;) &#125;) setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 定时器 回调5&apos;), 0) setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 定时器 回调6&apos;), 0)&#125;)setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 定时器 回调1&apos;), 0)setTimeout(() =&gt; &#123; console.log(&apos;[阶段1....定时器] 定时器 回调2&apos;) process.nextTick(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] nextTick 回调5&apos;) &#125;)&#125;, 0)setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 定时器 回调3&apos;), 0)setTimeout(() =&gt; console.log(&apos;[阶段1....定时器] 定时器 回调4&apos;), 0)process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] nextTick 回调1&apos;))process.nextTick(() =&gt; &#123; console.log(&apos;[...待切入下一阶段] nextTick 回调2&apos;) process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] nextTick 回调4&apos;))&#125;)process.nextTick(() =&gt; console.log(&apos;[...待切入下一阶段] nextTick 回调3&apos;))$ node test/event-loop[...待切入下一阶段] nextTick 回调1[...待切入下一阶段] nextTick 回调2[...待切入下一阶段] nextTick 回调3[...待切入下一阶段] nextTick 回调4[...待切入下一阶段] promise 回调1[阶段1....定时器] 定时器 回调1[阶段1....定时器] 定时器 回调2[阶段1....定时器] 定时器 回调3[阶段1....定时器] 定时器 回调4[...待切入下一阶段] nextTick 回调5[阶段2....IO回调] 读文件回调1[...待切入下一阶段] 读文件回调 1 增加的 nextTick 回调6[阶段3.immediate] immediate 回调1[阶段3.immediate] immediate 回调2[阶段3.immediate] immediate 回调3[阶段3.immediate] promise 回调1 增加的immediate 回调4[阶段3.immediate] immediate 回调4[阶段3.immediate] immediate 回调6[...待切入下一阶段] 这块正在同步阻塞的读一个大文件[...待切入下一阶段] immediate 回调6 增加的 nextTick 回调7[...待切入下一阶段] immediate 回调6 增加的 nextTick 回调8[...待切入下一阶段] promise 回调2[...待切入下一阶段] promise 回调3[...待切入下一阶段] promise 回调2 增加的 nextTick 回调5[阶段1....定时器] 定时器 回调5[阶段1....定时器] 定时器 回调6[阶段2....IO回调] 读文件回调2[阶段2....IO回调] 读文件回调3[阶段3.immediate] 读文件回调2 增加的immediate 回调4[阶段3.immediate] 读文件回调3 增加的immediate 回调6[阶段1....定时器] 读文件回调3 增加的定时器回调8","categories":[{"name":"node","slug":"node","permalink":"http://blog.master-ss.cn/categories/node/"}],"tags":[]},{"title":"es6 之 Set & Map","slug":"es6/set&map","date":"2018-03-24T14:19:46.000Z","updated":"2018-04-22T13:57:03.000Z","comments":true,"path":"es6/set&map/","link":"","permalink":"http://blog.master-ss.cn/es6/set&map/","excerpt":"ES6 引入了新的数据结构 Set、WeakSet、Map 以及 WeakMap。","text":"ES6 引入了新的数据结构 Set、WeakSet、Map 以及 WeakMap。 一、SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// Set 本身是一个构造函数，用来生成 Set 数据结构const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i); // 2 3 5 4（结果表明 Set 结构不会添加重复的值）&#125; // Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化const set = new Set([1, 2, 3, 4, 4]); // 例一[...set] // [1, 2, 3, 4]const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); // 例二items.size // 5const set = new Set(document.querySelectorAll(&apos;div&apos;)); // 例三，接受类似数组的对象作为参数set.size // 56const set = new Set(); // 类似于document .querySelectorAll(&apos;div&apos;) .forEach(div =&gt; set.add(div));set.size // 56 // 可用于去除数组的重复成员[...new Set(array)] // 向 Set 加入值的时候，不会发生类型转换，所以 5 和 &quot;5&quot; 是两个不同的值let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125;（Set 内部判断两个值是否不同类似于精确相等运算符 ===，主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身） // 两个对象总是不相等的let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 // 原型属性：constructor、size；实例操作方法：add、delete、has、clear（清除所有成员，没有返回值）s.add(1).add(2).add(2); // 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false // Object 结构和 Set 结构在判断是否包括一个键上面的写法不相同const properties = &#123; // 对象的写法 &apos;width&apos;: 1, &apos;height&apos;: 1&#125;;if (properties[someName]) &#123; // do something&#125;const properties = new Set(); // Set的写法properties.add(&apos;width&apos;);properties.add(&apos;height&apos;);if (properties.has(someName)) &#123; // do something&#125; // Array.from 方法可以将 Set 结构转为数组const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); // 提供了去除数组重复成员的另一种方法function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] // Set 结构的遍历方法：keys、values、entrieslet set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item); // red green blue，由于 Set 结构没有键名，只有键值，所以 keys 方法和 values 方法的行为完全一致&#125;for (let item of set.values()) &#123; console.log(item); // red green blue&#125;for (let item of set.entries()) &#123; console.log(item); // [&quot;red&quot;, &quot;red&quot;] [&quot;green&quot;, &quot;green&quot;] [&quot;blue&quot;, &quot;blue&quot;]&#125; // Set 结构的遍历方法：forEach（参数与数组的 forEach 一致，依次为键值、键名、集合本身）set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value)) // 注意 Set 结构的键名就是键值，因此第一个参数与第二个参数的值永远都一样// 1 : 1// 4 : 4// 9 : 9 // Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法Set.prototype[Symbol.iterator] === Set.prototype.values // 可以省略 values 方法，直接用 for...of 循环遍历 Setlet set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x); // red green blue&#125; // 扩展运算符（...）内部使用 for...of 循环，所以也可以用于 Set 结构let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);let arr = [...set]; // [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;] // 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)]; // [3, 5, 2] // 数组的 map 和 filter 方法也可以间接用于 Setlet set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2)); // 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0)); // 返回Set结构：&#123;2, 4&#125; // 使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);let union = new Set([...a, ...b]); // Set &#123;1, 2, 3, 4&#125;，并集let intersect = new Set([...a].filter(x =&gt; b.has(x))); // set &#123;2, 3&#125;，交集let difference = new Set([...a].filter(x =&gt; !b.has(x))); // Set &#123;1&#125;，差集 // 没有直接改变原来 Set 结构的方法：利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；利用 Array.from 方法let set = new Set([1, 2, 3]); // 方法一set = new Set([...set].map(val =&gt; val * 2)); // set的值是2, 4, 6let set = new Set([1, 2, 3]); // 方法二set = new Set(Array.from(set, val =&gt; val * 2)); // set的值是2, 4, 6 二、SetWeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 的成员是不适合引用的，因为它会随时消失，取决于垃圾回收机制有没有运行，因此 ES6 规定 WeakSet 不可遍历。123456789101112131415161718192021222324252627282930313233343536373839404142434445// WeakSet 是一个构造函数，可以使用 new 命令，创建 WeakSet 数据结构const ws = new WeakSet(); // 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数const a = [[1, 2], [3, 4]];const ws = new WeakSet(a); // WeakSet &#123;[1, 2], [3, 4]&#125;（注意，是 a 数组的成员成为 WeakSet 的成员，而不是 a 数组本身） // WeakSet 的成员只能是对象，而不能是其他类型的值const ws = new WeakSet();ws.add(1) // TypeError: Invalid value used in weak setws.add(Symbol()) // TypeError: invalid value used in weak set // 注意，作为构造函数参数的数组，它的成员只能是对象const b = [3, 4];const ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) // WeakSet 原型方法：add、delete、hasconst ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false // WeakSet 没有 size 属性，没有办法遍历它的成员ws.size // undefinedws.forEach // undefinedws.forEach(function(item)&#123; console.log(&apos;WeakSet has &apos; + item)&#125;) // TypeError: undefined is not a function // WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏// 另外一个作用保证 Foo 的实例方法只能在 Foo 的实例上调用，好处是删除实例的时候不用考虑foos，也不会出现内存泄漏const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError(&apos;Foo.prototype.method 只能在Foo的实例上调用！&apos;); &#125; &#125;&#125; 三、MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键，这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是 “键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了 “字符串—值” 的对应，Map 结构提供了 “值—值” 的对应，是一种更完善的 Hash 结构实现。如果你需要 “键值对” 的数据结构，Map 比 Object 更合适。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252// 原意是将一个 DOM 节点作为对象 data 的键，但是由于对象只接受字符串作为键名，所以 element 被自动转为字符串 [object HTMLDivElement]const data = &#123;&#125;;const element = document.getElementById(&apos;myDiv&apos;);data[element] = &apos;metadata&apos;;data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot; // 使用 Map 结构的 set 方法，将对象 o 当作 m 的一个键，然后又使用 get 方法读取这个键，接着使用 delete 方法删除了这个键const m = new Map();const o = &#123;p: &apos;Hello World&apos;&#125;;m.set(o, &apos;content&apos;)m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false // 作为构造函数，Map 也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组const map = new Map([ [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]]);map.size // 2map.has(&apos;name&apos;) // truemap.get(&apos;name&apos;) // &quot;张三&quot;map.has(&apos;title&apos;) // truemap.get(&apos;title&apos;) // &quot;Author&quot; // Map 构造函数接受数组作为参数，实际上执行的是下面的算法const items = [ [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)); // 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数。这就是说，Set 和 Map 都可以用来生成新的 Mapconst set = new Set([ [&apos;foo&apos;, 1], [&apos;bar&apos;, 2]]);const m1 = new Map(set);m1.get(&apos;foo&apos;) // 1const m2 = new Map([[&apos;baz&apos;, 3]]);const m3 = new Map(m2);m3.get(&apos;baz&apos;) // 3 // 对同一个键多次赋值，后面的值将覆盖前面的值const map = new Map();map.set(1, &apos;aaa&apos;).set(1, &apos;bbb&apos;);map.get(1) // &quot;bbb&quot; // 读取一个未知的键返回 undefinednew Map().get(&apos;asfddfsasadf&apos;) // undefined // 只有对同一个对象的引用，Map 结构才将其视为同一个键const map = new Map();map.set([&apos;a&apos;], 555);map.get([&apos;a&apos;]) // undefined，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，而 Map 的键实际上是跟内存地址绑定的 // 同样的值的两个实例，在 Map 结构中被视为两个键const map = new Map();const k1 = [&apos;a&apos;];const k2 = [&apos;a&apos;];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 // 只要两个值严格相等，Map 将其视为一个键，undefined 和 null 也是两个不同的键。虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set(&apos;true&apos;, 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 // size 属性返回 Map 结构的成员总数const map = new Map();map.set(&apos;foo&apos;, true);map.set(&apos;bar&apos;, false);map.size // 2 // set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键const m = new Map();m.set(&apos;edition&apos;, 6) // 键是字符串m.set(262, &apos;standard&apos;) // 键是数值m.set(undefined, &apos;nah&apos;) // 键是 undefined // set 方法返回的是当前的 Map 对象，因此可以采用链式写法let map = new Map().set(1, &apos;a&apos;).set(2, &apos;b&apos;).set(3, &apos;c&apos;); // get 方法读取 key 对应的键值，如果找不到 key，返回 undefinedconst m = new Map();const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;m.set(hello, &apos;Hello ES6!&apos;) // 键是函数m.get(hello) // Hello ES6! // has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中const m = new Map();m.set(&apos;edition&apos;, 6);m.set(262, &apos;standard&apos;);m.set(undefined, &apos;nah&apos;);m.has(&apos;edition&apos;) // truem.has(&apos;years&apos;) // falsem.has(262) // truem.has(undefined) // true // delete 方法删除某个键，返回 true。如果删除失败，返回 falseconst m = new Map();m.set(undefined, &apos;nah&apos;);m.has(undefined) // truem.delete(undefined)m.has(undefined) // false // clear 方法清除所有成员，没有返回值let map = new Map();map.set(&apos;foo&apos;, true);map.set(&apos;bar&apos;, false);map.size // 2map.clear()map.size // 0 // Map 结构原生提供的三个遍历器生成函数：keys、values、entries，注意 Map 的遍历顺序就是插入顺序const map = new Map([ [&apos;F&apos;, &apos;no&apos;], [&apos;T&apos;, &apos;yes&apos;],]);for (let key of map.keys()) &#123; console.log(key); // &quot;F&quot; &quot;T&quot;&#125;for (let value of map.values()) &#123; console.log(value); // &quot;no&quot; &quot;yes&quot;&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;for (let [key, value] of map.entries()) &#123; // 或者 console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;for (let [key, value] of map) &#123; // 等同于使用 map.entries() console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; // Map 结构的默认遍历器接口（Symbol.iterator属性），就是 entries 方法map[Symbol.iterator] === map.entries // true // Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）const map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);[...map.keys()] // [1, 2, 3][...map.values()] // [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;][...map.entries()] // [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]][...map] // [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]] // 结合数组的 map 方法、filter 方法，可以实现 Map 的遍历和过滤（Map 本身没有 map 和 filter 方法）const map0 = new Map().set(1, &apos;a&apos;).set(2, &apos;b&apos;).set(3, &apos;c&apos;);const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3) // 产生 Map 结构 &#123;1 =&gt; &apos;a&apos;, 2 =&gt; &apos;b&apos;&#125;);const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, &apos;_&apos; + v]) // 产生 Map 结构 &#123;2 =&gt; &apos;_a&apos;, 4 =&gt; &apos;_b&apos;, 6 =&gt; &apos;_c&apos;&#125;); // Map 还有一个 forEach 方法，与数组的 forEach 方法类似，也可以实现遍历map.forEach(function(value, key, map) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;); // forEach 方法还可以接受第二个参数，用来绑定 thisconst reporter = &#123; report: function(key, value) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); // Map 转为数组，使用扩展运算符（...）const myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);[...myMap] // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ] // 将数组传入 Map 构造函数，就可以转为 Mapnew Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125; // 如果所有 Map 的键都是字符串，它可以无损地转为对象；如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToObj(myMap) // &#123; yes: true, no: false &#125; // 对象转为 Mapfunction objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;) // Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; // Map 的键名都是字符串，这时可以选择转为对象 JSONfunction strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap) // &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; // Map 的键名有非字符串，这时可以选择转为数组 JSONfunction mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap) // &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; // JSON 转为 Map，正常情况下，所有键名都是字符串function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;) // Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; // 特殊情况整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组，可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;) // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125; 四、WeakMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2 // WeakMap 也可以接受一个数组，作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, &apos;foo&apos;], [k2, &apos;bar&apos;]]);wm2.get(k2) // &quot;bar&quot; // WeakMap 只接受对象作为键名（null 除外）const map = new WeakMap();map.set(1, 2) // TypeError: 1 is not an object!map.set(Symbol(), 2) // TypeError: Invalid value used as weak map keymap.set(null, 2) // TypeError: Invalid value used as weak map key // 有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用const e1 = document.getElementById(&apos;foo&apos;);const e2 = document.getElementById(&apos;bar&apos;);const arr = [ [e1, &apos;foo 元素&apos;], [e2, &apos;bar 元素&apos;],]; arr [0] = null; // 不需要 e1 和 e2 的时候，必须手动删除引用arr [1] = null; // WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;);wm.set(element, &apos;some information&apos;);wm.get(element) // &quot;some information&quot;，当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除 // WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key) // Object &#123;foo: 1&#125; // WeakMap 没有遍历操作，也没有 size 属性，而且无法清空，即不支持 clear 方法。因此 WeakMap 只有四个方法可用：get()、set()、has()、delete()const wm = new WeakMap();wm.size // undefinedwm.forEach // undefinedwm.clear // undefined // WeakMap 应用的典型场合就是 DOM 节点作为键名let myElement = document.getElementById(&apos;logo&apos;);let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener(&apos;click&apos;, function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); // WeakMap 的另一个用处是部署私有属性const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log(&apos;DONE&apos;));c.dec()c.dec() // DONE WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。不过 WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名，而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 Symbol","slug":"es6/symbol","date":"2018-03-22T08:27:10.000Z","updated":"2018-04-22T14:07:32.000Z","comments":true,"path":"es6/symbol/","link":"","permalink":"http://blog.master-ss.cn/es6/symbol/","excerpt":"ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。","text":"ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 一、简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546let s = Symbol();typeof s // &quot;symbol&quot; new Symbol() // Symbol is not a constructor（生成的 Symbol 是一个原始类型的值，不是对象） // 接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分let s1 = Symbol(&apos;foo&apos;);s1 // Symbol(foo)s1.toString() // &quot;Symbol(foo)&quot; // 如果 Symbol 的参数是一个对象，调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值const obj = &#123; toString() &#123; return &apos;abc&apos;; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) // Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的let s1 = Symbol(); // 没有参数的情况let s2 = Symbol();s1 === s2 // falselet s1 = Symbol(&apos;foo&apos;); // 有参数的情况let s2 = Symbol(&apos;foo&apos;);s1 === s2 // false // Symbol 值不能与其他类型的值进行运算，会报错let sym = Symbol(&apos;My symbol&apos;);&quot;your symbol is &quot; + sym // TypeError: can&apos;t convert symbol to string`your symbol is $&#123;sym&#125;` // TypeError: can&apos;t convert symbol to string // Symbol 值可以显式转为字符串let sym = Symbol(&apos;My symbol&apos;);String(sym) // &apos;Symbol(My symbol)&apos;sym.toString() // &apos;Symbol(My symbol)&apos; // Symbol 值也可以转为布尔值，但是不能转为数值let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 二、作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let mySymbol = Symbol(); // 第一种写法let a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;; // 第二种写法let a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;; // 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;); // 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; // Symbol 值作为对象属性名时，不能用点运算符，因为点运算符后面总是字符串const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = &apos;Hello!&apos;;a[mySymbol] // undefineda[&apos;mySymbol&apos;] // &quot;Hello!&quot; // 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125; // 如果 s 不放在方括号中，该属性的键名就是字符串 s&#125;;obj[s](123); // 采用增强的对象写法，上面代码的 obj 对象可以写得更简洁一些let obj = &#123; [s](arg) &#123; ... &#125;&#125;; // Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的log.levels = &#123; DEBUG: Symbol(&apos;debug&apos;), INFO: Symbol(&apos;info&apos;), WARN: Symbol(&apos;warn&apos;)&#125;;log(log.levels.DEBUG, &apos;debug message&apos;);log(log.levels.INFO, &apos;info message&apos;); // 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性 三、实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。12345678910111213141516171819202122232425262728293031function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case &apos;Triangle&apos;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea(&apos;Triangle&apos;, &#123; width: 100, height: 100 &#125;); // 魔术字符串 // 常用的消除魔术字符串的方法，就是把它写成一个变量，这样就消除了强耦合const shapeType = &#123; triangle: &apos;Triangle&apos;&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); // shapeType.triangle 等于哪个值并不重要，只要确保不会跟其他 shapeType 属性的值冲突即可。因此，这里就很适合改用 Symbol 值const shapeType = &#123; triangle: Symbol()&#125;; 四、属性名的遍历Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const obj = &#123;&#125;;let a = Symbol(&apos;a&apos;);let b = Symbol(&apos;b&apos;);obj[a] = &apos;Hello&apos;;obj[b] = &apos;World&apos;;const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols // [Symbol(a), Symbol(b)] // Object.getOwnPropertySymbols 方法与 for...in 循环、Object.getOwnPropertyNames 方法进行对比的例子const obj = &#123;&#125;;let foo = Symbol(&quot;foo&quot;);Object.defineProperty(obj, foo, &#123; value: &quot;foobar&quot;,&#125;);for (let i in obj) &#123; console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj) // []Object.getOwnPropertySymbols(obj) // [Symbol(foo)] // Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj) // [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] // 可以利用 Symbol 为对象定义一些非私有的、但又希望只用于内部的方法let size = Symbol(&apos;size&apos;);class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add(&apos;foo&apos;);Collection.sizeOf(x) // 1Object.keys(x) // [&apos;0&apos;]Object.getOwnPropertyNames(x) // [&apos;0&apos;]Object.getOwnPropertySymbols(x) // [Symbol(size)] 五、Symbol.for() &amp; Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。12345678910111213141516171819let s1 = Symbol.for(&apos;foo&apos;);let s2 = Symbol.for(&apos;foo&apos;);s1 === s2 // true，都是同样参数的 Symbol.for 方法生成的，所以实际上是同一个值 // Symbol.for 会被登记在全局环境中供搜索，Symbol 不会Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;) // true，多次调用返回相同的 Symbol 值Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;) // false，每次调用返回不同的 Symbol 值 // Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的keylet s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined // Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值iframe = document.createElement(&apos;iframe&apos;);iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for(&apos;foo&apos;) === Symbol.for(&apos;foo&apos;) // true 六、实例：模块的 Singleton 模式Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？很容易想到，可以把实例放到顶层对象 global。12345678910111213141516171819202122232425262728293031323334353637// mod.jsfunction A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo; // 加载上面的 mod.jsconst a = require(&apos;./mod.js&apos;);console.log(a.foo); // 这里有一个问题，全局变量 global._foo 是可写的，任何文件都可以修改global._foo = &#123; foo: &apos;world&apos; &#125;; // 会使得加载 mod.js 的脚本都失真const a = require(&apos;./mod.js&apos;);console.log(a.foo); // 可以使用 Symbol 防止这种情况出现，可以保证 global[FOO_KEY] 不会被无意间覆盖const FOO_KEY = Symbol.for(&apos;foo&apos;); // mod.jsfunction A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; // 但还是可以被改写global[Symbol.for(&apos;foo&apos;)] = &#123; foo: &apos;world&apos; &#125;;const a = require(&apos;./mod.js&apos;); // 如果键名使用 Symbol方法 生成，那么外部将无法引用这个值，当然也就无法改写const FOO_KEY = Symbol(&apos;foo&apos;); // mod.js// 后面代码相同 ……// 但这样也有一个问题，如果多次执行这个脚本，每次得到的 FOO_KEY 都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同// 一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠 七、内置的 Symbol 值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246// 对象的 Symbol.hasInstance 属性，指向一个内部方法。当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法。比如，// foo instanceof Foo 在语言内部，实际调用的是 Foo[Symbol.hasInstance](foo)class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass() // true，Symbol.hasInstance 在进行 instanceof 运算时自动调用，判断左侧的运算子是否为 Array 的实例 // Symbol 另一个例子class Even &#123; static [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125;const Even = &#123; // 等同于 [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125;;1 instanceof Even // false2 instanceof Even // true12345 instanceof Even // false // 对象的 Symbol.isConcatSpreadable 属性等于一个布尔值，表示该对象用于 Array.prototype.concat() 时，是否可以展开let arr1 = [&apos;c&apos;, &apos;d&apos;];[&apos;a&apos;, &apos;b&apos;].concat(arr1, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]arr1[Symbol.isConcatSpreadable] // undefined，数组的默认行为是可以展开，Symbol.isConcatSpreadable 默认等于 undefined。该属性等于 true 时，也有展开的效果let arr2 = [&apos;c&apos;, &apos;d&apos;];arr2[Symbol.isConcatSpreadable] = false;[&apos;a&apos;, &apos;b&apos;].concat(arr2, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, [&apos;c&apos;,&apos;d&apos;], &apos;e&apos;] // 类似数组的对象正好相反，默认不展开。它的 Symbol.isConcatSpreadable 属性设为true，才可以展开let obj = &#123;length: 2, 0: &apos;c&apos;, 1: &apos;d&apos;&#125;;[&apos;a&apos;, &apos;b&apos;].concat(obj, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, obj, &apos;e&apos;]obj[Symbol.isConcatSpreadable] = true;[&apos;a&apos;, &apos;b&apos;].concat(obj, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] // Symbol.isConcatSpreadable 属性也可以定义在类里面class A1 extends Array &#123; constructor(args) &#123; super(args); this[Symbol.isConcatSpreadable] = true; &#125;&#125;class A2 extends Array &#123; constructor(args) &#123; super(args); &#125; get [Symbol.isConcatSpreadable] () &#123; // 注意 Symbol.isConcatSpreadable 的位置差异，A1 是定义在实例上，A2 是定义在类本身，效果相同 return false; &#125;&#125;let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2) // [1, 2, 3, 4, [5, 6]] // 对象的 Symbol.species 属性，指向一个构造函数。创建衍生对象时，会使用该属性class MyArray extends Array &#123;&#125;const a = new MyArray(1, 2, 3);const b = a.map(x =&gt; x); // b 和 c 是 a 的衍生对象，虽然是调用数组方法生成的，但实际上它们也是 MyArray 的实例const c = a.filter(x =&gt; x &gt; 1);b instanceof MyArray // truec instanceof MyArray // true // Symbol.species 属性就是为了解决这个问题而提供的class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125; // 定义了 Symbol.species 属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数&#125; // 默认的 Symbol.species 属性等同于下面的写法static get [Symbol.species]() &#123; return this;&#125; // 现在衍生对象就不是 MyArray 的实例，而直接就是 Array 的实例class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true // Symbol.species 的另一个例子class T1 extends Promise &#123;&#125;class T2 extends Promise &#123; static get [Symbol.species]() &#123; return Promise; &#125;&#125;new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // true，T1 调用的是自身的构造方法new T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false，T2 调用的是 Promise 的构造方法 // 对象的 Symbol.match 属性，指向一个函数。当执行 str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值String.prototype.match(regexp)regexp[Symbol.match](this) // 等同于class MyMatcher &#123; [Symbol.match](string) &#123; return &apos;hello world&apos;.indexOf(string); &#125;&#125;&apos;e&apos;.match(new MyMatcher()) // 1 // 对象的 Symbol.replace 属性，指向一个方法，当该对象被 String.prototype.replace 方法调用时，会返回该方法的返回值String.prototype.replace(searchValue, replaceValue) // 第一个参数是 replace 方法正在作用的对象，第二个参数是替换后的值searchValue[Symbol.replace](this, replaceValue) // 等同于const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&apos;Hello&apos;.replace(x, &apos;World&apos;) // [&quot;Hello&quot;, &quot;World&quot;] // 对象的 Symbol.search 属性，指向一个方法，当该对象被 String.prototype.search 方法调用时，会返回该方法的返回值String.prototype.search(regexp)regexp[Symbol.search](this) // 等同于class MySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;&apos;foobar&apos;.search(new MySearch(&apos;foo&apos;)) // 0 // 对象的 Symbol.split 属性，指向一个方法，当该对象被 String.prototype.split 方法调用时，会返回该方法的返回值String.prototype.split(separator, limit)separator[Symbol.split](this, limit) // 等同于class MySplitter &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.split](string) &#123; // 重新定义了字符串对象的 split 方法的行为 let index = string.indexOf(this.value); if (index === -1) &#123; return string; &#125; return [ string.substr(0, index), string.substr(index + this.value.length) ]; &#125;&#125;&apos;foobar&apos;.split(new MySplitter(&apos;foo&apos;)) // [&apos;&apos;, &apos;bar&apos;]&apos;foobar&apos;.split(new MySplitter(&apos;bar&apos;)) // [&apos;foo&apos;, &apos;&apos;]&apos;foobar&apos;.split(new MySplitter(&apos;baz&apos;)) // &apos;foobar&apos; // 对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法const myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] // 对象的 Symbol.toPrimitive 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。// Symbol.toPrimitive 被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。// Number：该场合需要转成数值；String：该场合需要转成字符串；Default：该场合可以转成数值，也可以转成字符串let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case &apos;number&apos;: return 123; case &apos;string&apos;: return &apos;str&apos;; case &apos;default&apos;: return &apos;default&apos;; default: throw new Error(); &#125; &#125;&#125;;2 * obj // 2463 + obj // &apos;3default&apos;obj == &apos;default&apos; // trueString(obj) // &apos;str&apos; // 对象的 Symbol.toStringTag 属性，指向一个方法。在该对象上面调用 Object.prototype.toString 方法时，如果这个属性存在，它的返回值会出// 现在 toString 方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制 [object Object] 或 [object Array] 中 object 后面的那个字符串(&#123;[Symbol.toStringTag]: &apos;Foo&apos;&#125;.toString()) // &quot;[object Foo]&quot;class Collection &#123; get [Symbol.toStringTag]() &#123; return &apos;xxx&apos;; &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot; // ES6 新增内置对象的 Symbol.toStringTag 属性值如下// JSON[Symbol.toStringTag]：&apos;JSON&apos;// Math[Symbol.toStringTag]：&apos;Math&apos;// Module 对象M[Symbol.toStringTag]：&apos;Module&apos;// ArrayBuffer.prototype[Symbol.toStringTag]：&apos;ArrayBuffer&apos;// DataView.prototype[Symbol.toStringTag]：&apos;DataView&apos;// Map.prototype[Symbol.toStringTag]：&apos;Map&apos;// Promise.prototype[Symbol.toStringTag]：&apos;Promise&apos;// Set.prototype[Symbol.toStringTag]：&apos;Set&apos;// %TypedArray%.prototype[Symbol.toStringTag]：&apos;Uint8Array&apos;等// WeakMap.prototype[Symbol.toStringTag]：&apos;WeakMap&apos;// WeakSet.prototype[Symbol.toStringTag]：&apos;WeakSet&apos;// %MapIteratorPrototype%[Symbol.toStringTag]：&apos;Map Iterator&apos;// %SetIteratorPrototype%[Symbol.toStringTag]：&apos;Set Iterator&apos;// %StringIteratorPrototype%[Symbol.toStringTag]：&apos;String Iterator&apos;// Symbol.prototype[Symbol.toStringTag]：&apos;Symbol&apos;// Generator.prototype[Symbol.toStringTag]：&apos;Generator&apos;// GeneratorFunction.prototype[Symbol.toStringTag]：&apos;GeneratorFunction&apos; // 对象的 Symbol.unscopables 属性，指向一个对象。该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除Array.prototype[Symbol.unscopables]// &#123;// copyWithin: true,// entries: true,// fill: true,// find: true,// findIndex: true,// includes: true,// keys: true// &#125;Object.keys(Array.prototype[Symbol.unscopables]) // [&apos;copyWithin&apos;, &apos;entries&apos;, &apos;fill&apos;, &apos;find&apos;, &apos;findIndex&apos;, &apos;includes&apos;, &apos;keys&apos;] // 没有 unscopables 时class MyClass &#123; foo() &#123; return 1; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123; foo(); // 1&#125; // 有 unscopables 时，指定 Symbol.unscopables 属性，使得 with 语法块不会在当前作用域寻找 foo 属性，即 foo 将指向外层作用域的变量class MyClass &#123; foo() &#123; return 1; &#125; get [Symbol.unscopables]() &#123; return &#123; foo: true &#125;; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123; foo(); // 2&#125; 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法，如上。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 class 继承","slug":"es6/class-inherit","date":"2018-03-12T03:17:19.000Z","updated":"2018-04-22T13:06:43.000Z","comments":true,"path":"es6/class-inherit/","link":"","permalink":"http://blog.master-ss.cn/es6/class-inherit/","excerpt":"Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","text":"Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 一、简介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 通过 extends 关键字继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; // constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的 constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的 toString() &#125;&#125; // 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; // 子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工 &#125;&#125;let cp = new ColorPoint(); // ReferenceError，如果不调用 super 方法，子类就得不到 this 对象// ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质// 是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。 // 如果子类没有定义 constructor 方法，这个方法会被默认添加class ColorPoint extends Point &#123;&#125;class ColorPoint extends Point &#123; // 等同于（不管有没有显式定义，任何一个子类都有 constructor 方法） constructor(...args) &#123; super(...args); &#125;&#125; // 在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); // 子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例 this.color = color; // 正确 &#125;&#125; // 生成子类实例（与 ES5 的行为完全一致）let cp = new ColorPoint(25, 8, &apos;green&apos;);cp instanceof ColorPoint // truecp instanceof Point // true // 父类的静态方法也会被子类继承class A &#123; static hello() &#123; // hello() 是 A 类的静态方法，B 继承 A，也继承了 A 的静态方法 console.log(&apos;hello world&apos;); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world 二、Object.getPrototypeOf() &amp; super 关键字Object.getPrototypeOf 方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个类。super 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// 从子类上获取父类Object.getPrototypeOf(ColorPoint) === Point // true // super 作为函数调用时，代表父类的构造函数（super 虽然代表了父类的构造函数，但是返回的是子类的实例，即 super 内部的 this 指的是子类）class A &#123;&#125;class B extends A &#123; constructor() &#123; // ES6 要求，子类的构造函数必须执行一次 super 函数 super(); // super() 在这里相当于 A.prototype.constructor.call(this) &#125;&#125; // new.target 指向当前正在执行的函数（在 super() 执行时，它指向的是子类 B 的构造函数，而不是父类 A 的构造函数）class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B // 作为函数时，super() 只能用在子类的构造函数之中，用在其他地方就会报错class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; // super 作为对象时，在普通方法中指向父类的原型对象class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2，将 super 当作一个对象使用。这时，super 在普通方法之中，指向 A.prototype，所以 super.p() 就相当于 A.prototype.p() &#125;&#125;let b = new B(); // 由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; // p 是父类 A 实例的属性，super.p 就引用不到它 &#125;&#125;let b = new B();b.m // undefined // 如果属性定义在父类的原型对象上，super 就可以取到class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2，属性 x 是定义在 A.prototype 上面的，所以 super.x 可以取到它的值 &#125;&#125;let b = new B(); // ES6 规定，通过 super 调用父类的方法时，方法内部的 this 指向子类class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); // 实际上执行的是 super.print.call(this) &#125;&#125;let b = new B();b.m() // 2 // 由于 this 指向子类，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; // super.x 赋值为 3，这时等同于对 this.x 赋值为3 console.log(super.x); // undefined，当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); // 如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象class Parent &#123; static myMethod(msg) &#123; console.log(&apos;static&apos;, msg); &#125; myMethod(msg) &#123; console.log(&apos;instance&apos;, msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1，super 在静态方法之中指向父类var child = new Child();child.myMethod(2); // instance 2，super 在普通方法之中指向父类的原型对象 // 使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); // 报错，无法看出是作为函数使用还是作为对象使用 &#125;&#125; // 如果能清晰地表明 super 的数据类型，就不会报错（super.valueOf() 表明 super 是一个对象，因此就不会报错）class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); // true，由于 super 使得 this 指向 B，所以 super.valueOf() 返回的是一个 B 的实例 &#125;&#125;let b = new B(); // 由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字var obj = &#123; toString() &#123; return &quot;MyObject: &quot; + super.toString(); &#125;&#125;;obj.toString(); // MyObject: [object Object] 三、类的 prototype 属性 &amp; __proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有 __proto__ 属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class A &#123;&#125;class B extends A &#123;&#125;// 子类的 __proto__ 属性，表示构造函数的继承，总是指向父类B.__proto__ === A // true// 子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性B.prototype.__proto__ === A.prototype // true // 类的继承是按照下面的模式实现的class A &#123;&#125;class B &#123;&#125;Object.setPrototypeOf(B.prototype, A.prototype); // B 的实例继承 A 的实例Object.setPrototypeOf(B, A); // B 继承 A 的静态属性const b = new B();Object.setPrototypeOf = function (obj, proto) &#123; // Object.setPrototypeOf 方法的模拟实现 obj.__proto__ = proto; return obj;&#125; // 因此，就得到了上面的结果Object.setPrototypeOf(B.prototype, A.prototype);B.prototype.__proto__ = A.prototype; // 等同于Object.setPrototypeOf(B, A);B.__proto__ = A; // 等同于 // 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__ 属性）是父类（A）；作为一个构造函数，子类（B）的原型对象//（prototype 属性）是父类的原型对象（prototype 属性）的实例。Object.create(A.prototype);B.prototype.__proto__ = A.prototype; // 等同于 // extends 关键字后面可以跟多种类型的值class B extends A &#123; // 只要 A 是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数&#125; // 特殊情况一：子类继承 Object 类（子类其实就是构造函数 Object 的复制，子类的实例就是 Object 的实例）class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true // 特殊情况二：不存在任何继承class A &#123;&#125;A.__proto__ === Function.prototype // true，A 作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承 Function.prototypeA.prototype.__proto__ === Object.prototype // true，A 调用后返回一个空对象（即 Object 实例），所以 A.prototype.__proto__ 指向构造函数（Object）的 prototype 属性 // 特殊情况三：子类继承 nullclass A extends null &#123;&#125;A.__proto__ === Function.prototype // true，A 也是一个普通函数，所以直接继承 Function.prototypeA.prototype.__proto__ === undefined // true，A 调用后返回的对象不继承任何方法，所以它的 prototype.__proto__ 指向 undefinedclass C extends null &#123; // 实质上等同于 constructor() &#123; return Object.create(null); &#125;&#125; // 子类实例的 __proto__ 属性的 __proto__ 属性，指向父类实例的 __proto__ 属性。也就是说，子类的原型的原型，是父类的原型var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, &apos;red&apos;);p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true // 因此，通过子类实例的 __proto__.__proto__ 属性，可以修改父类实例的行为p2.__proto__.__proto__.printName = function () &#123; console.log(&apos;Ha&apos;);&#125;;p1.printName() // &quot;Ha&quot; 四、原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()。以前这些原生构造函数是无法继承的，比如，不能自己定义一个 Array 的子类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 定义了一个继承 Array 的 MyArray 类function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;); // 但是这个类的行为与 Array 完全不一致var colors = new MyArray();colors[0] = &quot;red&quot;;colors.length // 0colors.length = 0;colors[0] // &quot;red&quot;// 子类无法获得原生构造函数的内部属性，通过 Array.apply() 或者分配给原型对象都不行。原生构造函数会忽略 apply 方法传入的 this，也就是说，// 原生构造函数的 this 无法绑定，导致拿不到内部属性。ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法// 获取，导致无法继承原生的构造函数。比如，Array 构造函数有一个内部属性 [[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这// 个内部属性无法在子类获取，导致子类的 length 属性行为不正常。 // 让一个普通对象继承 Error 对象，但是 Error.call() 完全忽略传入的第一个参数，而是返回一个新对象，e 本身没有任何变化。这证明了 Error.call(e) 这种写法，无法继承原生构造函数var e = &#123;&#125;;Object.getOwnPropertyNames(Error.call(e)) // [ &apos;stack&apos; ]Object.getOwnPropertyNames(e) // [] // ES6 允许继承原生构造函数定义子类，比如：继承 Arrayclass MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined// ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。// 这意味着，ES6 可以自定义原生数据结构（比如 Array、String 等）的子类，这是 ES5 无法做到的。 // 可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3); x // [1, 2, 3]x.history // [[], [1, 2]]x.revert(); x // [1, 2] // 自定义 Error 子类，可以用来定制报错时的行为class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError(&apos;ll&apos;);myerror.message // &quot;ll&quot;myerror instanceof Error // truemyerror.name // &quot;MyError&quot;myerror.stack// Error// at MyError.ExtendableError// ... // 继承 Object 的子类，有一个行为差异（ES6 改变了 Object 构造函数的行为，一旦发现 Object 方法不是通过 new Object() 这种形式调用，ES6 规定 Object 构造函数会忽略参数）class NewObj extends Object&#123; constructor()&#123; super(...arguments); // NewObj 继承了 Object，但是无法通过 super 方法向父类 Object 传参 &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);o.attr === true // false 五、Mixin 模式的实现12345678910111213141516171819202122232425262728293031323334// c 对象是 a 对象和 b 对象的合成，具有两者的接口const a = &#123; a: &apos;a&apos;&#125;;const b = &#123; b: &apos;b&apos;&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125; // 将多个类的接口 &quot;混入&quot;（mix in）另一个类function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; // 上面代码的 mix 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125; Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如上。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 class","slug":"es6/class","date":"2018-03-12T01:35:38.000Z","updated":"2018-04-22T13:11:29.000Z","comments":true,"path":"es6/class/","link":"","permalink":"http://blog.master-ss.cn/es6/class/","excerpt":"JavaScript 语言中，生成实例对象的传统方法是通过构造函数。这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板，通过 class 关键字可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。","text":"JavaScript 语言中，生成实例对象的传统方法是通过构造函数。这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板，通过 class 关键字可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 一、简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 传统方法function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2); // ES6 类class Point &#123; constructor(x, y) &#123; // ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法 this.x = x; // this 关键字则代表实例对象 this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; // ES6 的类完全可以看作构造函数的另一种写法typeof Point // &quot;function&quot;，类的数据类型就是函数Point === Point.prototype.constructor // true，类本身就指向构造函数 // 使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致class Bar &#123; doStuff() &#123; console.log(&apos;stuff&apos;); &#125;&#125;var b = new Bar();b.doStuff() // &quot;stuff&quot; // 类的所有方法都定义在类的 prototype 属性上面class Point &#123; constructor() &#123; // 构造函数的 prototype 属性，在 ES6 的 &quot;类&quot; 上面继续存在 // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;Point.prototype = &#123; // 等同于 constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; // 在类的实例上面调用方法，其实就是调用原型上的方法class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true // 类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; // Object.assign 方法可以很方便地一次向类添加多个方法 toString()&#123;&#125;, toValue()&#123;&#125;&#125;); // prototype 对象的 constructor 属性，直接指向 &quot;类&quot; 的本身，这与 ES5 的行为是一致的Point.prototype.constructor === Point // true // 类的内部所有定义的方法都是不可枚举的class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype) // []Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;] // 采用 ES5 的写法，toString 方法就是可枚举的var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype) // [&quot;toString&quot;]Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;] // 类的属性名，可以采用表达式let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; // 类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。// 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 二、constructor 方法constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。1234567891011121314151617181920212223// 默认添加空的 constructor 方法class Point &#123;&#125;class Point &#123; // 等同于 constructor() &#123;&#125;&#125; // constructor 方法默认返回实例对象（即 this），完全可以指定返回另外一个对象class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo // false，返回一个全新的对象，结果导致实例对象不是 Foo 类的实例 // 类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo() // TypeError: Class constructor Foo cannot be invoked without &apos;new&apos; 三、类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上 new，像函数那样调用 Class，将会报错。12345678910111213141516171819202122232425262728293031323334353637// 类必须使用 new 调用class Point &#123; // ...&#125;var point = Point(2, 3); // 报错var point = new Point(2, 3); // 正确 // 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）class Point &#123; //定义类 constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true // 与 ES5 一样，类的所有实例共享一个原型对象var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__; //true // 可以通过实例的 __proto__ 属性为 &quot;类&quot;添加方法（__proto__ 各大厂商具体实现时添加的私有属性，并不是语言本身的特性，推荐使用 Object.getPrototypeOf）var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot; 四、Class 表达式 &amp; 不存在变量提升12345678910111213141516171819202122232425262728293031323334353637// 与函数一样，类也可以使用表达式的形式定义const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; // 这个类的名字是 MyClass 而不是 Me，Me 只在 Class 的内部代码可用，指代当前类let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined // 如果类的内部没用到的话，可以省略 Me，也就是可以写成下面的形式const MyClass = class &#123; /* ... */ &#125;; // 采用 Class 表达式，可以写出立即执行的 Classlet person = new class &#123; // person 是一个立即执行的类的实例 constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);person.sayName(); // &quot;张三&quot; // 类不存在变量提升（hoist），这一点与 ES5 完全不同new Foo(); // ReferenceErrorclass Foo &#123;&#125; // 这种规定的原因与继承有关，必须保证子类在父类之后定义&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; // 如果存在 class 的提升，上面代码就会报错，因为 class 会被提升到代码头部，而 let 命令是不提升的，所以导致 Bar 继承 Foo 的时候，Foo 还没有定义 &#125;&#125; 五、私有方法和私有属性私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为 class 加了私有属性。方法是在属性名之前，使用 # 表示。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 在命名上加以区别class Widget &#123; foo (baz) &#123; // 公有方法 this._bar(baz); &#125; _bar(baz) &#123; // 私有方法，前面的下划线表示这是一个只限于内部使用的私有方法，但是不保险，外部还是可以调用到这个方法 return this.snaf = baz; &#125; // ...&#125; // 将私有方法移出模块class Widget &#123; foo (baz) &#123; // foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法 bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; // 利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值const bar = Symbol(&apos;bar&apos;);const snaf = Symbol(&apos;snaf&apos;);export default class myClass&#123; foo(baz) &#123; // 公有方法 this[bar](baz); &#125; [bar](baz) &#123; // 私有方法，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果 return this[snaf] = baz; &#125; // ...&#125;; // #x 就表示私有属性 x，私有属性与实例的属性是可以同名的class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125;&#125; // 私有属性可以指定初始值，在构造函数执行时进行初始化class Point &#123; #x = 0; // 因为 JavaScript 是一门动态语言，所以没有采用private关键字；@ 已经被留给了 Decorator；所以采用 # constructor() &#123; #x; // 0 &#125;&#125; // 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法class Foo &#123; #a; #b; #sum() &#123; return #a + #b; &#125; // 私有方法 printSum() &#123; console.log(#sum()); &#125; constructor(a, b) &#123; #a = a; #b = b; &#125;&#125; // 私有属性也可以设置 getter 和 setter 方法class Counter &#123; #xValue = 0; get #x() &#123; return #xValue; &#125; // #x 是一个私有属性，它的读写都通过 get #x() 和 set #x() 来完成 set #x(value) &#123; this.#xValue = value; &#125; constructor() &#123; super(); // ... &#125;&#125; 六、this 的指向 &amp; name 属性类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括 name 属性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 单独提取 printName 出来单独使用，this 会指向该方法运行时所在的环境，因为找不到 print 方法而导致报错class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); // printName 方法中的 this，默认指向 Logger 类的实例 &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &apos;print&apos; of undefined // 解决方法一：在构造方法中绑定 thisclass Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; // 解决方法二：使用箭头函数（函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象）class Logger &#123; constructor() &#123; this.printName = (name = &apos;there&apos;) =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; // 解决方法三：使用 Proxy，获取方法的时候自动绑定 thisfunction selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== &apos;function&apos;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); // name 属性总是返回紧跟在 class 关键字后面的类名class Point &#123;&#125;Point.name // &quot;Point&quot; 七、Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。123456789101112131415161718192021222324252627282930313233// prop 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125;let inst = new MyClass();inst.prop = 123; // setter: 123inst.prop // &apos;getter&apos; // 存值函数和取值函数是设置在属性的 Descriptor 对象上的class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( // 存值函数和取值函数是定义在 html 属性的描述对象上面，这与 ES5 完全一致 CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor // true&quot;set&quot; in descriptor // true 八、Class 的 Generator 方法 &amp; 静态方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为 “静态方法”。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Symbol.iterator 方法前有一个星号，表示该方法是一个 Generator 函数class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; // Symbol.iterator 方法返回一个 Foo 类的默认遍历器，for...of 循环会自动调用这个遍历器 console.log(x); // hello，world&#125; // 如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法class Foo &#123; static classMethod() &#123; // Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo类上调用 return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod(); // TypeError: foo.classMethod is not a function // 如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log(&apos;hello&apos;); // this 指的是 Foo 类，而不是 Foo 的实例，等同于调用 Foo.baz &#125; baz () &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello // 父类的静态方法可以被子类继承class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &apos;hello&apos; // 静态方法也是可以从 super 对象上调用的class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125;&#125;Bar.classMethod() // &quot;hello, too&quot; 九、Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 为 Foo 类定义了一个静态属性 prop（目前只有这种写法可行）class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 // 因为 ES6 明确规定 Class 内部只有静态方法，没有静态属性（以下两种写法都无效）class Foo &#123; prop: 2 // 写法一 static prop: 2 // 写法二&#125;Foo.prop // undefined // 提案：类的实例属性class MyClass &#123; myProp = 42; // 类的实例属性可以用等式，写入类的定义之中 constructor() &#123; console.log(this.myProp); // 42 &#125;&#125; // 以前我们定义实例属性，只能写在类的 constructor 方法里面class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; // 提案：有了新的写法以后，可以不在 constructor 方法里面定义，写法比以前更清晰class ReactCounter extends React.Component &#123; state = &#123; count: 0 &#125;;&#125; // 提案：为了可读性的目的，对于那些在 constructor 里面已经定义的实例属性，新写法允许直接列出class ReactCounter extends React.Component &#123; state; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; // 提案：类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; // 提案：新写法大大方便了静态属性的表达class Foo &#123; // 老写法，静态属性定义在类的外部，这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则 // ...&#125;Foo.prop = 1;class Foo &#123; // 新写法，显式声明，而不是赋值处理，语义更好 static prop = 1;&#125; 十、new.target 属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 确保构造函数只能通过 new 命令调用function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;function Person(name) &#123; // 另一种写法 if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 // Class 内部调用 new.target，返回当前 Classclass Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true // 子类继承父类时，new.target 会返回子类class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false，new.target 会返回子类 // 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类（注意在函数外部，使用 new.target 会报错）class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; // Shape 类不能被实例化，只能用于继承 throw new Error(&apos;本类不能实例化&apos;); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 new 是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 Generator 异步应用","slug":"es6/generator-async","date":"2018-03-09T01:43:04.000Z","updated":"2018-04-22T13:21:29.000Z","comments":true,"path":"es6/generator-async/","link":"","permalink":"http://blog.master-ss.cn/es6/generator-async/","excerpt":"异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是 “单线程” 的，如果没有异步编程，根本没法用，非卡死不可。现在主要介绍 Generator 函数如何完成异步操作。","text":"异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是 “单线程” 的，如果没有异步编程，根本没法用，非卡死不可。现在主要介绍 Generator 函数如何完成异步操作。 一、简介123456789101112131415161718192021222324252627282930313233343536373839404142434445// 异步编程：回调函数fs.readFile(&apos;/etc/passwd&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) throw err; console.log(data);&#125;); // 异步编程：Promisevar readFile = require(&apos;fs-readfile-promise&apos;);readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); // 异步编程：Generatorfunction* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; // 异步任务的封装：异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）var fetch = require(&apos;node-fetch&apos;);function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function(data)&#123; // 由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个 next 方法 return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 二、JavaScript 语言的 Thunk 函数在 JavaScript 语言中，Thunk 函数替换的是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。123456789101112131415161718192021222324252627282930313233343536373839404142// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123; return function (callback) &#123; return fs.readFile(fileName, callback); &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback); // Generator 函数自动执行，不过不适合异步操作。如果必须保证前一步执行完，才能执行后一步，则下面的自动执行就不可行。function* gen() &#123; // ...&#125;var g = gen();var res = g.next();while(!res.done)&#123; console.log(res.value); res = g.next();&#125; // Thunk 函数的自动流程管理var fs = require(&apos;fs&apos;);function run(generator) &#123; var it = generator(go); function go(err, result) &#123; if (err) return it.throw(err); it.next(result); &#125; go();&#125;run(function* (done) &#123; var firstFile; try &#123; var dirFiles = yield fs.readdir(&apos;NoNoNoNo&apos;, done); // No such dir firstFile = dirFiles[0]; &#125; catch (err) &#123; firstFile = null; &#125; console.log(firstFile);&#125;); 三、co 模块co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。这样当异步操作有了结果就能够用 then 方法交回执行权。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// co 模块可以让你不用编写 Generator 函数的执行器，Generator 函数只要传入 co 函数，就会自动执行，并返回一个 Promise 对象var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* () &#123; var f1 = yield readFile(&apos;/etc/fstab&apos;); var f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;;var co = require(&apos;co&apos;);co(gen); // 基于 Promise 对象的自动执行function getFoo() &#123; return new Promise(function (resolve, reject) &#123; resolve(&apos;foo&apos;); &#125;);&#125;function run(generator) &#123; var it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(function* () &#123; try &#123; var foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;); // co 源码---------------------------------------------》var slice = Array.prototype.slice;module.exports = co[&apos;default&apos;] = co.co = co;// 将生成器函数 fn 封装到函数中，这个函数执行返回 Promiseco.wrap = function (fn) &#123; createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() &#123; return co.call(this, fn.apply(this, arguments)); &#125;&#125;;// 执行生成器函数或者迭代器，返回 Promisefunction co(gen) &#123; var ctx = this; var args = slice.call(arguments, 1); return new Promise(function (resolve, reject) &#123; if (typeof gen === &apos;function&apos;) gen = gen.apply(ctx, args); // 调用生成器函数来获得遍历器 if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen); // 如果不是遍历器，那么直接将 Promise 状态设置为 resolved // 手动执行一次 onFulfilled(); // 成功回调函数 function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); // 首次启动遍历器遍历，将返回值给 ret 变量 &#125; catch (e) &#123; return reject(e); // 如果执行失败将 Promise 状态设置为 rejected &#125; next(ret); return null; &#125; // 失败回调函数 function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); // 抛出错误 &#125; catch (e) &#123; return reject(e); // 将 Promise 状态设置为 rejected &#125; next(ret); &#125; // 主要是将 onFulfilled、onRejected 函数添加到 ret.value 或者其转化的 Promise 中的回调函数中 function next(ret) &#123; if (ret.done) return resolve(ret.value); // 如果已经遍历完成，那么返回 ret.value var value = toPromise.call(ctx, ret.value); // 将 ret.value 转化为 Promise if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); // 将 onFulfilled 和 onRejected 添加到 Promise 的回调函数中 return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos; + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;)); // 如果返回的数据转化失败，那么抛出错误，将 Promise 状态设置为 rejected &#125; &#125;);&#125;// 将参数 obj 转为 Promisefunction toPromise(obj) &#123; if (!obj) return obj; if (isPromise(obj)) return obj; if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果是生成器函数，那么执行 co 返回 Promise if (&apos;function&apos; == typeof obj) return thunkToPromise.call(this, obj); if (Array.isArray(obj)) return arrayToPromise.call(this, obj); if (isObject(obj)) return objectToPromise.call(this, obj); return obj;&#125;// 将 thunk 函数转换为 Promisefunction thunkToPromise(fn) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; fn.call(ctx, function (err, res) &#123; if (err) return reject(err); if (arguments.length &gt; 2) res = slice.call(arguments, 1); resolve(res); &#125;); &#125;);&#125;// 将数组转换为 Promisefunction arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125;// 将 obj 转换为 Promisefunction objectToPromise(obj) &#123; var results = new obj.constructor(); // 获取一个新的 obj 对象 results var keys = Object.keys(obj); // 获取对象的 keys var promises = []; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var promise = toPromise.call(this, obj[key]); // 将对象的 values 转为 promise 对象 if (promise &amp;&amp; isPromise(promise)) defer(promise, key); // 如果转换成功执行 defer else results[key] = obj[key]; // 如果转换失败则传值给新对象 &#125; return Promise.all(promises).then(function () &#123; // 将所有的 promise 合并为一个新的 promise 并添加回调函数 return results; // 返回新对象 results &#125;); function defer(promise, key) &#123; // predefine the key in the result results[key] = undefined; // 将新对象 results 的对应 value 设置为 undefined promises.push(promise.then(function (res) &#123; // 为新 promise 添加回调函数，并将值传入 promises 数组 results[key] = res; // 回调函数中将新对象 results 的对应 value 设置为原值 &#125;)); &#125;&#125;// 判断参数 obj 是否是 promise 对象function isPromise(obj) &#123; return &apos;function&apos; == typeof obj.then;&#125;// 判断参数 obj 是否是迭代器function isGenerator(obj) &#123; return &apos;function&apos; == typeof obj.next &amp;&amp; &apos;function&apos; == typeof obj.throw;&#125;// 判断参数 obj 是否是生成器函数或者 generator 生成的迭代器function isGeneratorFunction(obj) &#123; var constructor = obj.constructor; // ƒ GeneratorFunction() &#123; [native code] &#125; if (!constructor) return false; // displayName 属性将返回函数的显示名称；name(ES6) 属性返回一个函数声明的名称 if (&apos;GeneratorFunction&apos; === constructor.name || &apos;GeneratorFunction&apos; === constructor.displayName) return true; return isGenerator(constructor.prototype); // 判断是否是 generator 生成的迭代器，constructor.prototype 返回 Generator 对象&#125;// 判断是否为简单对象function isObject(val) &#123; return Object == val.constructor;&#125; 四、Generator 应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 异步操作的同步化表达function* main() &#123; var result = yield request(&quot;http://some.url&quot;); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); // 控制流管理（这里只适合同步操作，异步操作使用 Thunk 或者 co）scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; // 部署 Iterator 接口function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125; // 作为数据结构（Generator 使得数据或者操作，具备了类似数组的接口）function* doStuff() &#123; yield fs.readFile.bind(null, &apos;hello.txt&apos;); yield fs.readFile.bind(null, &apos;world.txt&apos;); yield fs.readFile.bind(null, &apos;and-such.txt&apos;);&#125;for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125;function doStuff() &#123; // 可以用数组模拟 Generator 的这种用法 return [ fs.readFile.bind(null, &apos;hello.txt&apos;), fs.readFile.bind(null, &apos;world.txt&apos;), fs.readFile.bind(null, &apos;and-such.txt&apos;) ];&#125; Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 async","slug":"es6/async","date":"2018-03-08T06:46:12.000Z","updated":"2018-04-22T13:02:53.000Z","comments":true,"path":"es6/async/","link":"","permalink":"http://blog.master-ss.cn/es6/async/","excerpt":"ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。","text":"ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。 一、简介1234567891011121314151617181920212223242526const fs = require(&apos;fs&apos;);const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;; // Generator 函数依次读取两个文件const gen = function* () &#123; const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;; // async 函数就是将 Generator 函数的星号 * 替换成 async，将 yield 替换成awaitconst asyncReadFile = async function () &#123; const f1 = await readFile(&apos;/etc/fstab&apos;); const f2 = await readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;; async函数对 Generator 函数的改进，体现在以下四点：1、Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行：asyncReadFile()，然后它就会自动执行输出最后结果。这完全不像 Generator 函数，需要调用 next 方法，或者用 co 模块，才能真正执行得到最后结果；2、async 和 await 比起星号和 yield 语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果；3、co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。4、async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。 二、基本用法async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result);&#125;); // 指定 50 毫秒以后，输出 hello worldfunction timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&apos;hello world&apos;, 50); // async 函数返回的是 Promise 对象，可以作为 await 命令的参数async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint(&apos;hello world&apos;, 50); // async 函数有多种使用形式async function foo() &#123;&#125; // 函数声明const foo = async function () &#123;&#125;; // 函数表达式let obj = &#123; async foo() &#123;&#125; &#125;; // 对象的方法obj.foo().then(...)class Storage &#123; // Class 的方法 constructor() &#123; this.cachePromise = caches.open(&apos;avatars&apos;); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar(&apos;jake&apos;).then(…);const foo = async () =&gt; &#123;&#125;; // 箭头函数，注意箭头函数不能用作 Generator 函数 三、语法async 函数的语法规则总体上比较简单，难点是错误处理机制。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// async 函数返回一个 Promise 对象，内部 return 语句返回的值，会成为 then 方法回调函数的参数async function f() &#123; return &apos;hello world&apos;;&#125;f().then(v =&gt; console.log(v)) // &quot;hello world&quot; // async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态，抛出的错误对象会被 catch 方法回调函数接收到async function f() &#123; throw new Error(&apos;出错了&apos;);&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e) // Error: 出错了) // async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log) // 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数// &quot;ECMAScript 2017 Language Specification&quot; // await 命令后面是一个 Promise 对象，如果不是会被转成一个立即 resolve 的 Promise 对象async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v)) // 123 // await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到async function f() &#123; await Promise.reject(&apos;出错了&apos;); // await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数，如果在 await 前面加上 return 效果是一样的&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e)) // 出错了 // 只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行async function f() &#123; await Promise.reject(&apos;出错了&apos;); await Promise.resolve(&apos;hello world&apos;); // 不会执行&#125; // 将 await 放在 try...catch 结构里面，这样不管这个异步操作是否成功，后面的 await 都会执行async function f() &#123; try &#123; await Promise.reject(&apos;出错了&apos;); &#125; catch(e) &#123; &#125; return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v)) // hello world // 或者 await 后面的 Promise 对象再跟一个 catch 方法处理前面可能出现的错误async function f() &#123; await Promise.reject(&apos;出错了&apos;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&apos;hello world&apos;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world // 如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 rejectasync function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e)) // Error：出错了 // 防止出错的方法是将 await 放在 try...catch 代码块之中async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;); &#125; catch(e) &#123; &#125; return await(&apos;hello world&apos;);&#125; // 有多个 await 命令，可以统一放在 try...catch 结构中async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log(&apos;Final: &apos;, val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; // 使用 try...catch 结构实现多次重复尝试（如果 await 操作成功，就会使用 break 语句退出循环；如果失败会被 catch 语句捕捉，然后进入下一轮循环）const superagent = require(&apos;superagent&apos;);const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get(&apos;http://google.com/this-throws-an-error&apos;); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); // 多个 await 命令后面的异步操作，如果不存在继发关系最好让它们同时触发，这样比较耗时let foo = await getFoo();let bar = await getBar(); // 可以让独立的异步操作同时触发，缩短程序的执行时间let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 写法一let fooPromise = getFoo(); // 写法二let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; // await 命令只能用在 async 函数之中，如果用在普通函数会报错async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; docs.forEach(function (doc) &#123; // 报错 await db.post(doc); &#125;);&#125; // 可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; docs.forEach(async function (doc) &#123; // 可能得到错误结果 await db.post(doc); &#125;);&#125; // 继发执行正确的写法是采用 for 循环async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; // 希望多个请求并发执行，可以使用 Promise.all 方法。当三个请求都会 resolved 时，下面两种写法效果相同async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;async function dbFuc(db) &#123; // 或者使用下面的写法 let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 四、async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。123456789101112131415161718192021222324252627282930313233// 所有的 async 函数都可以写成下面的第二种形式，其中的 spawn 函数就是自动执行器async function fn(args) &#123; // ...&#125;function fn(args) &#123; // 等同于 return spawn(function* () &#123; // ... &#125;);&#125; // spawn 函数的实现，基本就是上文 Generator 自动执行器的翻版function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 五、与其他异步处理方法的比较通过一个例子，来看 async 函数与 Promise、Generator 函数的比较：假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。1234567891011121314151617181920212223242526272829303132333435363738394041424344// Promise 的写法：比回调函数的写法大大改进，但是代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来function chainAnimationsPromise(elem, animations) &#123; let ret = null; // 变量 ret 用来保存上一个动画的返回值 let p = Promise.resolve(); // 新建一个空的 Promise for(let anim of animations) &#123; // 使用 then 方法，添加所有动画 p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; return p.catch(function(e) &#123; // 返回一个部署了错误捕捉机制的 Promise /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; // Generator 函数的写法：语义比 Promise 写法更清晰，问题在于必须有一个任务运行器自动执行 Generator 函数且 yield 语句后面的表达式必须返回一个 Promisefunction chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; // async 函数的写法：实现最简洁，最符合语义，几乎没有语义不相关的代码，Generator 写法中的自动执行器改在语言层面提供，不暴露给用户，代码量最少async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 六、实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。1234567891011121314151617181920212223242526272829// Promise 的写法：写法不太直观，可读性比较差function logInOrder(urls) &#123; const textPromises = urls.map(url =&gt; &#123; // 远程读取所有URL return fetch(url).then(response =&gt; response.text()); &#125;); textPromises.reduce((chain, textPromise) =&gt; &#123; // 依次处理每个 Promise 对象，然后使用 then 将所有 Promise 对象连起来，因此就可以依次输出结果 return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; // async 函数实现：所有远程操作都是继发，效率很差，非常浪费时间async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; // async 函数并发实现：只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出async function logInOrder(urls) &#123; const textPromises = urls.map(async url =&gt; &#123; // 并发读取远程URL const response = await fetch(url); return response.text(); &#125;); for (const textPromise of textPromises) &#123; // 按次序输出 console.log(await textPromise); &#125;&#125; 七、异步遍历器Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的 next 方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是 {value, done}，其中 value 表示当前的数据的值，done 是一个布尔值，表示遍历是否结束。这里隐含着一个规定，next 方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行 next 方法，就必须同步地得到 value 和 done 这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即 value 属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而 done 属性则还是同步产生的。ES2018 引入了 “异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即 value 和 done 这两个属性都是异步产生。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 Generator","slug":"es6/generator","date":"2018-03-07T06:39:41.000Z","updated":"2018-04-22T13:25:33.000Z","comments":true,"path":"es6/generator/","link":"","permalink":"http://blog.master-ss.cn/es6/generator/","excerpt":"Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator 函数有多种理解角度，首先可以理解成 Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。它有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是 “产出”）。遍历器对象的 next 方法的运行逻辑：1、遇到 yield 表达式就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值；2、下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式；3、如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值作为返回的对象的 value 属性值；4、如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。","text":"Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator 函数有多种理解角度，首先可以理解成 Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。它有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是 “产出”）。遍历器对象的 next 方法的运行逻辑：1、遇到 yield 表达式就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值；2、下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式；3、如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值作为返回的对象的 value 属性值；4、如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。 一、简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var hw = helloWorldGenerator(); // 调用后并不执行，返回的也不是函数运行结果，而是遍历器对象（Iterator Object）// Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行hw.next() // &#123; value: &apos;hello&apos;, done: false &#125;hw.next() // &#123; value: &apos;world&apos;, done: false &#125;hw.next() // &#123; value: &apos;ending&apos;, done: true &#125;，value 属性就是在 return 后面的表达式的值，done 属性的值 true 表示遍历已经结束hw.next() // &#123; value: undefined, done: true &#125;，函数已经运行完毕，以后再调用 next 方法返回的都是这个值 // 没有规定 function 关键字与函数名之间的星号写在哪个位置，下面的写法都能通过function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; // Generator 函数可以不用 yield 表达式，这时就变成了一个单纯的暂缓执行函数function* f() &#123; console.log(&apos;执行了！&apos;)&#125;var generator = f();setTimeout(function () &#123; generator.next() // 调用 next 方法时，函数 f 才会执行&#125;, 2000); // yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错(function ()&#123; yield 1; // SyntaxError: Unexpected number&#125;)() // forEach 方法的参数是一个普通函数，但是在里面使用了 yield 表达式，可改用 for 循环var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; a.forEach(function (item) &#123; if (typeof item !== &apos;number&apos;) &#123; yield* flat(item); // 产生句法错误 &#125; else &#123; yield item; &#125; &#125;);&#125;;for (var f of flat(arr))&#123; console.log(f);&#125; // yield 表达式如果用在另一个表达式之中，必须放在圆括号里面function* demo() &#123; console.log(&apos;Hello&apos; + yield); // SyntaxError console.log(&apos;Hello&apos; + yield 123); // SyntaxError console.log(&apos;Hello&apos; + (yield)); // OK console.log(&apos;Hello&apos; + (yield 123)); // OK&#125; // yield 表达式用作函数参数或放在赋值表达式的右边，可以不加括号function* demo() &#123; foo(yield &apos;a&apos;, yield &apos;b&apos;); // OK let input = yield; // OK&#125; // 可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] // Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g // true 二、next 方法的参数yield 表达式本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。123456789101112131415161718192021222324252627282930313233343536373839function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125;，当 next 方法带一个参数 true，reset 被重置，因此 i 会等于 -1，下一轮循环就会从 -1 开始递增 // 通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值，从而调整函数行为（第一次使用 next 方法时传递参数是无效的）function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;，next 方法不带参数，导致 y 的值等于 2 * undefined（即 NaN），除以 3 以后还是 NaNa.next() // Object&#123;value:NaN, done:true&#125;，不带参数所以 z 等于 undefined，返回对象的 value 属性等于 5 + NaN + undefined，即 NaNvar b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;，将上一次 yield 表达式的值设为 12，因此 y 等于 24，返回 y / 3 的值 8b.next(13) // &#123; value:42, done:true &#125;，将上一次 yield表 达式的值设为 13，因此 z 等于13，这时 x 等于 5，y 等于 24，所以 return 语句的值等于 42 // 用 wrapper 将 Generator 函数先包一层，使得第一次调用 next 方法就输入参数function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return &apos;DONE&apos;;&#125;);wrapped().next(&apos;hello!&apos;) // First input: hello! 三、for…of 循环for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 一旦 next 方法的返回对象的 done 属性为 true，for...of 循环就会中止且不包含该返回对象function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6; // return 语句返回的 6 不包括在 for...of 循环之中&#125;for (let v of foo()) &#123; console.log(v); // 1 2 3 4 5&#125; // 利用 Generator 函数和 for...of 循环实现斐波那契数列（for...of 语句不需要使用 next 方法）function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; // 为原生的 JavaScript 对象添加遍历接口function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe // 加上遍历器接口的另一种写法是将 Generator 函数加到对象的 Symbol.iterator 属性上面jane[Symbol.iterator] = objectEntries; // 可以将 Generator 函数返回的 Iterator 对象作为参数传递给扩展运算符、Array.from、解构赋值、for...of 循环function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;[...numbers()] // [1, 2]，扩展运算符Array.from(numbers()) // [1, 2]，Array.from 方法let [x, y] = numbers(); // x: 1， y: 2，解构赋值for (let n of numbers()) &#123; // for...of 循环 console.log(n) // 1 2&#125; 四、Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&apos;内部捕获&apos;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&apos;a&apos;); // 建议抛出 Error 对象的实例 i.throw(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e);&#125;// 内部捕获 a（第一个错误被 Generator 函数体内的 catch 语句捕获）// 外部捕获 b（第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获） // 全局的 throw 命令抛出的只能被函数体外的 catch 语句捕获（不要混淆遍历器对象的 throw 方法和全局的 throw 命令）var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != &apos;a&apos;) throw e; console.log(&apos;内部捕获&apos;, e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error(&apos;a&apos;); throw new Error(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e); // 外部捕获 [Error: a]，函数体外的 catch 语句块捕获了抛出的 a 错误以后，就不会再继续 try 代码块里面剩余的语句了&#125; // 如果 Generator 函数内部没有部署 try...catch 代码块，那么 throw 方法抛出的错误将被外部 try...catch 代码块捕获var g = function* () &#123; while (true) &#123; yield; console.log(&apos;内部捕获&apos;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&apos;a&apos;); i.throw(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e); // 外部捕获 a&#125; // 如果 Generator 函数内部和外部都没有部署 try...catch 代码块，那么程序将报错，直接中断执行var gen = function* gen()&#123; yield console.log(&apos;hello&apos;); yield console.log(&apos;world&apos;);&#125;var g = gen();g.next(); // hellog.throw(); // Uncaught undefined // throw 方法被捕获以后，会附带执行下一条 yield 表达式。也就是说，会附带执行一次 next 方法var gen = function* gen()&#123; try &#123; yield console.log(&apos;a&apos;); &#125; catch (e) &#123; // ... &#125; yield console.log(&apos;b&apos;); yield console.log(&apos;c&apos;);&#125;var g = gen();g.next() // ag.throw() // b，只要 Generator 函数内部部署了 try...catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历g.next() // c // throw 命令与 g.throw 方法是无关的，两者互不影响// 函数体内捕获错误的机制，大大方便了对错误的处理。多个 yield 表达式，可以只用一个 try...catch 代码块来捕获错误。如果使用回调函数的写法，// 想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次 catch 语句就可以了。var gen = function* gen()&#123; yield console.log(&apos;hello&apos;); yield console.log(&apos;world&apos;);&#125;var g = gen();g.next();try &#123; throw new Error();&#125; catch (e) &#123; g.next();&#125;// hello// world // Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获function* foo() &#123; var x = yield 3; var y = x.toUpperCase(); yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123; it.next(42); // 数值是没有 toUpperCase 方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获&#125; catch (err) &#123; console.log(err);&#125; // Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了function* g() &#123; yield 1; console.log(&apos;throwing an exception&apos;); throw new Error(&apos;generator broke!&apos;); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log(&apos;starting generator&apos;); try &#123; v = generator.next(); console.log(&apos;第一次运行next方法&apos;, v); &#125; catch (err) &#123; console.log(&apos;捕捉错误&apos;, v); &#125; try &#123; v = generator.next(); console.log(&apos;第二次运行next方法&apos;, v); &#125; catch (err) &#123; console.log(&apos;捕捉错误&apos;, v); &#125; try &#123; v = generator.next(); console.log(&apos;第三次运行next方法&apos;, v); &#125; catch (err) &#123; console.log(&apos;捕捉错误&apos;, v); &#125; console.log(&apos;caller done&apos;);&#125;log(g());// starting generator// 第一次运行 next 方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;，抛出错误且没有被内部捕获，停止执行，还是变量 v 值还是之前的// 第三次运行next方法 &#123; value: undefined, done: true &#125;，此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象// caller done，如果将 throw 用 try...catch 包起来，那么 next 的 value 属性依次为 1、2、3 五、Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。123456789101112131415161718192021222324252627282930313233343536373839// 调用 return 方法后，返回值的 value 属性就是 return 方法的参数 foo，并且 Generator 函数的遍历就终止了，返回值的done属性为truefunction* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125;，以后再调用 next 方法，done 属性总是返回 true // 如果 return 方法调用时，不提供参数，则返回值的 value 属性为 undefinedfunction* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; // 如果 Generator 函数内部有 try...finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 六、next()、throw()、return() 的共同点next()、throw()、return() 这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 yield 表达式。1234567891011121314151617181920// next() 是将 yield 表达式替换成一个值const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; // throw() 是将 yield 表达式替换成一个 throw 语句gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&apos;出错了&apos;)); // return() 是将 yield 表达式替换成一个 return 语句gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; 七、yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。这个时候就需要用到 yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178function* foo() &#123; yield &apos;a&apos;; yield &apos;b&apos;;&#125;function* bar() &#123; yield &apos;x&apos;; foo(); // 在 bar 里面调用 foo，是不会有效果的 yield &apos;y&apos;;&#125;for (let v of bar())&#123; console.log(v);&#125;// &quot;x&quot;// &quot;y&quot; // yield* 执行另一个 Generator 函数function* bar() &#123; yield &apos;x&apos;; yield* foo(); yield &apos;y&apos;;&#125;// 等同于function* bar() &#123; yield &apos;x&apos;; yield &apos;a&apos;; yield &apos;b&apos;; yield &apos;y&apos;;&#125;// 等同于function* bar() &#123; yield &apos;x&apos;; for (let v of foo()) &#123; yield v; &#125; yield &apos;y&apos;;&#125;for (let v of bar())&#123; console.log(v);&#125;// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot; // 如果 yield 表达式后面跟的是一个遍历器对象，需要在 yield 表达式后面加上星号，表明它返回的是一个遍历器对象，这被称为 yield* 表达式function* inner() &#123; yield &apos;hello!&apos;;&#125;function* outer1() &#123; yield &apos;open&apos;; yield inner(); yield &apos;close&apos;;&#125;var gen = outer1()gen.next().value // &quot;open&quot;gen.next().value // 返回一个遍历器对象gen.next().value // &quot;close&quot;function* outer2() &#123; yield &apos;open&apos; yield* inner() yield &apos;close&apos;&#125;var gen = outer2()gen.next().value // &quot;open&quot;gen.next().value // &quot;hello!&quot;gen.next().value // &quot;close&quot; // yield* 后面的 Generator 函数没有 return 语句时，等同于在 Generator 函数内部部署一个 for...of 循环function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125;// 在有 return 语句时，则需要用 yield* iterator 的形式获取 return 语句的值var value = yield* iterator; // 如果 yield* 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员function* gen()&#123; yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; // 如果不加星号，返回的是整个数组&#125;gen().next() // &#123; value:&quot;a&quot;, done:false &#125; // 任何数据结构只要有 Iterator 接口，就可以被 yield* 遍历let read = (function* () &#123; yield &apos;hello&apos;; yield* &apos;hello&apos;;&#125;)();read.next().value // &quot;hello&quot;，yield 表达式返回整个字符串read.next().value // &quot;h&quot;，yield* 语句返回单个字符 // 如果被代理的 Generator 函数有 return 语句，那么就可以向代理它的 Generator 函数返回数据function* foo() &#123; yield 2; yield 3; return &quot;foo&quot;;&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log(&quot;v: &quot; + v); yield 4;&#125;var it = bar();it.next() // &#123;value: 1, done: false&#125;it.next() // &#123;value: 2, done: false&#125;it.next() // &#123;value: 3, done: false&#125;it.next() // &quot;v: foo&quot;，&#123;value: 4, done: false&#125;，屏幕上会有输出是因为函数 foo 的 return 语句，向函数 bar 提供了返回值it.next() // &#123;value: undefined, done: true&#125; // 存在两次遍历，第一次是扩展运算符遍历函数 logReturned 返回的遍历器对象，第二次是 yield* 语句遍历函数 genFuncWithReturn 返回的遍历器对象function* genFuncWithReturn() &#123; yield &apos;a&apos;; yield &apos;b&apos;; return &apos;The result&apos;;&#125;function* logReturned(genObj) &#123; let result = yield* genObj; console.log(result);&#125;[...logReturned(genFuncWithReturn())]// The result// 值为 [ &apos;a&apos;, &apos;b&apos; ] // yield* 命令可以很方便地取出嵌套数组的所有成员function* iterTree(tree) &#123; if (Array.isArray(tree)) &#123; for(let i=0; i &lt; tree.length; i++) &#123; yield* iterTree(tree[i]); &#125; &#125; else &#123; yield tree; &#125;&#125;const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];for(let x of iterTree(tree)) &#123; console.log(x); // a, b, c, d, e&#125; // 使用 yield* 语句遍历完全二叉树// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[[&apos;a&apos;], &apos;b&apos;, [&apos;c&apos;]], &apos;d&apos;, [[&apos;e&apos;], &apos;f&apos;, [&apos;g&apos;]]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;] 八、作为对象属性的 Generator 函数12345678910111213// 对象的属性是 Generator 函数可以简写成下面的形式let obj = &#123; * myGeneratorMethod() &#123; // ··· &#125;&#125;; // 完整形式如下，与上面的写法是等价的let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; 九、Generator 函数的 this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Generator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototypefunction* g() &#123;&#125;g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;let obj = g();obj instanceof g // trueobj.hello() // &apos;hi!&apos; // 如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象function* g() &#123; this.a = 11;&#125;let obj = g();obj.next();obj.a // undefined // Generator 函数也不能跟 new 命令一起用，会报错function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F() // TypeError: F is not a constructor，因为 F 不是构造函数 // 使用 call 方法绑定 Generator 函数内部的 thisfunction* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 // 执行的是遍历器对象 f 和生成的对象实例是 obj 统一function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 // 再将 F 改成构造函数，就可以对它执行 new 命令了function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 Iterator","slug":"es6/iterator","date":"2018-03-06T08:21:12.000Z","updated":"2018-04-22T13:31:33.000Z","comments":true,"path":"es6/iterator/","link":"","permalink":"http://blog.master-ss.cn/es6/iterator/","excerpt":"JavaScript 有四种表示 “集合” 数据集合：Array、Object、Map 以及 Set，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。","text":"JavaScript 有四种表示 “集合” 数据集合：Array、Object、Map 以及 Set，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 一、简介Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。Iterator 的遍历过程：创建一个指针对象，指向当前数据结构的起始位置；第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员；第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员；不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。123456789101112131415161718192021222324252627282930// 调用指针对象的 next 方法，就可以遍历事先给定的数据结构var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; // 对于遍历器对象来说，done: false 和 value: undefined 属性都是可以省略的 return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; // 遍历器与它所遍历的那个数据结构，实际上是分开的，可以写出没有对应数据结构的遍历器对象var it = idMaker();it.next().value // 0it.next().value // 1it.next().value // 2function idMaker() &#123; var index = 0; return &#123; next: function() &#123; return &#123;value: index++, done: false&#125;; &#125; &#125;;&#125; 二、默认 Iterator 接口ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是 “可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 Symbol.iterator，它是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 部署 Symbol.iterator 属性const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; // 存在原生具备遍历器接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: &apos;a&apos;, done: false &#125;iter.next() // &#123; value: &apos;b&apos;, done: false &#125;iter.next() // &#123; value: &apos;c&apos;, done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; // 对象需要自己在 Symbol.iterator 属性部署遍历器才会被 for...of 循环遍历（不是很必要，因为 ES6 原生提供了 Map 结构）class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; // 遍历器实现指针结构function Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i); // 1, 2, 3&#125; // 类似数组的对象（存在数值键名和 length 属性），直接引用数组的 Iterator 接口部署NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; // 或者[...document.querySelectorAll(&apos;div&apos;)] // 可以执行了，NodeList 对象是类似数组的对象，本来就具有遍历接口，遍历接口改写后，没有任何影响 // 另一个类似数组的对象调用数组的 Symbol.iterator 方法let iterable = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125; // 普通对象部署数组的 Symbol.iterator 方法，并无效果let iterable = &#123; a: &apos;a&apos;, b: &apos;b&apos;, c: &apos;c&apos;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // undefined, undefined, undefined&#125; // 如果 Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错var obj = &#123;&#125;;obj[Symbol.iterator] = () =&gt; 1;[...obj] // TypeError: [] is not a function // 有了遍历器接口，数据结构就可以用 for...of 循环遍历，也可以使用 while 循环遍历var $iterator = ITERABLE[Symbol.iterator]();var $result = $iterator.next();while (!$result.done) &#123; var x = $result.value; // ... $result = $iterator.next();&#125; 三、调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即 Symbol.iterator 方法），除了 for…of 循环，还有几个别的场合。123456789101112131415161718192021222324252627// 对数组和 Set 结构进行解构赋值时let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);let [x,y] = set; // x=&apos;a&apos;; y=&apos;b&apos;let [first, ...rest] = set; // first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;]; // 扩展运算符（...）也会调用默认的 Iterator 接口var str = &apos;hello&apos;;[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]let arr = [&apos;b&apos;, &apos;c&apos;];[&apos;a&apos;, ...arr, &apos;d&apos;] // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]let arr = [...iterable]; // 只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符将其转为数组 // yield* 后面跟的是一个可遍历的结构let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; // 其他场合（for...of、Array.from()、Map(), Set(), WeakMap(), WeakSet()、Promise.all()、Promise.race()） 四、字符串的 Iterator 接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。1234567891011121314151617181920212223242526// 调用 Symbol.iterator 方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历var someString = &quot;hi&quot;;typeof someString[Symbol.iterator] // &quot;function&quot;var iterator = someString[Symbol.iterator]();iterator.next() // &#123; value: &quot;h&quot;, done: false &#125;iterator.next() // &#123; value: &quot;i&quot;, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; // 可以覆盖原生的 Symbol.iterator 方法，达到修改遍历器行为的目的var str = new String(&quot;hi&quot;);[...str] // [&quot;h&quot;, &quot;i&quot;]str[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if (this._first) &#123; this._first = false; return &#123; value: &quot;bye&quot;, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, _first: true &#125;;&#125;;[...str] // [&quot;bye&quot;]，字符串 str 的 Symbol.iterator 方法被修改了，所以扩展运算符（...）返回的值变成了 byestr // &quot;hi&quot;，而字符串本身还是 hi 五、Iterator 接口与 Generator 函数Symbol.iterator 方法的最简单实现，还是使用 Generator 函数。123456789101112131415161718192021// Symbol.iterator 方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// &quot;hello&quot;// &quot;world&quot; 六、遍历器对象的 return()，throw()遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。return 方法的使用场合是 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。注意，return 方法必须返回一个对象，这是 Generator 规格决定的。throw 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。123456789101112131415161718192021222324252627282930function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;; &#125;, &#125;;&#125;// 情况一：输出文件的第一行以后，就会执行 return 方法，关闭这个文件for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二：输出所有行以后，执行 return 方法，关闭该文件for (let line of readLinesSync(fileName)) &#123; console.log(line); continue;&#125;// 情况三：执行 return 方法关闭文件之后再抛出错误for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; 七、for…of 循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// 数组原生具备 iterator 接口const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];for(let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); // red green blue&#125; // for...of 循环可以代替数组实例的 forEach 方法arr.forEach(function (element, index) &#123; console.log(element); // red green blue console.log(index); // 0 1 2&#125;); // for...in 循环只能获得对象的键名；for...of 循环允许遍历获得键值（如果要获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法）var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; // for...of 循环只遍历具有数字索引的属性，跟 for...in 循环不一样let arr = [3, 5, 7];arr.foo = &apos;hello&apos;;for (let i in arr) &#123; console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;&#125;for (let i of arr) &#123; console.log(i); // &quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125; // Set 原生具有 Iterator 接口（遍历的顺序是按照各个成员被添加进数据结构的顺序）var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkit // Map 原生具有 Iterator 接口（遍历的顺序是按照各个成员被添加进数据结构的顺序）var es6 = new Map();es6.set(&quot;edition&quot;, 6);es6.set(&quot;committee&quot;, &quot;TC39&quot;);es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);for (var [name, value] of es6) &#123; console.log(name + &quot;: &quot; + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 // entries、keys、values 方法调用后均生成遍历器对象let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, &apos;a&apos;]// [1, &apos;b&apos;]// [2, &apos;c&apos;] // 遍历字符串let str = &quot;hello&quot;;for (let s of str) &#123; console.log(s); // h e l l o&#125; // 遍历 DOM NodeList 对象let paras = document.querySelectorAll(&quot;p&quot;);for (let p of paras) &#123; p.classList.add(&quot;test&quot;);&#125; // 遍历 arguments 对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs(&apos;a&apos;, &apos;b&apos;);// &apos;a&apos;// &apos;b&apos; // for...of 循环可正确识别 32 位 UTF-16 字符for (let x of &apos;a\\uD83D\\uDC0A&apos;) &#123; console.log(x);&#125;// &apos;a&apos;// &apos;\\uD83D\\uDC0A&apos; // 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组let arrayLike = &#123; length: 2, 0: &apos;a&apos;, 1: &apos;b&apos; &#125;;for (let x of arrayLike) &#123; // 报错 console.log(x);&#125;for (let x of Array.from(arrayLike)) &#123; // 正确 console.log(x);&#125; // 普通的对象，for...of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用，不过 for...in 循环依然可以用来遍历键名let es6 = &#123; edition: 6, committee: &quot;TC39&quot;, standard: &quot;ECMA-262&quot;&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function // 可以使用 Object.keys 方法将对象的键名生成一个数组，然后 for...of 遍历这个数组for (var key of Object.keys(someObject)) &#123; console.log(key + &apos;: &apos; + someObject[key]);&#125; // 或者使用 Generator 函数将对象重新包装一下function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, &apos;-&gt;&apos;, value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 // 遍历方法对比：// 写法麻烦for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125;// 简洁，但是无法中途跳出 forEach 循环，break 命令或 return 命令都不能奏效myArray.forEach(function (value) &#123; console.log(value);&#125;);// 简洁，不过数组的键名是数字，还会遍历手动添加的其他键，包括原型链上的键，甚至在某种情况下会以任意顺序遍历键名（主要为遍历对象而设计）for (var index in myArray) &#123; console.log(myArray[index]);&#125;// 简洁，没有 for...in 那些缺点，可以与 break、continue 和 return 配合使用，提供了遍历所有数据结构的统一操作接口for (let value of myArray) &#123; console.log(value);&#125; // break 语句跳出 for...of 循环（如果当前项大于 1000，就会使用 break 语句跳出 for...of 循环）for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; 一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for…of 循环遍历它的成员。也就是说，for…of 循环内部调用的是数据结构的 Symbol.iterator 方法。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 module 加载","slug":"es6/module-load","date":"2018-03-04T04:43:26.000Z","updated":"2018-04-22T13:37:41.000Z","comments":true,"path":"es6/module-load/","link":"","permalink":"http://blog.master-ss.cn/es6/module-load/","excerpt":"介绍浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。","text":"介绍浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。 一、浏览器加载HTML 网页中，浏览器通过 &lt;script&gt; 标签加载 JavaScript 脚本。默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到 &lt;script&gt; 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。1234567891011121314151617181920212223242526// defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；多个 defer 脚本，会按照它们在页面出现的顺序加载&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; // async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染；多个 async 脚本是不能保证加载顺序&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; // 浏览器加载 ES6 模块（加入 type=&quot;module&quot; 属性，效果等同于 defer 属性）&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt; // 浏览器加载 ES6 模块，同时打开 async 属性（只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染）&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt; // ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致&lt;script type=&quot;module&quot;&gt; import utils from &quot;./utils.js&quot;; // other code&lt;/script&gt; // ES6 模块之中，顶层的 this 返回undefined，而不是指向 window 。也就是说，在模块顶层使用 this 关键字，是无意义的import utils from &apos;https://example.com/js/utils.js&apos;;const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // true // 利用顶层的 this 等于 undefined 这个语法点，可以侦测当前代码是否在 ES6 模块之中const isNotModuleScript = this !== undefined; 对于外部的模块脚本，有几点需要注意：1.代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。2.模块脚本自动采用严格模式，不管有没有声明use strict。3.模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。4.模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。5.同一个模块如果加载多次，将只执行一次。 二、ES6 模块与 CommonJS 模块的差异他们有两个重大差异：CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用；CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; // main.js（mod.counter 是一个原始类型的值，会被缓存）var mod = require(&apos;./lib&apos;);console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 // lib.js（除非写成一个函数，才能得到内部变动后的值）var counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; // 输出的 counter 属性实际上是一个取值器函数 return counter &#125;, incCounter: incCounter,&#125;; // lib.js（ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块）export let counter = 3;export function incCounter() &#123; counter++;&#125; // main.js（原始值变了，import 加载的值也会跟着变）import &#123; counter, incCounter &#125; from &apos;./lib&apos;;console.log(counter); // 3incCounter();console.log(counter); // 4 // lib.jsexport let obj = &#123;&#125;; // main.jsimport &#123; obj &#125; from &apos;./lib&apos;;obj.prop = 123; // OKobj = &#123;&#125;; // TypeError（变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量） // mod.js（export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例）function C() &#123; this.sum = 0; this.add = function () &#123; this.sum += 1; &#125;; this.show = function () &#123; console.log(this.sum); &#125;;&#125;export let c = new C(); // x.jsimport &#123;c&#125; from &apos;./mod&apos;;c.add(); // y.jsimport &#123;c&#125; from &apos;./mod&apos;;c.show(); // main.js（输出 1，证明了 x.js 和 y.js 加载的都是 C 的同一个实例）import &apos;./x&apos;;import &apos;./y&apos;; 三、Node 加载Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。Node 要求 ES6 模块采用 .mjs 后缀文件名。也就是说，只要脚本文件里面使用 import 或者 export 命令，那么就必须采用 .mjs 后缀名。require 命令不能加载 .mjs 文件，会报错，只有 import 命令才可以加载 .mjs 文件。反过来，.mjs 文件里面也不能使用 require 命令，必须使用 import。目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用 –experimental-modules 参数才能打开该功能。12345678910111213// 支持 URL 路径，Node 会按 URL 规则解读；同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、? 等特殊字符，最好对这些字符进行转义import &apos;./foo?query=1&apos;; // 加载 ./foo 传入参数 ?query=1 // 如果模块名不含路径，那么 import 命令会去 node_modules 目录寻找这个模块import &apos;baz&apos;;import &apos;abc/123&apos;; // 如果模块名包含路径，那么 import 命令会按照路径去寻找这个名字的脚本文件import &apos;file:///etc/config/app.json&apos;; // 只支持加载本地模块（file:协议），不支持加载远程模块import &apos;./foo&apos;;import &apos;./foo?search&apos;;import &apos;../bar&apos;;import &apos;/baz&apos;; 如果脚本文件省略了后缀名，比如 import ‘./foo’，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载 ./foo/package.json 的 main 字段指定的脚本。如果 ./foo/package.json 不存在或者没有 main 字段，那么就会依次加载 ./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。Node 的 import 命令是异步加载，这一点与浏览器的处理方法相同。ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。首先，就是this关键字。ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块。其次，以下这些顶层变量在 ES6 模块之中都是不存在的：arguments、require、module、exports、__filename、__dirname。 四、ES6 模块加载 CommonJS 模块CommonJS 模块的输出都定义在 module.exports 这个属性上面。Node 的 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于export default xxx。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// a.jsmodule.exports = &#123; foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;// 等同于（即 import 命令实际上输入的是这样一个对象 &#123; default: module.exports &#125;）export default &#123; foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;; // 写法一（一共有三种写法，可以拿到 CommonJS 模块的 module.exports）import baz from &apos;./a&apos;;// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;// 写法二import &#123;default as baz&#125; from &apos;./a&apos;;// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;// 写法三（通过 baz.default 拿到 module.exports）import * as baz from &apos;./a&apos;;// baz = &#123;// get default() &#123;return module.exports;&#125;,// get foo() &#123;return this.default.foo&#125;.bind(baz),// get bar() &#123;return this.default.bar&#125;.bind(baz)// &#125; // b.jsmodule.exports = null;// es.jsimport foo from &apos;./b&apos;;// foo = null;import * as bar from &apos;./b&apos;;// bar = &#123; default:null &#125;; // 通过 bar.default 这样的写法，才能拿到 module.exports // c.jsmodule.exports = function two() &#123; return 2;&#125;;// es.jsimport foo from &apos;./c&apos;;foo(); // 2import * as bar from &apos;./c&apos;;bar.default(); // 2bar(); // throws, bar is not a function（bar 本身是一个对象，不能当作函数调用，只能通过 bar.default 调用） // foo.js（CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效）module.exports = 123;setTimeout(_ =&gt; module.exports = null); // 对于加载 foo.js 的脚本，module.exports 将一直是 123，而不会变成 null // ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口import &#123; readfile &#125; from &apos;fs&apos;; // 不正确，因为 fs 是 CommonJS 格式，只有在运行时才能确定 readfile 接口，而 import 命令要求编译时就确定这个接口 // 解决方法就是改为整体输入import * as express from &apos;express&apos;; // 写法一const app = express.default();import express from &apos;express&apos;; // 写法二const app = express(); 五、CommonJS 模块加载 ES6 模块CommonJS 模块加载 ES6 模块，不能使用 require 命令，而要使用 import() 函数。ES6 模块的所有输出接口，会成为输入对象的属性。1234567891011121314151617181920212223242526272829// es.mjslet foo = &#123; bar: &apos;my-default&apos; &#125;;export default foo;foo = null; // cjs.jsconst es_namespace = await import(&apos;./es&apos;);// es_namespace = &#123;// get default() &#123;// ...// &#125;// &#125;console.log(es_namespace.default); // 由于存在缓存机制，es.mjs 对 foo 的重新赋值没有在模块外部反映出来// &#123; bar:&apos;my-default&apos; &#125; // es.jsexport let foo = &#123; bar:&apos;my-default&apos; &#125;;export &#123; foo as bar &#125;;export function f() &#123;&#125;;export class c &#123;&#125;;// cjs.jsconst es_namespace = await import(&apos;./es&apos;);// es_namespace = &#123;// get foo() &#123;return foo;&#125;// get bar() &#123;return foo;&#125;// get f() &#123;return f;&#125;// get c() &#123;return c;&#125;// &#125; 六、循环加载“循环加载” 指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现 a 依赖 b，b 依赖 c，c 又依赖 a 这样的情况。这意味着，模块加载机制必须考虑 “循环加载” 的情况。目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。123456789101112131415161718192021222324252627282930313233343536373839404142// require 命令生成的对象&#123; id: &apos;...&apos;, // id 属性是模块名 exports: &#123; ... &#125;, // 模块输出的各个接口 loaded: true, // 布尔值，表示该模块的脚本是否执行完毕 ... // 其他属性&#125; // a.jsexports.done = false;var b = require(&apos;./b.js&apos;); // 1、加载另一个脚本文件 b.js，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a.js 执行完毕&apos;); // 5、a.js 接着往下执行，直到执行完毕 // b.jsexports.done = false;var a = require(&apos;./a.js&apos;); // 2、发生了 &quot;循环加载&quot;，系统会去 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done); // 3、已经执行的部分，只有一行，从 a.js 只输入一个变量 done，值为 falseexports.done = true;console.log(&apos;b.js 执行完毕&apos;); // 4、全部执行完毕，再把执行权交还给 a.js // main.jsvar a = require(&apos;./a.js&apos;); // 0、开始加载 a.jsvar b = require(&apos;./b.js&apos;); // 6、不会再次执行 b.js，而是输出缓存的 b.js 的执行结果console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.done);// 在 b.js 之中，a.done = false// b.js 执行完毕// 在 a.js 之中，b.done = true// a.js 执行完毕// 在 main.js 之中, a.done=true, b.done=true // 由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。var a = require(&apos;a&apos;); // 安全的写法var foo = require(&apos;a&apos;).foo; // 危险的写法exports.good = function (arg) &#123; return a.foo(&apos;good&apos;, arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo(&apos;bad&apos;, arg); // 使用的是一个部分加载时的值&#125;; 1、先介绍目前最流行的 CommonJS 模块格式的加载原理：CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被 “循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。如上。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// a.mjsimport &#123;bar&#125; from &apos;./b&apos;; // 1、执行 b.mjs，然后再执行 a.jsconsole.log(&apos;a.mjs&apos;);console.log(bar);export let foo = &apos;foo&apos;; // b.mjsimport &#123;foo&#125; from &apos;./a&apos;; // 2、不会去执行 a.mjs，而是认为这个接口已经存在了，继续往下执行console.log(&apos;b.mjs&apos;);console.log(foo); // 3、发现这个接口根本没定义，因此报错export let bar = &apos;bar&apos;;// node --experimental-modules a.mjs// b.mjs// ReferenceError: foo is not defined // 解决方法：因为函数具有提升作用，在执行 import &#123;bar&#125; from &apos;./b&apos; 时，函数 foo 就已经有定义了，所以 b.mjs 加载的时候不会报错// a.mjsimport &#123;bar&#125; from &apos;./b&apos;;console.log(&apos;a.mjs&apos;);console.log(bar());function foo() &#123; return &apos;foo&apos; &#125;export &#123;foo&#125;; // b.mjsimport &#123;foo&#125; from &apos;./a&apos;;console.log(&apos;b.mjs&apos;);console.log(foo());function bar() &#123; return &apos;bar&apos; &#125;export &#123;bar&#125;; // a.mjs（代码第四行改成了函数表达式，就不具有提升作用，执行就会报错）import &#123;bar&#125; from &apos;./b&apos;;console.log(&apos;a.mjs&apos;);console.log(bar());const foo = () =&gt; &apos;foo&apos;;export &#123;foo&#125;; // even.jsimport &#123; odd &#125; from &apos;./odd&apos;export var counter = 0;export function even(n) &#123; counter++; return n === 0 || odd(n - 1);&#125;// odd.jsimport &#123; even &#125; from &apos;./even&apos;;export function odd(n) &#123; return n !== 0 &amp;&amp; even(n - 1);&#125;$ babel-node&gt; import * as m from &apos;./even.js&apos;;&gt; m.even(10);true&gt; m.counter6&gt; m.even(20)true&gt; m.counter17// 要是改写成 CommonJS，就根本无法执行，会报错：// even.js 加载 odd.js，而 odd.js 又去加载 even.js，形成 &quot;循环加载&quot;。这时，执行引擎就会输出 even.js 已经执行的部分（不存在任何结果），// 所以在 odd.js 之中，变量 even 等于 null，等到后面调用 even(n-1) 就会报错。 2、ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 module","slug":"es6/module","date":"2018-03-01T13:04:42.000Z","updated":"2018-04-22T13:39:26.000Z","comments":true,"path":"es6/module/","link":"","permalink":"http://blog.master-ss.cn/es6/module/","excerpt":"历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。","text":"历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 一、简介12345678910// CommonJS 模块let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);// 等同于let _fs = require(&apos;fs&apos;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; // ES6 模块import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; 上面 CommonJS 模块代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象，然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。上面 ES6 模块代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为 “编译时加载” 或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 二、export 命令export 命令用于规定模块的对外接口，一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// profile.jsexport var firstName = &apos;Michael&apos;;export var lastName = &apos;Jackson&apos;;export var year = 1958; // 等同于（后面方式更为推荐）var firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123;firstName, lastName, year&#125;; // export 命令除了输出变量，还可以输出函数或类export function multiply(x, y) &#123; return x * y;&#125;; // export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; // export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系export 1; // 报错var m = 1;export m; // 报错export var m = 1; // 正确写法一export &#123;m&#125;; // 正确写法二var n = 1;export &#123;n as m&#125;; // 正确写法三 // function 和 class 的输出，也必须遵守这样的写法function f() &#123;&#125;export f; // 报错export function f() &#123;&#125;; // 正确export &#123;f&#125;; // 正确 // export 语句输出的接口，与其对应的值是动态绑定关系（输出变量 foo，值为 bar，500 毫秒之后变成 baz，与 CommonJS 规范完全不同）export var foo = &apos;bar&apos;;setTimeout(() =&gt; foo = &apos;baz&apos;, 500); // export 命令需要处于模块顶层。如果处于块级作用域内，就会报错，因为这样就没法做静态优化了function foo() &#123; export default &apos;bar&apos; // SyntaxError&#125;foo() 三、import 命令使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// main.js（大括号里面的变量名，必须与被导入模块 profile.js 对外接口的名称相同）import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;function setName(element) &#123; element.textContent = firstName + &apos; &apos; + lastName;&#125; // import 命令要使用 as 关键字，将输入的变量重命名import &#123; lastName as surname &#125; from &apos;./profile.js&apos;; // import 命令输入的变量都是只读的，不允许在加载模块的脚本里面，改写接口import &#123;a&#125; from &apos;./xxx.js&apos;a = &#123;&#125;; // Syntax Error : &apos;a&apos; is read-only;// 但是，如果 a 是一个对象，改写 a 的属性是允许的，其他模块也可以读到改写后的值，不过这种写法很难查错，不建议a.foo = &apos;hello&apos;; // 合法操作 // import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。模块名不带有路径，必须有配置文件告诉 JavaScript 引擎该模块的位置import &#123;myMethod&#125; from &apos;util&apos;; // import 命令具有提升效果，会提升到整个模块的头部，首先执行foo(); // 不会报错，因为 import 的执行早于 foo 的调用。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前import &#123; foo &#125; from &apos;my_module&apos;; // import 是静态执行，所以不能使用表达式和变量import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;; // 报错let module = &apos;my_module&apos;;import &#123; foo &#125; from module; // 报错if (x === 1) &#123; // 报错 import &#123; foo &#125; from &apos;module1&apos;;&#125; else &#123; import &#123; foo &#125; from &apos;module2&apos;;&#125; // import 语句会执行所加载的模块import &apos;lodash&apos;; // 代码仅仅执行 lodash 模块，但是不输入任何值 // 多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次import &apos;lodash&apos;;import &apos;lodash&apos;; // 加载了两次 lodash，但是只会执行一次 // import 语句是 Singleton 模式import &#123; foo &#125; from &apos;my_module&apos;;import &#123; bar &#125; from &apos;my_module&apos;;// 等同于import &#123; foo, bar &#125; from &apos;my_module&apos;; // 通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做，可能不会得到预期结果。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的require(&apos;core-js/modules/es6.symbol&apos;);require(&apos;core-js/modules/es6.promise&apos;);import React from &apos;React&apos;; 四、模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。12345678910111213141516171819202122// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; // main.js（逐一指定要加载的方法）import &#123; area, circumference &#125; from &apos;./circle&apos;;console.log(&apos;圆面积：&apos; + area(4));console.log(&apos;圆周长：&apos; + circumference(14)); // main.js（整体加载的写法）import * as circle from &apos;./circle&apos;;console.log(&apos;圆面积：&apos; + circle.area(4));console.log(&apos;圆周长：&apos; + circle.circumference(14)); // 模块整体加载所在的对象是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的import * as circle from &apos;./circle&apos;;circle.foo = &apos;hello&apos;;circle.area = function () &#123;&#125;; 五、export default 命令使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。这个时候就要用到 export default 命令，为模块指定默认输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125; // import-default.js（import 命令可以为该默认函数指定任意名字，后面不使用大括号。）import customName from &apos;./export-default&apos;;customName(); // &apos;foo&apos; // export-default.js（用在非匿名函数前，也是可以的；函数名 foo，在模块外部是无效的，加载的时候，视同匿名函数加载）export default function foo() &#123; console.log(&apos;foo&apos;);&#125;// 或者写成function foo() &#123; console.log(&apos;foo&apos;);&#125;export default foo; // modules.js（export default 命令用于指定模块的默认输出，只能使用一次）function add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add; // app.js（export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字）import &#123; default as foo &#125; from &apos;modules&apos;;// 等同于// import foo from &apos;modules&apos;; // 因为 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句export var a = 1; // 正确var a = 1;export default a; // 正确export default var a = 1; // 错误 // 也可以直接将一个值写在 export default 之后export default 42; // 正确export 42; // 报错 // 有了 export default 命令，输入模块时就非常直观了import _ from &apos;lodash&apos;; // 在一条 import 语句中，同时输入默认方法和其他接口import _, &#123; each, each as forEach &#125; from &apos;lodash&apos;; // 对应上面代码的 export 语句如下export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; // 暴露出 forEach 接口，默认指向 each 接口 // export default 也可以用来输出类// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from &apos;MyClass&apos;;let o = new MyClass(); 六、export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起。1234567891011121314151617181920212223242526// 写成一行以后，foo 和 bar 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 foo 和 barexport &#123; foo, bar &#125; from &apos;my_module&apos;;// 可以简单理解为import &#123; foo, bar &#125; from &apos;my_module&apos;;export &#123; foo, bar &#125;; // 模块的接口改名和整体输出，也可以采用这种写法export &#123; foo as myFoo &#125; from &apos;my_module&apos;; // 接口改名export * from &apos;my_module&apos;; // 整体输出 // 默认接口的写法export &#123; default &#125; from &apos;foo&apos;; // 具名接口改为默认接口的写法export &#123; es6 as default &#125; from &apos;./someModule&apos;;// 等同于import &#123; es6 &#125; from &apos;./someModule&apos;;export default es6; // 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from &apos;./someModule&apos;; // 下面三种 import 语句，没有对应的复合写法import * as someIdentifier from &quot;someModule&quot;;import someIdentifier from &quot;someModule&quot;;import someIdentifier, &#123; namedIdentifier &#125; from &quot;someModule&quot;; 七、模块的继承模块之间也可以继承。假设有一个 circleplus 模块，继承了 circle 模块。1234567891011// circleplus.jsexport * from &apos;circle&apos;; // export * 命令会忽略 circle 模块的 default 方法export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; // main.jsimport * as math from &apos;circleplus&apos;;import exp from &apos;circleplus&apos;; // 将 circleplus 模块的默认方法加载为 exp 方法console.log(exp(math.e)); 八、跨模块常量const 声明的常量只在当前代码块有效，如果想设置跨模块的常量或者一个值要被多个模块共享，可以采用下面的写法。1234567891011121314151617181920212223242526272829// constants.js 模块export const A = 1;export const B = 3;export const C = 4; // test1.js 模块import * as constants from &apos;./constants&apos;;console.log(constants.A); // 1console.log(constants.B); // 3 // test2.js 模块import &#123;A, B&#125; from &apos;./constants&apos;;console.log(A); // 1console.log(B); // 3 // 如果要使用的常量非常多，可以建一个专门的 constants 目录export const db = &#123; // constants/db.js url: &apos;http://my.couchdbserver.local:5984&apos;, admin_username: &apos;admin&apos;, admin_password: &apos;admin password&apos;&#125;;export const users = [&apos;root&apos;, &apos;admin&apos;, &apos;staff&apos;, &apos;ceo&apos;, &apos;chief&apos;, &apos;moderator&apos;]; // constants/user.js // constants/index.js（将这些文件输出的常量，合并在 index.js 里面）export &#123;db&#125; from &apos;./db&apos;;export &#123;users&#125; from &apos;./users&apos;; // script.js（使用的时候，直接加载 index.js 就可以了）import &#123;db, users&#125; from &apos;./index&apos;; 九、import()前面介绍过，import 命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行。这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。因此有一个提案，建议引入 import() 函数完成动态加载。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之对象扩展","slug":"es6/object-expand","date":"2018-02-01T05:58:19.000Z","updated":"2018-04-22T13:48:44.000Z","comments":true,"path":"es6/object-expand/","link":"","permalink":"http://blog.master-ss.cn/es6/object-expand/","excerpt":"ES6 扩展了对象。","text":"ES6 扩展了对象。 一、属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 属性简写const foo = &apos;bar&apos;;const baz = &#123;foo&#125;;baz // &#123;foo: &quot;bar&quot;&#125;const baz = &#123;foo: foo&#125;; // 等同于 // 方法简写const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;const o = &#123; // 等同于 method: function() &#123; return &quot;Hello!&quot;; &#125;&#125;; // CommonJS 模块输出一组变量非常合适使用简洁写法let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;module.exports = &#123; // 等同于 getItem: getItem, setItem: setItem, clear: clear&#125;; // 简洁写法的属性名总是字符串，所以不会因为 class 属于关键字，而导致语法解析报错const obj = &#123; class () &#123;&#125;&#125;;var obj = &#123; // 等同于 &apos;class&apos;: function() &#123;&#125;&#125;; // 如果某个方法的值是一个 Generator 函数，前面需要加上星号const obj = &#123; * m() &#123; yield &apos;hello world&apos;; &#125;&#125;; 二、属性名表达式JavaScript 定义对象的属性，有两种方法。方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。1234567891011121314151617181920212223242526272829303132333435363738394041obj.foo = true; // 方法一obj[&apos;a&apos; + &apos;bc&apos;] = 123; // 方法二 // 如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性var obj = &#123; foo: true, abc: 123&#125;; // ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名let lastWord = &apos;last word&apos;;const a = &#123; &apos;first word&apos;: &apos;hello&apos;, [lastWord]: &apos;world&apos;&#125;;a[&apos;first word&apos;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&apos;last word&apos;] // &quot;world&quot; // 表达式还可以用于定义方法名let obj = &#123; [&apos;h&apos; + &apos;ello&apos;]() &#123; return &apos;hi&apos;; &#125;&#125;;obj.hello() // hi // 属性名表达式与简洁表示法，不能同时使用，会报错const foo = &apos;bar&apos;;const bar = &apos;abc&apos;;const baz = &#123; [foo] &#125;; // 报错const baz = &#123; [foo]: &apos;abc&apos;&#125;; // 正确 // 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 [object Object]const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &apos;valueA&apos;, [keyB]: &apos;valueB&apos;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;，[keyA] 和 [keyB] 得到的都是 [object Object]，[keyB] 会把 [keyA] 覆盖掉 三、方法的 name 属性函数的 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。123456789101112131415161718192021222324252627282930313233343536// 方法的 name 属性返回函数名（即方法名）const person = &#123; sayName() &#123; console.log(&apos;hello!&apos;); &#125;,&#125;;person.sayName.name // &quot;sayName&quot; // 对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上 get 和 setconst obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name // TypeError: Cannot read property &apos;name&apos; of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);descriptor.get.name // &quot;get foo&quot;descriptor.set.name // &quot;set foo&quot; // Function 构造函数创造的函数，name 属性返回 anonymous(new Function()).name // &quot;anonymous&quot; // bind 方法创造的函数，name 属性返回 bound 加上原函数的名字var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // &quot;bound doSomething&quot; // 对象的方法是一个 Symbol 值，那么 name 属性返回的是 Symbol 值的描述const key1 = Symbol(&apos;description&apos;);const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name // &quot;[description]&quot;obj[key2].name // &quot;&quot; 四、Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及 +0 等于 -0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。ES6 提出 “Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是 +0 不等于 -0，二是 NaN 等于自身。12345+0 === -0 //trueNaN === NaN // false Object.is(+0, -0) // falseObject.is(NaN, NaN) // true 五、Object.assign()Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; // 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; // 如果只有一个参数，Object.assign 会直接返回该参数const obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true // 如果该参数不是对象，则会先转成对象，然后返回typeof Object.assign(2) // &quot;object&quot; // 由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错Object.assign(undefined) // 报错Object.assign(null) // 报错 // 如果非对象参数出现在源对象的位置（即非首参数），这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 undefined 和 null 不在首参数，就不会报错let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true // 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果const v1 = &apos;abc&apos;;const v2 = true;const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; // 上述结果是因为数值和布尔值都会被忽略，只有字符串的包装对象，会产生可枚举属性Object(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10) // &#123;[[PrimitiveValue]]: 10&#125;Object(&apos;abc&apos;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125; // Object.assign只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）Object.assign(&#123;b: &apos;c&apos;&#125;, Object.defineProperty(&#123;&#125;, &apos;invisible&apos;, &#123; enumerable: false, value: &apos;hello&apos; &#125;))// &#123; b: &apos;c&apos; &#125; // 属性名为 Symbol 值的属性，也会被 Object.assign 拷贝Object.assign(&#123; a: &apos;b&apos; &#125;, &#123; [Symbol(&apos;c&apos;)]: &apos;d&apos; &#125;)// &#123; a: &apos;b&apos;, Symbol(c): &apos;d&apos; &#125; // Object.assign 方法实行的是浅拷贝，而不是深拷贝const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 // 对于嵌套的对象，一旦遇到同名属性，Object.assign 的处理方法是替换const target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;const source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; // Object.assign 可以用来处理数组，但是会把数组视为属性名为 0、1、2... 的对象Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] // Object.assign 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制const source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125;// 应用：为属性指定默认值（代码原意是将 url.port 改成 8000，url.host 不变，实际结果却是 options.url 覆盖掉 DEFAULTS.url）const DEFAULTS = &#123; url: &#123; host: &apos;example.com&apos;, port: 7070 &#125;,&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options);&#125;processContent(&#123; url: &#123;port: 8000&#125; &#125;)// &#123;// url: &#123;port: 8000&#125;// &#125; 六、属性的可枚举性和遍历对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略 enumerable 为 false 的属性。1、for…in 循环：只遍历对象自身的和继承的可枚举的属性。2、Object.keys()：返回对象自身的所有可枚举的属性的键名。3、JSON.stringify()：只串行化对象自身的可枚举的属性。4、Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。实际上，引入”可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉 for…in 操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的 toString 方法，以及数组的 length 属性，就通过”可枚举性”，从而避免被 for…in 遍历到。ES6 一共有 5 种方法可以遍历对象的属性：1、for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。2、Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。3、Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。4、Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性的键名。5、Reflect.ownKeys 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则：1、首先遍历所有数值键，按照数值升序排列。2、其次遍历所有字符串键，按照加入时间升序排列。3、最后遍历所有 Symbol 键，按照加入时间升序排列。12345678910111213141516// Object.getOwnPropertyDescriptor 方法获取该属性的描述对象let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; // 规避 for...in 操作Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable // falseObject.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable // false // ES6 规定，所有 Class 的原型的方法都是不可枚举的Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &apos;foo&apos;).enumerable // false 七、Object.getOwnPropertyDescriptors()前面说过，Object.getOwnPropertyDescriptor 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors 方法，返回指定对象所有自身属性（非继承属性）的描述对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const obj = &#123; foo: 123, get bar() &#123; return &apos;abc&apos; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; // Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, &apos;foo&apos;)// &#123; value: undefined,// writable: true,// enumerable: true,// configurable: true &#125; // 解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, &apos;foo&apos;)// &#123; get: undefined,// set: [Function: set foo],// enumerable: true,// configurable: true &#125; // 两个对象合并的逻辑可以写成一个函数const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); // 配合 Object.create 方法，将对象属性克隆到一个新对象（浅拷贝）const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); // 继承另一个对象const obj = &#123; __proto__: prot, foo: 123,&#125;; // ES6 规定 __proto__ 只有浏览器要部署，其他环境需改写const obj = Object.create(prot);obj.foo = 123;// 或者const obj = Object.assign( Object.create(prot), &#123; foo: 123, &#125;); 八、__proto__ &amp; Object.setPrototypeOf() &amp; Object.getPrototypeOf()JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// __proto__ 由于浏览器广泛支持被加入了 ES6。只有浏览器必须部署这个属性，其他运行环境不一定需要部署，最好认为这个属性是不存在的const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj; // es6 的写法var obj = Object.create(someOtherObj); // es5 的写法obj.method = function() &#123; ... &#125;; // 如果一个对象本身部署了 __proto__ 属性，该属性的值就是对象的原型Object.getPrototypeOf(&#123; __proto__: null &#125;) // null // Object.setPrototypeOf 方法的作用与 __proto__ 相同，用来设置一个对象的 prototype 对象Object.setPrototypeOf(object, prototype) // 格式let proto = &#123;&#125;; // 案例let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 // 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果Object.setPrototypeOf(1, &#123;&#125;) === 1 // trueObject.setPrototypeOf(&apos;foo&apos;, &#123;&#125;) === &apos;foo&apos; // trueObject.setPrototypeOf(true, &#123;&#125;) === true // true // 由于 undefined 和 null 无法转为对象，所以如果第一个参数是 undefined 或 null，就会报错Object.setPrototypeOf(undefined, &#123;&#125;) // TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, &#123;&#125;) // // TypeError: Object.setPrototypeOf called on null or undefined // Object.getPrototypeOf 方法与 Object.setPrototypeOf 方法配套，用于读取一个对象的原型对象function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype // trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype // false // 如果参数不是对象，会被自动转为对象// 等同于 Object.getPrototypeOf(Number(1))Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;// 等同于 Object.getPrototypeOf(String(&apos;foo&apos;))Object.getPrototypeOf(&apos;foo&apos;) // String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;// 等同于 Object.getPrototypeOf(Boolean(true))Object.getPrototypeOf(true) // Boolean &#123;[[PrimitiveValue]]: false&#125;Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf(&apos;foo&apos;) === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true // 如果参数是 undefined 或 null，它们无法转为对象，所以会报错Object.getPrototypeOf(null) // TypeError: Cannot convert undefined or null to objectObject.getPrototypeOf(undefined) // TypeError: Cannot convert undefined or null to object 九、super 关键字this 关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。123456789101112131415161718192021222324252627282930313233343536373839const proto = &#123; foo: &apos;hello&apos;&#125;;const obj = &#123; find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot; // super 关键字表示原型对象时，只能用在对象的方法（简写法）之中，用在其他地方都会报错const obj = &#123; foo: super.foo // 报错，用在属性里面&#125;const obj = &#123; foo: () =&gt; super.foo // 报错，没有用简写法&#125;const obj = &#123; foo: function () &#123; return super.foo // 报错，没有用简写法 &#125;&#125; // super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）const proto = &#123; x: &apos;hello&apos;, foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: &apos;world&apos;, foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto); // 绑定的this 还是当前对象 objobj.foo() // &quot;world&quot; 十、Object.keys() &amp; Object.values() &amp; Object.entries()ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。ES2017 引入了跟 Object.keys 配套的 Object.values 和 Object.entries，作为遍历一个对象的补充手段，供 for…of 循环使用。123456789101112131415161718192021222324252627282930313233343536let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]&#125;// Object.values 会过滤属性名为 Symbol 值的属性Object.values(&#123; [Symbol()]: 123, foo: &apos;abc&apos; &#125;); // [&apos;abc&apos;] // 如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组Object.values(&apos;foo&apos;) // [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;] // 如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组Object.values(42) // []Object.values(true) // [] // Object.entries 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;Object.entries(obj) // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] // 如果原对象的属性名是一个 Symbol 值，该属性会被忽略Object.entries(&#123; [Symbol()]: 123, foo: &apos;abc&apos; &#125;); // [ [ &apos;foo&apos;, &apos;abc&apos; ] ] // 应用：将对象转为真正的 Map 结构const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125; 十一、对象的扩展运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; // 如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 // 解构赋值必须是最后一个参数，否则会报错let &#123; ...x, y, z &#125; = obj; // 句法错误let &#123; x, ...y, ...z &#125; = obj; // 句法错误 // 解构赋值的拷贝是浅拷贝let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 // 扩展运算符的解构赋值，不能复制继承来自原型对象的属性let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined // 另一个例子const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;x // 1y // undefinedz // 3 // 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，等同于使用 Object.assign 方法let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; // 完整克隆一个对象，同时拷贝对象原型的属性const clone1 = &#123; // 写法一 __proto__: Object.getPrototypeOf(obj), ...obj&#125;;const clone2 = Object.assign( // 写法二 Object.create(Object.getPrototypeOf(obj)), obj);const clone3 = Object.create( // 写法三 Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) // 扩展运算符可以用于合并两个对象let ab = &#123; ...a, ...b &#125;;let ab = Object.assign(&#123;&#125;, a, b); // 等同于 // 用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉（注意这不是解构赋值，否则必须是最后一个参数）let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;; // 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;; // 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); // 等同于 // 修改现有对象部分的属性就很方便let newVersion = &#123; ...previousVersion, name: &apos;New Name&apos; // Override the name property&#125;; // 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a); // 等同于let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a); // 等同于 // 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;; // 如果扩展运算符后面是一个空对象，则没有任何效果&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125; // 如果扩展运算符的参数是 null 或 undefined，这两个值会被忽略，不会报错let emptyObject = &#123; ...null, ...undefined &#125;; // 不报错// 并不会抛出错误，因为 x 属性只是被定义，但没执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error(&apos;not throw yet&apos;); &#125;&#125;;// 会抛出错误，扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的，所以 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error(&apos;throw now&apos;); &#125; &#125;&#125;; 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之数组扩展","slug":"es6/array-expand","date":"2018-01-31T01:49:55.000Z","updated":"2018-04-22T14:03:50.000Z","comments":true,"path":"es6/array-expand/","link":"","permalink":"http://blog.master-ss.cn/es6/array-expand/","excerpt":"ES6 扩展了数组。","text":"ES6 扩展了数组。 一、扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5 [...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] // 主要用于函数调用function push(array, ...items) &#123; array.push(...items);&#125; // 扩展运算符与正常的函数参数可以结合使用，非常灵活function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); // 扩展运算符后面还可以放置表达式const arr = [ ...(x &gt; 0 ? [&apos;a&apos;] : []), &apos;b&apos;,]; // 扩展运算符后面是一个空数组，则不产生任何效果[...[], 1]// [1] // 替代函数的 apply 方法Math.max.apply(null, [14, 3, 77]) // ES5 的写法Math.max(...[14, 3, 77]) // ES6 的写法Math.max(14, 3, 77); // 等同于 // bind 用于绑定参数，apply 使 bind 内部的 this 绑定 Datenew (Date.bind.apply(Date, [null, 2015, 1, 1])) // ES5new Date(...[2015, 1, 1]); // ES6 // 扩展运算符复制数组const a1 = [1, 2];const a2 = a1;a2[0] = 2;// 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组a1 // [2, 2]// ES5 只能用变通方法来复制数组const a2 = a1.concat();// 扩展运算符提供了复制数组的简便写法const a2 = [...a1];const [...a2] = a1; // 扩展运算符提供了数组合并的新写法var arr1 = [&apos;a&apos;, &apos;b&apos;];var arr2 = [&apos;c&apos;];var arr3 = [&apos;d&apos;, &apos;e&apos;];arr1.concat(arr2, arr3); // ES5 的合并数组，[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ][...arr1, ...arr2, ...arr3] // ES6 的合并数组，[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] // 扩展运算符与解构赋值结合a = list[0], rest = list.slice(1) // ES5[a, ...rest] = list // ES6const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] // 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 // 扩展运算符将字符串转为真正的数组[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] // 扩展运算符能够正确识别四个字节的 Unicode 字符&apos;x\\uD83D\\uDE80y&apos;.length // 4[...&apos;x\\uD83D\\uDE80y&apos;].length // 3 // 用扩展运算符将实现了 Iterator 接口的对象转为真正的数组let nodeList = document.querySelectorAll(&apos;div&apos;);let array = [...nodeList]; // 没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; // 用扩展运算符遍历 Map、Set 结构let map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);let arr = [...map.keys()]; // [1, 2, 3] // 用扩展运算符遍历 Generator 函数const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] // 没有 Iterator 接口的对象，使用扩展运算符，将会报错const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 二、Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）1234567891011121314151617181920212223242526272829303132let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;var arr1 = [].slice.call(arrayLike); // // ES5 的写法，[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]let arr2 = Array.from(arrayLike); // ES6 的写法，[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // 只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] // 参数是一个真正的数组，Array.from 会返回一个一模一样的新数组Array.from([1, 2, 3])// [1, 2, 3] // Array.from 方法还支持转换类似数组的对象，即必须有 length 属性Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] // Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组Array.from(arrayLike, x =&gt; x * x);Array.from(arrayLike).map(x =&gt; x * x); // 等同于Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] // Array.from 可以将字符串转为数组，然后返回字符串的长度，可以避免 JavaScript 将大于 \\uFFFF 的 Unicode 字符function countSymbols(string) &#123; return Array.from(string).length;&#125; 三、Array.of()Array.of 方法用于将一组值，转换为数组，用于弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。1234567891011Array() // []// 参数个数只有一个时，实际上是指定数组的长度Array(3) // [, , ,]// 只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组Array(3, 11, 8) // [3, 11, 8] // Array.of 基本上可以用来替代 Array() 或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 四、copyWithin()数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。12345678910111213141516171819202122232425Array.prototype.copyWithin(target, start = 0, end = this.length)// target（必需）：从该位置开始替换数据。如果为负值，表示倒数。// start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 // 从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] // 将 3 号位复制到 0 号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5] // -2 相当于 3 号位，-1 相当于 4 号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5] // 将 3 号位复制到 0 号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125; // 将 2 号位到数组结束，复制到 0 号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5] 五、find() &amp; findIndex()数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1。1234567891011121314151617181920// 接受三个参数，依次为当前的值、当前的位置和原数组[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 // 接受三个参数，依次为当前的值、当前的位置和原数组[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 // 这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &apos;John&apos;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 // 这两个方法都可以发现 NaN，弥补了数组的 indexOf 方法的不足（findIndex 方法可以借助 Object.is 方法做到）[NaN].indexOf(NaN) // -1[NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 六、fill()fill方法使用给定值，填充一个数组。123456789101112131415161718192021// 数组中已有的元素，会被全部抹去[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7] // fill 方法用于空数组的初始化非常方便new Array(3).fill(7)// [7, 7, 7] // fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] // 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);arr[0].name = &quot;Ben&quot;;arr// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 七、entries()、keys() &amp; values()ES6 提供三个新的方法——entries()，keys() 和 values()——用于遍历数组，它们都返回一个遍历器对象可以用 for…of 循环进行遍历。1234567891011121314151617181920// keys() 是对键名的遍历for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1 // values() 是对键值的遍历for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos; // entries() 是对键值对的遍历for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 八、includes()Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。12345678910111213[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true // 第二个参数表示搜索的起始位置，默认为 0[1, 2, 3].includes(3, 3); // false// 如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4，但数组长度为 3），则会重置为从 0 开始[1, 2, 3].includes(3, -1); // true// indexOf 不够语义化，需要去比较是否不等于 -1 而且内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判[NaN].indexOf(NaN) // -1// includes 使用的是不一样的判断算法，就没有这个问题[NaN].includes(NaN) 另外，Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。Map 结构的 has 方法，是用来查找键名的，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。Set 结构的 has 方法，是用来查找值的，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。 九、数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位。12345678910111213141516171819202122232425262728293031323334353637383940414243444546Array(3) // [, , ,] // 空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点0 in [undefined, undefined, undefined] // true0 in [, , ,] // false // forEach(), filter(), reduce(), every() 和 some() 都会跳过空位[,&apos;a&apos;].forEach((x,i) =&gt; console.log(i)); // 1[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;][,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true[1,,2].reduce((x,y) =&gt; return x+y) // 3[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false // map 会跳过空位，但会保留这个值[,&apos;a&apos;].map(x =&gt; 1) // [,1] // join() 和 toString() 会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot; // Array.from 会将空位转为 undefinedArray.from([&apos;a&apos;,,&apos;b&apos;]) // [ &quot;a&quot;, undefined, &quot;b&quot; ] // 扩展运算符会将空位转为 undefined[...[&apos;a&apos;,,&apos;b&apos;]] // [ &quot;a&quot;, undefined, &quot;b&quot; ] // copyWithin 会连空位一起拷贝[,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;] // fill 会将空位视为正常的数组位置new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] // for...of 循环会遍历空位let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 // entries()、keys()、values()、find() 和 findIndex() 会将空位处理成 undefined[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]][...[,&apos;a&apos;].keys()] // [0,1][...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;][,&apos;a&apos;].find(x =&gt; true) // undefined[,&apos;a&apos;].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之函数扩展","slug":"es6/function-expand","date":"2018-01-29T11:56:03.000Z","updated":"2018-04-22T14:03:43.000Z","comments":true,"path":"es6/function-expand/","link":"","permalink":"http://blog.master-ss.cn/es6/function-expand/","excerpt":"ES6 扩展了函数。","text":"ES6 扩展了函数。 一、函数参数的默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function log(x, y) &#123; y = y || &apos;World&apos;; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello China// 如果参数 y 赋值了，但是对应的布尔值为 false，则该赋值不起作用。就像参数 y 等于空字符，结果被改为默认值log(&apos;Hello&apos;, &apos;&apos;) // Hello World // 为了避免这个问题，通常需要先判断一下参数 y 是否被赋值if (typeof y === &apos;undefined&apos;) &#123; y = &apos;World&apos;;&#125; // ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello // 参数变量是默认声明的，所以不能用 let 或 const 再次声明function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; // 使用参数默认值时，函数不能有同名参数function foo(x, x, y) &#123; // 不报错&#125;function foo(x, x, y = 1) &#123; // 报错。SyntaxError: Duplicate parameter name not allowed in this context&#125; // 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 // 参数默认值可以与解构赋值的默认值，结合起来使用function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &apos;x&apos; of undefined // 提供函数参数的默认值，避免报错function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 // 练习// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] // 参数默认值的位置（如果非尾部的参数设置默认值，实际上这个参数是没法省略的）// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错// 例二f(undefined, 1) // [1, 1]function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] // 如果传入 undefined，将触发该参数等于默认值，null 则没有这个效果function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null // 函数的 length 属性（返回没有指定默认值的参数个数。指定了默认值后，length 属性将失真）(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2// rest 参数也不会计入 length 属性(function(...args) &#123;&#125;).length // 0// 如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1// 作用域（一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的）var x = 1;function f(x, y = x) &#123; console.log(y);&#125;// 参数 y 的默认值等于变量 x。调用函数 f 时，默认值变量 x 指向第一个参数x，而不是全局变量 x，所以输出是2f(2) // 2 let x = 1; // 全局变量 x 如果不存在会报错（ReferenceError: x is not defined）function f(y = x) &#123; let x = 2; console.log(y);&#125;// 函数 f 调用时，变量 x 本身没有定义，所以指向外层的全局变量 x 。函数调用时，函数体内部的局部变量 x 影响不到默认值变量 x。f() // 1 var x = 1;function foo(x = x) &#123; // ...&#125;// 数 x = x 形成一个单独作用域。实际执行的是 let x = x，由于暂时性死区的原因，这行代码会报错 ”x 未定义“foo() // ReferenceError: x is not defined // y 的默认值是一个匿名函数。这个匿名函数内部的变量 x，指向同一个作用域的第一个参数 x。函数 foo 内部又声明了一个内部变量 x，// 该变量与第一个参数 x 由于不是同一个作用域，所以不是同一个变量，因此执行 y 后，内部变量 x 和外部全局变量 x 的值都没变var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 // 如果将 var x = 3 的 var 去除，函数 foo 的内部变量 x 就指向第一个参数 x，与匿名函数内部的 x 是一致的，所以最后输出的就是 2，// 而外层的全局变量 x 依然不受影响var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 二、rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。123456789101112131415161718192021222324252627// arguments 变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125; // rest 参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); // rest 参数改写数组 push 方法function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) // rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错function f(a, ...b, c) &#123; // 报错 // ...&#125;// 函数的 length 属性，不包括 rest 参数(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 三、严格模式从 ES5 开始，函数内部可以设定为严格模式。ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。12345678910111213141516171819// 报错function doSomething(a, b = a) &#123; &apos;use strict&apos;; // code&#125; // 设定全局性的严格模式规避限制&apos;use strict&apos;;function doSomething(a, b = a) &#123; // code&#125; // 函数包在一个无参数的立即执行函数里面规避限制const doSomething = (function () &#123; &apos;use strict&apos;; return function(value = 42) &#123; return value; &#125;;&#125;()); 四、name 属性函数的 name 属性，返回该函数的函数名。ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。12345678910111213var f = function () &#123;&#125;;// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot; // Function 构造函数返回的函数实例，name 属性的值为 anonymous(new Function).name // &quot;anonymous&quot; // bind 返回的函数，name 属性值会加上 bound 前缀function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot; 五、函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。123456789function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( &apos;foo&apos;, &apos;bar&apos;,); 六、箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var f = v =&gt; v; // 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分var f = () =&gt; 5;var sum = (num1, num2) =&gt; num1 + num2; // 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; // 如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;; // 报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); // // 不报错 // 箭头函数可以与变量解构结合使用const full = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last; // rest 参数与箭头函数结合const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数，this 总是指向函数定义生效时所在的对象 setInterval(() =&gt; this.s1++, 1000); // 普通函数，执行时 this 应该指向全局对象 window setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);// s1: 3// s2: 0 // 所有的内层函数都是箭头函数，都没有自己的 this，它们的 this 其实都是最外层 foo 函数的 thisfunction foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 箭头函数有几个使用注意点：（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之数值扩展","slug":"es6/number-expand","date":"2018-01-29T05:58:07.000Z","updated":"2018-04-22T13:43:40.000Z","comments":true,"path":"es6/number-expand/","link":"","permalink":"http://blog.master-ss.cn/es6/number-expand/","excerpt":"ES6 扩展了数值。","text":"ES6 扩展了数值。 一、Number.isFinite() &amp; Number.isNaN()ES6 在 Number 对象上，新提供了 Number.isFinite() 和 Number.isNaN() 两个方法。Number.isFinite() 用来检查一个数值是否为有限的（finite），即不是 Infinity。注意，如果参数类型不是数值，Number.isFinite 一律返回 false。Number.isNaN() 用来检查一个值是否为 NaN。注意，如果参数类型不是数值，Number.isNaN 一律返回 false。12345678910111213141516Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // false Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN(&apos;15&apos;) // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN(&apos;true&apos; / 0) // trueNumber.isNaN(&apos;true&apos; / &apos;true&apos;) // true 它们与传统的全局方法 isFinite() 和 isNaN() 的区别在于，传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite() 对于非数值一律返回 false, Number.isNaN() 只有对于 NaN 才返回 true，非 NaN 一律返回 false。 二、Number.parseInt(), Number.parseFloat()ES6 将全局方法 parseInt() 和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。12345678910// ES5的写法parseInt(&apos;12.34&apos;) // 12parseFloat(&apos;123.45#&apos;) // 123.45 // ES6的写法Number.parseInt(&apos;12.34&apos;) // 12Number.parseFloat(&apos;123.45#&apos;) // 123.45 Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true 三、Number.isInteger()Number.isInteger() 用来判断一个数值是否为整数。12345678910111213141516Number.isInteger(25) // trueNumber.isInteger(25.1) // false // JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值Number.isInteger(25) // trueNumber.isInteger(25.0) // true // 如果参数不是数值，Number.isInteger 返回 false。Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger(&apos;15&apos;) // falseNumber.isInteger(true) // false // 5E-325 由于值太小，会被自动转为 0，因此返回 true。如果对数据精度的要求较高，不建议使用 Number.isInteger() 判断一个数值是否为整数Number.isInteger(5E-324) // falseNumber.isInteger(5E-325) // true 四、Number.EPSILONES6 在 Number 对象上面，新增一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。Number.EPSILON 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的，Number.EPSILON 可以用来设置 “能够接受的误差范围”。1234567Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16 5.551115123125783e-17 &lt; Number.EPSILON// true 五、Number.isSafeInteger()JavaScript 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了 Number.MAX_SAFE_INTEGER 和Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。1234567891011121314151617181920212223242526272829303132333435Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// true Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true // Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内Number.isSafeInteger(&apos;a&apos;) // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false // 使用这个函数时，不要只验证运算结果，而要同时验证参与运算的每个值Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 六、Math 对象的扩展1、Math.trunc()Math.trunc 方法用于去除一个数的小数部分，返回整数部分1234567891011121314151617Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 // 对于非数值，Math.trunc 内部使用 Number 方法将其先转为数值Math.trunc(&apos;123.456&apos;) // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(null) // 0 // 对于空值和无法截取整数的值，返回 NaNMath.trunc(NaN); // NaNMath.trunc(&apos;foo&apos;); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 2、Math.sign()Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。参数为正数，返回 +1；参数为负数，返回 -1；参数为 0，返回 0；参数为 -0，返回 -0；其他值，返回 NaN。123456789101112131415Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN // 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回 NaNMath.sign(&apos;&apos;) // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign(&apos;9&apos;) // +1Math.sign(&apos;foo&apos;) // NaNMath.sign() // NaNMath.sign(undefined) // NaN 3、Math.cbrt()Math.cbrt 方法用于计算一个数的立方根。12345678Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 // 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值Math.cbrt(&apos;8&apos;) // 2Math.cbrt(&apos;hello&apos;) // NaN 4、Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。12345678910111213141516171819Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 // 对于小数，Math.clz32方法只考虑整数部分Math.clz32(3.2) // 30Math.clz32(3.9) // 30 // 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算Math.clz32() // 32Math.clz32(NaN) // 32Math.clz32(Infinity) // 32Math.clz32(null) // 32Math.clz32(&apos;foo&apos;) // 32Math.clz32([]) // 32Math.clz32(&#123;&#125;) // 32Math.clz32(true) // 31 5、Math.imul()Math.imul 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。12345678Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 // Math.imul(a, b)与a * b的结果是相同的。因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示，Math.imul 方法可以返回正确的低位数值。(0x7fffffff * 0x7fffffff)|0 // 0// 因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul 方法可以返回正确的值 1Math.imul(0x7fffffff, 0x7fffffff) // 1 6、Math.fround()Math.fround 方法返回一个数的32位单精度浮点数形式。Math.fround 方法的主要作用，是将 64 位双精度浮点数转为 32 位单精度浮点数。如果小数的精度超过 24 个二进制位，返回值就会不同于原值，否则返回值不变（即与 64 位双精度值一致）。12345678910111213141516171819// 未丢失有效精度Math.fround(1.125) // 1.125Math.fround(7.25) // 7.25 // 丢失精度Math.fround(0.3) // 0.30000001192092896Math.fround(0.7) // 0.699999988079071Math.fround(1.0000000123) // 1 // 对于 NaN 和 Infinity，此方法返回原值Math.fround(NaN) // NaNMath.fround(Infinity) // Infinity // 其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数Math.fround(&apos;5&apos;) // 5Math.fround(true) // 1Math.fround(null) // 0Math.fround([]) // 0Math.fround(&#123;&#125;) // NaN 7、Math.hypot()Math.hypot 方法返回所有参数的平方和的平方根。12345678Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0// 参数不是数值，Math.hypot 方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaNMath.hypot(NaN); // NaNMath.hypot(3, 4, &apos;foo&apos;); // NaNMath.hypot(3, 4, &apos;5&apos;); // 7.0710678118654755Math.hypot(-3); // 3 8、Math.expm1(), Math.log1p(), Math.log10(), Math.log2()1234567891011121314151617181920212223242526// Math.expm1(x) 返回 Math.pow(e, x) - 1，即 Math.exp(x) - 1。Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 // Math.log1p(x) 方法返回 1 + x 的自然对数，即 Math.log(1 + x)。如果 x 小于 -1，返回 NaNMath.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN // Math.log10(x) 返回以 10 为底的 x 的对数。如果 x 小于 0，则返回 NaNMath.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 // Math.log2(x) 返回以 2 为底的 x 的对数。如果 x 小于 0，则返回 NaNMath.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 9、双曲函数方法Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 10、指数运算符12345678910111213141516172 ** 2 // 42 ** 3 // 8 // 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; // 在 V8 引擎中，指数运算符与 Math.pow 的实现不相同，对于特别大的运算结果，两者会有细微的差异Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197// 两个运算结果的最后一位有效数字是有差异的 ES2016 新增了一个指数运算符（**）","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之字符串扩展","slug":"es6/string-expand","date":"2018-01-28T06:56:48.000Z","updated":"2018-04-22T14:01:39.000Z","comments":true,"path":"es6/string-expand/","link":"","permalink":"http://blog.master-ss.cn/es6/string-expand/","excerpt":"ES6 扩展了字符串对象。","text":"ES6 扩展了字符串对象。 一、codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点；对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。1234567891011121314151617181920212223242526272829303132333435363738// 汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。var s = &quot;𠮷a&quot;;// JavaScript 不能正确处理，字符串长度会误判为2s.length // 2// charAt方法无法读取整个字符s.charAt(0) // &apos;&apos;s.charAt(1) // &apos;&apos;// charCodeAt方法只能分别返回前两个字节和后两个字节的值s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271s.codePointAt(2) // 97 let s = &apos;𠮷a&apos;;// JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）s.codePointAt(0) // 134071// 在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同s.codePointAt(1) // 57271s.codePointAt(2) // 97 let s = &apos;𠮷a&apos;;// codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString 方法转换一下s.codePointAt(0).toString(16) // &quot;20bb7&quot;s.codePointAt(2).toString(16) // &quot;61&quot; // 解决字符 a 在字符串 s 的位置序号问题let s = &apos;𠮷a&apos;;for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 // 测试一个字符由两个字节还是由四个字节组成的最简单方法function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(&quot;𠮷&quot;) // trueis32Bit(&quot;a&quot;) // false 二、String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。1234567String.fromCharCode(0x20BB7)// &quot;ஷ&quot;，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\\uD83D\\uDE80y&apos;// true，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 三、字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。12345678910111213141516171819for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; // 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点let text = String.fromCodePoint(0x20BB7);// 字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印）for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// &quot; &quot;// &quot; &quot;for (let i of text) &#123; console.log(i);&#125;// &quot;𠮷&quot;，而for...of循环会正确识别出这一个字符 四、normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。123456&apos;\\u01D1&apos;===&apos;\\u004F\\u030C&apos; //false&apos;\\u01D1&apos;.length // 1&apos;\\u004F\\u030C&apos;.length // 2 &apos;\\u01D1&apos;.normalize() === &apos;\\u004F\\u030C&apos;.normalize()// true 五、includes(), startsWith(), endsWith()传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。1、includes()：返回布尔值，表示是否找到了参数字符串。2、startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。3、endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。支持第二个参数，表示开始搜索的位置。12345678910let s = &apos;Hello world!&apos;; s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true // 使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false 六、repeat()repeat 方法返回一个新字符串，表示将原字符串重复 n 次。12345678910111213141516171819202122&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot; // 参数如果是小数，会被取整。&apos;na&apos;.repeat(2.9) // &quot;nana&quot; // 如果 repeat 的参数是负数或者 Infinity，会报错。&apos;na&apos;.repeat(Infinity)// RangeError&apos;na&apos;.repeat(-1)// RangeError // 如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于 -0，repeat 视同为 0。&apos;na&apos;.repeat(-0.9) // &quot;&quot; // 参数 NaN 等同于 0。&apos;na&apos;.repeat(NaN) // &quot;&quot; // 如果 repeat 的参数是字符串，则会先转换成数字。&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; 七、padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart() 用于头部补全，padEnd() 用于尾部补全。一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。12345678910111213141516171819202122232425&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos; // 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)// &apos;0123456abc&apos; // 如果省略第二个参数，默认使用空格补全长度&apos;x&apos;.padStart(4) // &apos; x&apos;&apos;x&apos;.padEnd(4) // &apos;x &apos; // padStart 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot; // 另一个用途是提示字符串格式&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-MM-12&quot;&apos;09-12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-09-12&quot; 八、模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 普通字符串`In JavaScript &apos;\\n&apos; is a line-feed.` // 多行字符串`In JavaScript this is not legal.` console.log(`string text line 1string text line 2`); // 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` // 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义let greeting = `\\`Yo\\` World!`; // 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用 trim 方法消除它$(&apos;#list&apos;).html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); // 模板字符串中嵌入变量，需要将变量名写在 $&#123;&#125; 之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// &quot;1 + 2 = 3&quot;`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// &quot;1 + 4 = 5&quot;let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot; // 模板字符串之中还能调用函数function fn() &#123; return &quot;Hello World&quot;;&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar // 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。如果模板字符串中的变量没有声明，将报错。let msg = `Hello, $&#123;place&#125;`;// 报错，变量 place 没有声明 // 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。`Hello $&#123;&apos;World&apos;&#125;`// &quot;Hello World&quot; // 模板字符串甚至还能嵌套const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join(&apos;&apos;)&#125; &lt;/table&gt;`;const data = [ &#123; first: &apos;&lt;Jane&gt;&apos;, last: &apos;Bond&apos; &#125;, &#123; first: &apos;Lars&apos;, last: &apos;&lt;Croft&gt;&apos; &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; // 如果需要引用模板字符串本身，在需要时执行// 写法一let str = &apos;return &apos; + &apos;`Hello $&#123;name&#125;!`&apos;;let func = new Function(&apos;name&apos;, str);func(&apos;Jack&apos;) // &quot;Hello Jack!&quot;// 写法二let str = &apos;(name) =&gt; `Hello $&#123;name&#125;!`&apos;;let func = eval.call(null, str);func(&apos;Jack&apos;) // &quot;Hello Jack!&quot; 九、标签模板模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数alert`123`// 等同于alert(123) // 如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);// 我们可以按照需要编写 tag 函数的代码function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return &quot;OK&quot;;&#125;// &quot;Hello &quot;// &quot; world &quot;// &quot;&quot;// 15// 50// &quot;OK&quot; // “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&apos;t escape special characters in the template. s += templateData[i]; &#125; return s;&#125; // 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。接受的参数，实际上是一个数组，该数组有一个 raw 属性，保存的是转义后的原字符串console.log`123` // tag函数的第一个参数 strings，有一个 raw 属性，也指向一个数组，数组中字符串里面的斜杠都被转义了tag`First line\\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 &quot;First line\\\\nSecond line&quot; // 打印输出 &quot;First line\\nSecond line&quot;&#125; 十、String.raw()1234567891011121314String.raw`Hi\\n$&#123;2+3&#125;!`;// 返回 &quot;Hi\\\\n5!&quot;String.raw`Hi\\u000A!`;// 返回 &quot;Hi\\\\u000A!&quot;// 如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义String.raw`Hi\\\\n`// 返回 &quot;Hi\\\\\\\\n&quot; // String.raw 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组String.raw(&#123; raw: &apos;test&apos; &#125;, 0, 1, 2);// &apos;t0e1s2t&apos;// 等同于String.raw(&#123; raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] &#125;, 0, 1, 2); ES6 还为原生的 String 对象，提供了一个raw方法。String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之解构赋值","slug":"es6/destructuring","date":"2018-01-26T09:42:56.000Z","updated":"2018-04-22T14:03:26.000Z","comments":true,"path":"es6/destructuring/","link":"","permalink":"http://blog.master-ss.cn/es6/destructuring/","excerpt":"ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 一、数组的解构赋值可以从数组中提取值，按照对应位置，对变量赋值。本质上等号两边的模式相同，左边的变量就会被赋予对应的值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596let [a, b, c] = [1, 2, 3];a // 1b // 2c // 3 let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3 let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot; let [x, , y] = [1, 2, 3];x // 1y // 3 let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4] let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] // 如果解构不成功，变量的值就等于undefinedlet [foo] = [];let [bar, foo] = [1]; // 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 // 等号的右边不是可遍历的结构，那么将会报错（要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口）let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; // 对于 Set 结构，也可以使用数组的解构赋值let [x, y, z] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);x // &quot;a&quot; // 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值（fibs是一个 Generator 函数，原生具有 Iterator 接口，解构赋值会依次从这个接口获取值）function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;// 0 1 1 2 3 5let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 // 解构赋值允许指定默认值let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; // ES6 内部使用严格相等运算符（===），判断一个位置是否有值let [x = 1] = [undefined];x // 1// null不严格等于undefinedlet [x = 1] = [null];x // null // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2// x 用 y 做默认值时，y 还没有声明let [x = y, y = 1] = []; // ReferenceError: y is not defined // 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值function f() &#123; console.log(&apos;aaa&apos;);&#125;let [x = f()] = [1];// 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 二、对象的解构赋值解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; // 变量没有对应的同名属性，导致取不到值，最后等于undefinedlet &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined // 变量名与属性名不一致时写法let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot; // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; // foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foolet &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined // 解构也可以用于嵌套结构的对象const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; // 对象的解构也可以指定默认值var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; // 默认值生效的条件是，对象的属性值严格等于undefinedvar &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3 // null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效var &#123;x = 3&#125; = &#123;x: null&#125;;x // null // 解构失败，变量的值等于undefined，如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。let &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;foo // undefined // 报错，相当于 let _tmp = &#123;baz: &apos;baz&apos;&#125;; _tmp.foo.bar;let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;; // 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量let &#123; log, sin, cos &#125; = Math; // 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构（方括号这种写法，属于“属性名表达式”）let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 // 如果要将一个已经声明的变量用于解构赋值，必须非常小心。下例JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误// 错误的写法 SyntaxError: syntax errorlet x;&#123;x&#125; = &#123;x: 1&#125;;// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 三、字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。12345678910const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; // 类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值let &#123;length : len&#125; = &apos;hello&apos;;len // 5 四、数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。123456789let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true let &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true // 只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 五、函数参数的解构赋值函数的参数也可以使用解构赋值。12345678910111213141516171819202122232425262728293031// 传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 yfunction add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 // 另一个例子[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] // 函数参数的解构也可以使用默认值function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] // 下面的写法会得到不一样的结果function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] // undefined就会触发函数参数的默认值[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);// [ 1, &apos;yes&apos;, 3 ] 六、圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。12345678910111213141516171819202122232425// 变量声明语句，模式不能使用圆括号，报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; // 函数参数也属于变量声明，因此不能带有圆括号，报错function f([(z)]) &#123; return z; &#125;function f([z,(x)]) &#123; return x; &#125; // 赋值语句的模式，报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; // 模式是取数组的第一个成员，跟圆括号无关[(b)] = [3]; // 正确 // 模式是p，而不是d(&#123; p: (d) &#125; = &#123;&#125;); // 正确 // 模式是取数组的第一个成员，跟圆括号无关[(parseInt.prop)] = [3]; // 正确 七、用途12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 交换变量的值let x = 1;let y = 2;[x, y] = [y, x]; // 从函数返回多个值（返回一个数组 | 返回一个对象）function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); // 函数参数的定义（参数是一组有次序的值 | 参数是一组无次序的值）function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); // 提取 JSON 数据let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] // 函数参数的默认值（避免了在函数体内部再写var foo = config.foo || &apos;default foo&apos;;这样的语句）jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; // 遍历 Map 结构const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world // 只想获取键名，或者只想获取键值for (let [key] of map) &#123; // ...&#125;for (let [,value] of map) &#123; // ...&#125; // 输入模块的指定方法const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;); 变量的解构赋值用途很多，如上。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 let & const","slug":"es6/let&const","date":"2018-01-25T03:59:59.000Z","updated":"2018-04-22T12:56:25.000Z","comments":true,"path":"es6/let&const/","link":"","permalink":"http://blog.master-ss.cn/es6/let&const/","excerpt":"ES6 添加 let 和 const 两种声明变量的命令，现在简单介绍下。","text":"ES6 添加 let 和 const 两种声明变量的命令，现在简单介绍下。 一、let用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效：1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 再比如循环中的使用：使用 ES5 的 var 变量声明的话，在例子中会导致函数内部的 i 都指向同一个 i（全局的），最后都输出 10；如果使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。另外，for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。123456789101112131415161718192021var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 // 正常运行，函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。如果在同一作用域会报错，见下文。for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125; let 命令改变了 ES6 的 var 语法行为，它所声明的变量一定要在声明后使用，在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2; // let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; let 不允许在相同作用域内，重复声明同一个变量123456789101112131415161718192021// 报错function func() &#123; let a = 10; var a = 1;&#125; // 报错function func() &#123; let a = 10; let a = 1;&#125; function func(arg) &#123; let arg; // 报错&#125; function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响（称为暂时性死区）。本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。123456789101112131415161718192021// 存在全局变量 tmp，但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 let 声明变量前，对 tmp 赋值会报错。var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; // 参数 x 默认值等于另一个参数 y ，而此时 y 还没有声明，属于”死区“（某些实现可能不报错）function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 // 不报错var x = x;// 报错；在变量 x 的声明语句还没有执行完成前，就去取 x 的值，导致报错”x 未定义“。let x = x;// ReferenceError: x is not defined 二、constconst 声明一个只读的常量。一旦声明，常量的值就不能改变。一旦声明变量，就必须立即初始化，不能留到以后赋值，否则会报错。12345678const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const foo;// SyntaxError: Missing initializer in const declaration 作用域与 let 命令相同：只在声明所在的块级作用域内有效。1234567891011121314151617if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined // 声明的常量同样不提升，同样存在暂时性死区，只能在声明的位置后面使用。if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; // 声明的常量，也与let一样不可重复声明。var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。12345678910111213141516171819202122// 常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only // 常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a ，就会报错。const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 // 真的想将对象冻结，应该使用Object.freeze方法。const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 三、顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1 a = 2;window.a // 2 ES6 规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，而let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1 let b = 1;window.b // undefined 四、块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。12345678910111213141516// 内层变量可能会覆盖外层变量var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined // 用来计数的循环变量泄露为全局变量。var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 let、const 实际上为 JavaScript 新增了块级作用域1234567891011121314151617181920212223242526272829303132// 运行后输出 5，表示外层代码块不受内层代码块的影响。如果两次都使用 var 定义变量 n，最后输出的值才是 10。function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; // 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量。&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; // 内层作用域可以定义外层作用域的同名变量。&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; // 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，但是为了兼容以前的旧代码，浏览器没有遵守这个规定。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。同时ES6 在附录里面规定，浏览器兼容为了老代码，实现上可以不遵守上面的规定，有自己的行为方式，函数声明类似于var。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"es6 之 promise","slug":"es6/promise","date":"2018-01-03T03:01:43.000Z","updated":"2018-04-24T06:44:53.000Z","comments":true,"path":"es6/promise/","link":"","permalink":"http://blog.master-ss.cn/es6/promise/","excerpt":"异步编程传统做法是使用回调函数，而 promise 提供了一种更加合理、更加强大的解决方案，避免出现地狱回调。在前面的文章介绍 zepto 源码时有讲到 promise 实现方案，而现在 ES6 将其写进了语言标准，原生提供了 promise 对象。","text":"异步编程传统做法是使用回调函数，而 promise 提供了一种更加合理、更加强大的解决方案，避免出现地狱回调。在前面的文章介绍 zepto 源码时有讲到 promise 实现方案，而现在 ES6 将其写进了语言标准，原生提供了 promise 对象。 一、promise resolve/rejectES6 规定，promise 对象是一个构造函数，用来生成 promise 实例，该构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。1234567891011121314151617181920212223// 300ms 后打印出 &quot;FULFILLED&quot;var promise = new Promise((fulfill, reject) =&gt; &#123; setTimeout(() =&gt; &#123; fulfill(&apos;FULFILLED!&apos;); &#125;, 300);&#125;);promise.then((val) =&gt; &#123; console.log(val);&#125;); // 300ms 后打印出 &quot;REJECTED&quot;var promise = new Promise(function (fulfill, reject) &#123; setTimeout(() =&gt; &#123; reject(new Error(&apos;REJECTED!&apos;)); &#125;, 300);&#125;);function onReject(error) &#123; console.log(error.message);&#125;promise.then(null, onReject); 二、promise stateresolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去；一旦状态改变，就不会再变。1234567891011// 打印出 &quot;I FIRED&quot;var promise = new Promise((fulfill, reject) =&gt; &#123; fulfill(&apos;I FIRED&apos;); reject(new Error(&apos;I DID NOT FIRE&apos;));&#125;);function onReject(error) &#123; console.log(error.message);&#125;promise.then(console.log, onReject); 三、promise asynchronouslypromise 可以将异步操作改成同步写法，避免地狱回调，但是其实 promise 在执行中还是异步的。1234567var promise = new Promise((fulfill, reject) =&gt; &#123; fulfill(&apos;PROMISE VALUE&apos;);&#125;);promise.then(console.log);console.log(&apos;MAIN PROGRAM&apos;); 四、promise shortcutsPromise.resolve、Promise.reject 是 promise 构造函数语法糖，可用于快速得到 promise 对象。 Promise.resolve 方法的参数分成四种情况：1、参数是一个 Promise 实例如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。 2、参数是一个 thenable 对象thenable对象指的是具有then方法的对象，Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。 3、参数不是具有 then 方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。 4、不带有任何参数Promise.resolve 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。 Promise.resolve 方法的参数Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。注意，Promise.reject() 方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。这一点与 Promise.resolve 方法不一致。123456789101112Promise.resolve(&apos;SECRET VALUE&apos;).then(val =&gt; &#123; console.log(val);&#125;); Promise.reject(new Error(&apos;SECRET VALUE&apos;)).then(err =&gt; &#123; console.log(err.message);&#125;);// 等价于 var promise = Promise.reject(new Error(&apos;SECRET VALUE&apos;));// var promise = new Promise(function (fulfill, reject) &#123;// reject(new Error(&apos;SECRET VALUE&apos;));// &#125;); 五、promise catchcatch 方法是 then(null, reject) 的别名，用于指定发生错误时的回调函数。如果异步操作抛出错误，状态就会变为 rejected，就会调用catch 方法指定的回调函数，处理这个错误。另外，then 方法指定的回调函数，如果运行中抛出错误，也会被 catch 方法捕获。123456789101112131415161718192021222324function alwaysThrows() &#123; throw new Error(&apos;OH NOES&apos;);&#125;function iterate(num) &#123; console.log(num); return num + 1;&#125;// 打印 &quot;1, 2, 3, 4, 5, OH NOES&quot;Promise.resolve(iterate(1)) .then(iterate) .then(iterate) .then(iterate) .then(iterate) .then(alwaysThrows) .then(iterate) .then(iterate) .then(iterate) .then(iterate) .then(iterate) .catch(err =&gt; &#123; console.log(err.message); &#125;); 六、promise allPromise.all 方法接受一个数组作为参数，数组中都是 Promise 实例，如果不是，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理；数组 Promise 实例状态都变成 fulfilled，返回的 Promise 的状态才会变成 fulfilled，有一个被 rejected，返回的就是 rejected；注意如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch 方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); // 自定义了 catch 方法const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;hello&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;报错了&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] // 精简版 Promise.all 实现function all(a, b) &#123; return new Promise(function (fulfill, reject) &#123; var counter = 0; var out = []; a.then(function (val) &#123; out[0] = val; counter++; if (counter &gt;= 2) &#123; fulfill(out); &#125; &#125;); b.then(function (val) &#123; out[1] = val; counter++; if (counter &gt;= 2) &#123; fulfill(out); &#125; &#125;); &#125;);&#125;all(getPromise1(), getPromise2()) .then(console.log); 七、promise race123456789// 如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error)); Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例，参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。只要数组参数中有一个实例率先改变状态，返回 promise 对象的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给返回 promise 对象的回调函数。","categories":[{"name":"es6","slug":"es6","permalink":"http://blog.master-ss.cn/categories/es6/"}],"tags":[]},{"title":"tools 之 git","slug":"tools/git","date":"2017-11-22T14:27:35.000Z","updated":"2018-04-27T02:35:28.000Z","comments":true,"path":"tools/git/","link":"","permalink":"http://blog.master-ss.cn/tools/git/","excerpt":"现在项目托管一般是使用 git，而之前则是 svn，那么两者之前的区别在哪呢。git 为什么能取代 svn，成为代码托管的首选呢。其实 svn 是集中式版本管理，需要一个中央服务器，每次工作的时候先从服务器获取最新数据，然后提交自己的修改到服务器，而集中式版本管理最大的毛病是必须联网才能工作，而且提交一个较大的文件需要特别多的时间。而 git 则是分布式版本管理，每个人的电脑都是一个版本库，通常需要一台充当 “中央服务器” 的电脑，作用仅限于方便交换修改，而且他的分支管理把 svn 甩在了后面。","text":"现在项目托管一般是使用 git，而之前则是 svn，那么两者之前的区别在哪呢。git 为什么能取代 svn，成为代码托管的首选呢。其实 svn 是集中式版本管理，需要一个中央服务器，每次工作的时候先从服务器获取最新数据，然后提交自己的修改到服务器，而集中式版本管理最大的毛病是必须联网才能工作，而且提交一个较大的文件需要特别多的时间。而 git 则是分布式版本管理，每个人的电脑都是一个版本库，通常需要一台充当 “中央服务器” 的电脑，作用仅限于方便交换修改，而且他的分支管理把 svn 甩在了后面。 一、常用命令及工作流程1、创建版本库创建版本有两种情况，一种是本地新建的项目新建一个 git 代码库，另外一种则是从远程服务器下载项目(即 git 代码库)，创建成功后会有一个 .git 的隐藏文件，请不要去修改它，否则会破坏 git 仓库。12345# 在当前目录新建一个 Git 代码库$ git init # 下载一个项目和它的整个代码历史$ git clone [url] 2、增加/删除文件这里的 add 和 rm 并不是提交到仓库上，而是提交到缓存区。1234567891011# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... 3、代码提交这里的 commit 才是把本地代码修改提交到仓库上。12345# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] 4、分支123456789101112131415161718192021222324# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch] # 合并指定分支到当前分支$ git merge [branch] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 5、查看信息12345# 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log 6、远程同步1234567891011121314151617181920212223242526# 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名(为本地代码指定远程服务器)$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库(提交本地仓库变化到服务器仓库中)$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force # 推送所有分支到远程仓库$ git push [remote] --all# 添加远程仓库地址git remote add origin [url]# 修改远程仓库地址git remote set-url origin [url]#从远程服务器上获取分支信息并更新到本地(有时同事在服务器上新增、删除分支，但是本地看不到分支变化，可用该命令从服务器拉取分支信息刷新本地分支)git remote update origin --prune 7、撤销1234567891011121314151617# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区(即当前电脑看到的目录)不变$ git reset [file] # 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit] # 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] # 暂时将未提交的变化移除$ git stash 二、.gitignore如果我们有些文件不需要提交到远程服务器，比如执行特定命令后生成的文件，这个时候 .gitignore 文件就可以用来配置这些。1234567891011# 1、忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；fd1/*# 2、忽略根目录下的 /fd1/ 目录的全部内容；/fd1/*# 3、忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；/*!.gitignore!/fw/bin/!/fw/sf/ 三、.editorconfig既然我们这里是讲 git，为什么需要讲到 .editorconfig，它只是与编码规范有关。让我们先来了解下它吧。当多人开发共同开发一个项目时，往往会使用不同的编辑器，比如 Sublime、Atom、Webstorm 等，而且不同人会在不同系统环境下开发，这就会导致一个问题，那就是不同编辑器编码规范是不同的，而且不同系统环境下也不一样，很有可能就会导致代码冲突，而 .editorconfig 则是用来统一配置这些。如果编译器不支持，可能需要一个 editorconfig 插件。以 Webstorm 为例，点开 Preferences，点击 Plugins，搜索 EditorConfig，如果不存在则到 repositories 下载。常用编码规范如下：123456789101112131415161718192021# http://editorconfig.orgroot = true# 对所有文件生效[*]# 文件编码charset = utf-8# 缩进类型indent_style = space# 缩进数量indent_size = 2# 换行符格式end_of_line = lf# 是否在文件的最后插入一个空行insert_final_newline = true# 是否删除行尾的空格trim_trailing_whitespace = true[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 四、补充Git 会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置 .gitkeep 文件。其实对文件名没有特定的要求，一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.master-ss.cn/categories/tools/"}],"tags":[]},{"title":"tools 之 npm","slug":"tools/npm","date":"2017-11-22T14:16:56.000Z","updated":"2018-04-19T07:11:18.000Z","comments":true,"path":"tools/npm/","link":"","permalink":"http://blog.master-ss.cn/tools/npm/","excerpt":"npm 是 nodeJs 的包管理器，使 JavaScript 开发人员可以轻松地共享和重用代码，并且可以轻松更新您共享的代码。NodeJs 自带 npm，所以下载安装 NodeJs 即可。那为什么前端也需要知道 npm 呢，nodeJs 不是后台开发吗？其实前端工具 bower、gulp 等等前端工具都依赖于 npm，所以在这里介绍下 npm。","text":"npm 是 nodeJs 的包管理器，使 JavaScript 开发人员可以轻松地共享和重用代码，并且可以轻松更新您共享的代码。NodeJs 自带 npm，所以下载安装 NodeJs 即可。那为什么前端也需要知道 npm 呢，nodeJs 不是后台开发吗？其实前端工具 bower、gulp 等等前端工具都依赖于 npm，所以在这里介绍下 npm。 一、安装 npm 包1234567//本地安装npm install &lt;package_name&gt;//全局安装npm install &lt;package_name&gt; -g//添加依赖性npm install &lt;package_name&gt; --savenpm install &lt;package_name&gt; --save-dev 有两种方法来安装 npm 包：本地或全局。您可以根据要使用的软件包选择要使用的安装类型：本地安装即类似 Node.js 的 require，在自己项目中安装然后引入使用；全局安装会将 npm 包下载安装到 node 安装文件夹中，然后作为命令行工具来使用。添加依赖性也有两种方法 –save 和 –save-dev，分别添加到 package.json 的 dependencies (发布之后还依赖的东西) 和 devDependencies (开发时候依赖的东西)，具体使用哪个，取决于如何使用这种依赖性。比如，你写 ES6 代码，如果你想编译成 ES5发布那么babel 就是 devDependencies。如果你用了 jQuery，由于发布之后还是依赖 jQuery，所以是 dependencies。 二、使用 package.json管理 npm 包的最好方法是创建一个 package.json 文件，可以用作项目所依赖的包的文档、指定项目可以使用的包的版本及重现项目构建。1234//启动命令行问卷，在启动命令的目录中创建一个 package.jsonnpm init//填写默认值npm init --yes package.json内容介绍：1234567891011121314151617181920&#123; &quot;name&quot;：&quot;my_package&quot;， //包名 &quot;description&quot;：&quot;&quot;， //包的描述信息 &quot;version&quot;：&quot;1.0.0&quot;，//包的版本信息 &quot;main&quot;：&quot;index.js&quot;，//模块的入口文件 &quot;scripts&quot;：&#123; //钩子，定义一些脚本操作，比如测试之类的(NodeJs) &quot;test&quot;：&quot;echo \\&quot;错误：未指定测试\\&quot;&amp;&amp;退出1&quot; &#125;， &quot;keywords&quot;：[]， //关键字集合 &quot;author&quot;：&quot;&quot;， //包的作者 &quot;license&quot;：&quot;ISC&quot;，//证书 &quot;repository&quot;：&#123; //存储地址信息 &quot;type&quot;：&quot;git&quot;， &quot;url&quot;：&quot;https://github.com/ashleygwilliams/my_package.git&quot; &#125;， &quot;bugs&quot;：&#123; //bug信息 &quot;url&quot;：&quot;https://github.com/ashleygwilliams/my_package/issues&quot; &#125;， &quot;homepage&quot;：&quot;https://github.com/ashleygwilliams/my_package&quot; //包的网站主页介绍&#125;&#125; 三、常用命令12345678910111213141516171819202122232425262728293031// 更新npm包npm install npm -g// 安装 / 更新包npm install XXX// 更新所有本地包(如果是更新全局包，必须使用-g)npm update// 卸载本地包(如果包在package.json中依赖性，必须使用--save或者--save-dev卸载，如安装的时候，全局包同理添加-g)npm uninstall/rm &lt;package&gt;// 查看全局安装过的包npm list -g --depth 0// npm包细节repository / description / README.md// 创建npm用户npm adduser// 登录，在客户端上存储凭据npm login// 确保凭据存储在客户端上npm config ls//发布包npm publish// 更新npm包版本号npm version x.x.x// 查看当前安装包是否已经过时了(wanted: 满足package.json条件的最新版本号，如果不满足则显示当前安装的版本号，latest: latest tag所在版本号)npm outdated// 执行后可以使用npm i project-name@tag来安装这个版本，这等价于npm i project@x.x.x// 如果之前版本存在这个tag，那么之前版本的tag会被删除，当前执行版本添加tagnpm dist-tag add &lt;package&gt;@&lt;version&gt; tag// 切记不能删除latest，否则npm仓库会报错，可以使用add命令更新版本号npm dist-tag rm &lt;pkg&gt; &lt;tag&gt;// 列举出所有的tagnpm dist-tag ls [&lt;pkg&gt;]","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.master-ss.cn/categories/tools/"}],"tags":[]},{"title":"bootstrap 之 scrollspy","slug":"bootstrap/scrollspy","date":"2017-11-13T12:16:15.000Z","updated":"2018-04-15T13:54:46.000Z","comments":true,"path":"bootstrap/scrollspy/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/scrollspy/","excerpt":"这节介绍下 scrollspy(滚动侦测)模块的源码实现。","text":"这节介绍下 scrollspy(滚动侦测)模块的源码实现。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* ======================================================================== * Bootstrap: scrollspy.js v3.3.7(滚动侦测) * http://getbootstrap.com/javascript/#scrollspy * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // SCROLLSPY CLASS DEFINITION(构造函数，初始化要监听的滚动对象、nav区(selector)，执行滚动事件绑定) // ========================== function ScrollSpy(element, options) &#123; this.$body = $(document.body) this.$scrollElement = $(element).is(document.body) ? $(window) : $(element) this.options = $.extend(&#123;&#125;, ScrollSpy.DEFAULTS, options) this.selector = (this.options.target || &apos;&apos;) + &apos; .nav li &gt; a&apos; this.offsets = [] this.targets = [] this.activeTarget = null this.scrollHeight = 0 this.$scrollElement.on(&apos;scroll.bs.scrollspy&apos;, $.proxy(this.process, this)) this.refresh() this.process() &#125; ScrollSpy.VERSION = &apos;3.3.7&apos; ScrollSpy.DEFAULTS = &#123; offset: 10 &#125; // 获取指定元素的scrollHeight(内容高度)，或兼容获取body的内容高度 ScrollSpy.prototype.getScrollHeight = function () &#123; // scrollHeigth是元素内容的高度，包括overflow导致不可见的部分，this.$body[0].scrollHeight和document.body.scrollHeight其实是一样的 // 在DTD声明和未声明时，document.documentElement.scrollHeight和document.body.scrollHeight有一个会为可视窗口高度，所以用Math.max取得全部内容高度 return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) &#125; // 获得content区中对应的锚点（放到targets中）和对应的高度（放到offsets中），及获取滚动容器的内容高度 ScrollSpy.prototype.refresh = function () &#123; var that = this var offsetMethod = &apos;offset&apos; // offsetBase为滚动容器data-spy=&quot;scroll&quot;相对于滚动条顶部的偏移 var offsetBase = 0 this.offsets = [] this.targets = [] this.scrollHeight = this.getScrollHeight() // 如果监听的滚动对象不是body，则使用position方法来获取offsets值； // jquery的offset()方法是获取匹配元素在当前视口的相对偏移，position()方法是获取匹配元素相对父元素的偏移 if (!$.isWindow(this.$scrollElement[0])) &#123; offsetMethod = &apos;position&apos; offsetBase = this.$scrollElement.scrollTop() &#125; // 找到全部的锚点，返回由[offsets，锚点]组成的数组 // jquery的map有点奇怪，return值或return[值]得到的都是数组。return [[值]]得到的才是数组组成的数组 this.$body .find(this.selector) .map(function () &#123; var $el = $(this) // 获取符合格式的锚点$href var href = $el.data(&apos;target&apos;) || $el.attr(&apos;href&apos;) var $href = /^#./.test(href) &amp;&amp; $(href) // $href[offsetMethod]().top =&gt; 相对于父元素(即滚动容器data-spy=&quot;scroll&quot;)的偏移量 return ($href &amp;&amp; $href.length &amp;&amp; $href.is(&apos;:visible&apos;) &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null &#125;) .sort(function (a, b) &#123; return a[0] - b[0] &#125;) .each(function () &#123; that.offsets.push(this[0]) that.targets.push(this[1]) &#125;) &#125; // 根据this.offsets与当前的scrollTop比较，判断是否需要activate ScrollSpy.prototype.process = function () &#123; // 加上规定offset的，距离顶部的值(this.options.offset：当计算滚动位置时，距离顶部的偏移像素) var scrollTop = this.$scrollElement.scrollTop() + this.options.offset // 当前的内容高度 var scrollHeight = this.getScrollHeight() // offset值+内容高度-可视高度得到的最大可滚动高度 var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height() var offsets = this.offsets var targets = this.targets var activeTarget = this.activeTarget var i // 当内容高度发生动态变化时调用refresh方法 if (this.scrollHeight != scrollHeight) &#123; this.refresh() &#125; // 超过或等于当前元素的最大可滚动高度，说明滚动到了最底部，直接激活最后一个nav if (scrollTop &gt;= maxScroll) &#123; return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i) &#125; // 没超过第一个offset，清除当前的激活对象（当this.options.offset为负数时存在这种情况） if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) &#123; this.activeTarget = null return this.clear() &#125; // 最精彩的部分，循环判断是否需要激活 for (i = offsets.length; i--;) &#123; activeTarget != targets[i] // 满足当前遍历的target不是激活对象 &amp;&amp; scrollTop &gt;= offsets[i] // 满足当前滚动高度大于对应的offset &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1]) // 满足当前滚动高度小于下一个滚动高度，或下一个滚动高度未定义 &amp;&amp; this.activate(targets[i]) // 激活该nav &#125; &#125; // 激活传进来的dom对象（即为其添加active类） ScrollSpy.prototype.activate = function (target) &#123; this.activeTarget = target // 先把该对象存入实例对象中 this.clear() // 清除当前的激活对象 var selector = this.selector + &apos;[data-target=&quot;&apos; + target + &apos;&quot;],&apos; + this.selector + &apos;[href=&quot;&apos; + target + &apos;&quot;]&apos; // 为对应的a标签的父元素li添加active类 var active = $(selector) .parents(&apos;li&apos;) .addClass(&apos;active&apos;) // 为下拉菜单的相应li元素添加active类 if (active.parent(&apos;.dropdown-menu&apos;).length) &#123; active = active .closest(&apos;li.dropdown&apos;) .addClass(&apos;active&apos;) &#125; // 触发自定义事件 active.trigger(&apos;activate.bs.scrollspy&apos;) &#125; // 清除当前的nav中的激活对象 ScrollSpy.prototype.clear = function () &#123; $(this.selector) .parentsUntil(this.options.target, &apos;.active&apos;) .removeClass(&apos;active&apos;) &#125; // SCROLLSPY PLUGIN DEFINITION // =========================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.scrollspy&apos;) var options = typeof option == &apos;object&apos; &amp;&amp; option if (!data) $this.data(&apos;bs.scrollspy&apos;, (data = new ScrollSpy(this, options))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.scrollspy $.fn.scrollspy = Plugin $.fn.scrollspy.Constructor = ScrollSpy // SCROLLSPY NO CONFLICT // ===================== $.fn.scrollspy.noConflict = function () &#123; $.fn.scrollspy = old return this &#125; // SCROLLSPY DATA-API // ================== $(window).on(&apos;load.bs.scrollspy.data-api&apos;, function () &#123; $(&apos;[data-spy=&quot;scroll&quot;]&apos;).each(function () &#123; var $spy = $(this) Plugin.call($spy, $spy.data()) &#125;) &#125;)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;nav id=&quot;navbar-example&quot; class=&quot;navbar navbar-default navbar-static&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button class=&quot;navbar-toggle&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.bs-js-navbar-scrollspy&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;教程名称&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapse navbar-collapse bs-js-navbar-scrollspy&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#ios&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#svn&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;navbarDrop1&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;navbarDrop1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#jmeter&quot; tabindex=&quot;-1&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#ejb&quot; tabindex=&quot;-1&quot;&gt;ejb&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#spring&quot; tabindex=&quot;-1&quot;&gt;spring&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div data-spy=&quot;scroll&quot; data-target=&quot;#navbar-example&quot; data-offset=&quot;-10&quot; style=&quot;height:200px;overflow:auto; position: relative;&quot;&gt; &lt;h4 id=&quot;ios&quot;&gt;iOS&lt;/h4&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。 &lt;/p&gt; &lt;h4 id=&quot;svn&quot;&gt;SVN&lt;/h4&gt; &lt;p&gt;Apache Subversion，通常缩写为 SVN，是一款开源的版本控制系统软件。Subversion 由 CollabNet 公司在 2000 年创建。但是现在它已经发展为 Apache Software Foundation 的一个项目，因此拥有丰富的开发人员和用户社区。 &lt;/p&gt; &lt;h4 id=&quot;jmeter&quot;&gt;jMeter&lt;/h4&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。 &lt;/p&gt; &lt;h4 id=&quot;ejb&quot;&gt;EJB&lt;/h4&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;h4 id=&quot;spring&quot;&gt;Spring&lt;/h4&gt; &lt;p&gt;Spring 框架是一个开源的 Java 平台，为快速开发功能强大的 Java 应用程序提供了完备的基础设施支持。 &lt;/p&gt; &lt;p&gt;Spring 框架最初是由 Rod Johnson 编写的，在 2003 年 6 月首次发布于 Apache 2.0 许可证下。 &lt;/p&gt;&lt;/div&gt; 2、源码分析1、refresh获取导航元素 nav 内各链接对应元素的相对高度(如果不是 body，则相对于父元素)，然后存储各锚点和相对高度2、process遍历锚点，判断锚点对应元素的相对高度是否位于锚点之间，然后’激活’对应锚点","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 tab","slug":"bootstrap/tab","date":"2017-11-13T12:16:15.000Z","updated":"2018-04-15T13:56:40.000Z","comments":true,"path":"bootstrap/tab/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/tab/","excerpt":"这节介绍下 tab(选项卡)模块的源码实现。","text":"这节介绍下 tab(选项卡)模块的源码实现。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/* ======================================================================== * Bootstrap: tab.js v3.3.7(选项卡) * http://getbootstrap.com/javascript/#tabs * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // TAB CLASS DEFINITION // ==================== var Tab = function (element) &#123; // jscs:disable requireDollarBeforejQueryAssignment this.element = $(element) // jscs:enable requireDollarBeforejQueryAssignment &#125; Tab.VERSION = &apos;3.3.7&apos; Tab.TRANSITION_DURATION = 150 Tab.prototype.show = function () &#123; var $this = this.element // tab菜单可能存在二级菜单，&apos;ul:not(.dropdown-menu)&apos; =&gt; 找到外层的ul元素 var $ul = $this.closest(&apos;ul:not(.dropdown-menu)&apos;) // 读取data-target属性数据，如果不存在则读取href属性数据并格式化为CSS选择符 var selector = $this.data(&apos;target&apos;) if (!selector) &#123; selector = $this.attr(&apos;href&apos;) selector = selector &amp;&amp; selector.replace(/.*(?=#[^\\s]*$)/, &apos;&apos;) // strip for ie7 &#125; // 如果已经被选中则直接返回 if ($this.parent(&apos;li&apos;).hasClass(&apos;active&apos;)) return // 之前被选中的最后一个tab a触发hide事件，relatedTarget为将要显示的元素；将要显示的tab a触发show事件，relatedTarget为之前被选中的 var $previous = $ul.find(&apos;.active:last a&apos;) var hideEvent = $.Event(&apos;hide.bs.tab&apos;, &#123; relatedTarget: $this[0] &#125;) var showEvent = $.Event(&apos;show.bs.tab&apos;, &#123; relatedTarget: $previous[0] &#125;) $previous.trigger(hideEvent) $this.trigger(showEvent) if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return var $target = $(selector) this.activate($this.closest(&apos;li&apos;), $ul) this.activate($target, $target.parent(), function () &#123; $previous.trigger(&#123; type: &apos;hidden.bs.tab&apos;, relatedTarget: $this[0] &#125;) $this.trigger(&#123; type: &apos;shown.bs.tab&apos;, relatedTarget: $previous[0] &#125;) &#125;) &#125; Tab.prototype.activate = function (element, container, callback) &#123; var $active = container.find(&apos;&gt; .active&apos;) var transition = callback &amp;&amp; $.support.transition &amp;&amp; ($active.length &amp;&amp; $active.hasClass(&apos;fade&apos;) || !!container.find(&apos;&gt; .fade&apos;).length) function next() &#123; // 如果是tab的下拉菜单的话，那么$active是dropdown的li元素 $active .removeClass(&apos;active&apos;) .find(&apos;&gt; .dropdown-menu &gt; .active&apos;) .removeClass(&apos;active&apos;) .end() .find(&apos;[data-toggle=&quot;tab&quot;]&apos;) .attr(&apos;aria-expanded&apos;, false) element .addClass(&apos;active&apos;) .find(&apos;[data-toggle=&quot;tab&quot;]&apos;) .attr(&apos;aria-expanded&apos;, true) if (transition) &#123; element[0].offsetWidth // reflow for transition element.addClass(&apos;in&apos;) &#125; else &#123; element.removeClass(&apos;fade&apos;) &#125; if (element.parent(&apos;.dropdown-menu&apos;).length) &#123; element .closest(&apos;li.dropdown&apos;) .addClass(&apos;active&apos;) .end() .find(&apos;[data-toggle=&quot;tab&quot;]&apos;) .attr(&apos;aria-expanded&apos;, true) &#125; callback &amp;&amp; callback() &#125; // 如果是菜单元素直接执行next，否则等$active移除in再执行next方法 $active.length &amp;&amp; transition ? $active .one(&apos;bsTransitionEnd&apos;, next) .emulateTransitionEnd(Tab.TRANSITION_DURATION) : next() $active.removeClass(&apos;in&apos;) &#125; // TAB PLUGIN DEFINITION // ===================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.tab&apos;) if (!data) $this.data(&apos;bs.tab&apos;, (data = new Tab(this))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.tab $.fn.tab = Plugin $.fn.tab.Constructor = Tab // TAB NO CONFLICT // =============== $.fn.tab.noConflict = function () &#123; $.fn.tab = old return this &#125; // TAB DATA-API // ============ var clickHandler = function (e) &#123; e.preventDefault() Plugin.call($(this), &apos;show&apos;) &#125; $(document) .on(&apos;click.bs.tab.data-api&apos;, &apos;[data-toggle=&quot;tab&quot;]&apos;, clickHandler) .on(&apos;click.bs.tab.data-api&apos;, &apos;[data-toggle=&quot;pill&quot;]&apos;, clickHandler)&#125;(jQuery); 二、component-animations.less 源码1234567891011121314151617181920212223242526272829303132//// Component animations(组件动画)// --------------------------------------------------// Heads up!//// We don&apos;t use the `.opacity()` mixin here since it causes a bug with text// fields in IE7-8. Source: https://github.com/twbs/bootstrap/pull/3552..fade &#123; opacity: 0; .transition(opacity .15s linear); &amp;.in &#123; opacity: 1; &#125;&#125;// 默认折叠内容隐藏.collapse &#123; display: none; &amp;.in &#123; display: block; &#125; tr&amp;.in &#123; display: table-row; &#125; tbody&amp;.in &#123; display: table-row-group; &#125;&#125;.collapsing &#123; position: relative; height: 0; overflow: hidden; .transition-property(~&quot;height, visibility&quot;); .transition-duration(.35s); .transition-timing-function(ease);&#125; 三、应用 &amp; 源码分析1、应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;hr&gt;&lt;p class=&quot;active-tab&quot;&gt;&lt;strong&gt;激活的标签页&lt;/strong&gt;：&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;previous-tab&quot;&gt;&lt;strong&gt;前一个激活的标签页&lt;/strong&gt;：&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr&gt;&lt;ul id=&quot;myTab&quot; class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#home&quot; data-toggle=&quot;tab&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#ios&quot; data-toggle=&quot;tab&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;myTabDrop1&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;Java&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;myTabDrop1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#jmeter&quot; tabindex=&quot;-1&quot; data-toggle=&quot;tab&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#ejb&quot; tabindex=&quot;-1&quot; data-toggle=&quot;tab&quot;&gt;ejb&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;myTabContent&quot; class=&quot;tab-content&quot;&gt; &lt;div class=&quot;tab-pane fade in active&quot; id=&quot;home&quot;&gt; &lt;p&gt;菜鸟教程是一个提供最新的web技术站点，本站免费提供了建站相关的技术文档，帮助广大web技术爱好者快速入门并建立自己的网站。菜鸟先飞早入行——学的不仅是技术，更是梦想。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;tab-pane fade&quot; id=&quot;ios&quot;&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;tab-pane fade&quot; id=&quot;jmeter&quot;&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;tab-pane fade&quot; id=&quot;ejb&quot;&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; $(&apos;#myTab a:last&apos;).tab(&apos;show&apos;); $(&apos;a[data-toggle=&quot;tab&quot;]&apos;).on(&apos;shown.bs.tab&apos;, function (e) &#123; // 获取已激活的标签页的名称 var activeTab = $(e.target).text(); // 获取前一个激活的标签页的名称 var previousTab = $(e.relatedTarget).text(); $(&quot;.active-tab span&quot;).html(activeTab); $(&quot;.previous-tab span&quot;).html(previousTab); &#125;); &#125;)&lt;/script&gt; 2、源码分析1、showtab 插件可能内嵌下拉菜单插件 dropdown，所以需要判断是否是 tab 插件链接还是存在于 dropdown2、activate核心方法，为点击相应元素添加 active 类，并移除前 active 类元素；如果具有 fade 类(见component-animations.less源码)，则在过渡执行完成后再回调","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 collapse","slug":"bootstrap/collapse","date":"2017-11-13T12:16:15.000Z","updated":"2018-04-15T13:34:52.000Z","comments":true,"path":"bootstrap/collapse/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/collapse/","excerpt":"这节介绍下 collapse(手风琴)模块的源码实现。","text":"这节介绍下 collapse(手风琴)模块的源码实现。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232/* ======================================================================== * Bootstrap: collapse.js v3.3.7(折叠/手风琴) * http://getbootstrap.com/javascript/#collapse * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== *//* jshint latedef: false */+function ($) &#123; &apos;use strict&apos;; // COLLAPSE PUBLIC CLASS DEFINITION // ================================ var Collapse = function (element, options) &#123; this.$element = $(element) this.options = $.extend(&#123;&#125;, Collapse.DEFAULTS, options) this.$trigger = $(&apos;[data-toggle=&quot;collapse&quot;][href=&quot;#&apos; + element.id + &apos;&quot;],&apos; + &apos;[data-toggle=&quot;collapse&quot;][data-target=&quot;#&apos; + element.id + &apos;&quot;]&apos;) // 变量：是否正在过渡动画中 this.transitioning = null if (this.options.parent) &#123; this.$parent = this.getParent() &#125; else &#123; this.addAriaAndCollapsedClass(this.$element, this.$trigger) &#125; if (this.options.toggle) this.toggle() &#125; Collapse.VERSION = &apos;3.3.7&apos; Collapse.TRANSITION_DURATION = 350 Collapse.DEFAULTS = &#123; toggle: true &#125; // 高度还是宽度发生改变 Collapse.prototype.dimension = function () &#123; var hasWidth = this.$element.hasClass(&apos;width&apos;) return hasWidth ? &apos;width&apos; : &apos;height&apos; &#125; // 显示 Collapse.prototype.show = function () &#123; // 如果正在动画过渡中，或者已经显示，那么直接返回不做任何处理 if (this.transitioning || this.$element.hasClass(&apos;in&apos;)) return var activesData // 展开或者正在展开的手风琴控制面板 var actives = this.$parent &amp;&amp; this.$parent.children(&apos;.panel&apos;).children(&apos;.in, .collapsing&apos;) // 如果手风琴控制面板正在过渡中，则不作任何处理(这里只考虑actives.length为1的处理，即控制面板只有单个展开的情况) if (actives &amp;&amp; actives.length) &#123; activesData = actives.data(&apos;bs.collapse&apos;) if (activesData &amp;&amp; activesData.transitioning) return &#125; var startEvent = $.Event(&apos;show.bs.collapse&apos;) this.$element.trigger(startEvent) if (startEvent.isDefaultPrevented()) return if (actives &amp;&amp; actives.length) &#123; // 将之前拓展开的控制面板隐藏起来 Plugin.call(actives, &apos;hide&apos;) // 存在一种情况：如果一开始有控制面板展开，这时候点击其他面板，展开的面板会被触发隐藏同时初始化bs.collapse对象(&apos;hide&apos;参数)存储到 // data中，下次点击最开始展开的面板时，这时候会从data中读取bs.collapse作为对象而不是重新初始化，然后触发toggle，但是因为并没有将 // parent传到option中，所以后面点击的面板并不会收拢；这里做的处理是将所有已经展开的面板都隐藏，而且清除掉存在data的bs.collapse数 // 据，下次点击重新初始化 // 不过其实将对象存在data的bs.collapse属性中还是有必要的，如果多次点击同一面板触发器，可以避免多次初始化对象 activesData || actives.data(&apos;bs.collapse&apos;, null) &#125; var dimension = this.dimension() // 目标元素移除collapse类，添加collapsing，设置height为0 this.$element .removeClass(&apos;collapse&apos;) .addClass(&apos;collapsing&apos;)[dimension](0) .attr(&apos;aria-expanded&apos;, true) // 触发元素移除collapsed类 this.$trigger .removeClass(&apos;collapsed&apos;) .attr(&apos;aria-expanded&apos;, true) this.transitioning = 1 var complete = function () &#123; // 目标元素移除collapsing类，添加.collapse .in类，并重置height this.$element .removeClass(&apos;collapsing&apos;) .addClass(&apos;collapse in&apos;)[dimension](&apos;&apos;) this.transitioning = 0 this.$element .trigger(&apos;shown.bs.collapse&apos;) &#125; // 如果设备不支持动画，那么直接执行完成函数 if (!$.support.transition) return complete.call(this) var scrollSize = $.camelCase([&apos;scroll&apos;, dimension].join(&apos;-&apos;)) // 设置函数动画结束监听函数，并设置height为目标元素的scrollHeight this.$element .one(&apos;bsTransitionEnd&apos;, $.proxy(complete, this)) .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]) &#125; // 隐藏 Collapse.prototype.hide = function () &#123; if (this.transitioning || !this.$element.hasClass(&apos;in&apos;)) return var startEvent = $.Event(&apos;hide.bs.collapse&apos;) this.$element.trigger(startEvent) if (startEvent.isDefaultPrevented()) return var dimension = this.dimension() // 强制回流，为页面重绘做准备 this.$element[dimension](this.$element[dimension]())[0].offsetHeight this.$element .addClass(&apos;collapsing&apos;) .removeClass(&apos;collapse in&apos;) .attr(&apos;aria-expanded&apos;, false) this.$trigger .addClass(&apos;collapsed&apos;) .attr(&apos;aria-expanded&apos;, false) this.transitioning = 1 var complete = function () &#123; this.transitioning = 0 this.$element .removeClass(&apos;collapsing&apos;) .addClass(&apos;collapse&apos;) .trigger(&apos;hidden.bs.collapse&apos;) &#125; if (!$.support.transition) return complete.call(this) this.$element [dimension](0) .one(&apos;bsTransitionEnd&apos;, $.proxy(complete, this)) .emulateTransitionEnd(Collapse.TRANSITION_DURATION) &#125; // 切换手风琴显示隐藏 Collapse.prototype.toggle = function () &#123; this[this.$element.hasClass(&apos;in&apos;) ? &apos;hide&apos; : &apos;show&apos;]() &#125; // 找到手风琴目标元素并为所有拓展面板执行addAriaAndCollapsedClass方法 Collapse.prototype.getParent = function () &#123; return $(this.options.parent) .find(&apos;[data-toggle=&quot;collapse&quot;][data-parent=&quot;&apos; + this.options.parent + &apos;&quot;]&apos;) .each($.proxy(function (i, element) &#123; var $element = $(element) this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element) &#125;, this)) .end() &#125; // 添加无障碍阅读属性和collapsed类 Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) &#123; var isOpen = $element.hasClass(&apos;in&apos;) $element.attr(&apos;aria-expanded&apos;, isOpen) $trigger .toggleClass(&apos;collapsed&apos;, !isOpen) .attr(&apos;aria-expanded&apos;, isOpen) &#125; // 获取目标元素 function getTargetFromTrigger($trigger) &#123; var href var target = $trigger.attr(&apos;data-target&apos;) || (href = $trigger.attr(&apos;href&apos;)) &amp;&amp; href.replace(/.*(?=#[^\\s]+$)/, &apos;&apos;) // strip for ie7 return $(target) &#125; // COLLAPSE PLUGIN DEFINITION // ========================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.collapse&apos;) var options = $.extend(&#123;&#125;, Collapse.DEFAULTS, $this.data(), typeof option == &apos;object&apos; &amp;&amp; option) // 如果直接用JS触发手风琴，而且option为show/hide字符串，那么没有不调用toggle方法，而直接调用相应hide/show方法 if (!data &amp;&amp; options.toggle &amp;&amp; /show|hide/.test(option)) options.toggle = false if (!data) $this.data(&apos;bs.collapse&apos;, (data = new Collapse(this, options))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.collapse $.fn.collapse = Plugin $.fn.collapse.Constructor = Collapse // COLLAPSE NO CONFLICT // ==================== $.fn.collapse.noConflict = function () &#123; $.fn.collapse = old return this &#125; // COLLAPSE DATA-API // ================= $(document).on(&apos;click.bs.collapse.data-api&apos;, &apos;[data-toggle=&quot;collapse&quot;]&apos;, function (e) &#123; var $this = $(this) if (!$this.attr(&apos;data-target&apos;)) e.preventDefault() var $target = getTargetFromTrigger($this) // 如果已经初始化了bs.collapse属性对应的对象，那么直接触发toggle方法(即除了第一次点击初始化之外) var data = $target.data(&apos;bs.collapse&apos;) var option = data ? &apos;toggle&apos; : $this.data() Plugin.call($target, option) &#125;)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;panel-group&quot; id=&quot;accordion&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h4 class=&quot;panel-title&quot;&gt; &lt;a data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot; href=&quot;#collapseOne&quot;&gt; 点击我进行展开，再次点击我进行折叠。第 1 部分 &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id=&quot;collapseOne&quot; class=&quot;panel-collapse collapse in&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h4 class=&quot;panel-title&quot;&gt; &lt;a data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot; href=&quot;#collapseTwo&quot;&gt; 点击我进行展开，再次点击我进行折叠。第 2 部分 &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id=&quot;collapseTwo&quot; class=&quot;panel-collapse collapse&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h4 class=&quot;panel-title&quot;&gt; &lt;a data-toggle=&quot;collapse&quot; data-parent=&quot;#accordion&quot; href=&quot;#collapseThree&quot;&gt; 点击我进行展开，再次点击我进行折叠。第 3 部分 &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id=&quot;collapseThree&quot; class=&quot;panel-collapse collapse&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; $(&apos;#collapseFour&apos;).collapse(&#123; toggle: false &#125;)&#125;); $(function () &#123; $(&apos;#collapseTwo&apos;).collapse(&apos;show&apos;)&#125;); $(function () &#123; $(&apos;#collapseThree&apos;).collapse(&apos;toggle&apos;)&#125;); $(function () &#123; $(&apos;#collapseOne&apos;).collapse(&apos;hide&apos;)&#125;);&lt;/script&gt; 2、源码分析1、data-parent如果元素具有相同的 data-parent 属性，那么可以具有点击一个折叠面板，其他所有展开的面板均折叠2、show开始时每个面板均添加 collapse 类(display:none)，动画准备时移除 collapse 并添加 collapsing 类(height:0;overflow:hidden;)，动画执行时 collapsing 移除添加 .collapse.in(display: block;) 并清空行内 height 达到过渡打开面板的效果","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 affix","slug":"bootstrap/affix","date":"2017-11-13T12:16:15.000Z","updated":"2018-04-15T09:04:14.000Z","comments":true,"path":"bootstrap/affix/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/affix/","excerpt":"这节介绍下 affix(自动定位浮标)模块的源码实现。","text":"这节介绍下 affix(自动定位浮标)模块的源码实现。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175/* ======================================================================== * Bootstrap: affix.js v3.3.7(自动定位浮标) * http://getbootstrap.com/javascript/#affix * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * bottom使用时会有bug(见107行) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // AFFIX CLASS DEFINITION // ====================== var Affix = function (element, options) &#123; this.options = $.extend(&#123;&#125;, Affix.DEFAULTS, options) this.$target = $(this.options.target) .on(&apos;scroll.bs.affix.data-api&apos;, $.proxy(this.checkPosition, this)) .on(&apos;click.bs.affix.data-api&apos;, $.proxy(this.checkPositionWithEventLoop, this)) this.$element = $(element) this.affixed = null this.unpin = null this.pinnedOffset = null this.checkPosition() &#125; Affix.VERSION = &apos;3.3.7&apos; Affix.RESET = &apos;affix affix-top affix-bottom&apos; Affix.DEFAULTS = &#123; offset: 0, target: window &#125; // 获取滚动状态 Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) &#123; var scrollTop = this.$target.scrollTop() // 滚动元素(目标元素|Window)的滚动距离 var position = this.$element.offset() // 元素相对于视口的距离 var targetHeight = this.$target.height() // 滚动元素(目标元素|Window)的可视高度 // 后续滚动的话，如果滚动元素的滚动距离少于自定义向上偏移量offsetTop，返回&apos;top&apos; if (offsetTop != null &amp;&amp; this.affixed == &apos;top&apos;) return scrollTop &lt; offsetTop ? &apos;top&apos; : false if (this.affixed == &apos;bottom&apos;) &#123; // target的top＋getpinnedOffset的值&gt;粘住元素当前定位到top的值, 返回&apos;bottom&apos; if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &apos;bottom&apos; // target的top＋target元素的高度&gt;文档高度–粘住元素距离底部的高度 return (scrollTop+targetHeight&lt;=scrollHeight-offsetBottom) ? false : &apos;bottom&apos; &#125; // 初次运行执行代码 var initializing = this.affixed == null var colliderTop = initializing ? scrollTop : position.top var colliderHeight = initializing ? targetHeight : height // 初始时，如果滚动元素的滚动距离少于等于自定义向上偏移量offsetTop，返回&apos;top&apos; if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return &apos;top&apos; // 初始时，如果滚动元素的滚动距离+滚动元素的高度+自定义向下偏移量offsetBottom大于内容高度，返回&apos;bottom&apos; // 滚动时，如果元素的offsetTop(距顶部距离)+元素的高度+自定义向下偏移量offsetBottom大于内容高度，返回&apos;bottom&apos; if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight &gt;= scrollHeight - offsetBottom)) return &apos;bottom&apos; return false &#125; // 获取粘住元素top–target滚动条的top Affix.prototype.getPinnedOffset = function () &#123; if (this.pinnedOffset) return this.pinnedOffset this.$element.removeClass(Affix.RESET).addClass(&apos;affix&apos;) var scrollTop = this.$target.scrollTop() var position = this.$element.offset() return (this.pinnedOffset = position.top - scrollTop) &#125; // 如果点击目标元素，那么滚动元素会通过锚点滚动，然后执行checkPosition，判断菜单位置 Affix.prototype.checkPositionWithEventLoop = function () &#123; setTimeout($.proxy(this.checkPosition, this), 1) &#125; // 检查位置信息 Affix.prototype.checkPosition = function () &#123; // 如果data-spy=&quot;affix&quot;元素不可见，那么直接返回 if (!this.$element.is(&apos;:visible&apos;)) return var height = this.$element.height() var offset = this.options.offset var offsetTop = offset.top var offsetBottom = offset.bottom // 文档内容高度 var scrollHeight = Math.max($(document).height(), $(document.body).height()) // 如果offset不是对象，那么offsetBottom、offsetTop均为offset if (typeof offset != &apos;object&apos;) offsetBottom = offsetTop = offset // 如果offsetTop、offsetBottom为function，那么offsetTop、offsetBottom将执行并以this.$element为参数得到结果作为值 if (typeof offsetTop == &apos;function&apos;) offsetTop = offset.top(this.$element) if (typeof offsetBottom == &apos;function&apos;) offsetBottom = offset.bottom(this.$element) var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom) if (this.affixed != affix) &#123; // 从affix-bottom到其他状态，设置top样式为0 if (this.unpin != null) this.$element.css(&apos;top&apos;, &apos;&apos;) // 去掉行内样式position，不然会覆盖掉position为fixed的affix类样式，affix的bug // , this.$element.css(&apos;position&apos;, &apos;&apos;) var affixType = &apos;affix&apos; + (affix ? &apos;-&apos; + affix : &apos;&apos;) var e = $.Event(affixType + &apos;.bs.affix&apos;) this.$element.trigger(e) if (e.isDefaultPrevented()) return this.affixed = affix this.unpin = affix == &apos;bottom&apos; ? this.getPinnedOffset() : null this.$element .removeClass(Affix.RESET) .addClass(affixType) .trigger(affixType.replace(&apos;affix&apos;, &apos;affixed&apos;) + &apos;.bs.affix&apos;) &#125; // 到达底部时，去掉fixed后，改成relative，设置top属性为刚为bottom时的位置 if (affix == &apos;bottom&apos;) &#123; this.$element.offset(&#123; top: scrollHeight - height - offsetBottom &#125;) &#125; &#125; // AFFIX PLUGIN DEFINITION // ======================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.affix&apos;) var options = typeof option == &apos;object&apos; &amp;&amp; option if (!data) $this.data(&apos;bs.affix&apos;, (data = new Affix(this, options))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.affix $.fn.affix = Plugin $.fn.affix.Constructor = Affix // AFFIX NO CONFLICT // ================= $.fn.affix.noConflict = function () &#123; $.fn.affix = old return this &#125; // AFFIX DATA-API // ============== $(window).on(&apos;load&apos;, function () &#123; $(&apos;[data-spy=&quot;affix&quot;]&apos;).each(function () &#123; var $spy = $(this) var data = $spy.data() data.offset = data.offset || &#123;&#125; if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom if (data.offsetTop != null) data.offset.top = data.offsetTop Plugin.call($spy, data) &#125;) &#125;)&#125;(jQuery); 二、utilities.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Utility classes// --------------------------------------------------// Floats// -------------------------.clearfix &#123; .clearfix();&#125;.center-block &#123; .center-block();&#125;.pull-right &#123; float: right !important;&#125;.pull-left &#123; float: left !important;&#125;// Toggling content// -------------------------// Note: Deprecated .hide in favor of .hidden or .sr-only (as appropriate) in v3.0.1.hide &#123; display: none !important;&#125;.show &#123; display: block !important;&#125;.invisible &#123; visibility: hidden;&#125;.text-hide &#123; .text-hide();&#125;// Hide from screenreaders and browsers//// Credit: HTML5 Boilerplate.hidden &#123; display: none !important;&#125;// For Affix plugin(固定定位插件)// -------------------------.affix &#123; position: fixed;&#125; 三、应用 &amp; 源码分析1、应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240&lt;style&gt; /* Custom Styles */ ul.nav-tabs &#123; width: 140px; margin-top: 20px; border-radius: 4px; border: 1px solid #ddd; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.067); &#125; ul.nav-tabs li &#123; margin: 0; border-top: 1px solid #ddd; &#125; ul.nav-tabs li:first-child &#123; border-top: none; &#125; ul.nav-tabs li a &#123; margin: 0; padding: 8px 16px; border-radius: 0; &#125; ul.nav-tabs li.active a, ul.nav-tabs li.active a:hover &#123; color: #fff; background: #0088cc; border: 1px solid #0088cc; &#125; ul.nav-tabs li:first-child a &#123; border-radius: 4px 4px 0 0; &#125; ul.nav-tabs li:last-child a &#123; border-radius: 0 0 4px 4px; &#125; ul.nav-tabs.affix &#123; top: 30px; /* Set the top position of pinned element */ &#125;&lt;/style&gt;&lt;body data-spy=&quot;scroll&quot; data-target=&quot;#myScrollspy&quot;&gt;&lt;script&gt; $(document).ready(function () &#123; $(&quot;#myNav&quot;).affix(&#123; offset: &#123; top: 125, bottom: function () &#123; return (this.bottom = $(&apos;#comments&apos;).outerHeight(true) + $(&apos;#footer&apos;).outerHeight(true) + 40) &#125; &#125; &#125;); &#125;);&lt;/script&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;Bootstrap Affix&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-3&quot; id=&quot;myScrollspy&quot;&gt; &lt;ul class=&quot;nav nav-tabs nav-stacked&quot; id=&quot;myNav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#section-1&quot;&gt;第一部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;第二部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;第三部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;第四部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;第五部分&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-9&quot;&gt; &lt;h2 id=&quot;section-1&quot;&gt;第一部分&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam eu sem tempor, varius quam at, luctus dui. Mauris magna metus, dapibus nec turpis vel, semper malesuada ante. Vestibulum id metus ac nisl bibendum scelerisque non non purus. Suspendisse varius nibh non aliquet sagittis. In tincidunt orci sit amet elementum vestibulum. Vivamus fermentum in arcu in aliquam. Quisque aliquam porta odio in fringilla. Vivamus nisl leo, blandit at bibendum eu, tristique eget risus. Integer aliquet quam ut elit suscipit, id interdum neque porttitor. Integer faucibus ligula.&lt;/p&gt; &lt;p&gt;Vestibulum quis quam ut magna consequat faucibus. Pellentesque eget nisi a mi suscipit tincidunt. Ut tempus dictum risus. Pellentesque viverra sagittis quam at mattis. Suspendisse potenti. Aliquam sit amet gravida nibh, facilisis gravida odio. Phasellus auctor velit at lacus blandit, commodo iaculis justo viverra. Etiam vitae est arcu. Mauris vel congue dolor. Aliquam eget mi mi. Fusce quam tortor, commodo ac dui quis, bibendum viverra erat. Maecenas mattis lectus enim, quis tincidunt dui molestie euismod. Curabitur et diam tristique, accumsan nunc eu, hendrerit tellus.&lt;/p&gt; &lt;hr&gt; &lt;h2 id=&quot;section-2&quot;&gt;第二部分&lt;/h2&gt; &lt;p&gt;Nullam hendrerit justo non leo aliquet imperdiet. Etiam in sagittis lectus. Suspendisse ultrices placerat accumsan. Mauris quis dapibus orci. In dapibus velit blandit pharetra tincidunt. Quisque non sapien nec lacus condimentum facilisis ut iaculis enim. Sed viverra interdum bibendum. Donec ac sollicitudin dolor. Sed fringilla vitae lacus at rutrum. Phasellus congue vestibulum ligula sed consequat.&lt;/p&gt; &lt;p&gt;Vestibulum consectetur scelerisque lacus, ac fermentum lorem convallis sed. Nam odio tortor, dictum quis malesuada at, pellentesque vitae orci. Vivamus elementum, felis eu auctor lobortis, diam velit egestas lacus, quis fermentum metus ante quis urna. Sed at facilisis libero. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Vestibulum bibendum blandit dolor. Nunc orci dolor, molestie nec nibh in, hendrerit tincidunt ante. Vivamus sem augue, hendrerit non sapien in, mollis ornare augue.&lt;/p&gt; &lt;hr&gt; &lt;h2 id=&quot;section-3&quot;&gt;第三部分&lt;/h2&gt; &lt;p&gt;Integer pulvinar leo id risus pellentesque vestibulum. Sed diam libero, sodales eget sapien vel, porttitor bibendum enim. Donec sed nibh vitae lorem porttitor blandit in nec ante. Pellentesque vitae metus ipsum. Phasellus sed nunc ac sem malesuada condimentum. Etiam in aliquam lectus. Nam vel sapien diam. Donec pharetra id arcu eget blandit. Proin imperdiet mattis augue in porttitor. Quisque tempus enim id lobortis feugiat. Suspendisse tincidunt risus quis dolor fringilla blandit. Ut sed sapien at purus lacinia porttitor. Nullam iaculis, felis a pretium ornare, dolor nisl semper tortor, vel sagittis lacus est consequat eros. Sed id pretium nisl. Curabitur dolor nisl, laoreet vitae aliquam id, tincidunt sit amet mauris.&lt;/p&gt; &lt;p&gt;Phasellus vitae suscipit justo. Mauris pharetra feugiat ante id lacinia. Etiam faucibus mauris id tempor egestas. Duis luctus turpis at accumsan tincidunt. Phasellus risus risus, volutpat vel tellus ac, tincidunt fringilla massa. Etiam hendrerit dolor eget ante rutrum adipiscing. Cras interdum ipsum mattis, tempus mauris vel, semper ipsum. Duis sed dolor ut enim lobortis pellentesque ultricies ac ligula. Pellentesque convallis elit nisi, id vulputate ipsum ullamcorper ut. Cras ac pulvinar purus, ac viverra est. Suspendisse potenti. Integer pellentesque neque et elementum tempus. Curabitur bibendum in ligula ut rhoncus.&lt;/p&gt; &lt;p&gt;Quisque pharetra velit id velit iaculis pretium. Nullam a justo sed ligula porta semper eu quis enim. Pellentesque pellentesque, metus at facilisis hendrerit, lectus velit facilisis leo, quis volutpat turpis arcu quis enim. Nulla viverra lorem elementum interdum ultricies. Suspendisse accumsan quam nec ante mollis tempus. Morbi vel accumsan diam, eget convallis tellus. Suspendisse potenti.&lt;/p&gt; &lt;hr&gt; &lt;h2 id=&quot;section-4&quot;&gt;第四部分&lt;/h2&gt; &lt;p&gt;Suspendisse a orci facilisis, dignissim tortor vitae, ultrices mi. Vestibulum a iaculis lacus. Phasellus vitae convallis ligula, nec volutpat tellus. Vivamus scelerisque mollis nisl, nec vehicula elit egestas a. Sed luctus metus id mi gravida, faucibus convallis neque pretium. Maecenas quis sapien ut leo fringilla tempor vitae sit amet leo. Donec imperdiet tempus placerat. Pellentesque pulvinar ultrices nunc sed ultrices. Morbi vel mi pretium, fermentum lacus et, viverra tellus. Phasellus sodales libero nec dui convallis, sit amet fermentum sapien auctor. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed eu elementum nibh, quis varius libero.&lt;/p&gt; &lt;p&gt;Vestibulum quis quam ut magna consequat faucibus. Pellentesque eget nisi a mi suscipit tincidunt. Ut tempus dictum risus. Pellentesque viverra sagittis quam at mattis. Suspendisse potenti. Aliquam sit amet gravida nibh, facilisis gravida odio. Phasellus auctor velit at lacus blandit, commodo iaculis justo viverra. Etiam vitae est arcu. Mauris vel congue dolor. Aliquam eget mi mi. Fusce quam tortor, commodo ac dui quis, bibendum viverra erat. Maecenas mattis lectus enim, quis tincidunt dui molestie euismod. Curabitur et diam tristique, accumsan nunc eu, hendrerit tellus.&lt;/p&gt; &lt;p&gt;Phasellus fermentum, neque sit amet sodales tempor, enim ante interdum eros, eget luctus ipsum eros ut ligula. Nunc ornare erat quis faucibus molestie. Proin malesuada consequat commodo. Mauris iaculis, eros ut dapibus luctus, massa enim elementum purus, sit amet tristique purus purus nec felis. Morbi vestibulum sapien eget porta pulvinar. Nam at quam diam. Proin rhoncus, felis elementum accumsan dictum, felis nisi vestibulum tellus, et ultrices risus felis in orci. Quisque vestibulum sem nisl, vel congue leo dictum nec. Cras eget est at velit sagittis ullamcorper vel et lectus. In hac habitasse platea dictumst. Etiam interdum iaculis velit, vel sollicitudin lorem feugiat sit amet. Etiam luctus, quam sed sodales aliquam, lorem libero hendrerit urna, faucibus rhoncus massa nibh at felis. Curabitur ac tempus nulla, ut semper erat. Vivamus porta ullamcorper sem, ornare egestas mauris facilisis id.&lt;/p&gt; &lt;p&gt;Ut ut risus nisl. Fusce porttitor eros at magna luctus, non congue nulla eleifend. Aenean porttitor feugiat dolor sit amet facilisis. Pellentesque venenatis magna et risus commodo, a commodo turpis gravida. Nam mollis massa dapibus urna aliquet, quis iaculis elit sodales. Sed eget ornare orci, eu malesuada justo. Nunc lacus augue, dictum quis dui id, lacinia congue quam. Nulla sem sem, aliquam nec dolor ac, tempus convallis nunc. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nulla suscipit convallis iaculis. Quisque eget commodo ligula. Praesent leo dui, facilisis quis eleifend in, aliquet vitae nunc. Suspendisse fermentum odio ac massa ultricies pellentesque. Fusce eu suscipit massa.&lt;/p&gt; &lt;hr&gt; &lt;h2 id=&quot;section-5&quot;&gt;第五部分&lt;/h2&gt; &lt;p&gt;Nam eget purus nec est consectetur vehicula. Nullam ultrices nisl risus, in viverra libero egestas sit amet. Etiam porttitor dolor non eros pulvinar malesuada. Vestibulum sit amet est mollis nulla tempus aliquet. Praesent luctus hendrerit arcu non laoreet. Morbi consequat placerat magna, ac ornare odio sagittis sed. Donec vitae ullamcorper purus. Vivamus non metus ac justo porta volutpat.&lt;/p&gt; &lt;p&gt;Vivamus mattis accumsan erat, vel convallis risus pretium nec. Integer nunc nulla, viverra ut sem non, scelerisque vehicula arcu. Fusce bibendum convallis augue sit amet lobortis. Cras porta urna turpis, sodales lobortis purus adipiscing id. Maecenas ullamcorper, turpis suscipit pellentesque fringilla, massa lacus pulvinar mi, nec dignissim velit arcu eget purus. Nam at dapibus tellus, eget euismod nisl. Ut eget venenatis sapien. Vivamus vulputate varius mauris, vel varius nisl facilisis ac. Nulla aliquet justo a nibh ornare, eu congue neque rutrum.&lt;/p&gt; &lt;p&gt;Suspendisse a orci facilisis, dignissim tortor vitae, ultrices mi. Vestibulum a iaculis lacus. Phasellus vitae convallis ligula, nec volutpat tellus. Vivamus scelerisque mollis nisl, nec vehicula elit egestas a. Sed luctus metus id mi gravida, faucibus convallis neque pretium. Maecenas quis sapien ut leo fringilla tempor vitae sit amet leo. Donec imperdiet tempus placerat. Pellentesque pulvinar ultrices nunc sed ultrices. Morbi vel mi pretium, fermentum lacus et, viverra tellus. Phasellus sodales libero nec dui convallis, sit amet fermentum sapien auctor. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed eu elementum nibh, quis varius libero.&lt;/p&gt; &lt;p&gt;Morbi sed fermentum ipsum. Morbi a orci vulputate tortor ornare blandit a quis orci. Donec aliquam sodales gravida. In ut ullamcorper nisi, ac pretium velit. Vestibulum vitae lectus volutpat, consequat lorem sit amet, pulvinar tellus. In tincidunt vel leo eget pulvinar. Curabitur a eros non lacus malesuada aliquam. Praesent et tempus odio. Integer a quam nunc. In hac habitasse platea dictumst. Aliquam porta nibh nulla, et mattis turpis placerat eget. Pellentesque dui diam, pellentesque vel gravida id, accumsan eu magna. Sed a semper arcu, ut dignissim leo.&lt;/p&gt; &lt;p&gt;Sed vitae lobortis diam, id molestie magna. Aliquam consequat ipsum quis est dictum ultrices. Aenean nibh velit, fringilla in diam id, blandit hendrerit lacus. Donec vehicula rutrum tellus eget fermentum. Pellentesque ac erat et arcu ornare tincidunt. Aliquam erat volutpat. Vivamus lobortis urna quis gravida semper. In condimentum, est a faucibus luctus, mi dolor cursus mi, id vehicula arcu risus a nibh. Pellentesque blandit sapien lacus, vel vehicula nunc feugiat sit amet.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div id=&quot;comments&quot;&gt; &lt;p&gt;Nam eget purus nec est consectetur vehicula. Nullam ultrices nisl risus, in viverra libero egestas sit amet. Etiam porttitor dolor non eros pulvinar malesuada. Vestibulum sit amet est mollis nulla tempus aliquet. Praesent luctus hendrerit arcu non laoreet. Morbi consequat placerat magna, ac ornare odio sagittis sed. Donec vitae ullamcorper purus. Vivamus non metus ac justo porta volutpat.&lt;/p&gt; &lt;p&gt;Vivamus mattis accumsan erat, vel convallis risus pretium nec. Integer nunc nulla, viverra ut sem non, scelerisque vehicula arcu. Fusce bibendum convallis augue sit amet lobortis. Cras porta urna turpis, sodales lobortis purus adipiscing id. Maecenas ullamcorper, turpis suscipit pellentesque fringilla, massa lacus pulvinar mi, nec dignissim velit arcu eget purus. Nam at dapibus tellus, eget euismod nisl. Ut eget venenatis sapien. Vivamus vulputate varius mauris, vel varius nisl facilisis ac. Nulla aliquet justo a nibh ornare, eu congue neque rutrum.&lt;/p&gt; &lt;p&gt;Suspendisse a orci facilisis, dignissim tortor vitae, ultrices mi. Vestibulum a iaculis lacus. Phasellus vitae convallis ligula, nec volutpat tellus. Vivamus scelerisque mollis nisl, nec vehicula elit egestas a. Sed luctus metus id mi gravida, faucibus convallis neque pretium. Maecenas quis sapien ut leo fringilla tempor vitae sit amet leo. Donec imperdiet tempus placerat. Pellentesque pulvinar ultrices nunc sed ultrices. Morbi vel mi pretium, fermentum lacus et, viverra tellus. Phasellus sodales libero nec dui convallis, sit amet fermentum sapien auctor. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed eu elementum nibh, quis varius libero.&lt;/p&gt; &lt;p&gt;Morbi sed fermentum ipsum. Morbi a orci vulputate tortor ornare blandit a quis orci. Donec aliquam sodales gravida. In ut ullamcorper nisi, ac pretium velit. Vestibulum vitae lectus volutpat, consequat lorem sit amet, pulvinar tellus. In tincidunt vel leo eget pulvinar. Curabitur a eros non lacus malesuada aliquam. Praesent et tempus odio. Integer a quam nunc. In hac habitasse platea dictumst. Aliquam porta nibh nulla, et mattis turpis placerat eget. Pellentesque dui diam, pellentesque vel gravida id, accumsan eu magna. Sed a semper arcu, ut dignissim leo.&lt;/p&gt; &lt;p&gt;Sed vitae lobortis diam, id molestie magna. Aliquam consequat ipsum quis est dictum ultrices. Aenean nibh velit, fringilla in diam id, blandit hendrerit lacus. Donec vehicula rutrum tellus eget fermentum. Pellentesque ac erat et arcu ornare tincidunt. Aliquam erat volutpat. Vivamus lobortis urna quis gravida semper. In condimentum, est a faucibus luctus, mi dolor cursus mi, id vehicula arcu risus a nibh. Pellentesque blandit sapien lacus, vel vehicula nunc feugiat sit amet.&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;p&gt;Nam eget purus nec est consectetur vehicula. Nullam ultrices nisl risus, in viverra libero egestas sit amet. Etiam porttitor dolor non eros pulvinar malesuada. Vestibulum sit amet est mollis nulla tempus aliquet. Praesent luctus hendrerit arcu non laoreet. Morbi consequat placerat magna, ac ornare odio sagittis sed. Donec vitae ullamcorper purus. Vivamus non metus ac justo porta volutpat.&lt;/p&gt; &lt;p&gt;Vivamus mattis accumsan erat, vel convallis risus pretium nec. Integer nunc nulla, viverra ut sem non, scelerisque vehicula arcu. Fusce bibendum convallis augue sit amet lobortis. Cras porta urna turpis, sodales lobortis purus adipiscing id. Maecenas ullamcorper, turpis suscipit pellentesque fringilla, massa lacus pulvinar mi, nec dignissim velit arcu eget purus. Nam at dapibus tellus, eget euismod nisl. Ut eget venenatis sapien. Vivamus vulputate varius mauris, vel varius nisl facilisis ac. Nulla aliquet justo a nibh ornare, eu congue neque rutrum.&lt;/p&gt; &lt;p&gt;Suspendisse a orci facilisis, dignissim tortor vitae, ultrices mi. Vestibulum a iaculis lacus. Phasellus vitae convallis ligula, nec volutpat tellus. Vivamus scelerisque mollis nisl, nec vehicula elit egestas a. Sed luctus metus id mi gravida, faucibus convallis neque pretium. Maecenas quis sapien ut leo fringilla tempor vitae sit amet leo. Donec imperdiet tempus placerat. Pellentesque pulvinar ultrices nunc sed ultrices. Morbi vel mi pretium, fermentum lacus et, viverra tellus. Phasellus sodales libero nec dui convallis, sit amet fermentum sapien auctor. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed eu elementum nibh, quis varius libero.&lt;/p&gt; &lt;p&gt;Morbi sed fermentum ipsum. Morbi a orci vulputate tortor ornare blandit a quis orci. Donec aliquam sodales gravida. In ut ullamcorper nisi, ac pretium velit. Vestibulum vitae lectus volutpat, consequat lorem sit amet, pulvinar tellus. In tincidunt vel leo eget pulvinar. Curabitur a eros non lacus malesuada aliquam. Praesent et tempus odio. Integer a quam nunc. In hac habitasse platea dictumst. Aliquam porta nibh nulla, et mattis turpis placerat eget. Pellentesque dui diam, pellentesque vel gravida id, accumsan eu magna. Sed a semper arcu, ut dignissim leo.&lt;/p&gt; &lt;p&gt;Sed vitae lobortis diam, id molestie magna. Aliquam consequat ipsum quis est dictum ultrices. Aenean nibh velit, fringilla in diam id, blandit hendrerit lacus. Donec vehicula rutrum tellus eget fermentum. Pellentesque ac erat et arcu ornare tincidunt. Aliquam erat volutpat. Vivamus lobortis urna quis gravida semper. In condimentum, est a faucibus luctus, mi dolor cursus mi, id vehicula arcu risus a nibh. Pellentesque blandit sapien lacus, vel vehicula nunc feugiat sit amet.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 2、源码分析1、getState开始时滚动元素滚动距离少于自定义 offsetTop 高度返回 affix-top ；当滚动元素滚动超过自定义 offsetTop 高度时，返回 affix；当目标元素滚动距离超过了(内容高度scrollHeight - offsetBottom - 元素高度targetHeight)时返回 affix-bottom2、checkPosition根据 getState 返回的状态进行判断设置相应的类，返回 affix-top 时不做任何处理；返回 affix 时设置 position 为 absolute；返回affix-bottom 时设置 position 为 relative，并设置 top 为相应的高度(源代码存在一个 bug，需在从 affix-bottom 状态转变为 affix 状态时设置行内 top 为空，同时设置清空行内 position)","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 media & close & well 样式","slug":"bootstrap/media&close&well","date":"2017-11-11T15:18:38.000Z","updated":"2018-04-15T13:39:15.000Z","comments":true,"path":"bootstrap/media&close&well/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/media&close&well/","excerpt":"现在开始介绍 bootstrap 的多媒体(media)、关闭图标(close)和凹陷容器(well)样式。","text":"现在开始介绍 bootstrap 的多媒体(media)、关闭图标(close)和凹陷容器(well)样式。 一、源码1、media.less1.1、media.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.media &#123; // Proper spacing between instances of .media margin-top: 15px; &amp;:first-child &#123; margin-top: 0; &#125;&#125;.media,.media-body &#123; zoom: 1; overflow: hidden;&#125;.media-body &#123; width: 10000px;&#125;.media-object &#123; display: block; // Fix collapse in webkit from max-width: 100% and display: table-cell. &amp;.img-thumbnail &#123; max-width: none; &#125;&#125;.media-right,.media &gt; .pull-right &#123; padding-left: 10px;&#125;.media-left,.media &gt; .pull-left &#123; padding-right: 10px;&#125;.media-left,.media-right,.media-body &#123; display: table-cell; vertical-align: top;&#125;.media-middle &#123; vertical-align: middle;&#125;.media-bottom &#123; vertical-align: bottom;&#125;// Reset margins on headings for tighter default spacing.media-heading &#123; margin-top: 0; margin-bottom: 5px;&#125;// Media list variation//// Undo default ul/ol styles.media-list &#123; padding-left: 0; list-style: none;&#125; 1.2、media.less 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;ul class=&quot;media-list&quot;&gt; &lt;li class=&quot;media&quot;&gt; &lt;!--使用table布局同行显示--&gt; &lt;a class=&quot;media-left&quot; href=&quot;#&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; width=&quot;64px&quot; alt=&quot;通用的占位符图像&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;媒体标题&lt;/h4&gt; &lt;p&gt;这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。&lt;/p&gt; &lt;!-- 嵌套的媒体对象 --&gt; &lt;div class=&quot;media&quot;&gt; &lt;a class=&quot;media-left&quot; href=&quot;#&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; width=&quot;64px&quot; alt=&quot;通用的占位符图像&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;嵌套的媒体标题&lt;/h4&gt; 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 &lt;!-- 嵌套的媒体对象 --&gt; &lt;div class=&quot;media&quot;&gt; &lt;a class=&quot;media-left&quot; href=&quot;#&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; width=&quot;64px&quot; alt=&quot;通用的占位符图像&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;嵌套的媒体标题&lt;/h4&gt; 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 嵌套的媒体对象 --&gt; &lt;div class=&quot;media&quot;&gt; &lt;a class=&quot;media-left&quot; href=&quot;#&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; width=&quot;64px&quot; alt=&quot;通用的占位符图像&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;嵌套的媒体标题&lt;/h4&gt; 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;media&quot;&gt; &lt;a class=&quot;media-right&quot; href=&quot;#&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; width=&quot;64px&quot; alt=&quot;通用的占位符图像&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;媒体标题&lt;/h4&gt; 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 这是一些示例文本。这是一些示例文本。 &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 2、close.less2.1、close.less 源码12345678910111213141516171819202122232425262728293031323334//// Close icons// --------------------------------------------------.close &#123; float: right; font-size: (@font-size-base * 1.5); font-weight: @close-font-weight; line-height: 1; color: @close-color; text-shadow: @close-text-shadow; .opacity(.2); &amp;:hover, &amp;:focus &#123; color: @close-color; text-decoration: none; cursor: pointer; .opacity(.5); &#125; // Additional properties for button version // iOS requires the button element instead of an anchor tag. // If you want the anchor version, it requires `href=&quot;#&quot;`. // See https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile button&amp; &#123; padding: 0; cursor: pointer; background: transparent; border: 0; -webkit-appearance: none; &#125;&#125; 2.2、close.less 应用1&lt;span class=&quot;close&quot;&gt;x&lt;/span&gt; 3、wells.less.less3.1、wells.less 源码1234567891011121314151617181920212223242526272829//// Wells// --------------------------------------------------// Base class.well &#123; min-height: 20px; padding: 19px; margin-bottom: 20px; background-color: @well-bg; border: 1px solid @well-border; border-radius: @border-radius-base; .box-shadow(inset 0 1px 1px rgba(0,0,0,.05)); blockquote &#123; border-color: #ddd; border-color: rgba(0,0,0,.15); &#125;&#125;// Sizes.well-lg &#123; padding: 24px; border-radius: @border-radius-large;&#125;.well-sm &#123; padding: 9px; border-radius: @border-radius-small;&#125; 3.2、wells.less 应用1234&lt;!--box-shadow: inset 达到凹陷的效果--&gt;&lt;div class=&quot;well&quot;&gt;您好，我在 Well 中！&lt;/div&gt;&lt;div class=&quot;well well-lg&quot;&gt;您好，我在大的 Well 中！&lt;/div&gt;&lt;div class=&quot;well well-sm&quot;&gt;您好，我在小的 Well 中！&lt;/div&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 jumbotron & thumbnail & progressBar 样式","slug":"bootstrap/jumbotron&thumbnail&progressBar","date":"2017-11-11T14:54:04.000Z","updated":"2018-04-15T13:35:05.000Z","comments":true,"path":"bootstrap/jumbotron&thumbnail&progressBar/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/jumbotron&thumbnail&progressBar/","excerpt":"现在开始介绍 bootstrap 的超大屏幕(jumbotron)、缩略图(thumbnail)和徽章(badge)样式。","text":"现在开始介绍 bootstrap 的超大屏幕(jumbotron)、缩略图(thumbnail)和徽章(badge)样式。 一、源码1、jumbotron.less1.1、jumbotron.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// Jumbotron// --------------------------------------------------.jumbotron &#123; padding-top: @jumbotron-padding; padding-bottom: @jumbotron-padding; margin-bottom: @jumbotron-padding; color: @jumbotron-color; background-color: @jumbotron-bg; h1, .h1 &#123; color: @jumbotron-heading-color; &#125; p &#123; margin-bottom: (@jumbotron-padding / 2); font-size: @jumbotron-font-size; font-weight: 200; &#125; &gt; hr &#123; border-top-color: darken(@jumbotron-bg, 10%); &#125; .container &amp;, .container-fluid &amp; &#123; border-radius: @border-radius-large; // Only round corners at higher resolutions if contained in a container padding-left: (@grid-gutter-width / 2); padding-right: (@grid-gutter-width / 2); &#125; .container &#123; max-width: 100%; &#125; @media screen and (min-width: @screen-sm-min) &#123; padding-top: (@jumbotron-padding * 1.6); padding-bottom: (@jumbotron-padding * 1.6); .container &amp;, .container-fluid &amp; &#123; padding-left: (@jumbotron-padding * 2); padding-right: (@jumbotron-padding * 2); &#125; h1, .h1 &#123; font-size: @jumbotron-heading-font-size; &#125; &#125;&#125; 1.2、jumbotron.less应用12345678910&lt;!--超大屏幕: h1更大，font-weight被减为200--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;欢迎登陆页面！&lt;/h1&gt; &lt;p&gt;这是一个超大屏幕（Jumbotron）的实例。&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; role=&quot;button&quot;&gt; 学习更多&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 2、thumbnails.less2.1、thumbnails.less源码123456789101112131415161718192021222324252627282930313233343536//// Thumbnails(更为复杂的缩略图，相对于scaffolding.less的.img-thumbnail来说，可以配合bootstrap的栅格系统显示标题、描述内容、按钮等)// --------------------------------------------------// Mixin and adjust the regular image class.thumbnail &#123; display: block; padding: @thumbnail-padding; margin-bottom: @line-height-computed; line-height: @line-height-base; background-color: @thumbnail-bg; border: 1px solid @thumbnail-border; border-radius: @thumbnail-border-radius; .transition(border .2s ease-in-out); &gt; img, a &gt; img &#123; &amp;:extend(.img-responsive); margin-left: auto; margin-right: auto; &#125; // Add a hover state for linked versions only a&amp;:hover, a&amp;:focus, a&amp;.active &#123; border-color: @link-color; &#125; // Image captions .caption &#123; padding: @thumbnail-caption-padding; color: @thumbnail-caption-color; &#125;&#125; 2.2、thumbnails.less应用123456789101112131415161718192021222324252627282930313233343536&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; alt=&quot;通用的占位符缩略图&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h3&gt;缩略图标签&lt;/h3&gt; &lt;p&gt;一些示例文本。一些示例文本。&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot; role=&quot;button&quot;&gt; 按钮 &lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default&quot; role=&quot;button&quot;&gt; 按钮 &lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-6 col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;/assets/bootstrap/kittens.jpg&quot; alt=&quot;通用的占位符缩略图&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h3&gt;缩略图标签&lt;/h3&gt; &lt;p&gt;一些示例文本。一些示例文本。&lt;/p&gt; &lt;p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot; role=&quot;button&quot;&gt; 按钮 &lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-default&quot; role=&quot;button&quot;&gt; 按钮 &lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3、progress-bars.less3.1、progress-bars.less源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Progress bars// --------------------------------------------------// Bar animations(进度条动画)// -------------------------// WebKit@-webkit-keyframes progress-bar-stripes &#123; from &#123; background-position: 40px 0; &#125; to &#123; background-position: 0 0; &#125;&#125;// Spec and IE10+@keyframes progress-bar-stripes &#123; from &#123; background-position: 40px 0; &#125; to &#123; background-position: 0 0; &#125;&#125;// Bar itself// -------------------------// Outer container(外容器).progress &#123; overflow: hidden; height: @line-height-computed; margin-bottom: @line-height-computed; background-color: @progress-bg; border-radius: @progress-border-radius; .box-shadow(inset 0 1px 2px rgba(0,0,0,.1));&#125;// Bar of progress(进度条).progress-bar &#123; float: left; width: 0%; height: 100%; font-size: @font-size-small; line-height: @line-height-computed; color: @progress-bar-color; text-align: center; background-color: @progress-bar-bg; .box-shadow(inset 0 -1px 0 rgba(0,0,0,.15)); .transition(width .6s ease);&#125;// Striped bars(条纹进度条)//// `.progress-striped .progress-bar` is deprecated as of v3.2.0 in favor of the// `.progress-bar-striped` class, which you just add to an existing// `.progress-bar`..progress-striped .progress-bar,.progress-bar-striped &#123; #gradient &gt; .striped(); background-size: 40px 40px;&#125;// Call animation for the active one(动态条纹进度条)//// `.progress.active .progress-bar` is deprecated as of v3.2.0 in favor of the// `.progress-bar.active` approach..progress.active .progress-bar,.progress-bar.active &#123; .animation(progress-bar-stripes 2s linear infinite);&#125;// Variations(彩色进度条)// -------------------------.progress-bar-success &#123; .progress-bar-variant(@progress-bar-success-bg);&#125;.progress-bar-info &#123; .progress-bar-variant(@progress-bar-info-bg);&#125;.progress-bar-warning &#123; .progress-bar-variant(@progress-bar-warning-bg);&#125;.progress-bar-danger &#123; .progress-bar-variant(@progress-bar-danger-bg);&#125; 3.2、progress-bars.less应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!--进度条--&gt;&lt;div class=&quot;progress&quot;&gt; &lt;!--进度条状态--&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 90%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;90% 完成（成功）&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-info&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 30%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;30% 完成（信息）&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--条纹进度条--&gt;&lt;div class=&quot;progress progress-striped&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-warning&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 20%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;20% 完成（警告）&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--动画的进度条: 使线性渐变具有动画效果--&gt;&lt;div class=&quot;progress progress-striped active&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-danger&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 10%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;10% 完成（危险）&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--堆叠的进度条--&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 40%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;40% 完成&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-info&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 30%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;30% 完成（信息）&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-warning&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;60&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 20%;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;20% 完成（警告）&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 pager & listGroup & badge 样式","slug":"bootstrap/pager&listGroup&badge","date":"2017-11-11T14:17:31.000Z","updated":"2018-04-15T13:48:53.000Z","comments":true,"path":"bootstrap/pager&listGroup&badge/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/pager&listGroup&badge/","excerpt":"现在开始介绍 bootstrap 的翻页(pager)、列表组(list-group)和徽章(badge) 样式。","text":"现在开始介绍 bootstrap 的翻页(pager)、列表组(list-group)和徽章(badge) 样式。 一、源码1、pager.less1.1、pager.less源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Pager pagination(翻页分页导航)// --------------------------------------------------.pager &#123; padding-left: 0; margin: @line-height-computed 0; list-style: none; text-align: center; &amp;:extend(.clearfix all); li &#123; display: inline; &gt; a, &gt; span &#123; display: inline-block; padding: 5px 14px; background-color: @pager-bg; border: 1px solid @pager-border; border-radius: @pager-border-radius; &#125; &gt; a:hover, &gt; a:focus &#123; text-decoration: none; background-color: @pager-hover-bg; &#125; &#125; .next &#123; &gt; a, &gt; span &#123; float: right; &#125; &#125; .previous &#123; &gt; a, &gt; span &#123; float: left; &#125; &#125; .disabled &#123; &gt; a, &gt; a:hover, &gt; a:focus, &gt; span &#123; color: @pager-disabled-color; background-color: @pager-bg; cursor: @cursor-disabled; &#125; &#125;&#125; 1.2、pager.less应用1234567891011&lt;!--默认的翻页--&gt;&lt;ul class=&quot;pager&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;larr; Previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Next &amp;rarr;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--对齐的链接--&gt;&lt;ul class=&quot;pager&quot;&gt; &lt;!--翻页的状态--&gt; &lt;li class=&quot;previous disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;&amp;larr; Older&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;#&quot;&gt;Newer &amp;rarr;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 2、list-group.less2.1、list-group.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//// List groups(列表组)// --------------------------------------------------// Base class(基础列表样式)//// Easily usable on &lt;ul&gt;, &lt;ol&gt;, or &lt;div&gt;..list-group &#123; // No need to set list-style: none; since .list-group-item is block level margin-bottom: 20px; padding-left: 0; // reset padding because ul and ol&#125;// Individual list items(基础列表项)//// Use on `li`s or `div`s within the `.list-group` parent..list-group-item &#123; position: relative; display: block; padding: 10px 15px; // Place the border on the list items and negative margin up for better styling margin-bottom: -1px; background-color: @list-group-bg; border: 1px solid @list-group-border; // Round the first and last items &amp;:first-child &#123; .border-top-radius(@list-group-border-radius); &#125; &amp;:last-child &#123; margin-bottom: 0; .border-bottom-radius(@list-group-border-radius); &#125;&#125;// Interactive list items//// Use anchor or button elements instead of `li`s or `div`s to create interactive items.// Includes an extra `.active` modifier class for showing selected items.// 带链接的列表组a.list-group-item,button.list-group-item &#123; color: @list-group-link-color; .list-group-item-heading &#123; color: @list-group-link-heading-color; &#125; // Hover state &amp;:hover, &amp;:focus &#123; text-decoration: none; color: @list-group-link-hover-color; background-color: @list-group-hover-bg; &#125;&#125;button.list-group-item &#123; width: 100%; text-align: left;&#125;// 列表项的状态设置.list-group-item &#123; // Disabled state &amp;.disabled, &amp;.disabled:hover, &amp;.disabled:focus &#123; background-color: @list-group-disabled-bg; color: @list-group-disabled-color; cursor: @cursor-disabled; // Force color to inherit for custom content .list-group-item-heading &#123; color: inherit; &#125; .list-group-item-text &#123; color: @list-group-disabled-text-color; &#125; &#125; // Active class on item itself, not parent &amp;.active, &amp;.active:hover, &amp;.active:focus &#123; z-index: 2; // Place active items above their siblings for proper border styling color: @list-group-active-color; background-color: @list-group-active-bg; border-color: @list-group-active-border; // Force color to inherit for custom content .list-group-item-heading, .list-group-item-heading &gt; small, .list-group-item-heading &gt; .small &#123; color: inherit; &#125; .list-group-item-text &#123; color: @list-group-active-text-color; &#125; &#125;&#125;// Contextual variants(多彩列表组)//// Add modifier classes to change text and background color on individual items.// Organizationally, this must come after the `:hover` states..list-group-item-variant(success; @state-success-bg; @state-success-text);.list-group-item-variant(info; @state-info-bg; @state-info-text);.list-group-item-variant(warning; @state-warning-bg; @state-warning-text);.list-group-item-variant(danger; @state-danger-bg; @state-danger-text);// Custom content options(自定义列表组)//// Extra classes for creating well-formatted content within `.list-group-item`s..list-group-item-heading &#123; margin-top: 0; margin-bottom: 5px;&#125;.list-group-item-text &#123; margin-bottom: 0; line-height: 1.3;&#125; 2.2、list-group.less应用123456789101112131415161718192021&lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;免费域名注册&lt;/li&gt; &lt;!--列表项的状态--&gt; &lt;li class=&quot;list-group-item disabled&quot;&gt;免费 Window 空间托管&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;图像的数量&lt;/li&gt; &lt;!--添加徽章--&gt; &lt;li class=&quot;list-group-item&quot;&gt;&lt;span class=&quot;badge&quot;&gt;新&lt;/span&gt;24*7 支持&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;每年更新成本&lt;/li&gt; &lt;!--添加链接--&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item active&quot;&gt;免费域名注册&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;24*7 支持&lt;/a&gt; &lt;!--添加自定义内容--&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt; &lt;h4 class=&quot;list-group-item-heading&quot;&gt; 免费域名注册 &lt;/h4&gt; &lt;p class=&quot;list-group-item-text&quot;&gt; 您将通过网页进行免费域名注册。 &lt;/p&gt; &lt;/a&gt;&lt;/ul&gt; 3、badges.less3.1、badges.less源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// Badges(徽章)// --------------------------------------------------// Base class.badge &#123; display: inline-block; min-width: 10px; padding: 3px 7px; font-size: @font-size-small; font-weight: @badge-font-weight; color: @badge-color; line-height: @badge-line-height; vertical-align: middle; white-space: nowrap; text-align: center; background-color: @badge-bg; border-radius: @badge-border-radius; // Empty badges collapse automatically (not available in IE8) &amp;:empty &#123; display: none; &#125; // Quick fix for badges in buttons .btn &amp; &#123; position: relative; top: -1px; &#125; .btn-xs &amp;, .btn-group-xs &gt; .btn &amp; &#123; top: 0; padding: 1px 5px; &#125; // Hover state, but only for links a&amp; &#123; &amp;:hover, &amp;:focus &#123; color: @badge-link-hover-color; text-decoration: none; cursor: pointer; &#125; &#125; // Account for badges in navs .list-group-item.active &gt; &amp;, .nav-pills &gt; .active &gt; a &gt; &amp; &#123; color: @badge-active-color; background-color: @badge-active-bg; &#125; .list-group-item &gt; &amp; &#123; float: right; &#125; .list-group-item &gt; &amp; + &amp; &#123; margin-right: 5px; &#125; .nav-pills &gt; li &gt; a &gt; &amp; &#123; margin-left: 3px; &#125;&#125; 3.2、badges.less应用123456789101112131415161718192021222324252627282930313233&lt;h4&gt;胶囊式导航中的激活状态&lt;/h4&gt;&lt;ul class=&quot;nav nav-pills&quot;&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#&quot;&gt;首页 &lt;span class=&quot;badge&quot;&gt;42&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;简介&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;消息 &lt;span class=&quot;badge&quot;&gt;3&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;h4&gt;列表导航中的激活状态&lt;/h4&gt;&lt;ul class=&quot;nav nav-pills nav-stacked&quot; style=&quot;max-width: 260px;&quot;&gt; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;badge pull-right&quot;&gt;42&lt;/span&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;简介&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;!--empty时隐藏徽标，使用 :empty 选择器--&gt; &lt;span class=&quot;badge pull-right&quot;&gt;&lt;/span&gt;消息 &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 breadcrumb & panel 样式","slug":"bootstrap/breadcrumb&panel","date":"2017-11-11T12:50:46.000Z","updated":"2018-04-15T12:59:37.000Z","comments":true,"path":"bootstrap/breadcrumb&panel/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/breadcrumb&panel/","excerpt":"现在开始介绍 bootstrap 的面包屑导航(breadcrumb)和面板(panel) 样式。","text":"现在开始介绍 bootstrap 的面包屑导航(breadcrumb)和面板(panel) 样式。 一、源码1、breadcrumbs.less1.1、breadcrumbs.less 源码123456789101112131415161718192021222324//// Breadcrumbs(面包屑式导航)// --------------------------------------------------.breadcrumb &#123; padding: @breadcrumb-padding-vertical @breadcrumb-padding-horizontal; margin-bottom: @line-height-computed; list-style: none; background-color: @breadcrumb-bg; border-radius: @border-radius-base; &gt; li &#123; display: inline-block; + li:before &#123; content: &quot;@&#123;breadcrumb-separator&#125;\\00a0&quot;; // Unicode space added since inline-block means non-collapsing white-space padding: 0 5px; color: @breadcrumb-color; &#125; &#125; &gt; .active &#123; color: @breadcrumb-active-color; &#125;&#125; 1.2、breadcrumbs.less 应用123456&lt;!--display: inline-block同行显示--&gt;&lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2013&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;十一月&lt;/li&gt;&lt;/ol&gt; 2、panels.less2.1、panels.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266//// Panels// --------------------------------------------------// Base class(基础面板).panel &#123; margin-bottom: @line-height-computed; background-color: @panel-bg; border: 1px solid transparent; border-radius: @panel-border-radius; .box-shadow(0 1px 1px rgba(0,0,0,.05));&#125;// Panel contents.panel-body &#123; padding: @panel-body-padding; &amp;:extend(.clearfix all);&#125;// Optional heading(可选面板头部).panel-heading &#123; padding: @panel-heading-padding; border-bottom: 1px solid transparent; .border-top-radius((@panel-border-radius - 1)); &gt; .dropdown .dropdown-toggle &#123; color: inherit; &#125;&#125;// Within heading, strip any `h*` tag of its default margins for spacing.(面板标题).panel-title &#123; margin-top: 0; margin-bottom: 0; font-size: ceil((@font-size-base * 1.125)); color: inherit; &gt; a, &gt; small, &gt; .small, &gt; small &gt; a, &gt; .small &gt; a &#123; color: inherit; &#125;&#125;// Optional footer (stays gray in every modifier class)(可选面板尾部).panel-footer &#123; padding: @panel-footer-padding; background-color: @panel-footer-bg; border-top: 1px solid @panel-inner-border; .border-bottom-radius((@panel-border-radius - 1));&#125;// List groups in panels(面板中嵌套列表组)//// By default, space out list group content from panel headings to account for// any kind of custom content between the two..panel &#123; &gt; .list-group, &gt; .panel-collapse &gt; .list-group &#123; margin-bottom: 0; .list-group-item &#123; border-width: 1px 0; border-radius: 0; &#125; // Add border top radius for first one &amp;:first-child &#123; .list-group-item:first-child &#123; border-top: 0; .border-top-radius((@panel-border-radius - 1)); &#125; &#125; // Add border bottom radius for last one &amp;:last-child &#123; .list-group-item:last-child &#123; border-bottom: 0; .border-bottom-radius((@panel-border-radius - 1)); &#125; &#125; &#125; &gt; .panel-heading + .panel-collapse &gt; .list-group &#123; .list-group-item:first-child &#123; .border-top-radius(0); &#125; &#125;&#125;// Collapse space between when there&apos;s no additional content..panel-heading + .list-group &#123; .list-group-item:first-child &#123; border-top-width: 0; &#125;&#125;.list-group + .panel-footer &#123; border-top-width: 0;&#125;// Tables in panels(面板中嵌套表格)//// Place a non-bordered `.table` within a panel (not within a `.panel-body`) and// watch it go full width..panel &#123; &gt; .table, &gt; .table-responsive &gt; .table, &gt; .panel-collapse &gt; .table &#123; margin-bottom: 0; caption &#123; padding-left: @panel-body-padding; padding-right: @panel-body-padding; &#125; &#125; // Add border top radius for first one &gt; .table:first-child, &gt; .table-responsive:first-child &gt; .table:first-child &#123; .border-top-radius((@panel-border-radius - 1)); &gt; thead:first-child, &gt; tbody:first-child &#123; &gt; tr:first-child &#123; border-top-left-radius: (@panel-border-radius - 1); border-top-right-radius: (@panel-border-radius - 1); td:first-child, th:first-child &#123; border-top-left-radius: (@panel-border-radius - 1); &#125; td:last-child, th:last-child &#123; border-top-right-radius: (@panel-border-radius - 1); &#125; &#125; &#125; &#125; // Add border bottom radius for last one &gt; .table:last-child, &gt; .table-responsive:last-child &gt; .table:last-child &#123; .border-bottom-radius((@panel-border-radius - 1)); &gt; tbody:last-child, &gt; tfoot:last-child &#123; &gt; tr:last-child &#123; border-bottom-left-radius: (@panel-border-radius - 1); border-bottom-right-radius: (@panel-border-radius - 1); td:first-child, th:first-child &#123; border-bottom-left-radius: (@panel-border-radius - 1); &#125; td:last-child, th:last-child &#123; border-bottom-right-radius: (@panel-border-radius - 1); &#125; &#125; &#125; &#125; &gt; .panel-body + .table, &gt; .panel-body + .table-responsive, &gt; .table + .panel-body, &gt; .table-responsive + .panel-body &#123; border-top: 1px solid @table-border-color; &#125; &gt; .table &gt; tbody:first-child &gt; tr:first-child th, &gt; .table &gt; tbody:first-child &gt; tr:first-child td &#123; border-top: 0; &#125; &gt; .table-bordered, &gt; .table-responsive &gt; .table-bordered &#123; border: 0; &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th:first-child, &gt; td:first-child &#123; border-left: 0; &#125; &gt; th:last-child, &gt; td:last-child &#123; border-right: 0; &#125; &#125; &#125; &gt; thead, &gt; tbody &#123; &gt; tr:first-child &#123; &gt; td, &gt; th &#123; border-bottom: 0; &#125; &#125; &#125; &gt; tbody, &gt; tfoot &#123; &gt; tr:last-child &#123; &gt; td, &gt; th &#123; border-bottom: 0; &#125; &#125; &#125; &#125; &gt; .table-responsive &#123; border: 0; margin-bottom: 0; &#125;&#125;// Collapsible panels (aka, accordion)(面板组)//// Wrap a series of panels in `.panel-group` to turn them into an accordion with// the help of our collapse JavaScript plugin..panel-group &#123; margin-bottom: @line-height-computed; // Tighten up margin so it&apos;s only between panels .panel &#123; margin-bottom: 0; border-radius: @panel-border-radius; + .panel &#123; margin-top: 5px; &#125; &#125; .panel-heading &#123; border-bottom: 0; + .panel-collapse &gt; .panel-body, + .panel-collapse &gt; .list-group &#123; border-top: 1px solid @panel-inner-border; &#125; &#125; .panel-footer &#123; border-top: 0; + .panel-collapse .panel-body &#123; border-bottom: 1px solid @panel-inner-border; &#125; &#125;&#125;// Contextual variations(彩色面板).panel-default &#123; .panel-variant(@panel-default-border; @panel-default-text; @panel-default-heading-bg; @panel-default-border);&#125;.panel-primary &#123; .panel-variant(@panel-primary-border; @panel-primary-text; @panel-primary-heading-bg; @panel-primary-border);&#125;.panel-success &#123; .panel-variant(@panel-success-border; @panel-success-text; @panel-success-heading-bg; @panel-success-border);&#125;.panel-info &#123; .panel-variant(@panel-info-border; @panel-info-text; @panel-info-heading-bg; @panel-info-border);&#125;.panel-warning &#123; .panel-variant(@panel-warning-border; @panel-warning-text; @panel-warning-heading-bg; @panel-warning-border);&#125;.panel-danger &#123; .panel-variant(@panel-danger-border; @panel-danger-text; @panel-danger-heading-bg; @panel-danger-border);&#125; 2.2、panels.less 应用1234567891011121314151617181920212223242526272829303132333435&lt;!--面板组--&gt;&lt;div class=&quot;panel-group&quot;&gt; &lt;!--面板--&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;!--面板头部--&gt; &lt;div class=&quot;panel-heading&quot;&gt; 不带 title 的面板标题 &lt;/div&gt; &lt;!--嵌入面板--&gt; &lt;table class=&quot;table&quot;&gt; &lt;th&gt;产品&lt;/th&gt;&lt;th&gt;价格 &lt;/th&gt; &lt;tr&gt;&lt;td&gt;产品 A&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;产品 B&lt;/td&gt;&lt;td&gt;400&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;!--嵌入列表组--&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;免费域名注册&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;免费 Window 空间托管&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;图像的数量&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;24*7 支持&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;每年更新成本&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--面板状态：panel-primary、panel-success、panel-info、panel-warning、panel-danger--&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;!--面板标题--&gt; &lt;h3 class=&quot;panel-title&quot;&gt; 带有 title 的面板标题 &lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt;面板内容&lt;/div&gt; &lt;div class=&quot;panel-footer&quot;&gt;面板脚注&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 navs & pagination 样式","slug":"bootstrap/nav&pagination","date":"2017-11-11T11:26:51.000Z","updated":"2018-04-15T13:44:50.000Z","comments":true,"path":"bootstrap/nav&pagination/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/nav&pagination/","excerpt":"现在开始介绍 bootstrap 的 navs(导航) 和 pagination(分页)，包括 navs.less、pagination.less。","text":"现在开始介绍 bootstrap 的 navs(导航) 和 pagination(分页)，包括 navs.less、pagination.less。 一、源码1、navs.less1.1、navs.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238//// Navs(导航)// --------------------------------------------------// Base class(基础样式)// --------------------------------------------------.nav &#123; margin-bottom: 0; padding-left: 0; // Override default ul/ol list-style: none; &amp;:extend(.clearfix all); &gt; li &#123; position: relative; display: block; &gt; a &#123; position: relative; display: block; padding: @nav-link-padding; &amp;:hover, &amp;:focus &#123; text-decoration: none; background-color: @nav-link-hover-bg; &#125; &#125; // Disabled state sets text to gray and nukes hover/tab effects &amp;.disabled &gt; a &#123; color: @nav-disabled-link-color; &amp;:hover, &amp;:focus &#123; color: @nav-disabled-link-hover-color; text-decoration: none; background-color: transparent; cursor: @cursor-disabled; &#125; &#125; &#125; // Open dropdowns .open &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; background-color: @nav-link-hover-bg; border-color: @link-color; &#125; &#125; // Nav dividers (deprecated with v3.0.1) // // This should have been removed in v3 with the dropping of `.nav-list`, but // we missed it. We don&apos;t currently support this anywhere, but in the interest // of maintaining backward compatibility in case you use it, it&apos;s deprecated. .nav-divider &#123; .nav-divider(); &#125; // Prevent IE8 from misplacing imgs // // See https://github.com/h5bp/html5-boilerplate/issues/984#issuecomment-3985989 &gt; li &gt; a &gt; img &#123; max-width: none; &#125;&#125;// Tabs(标签形tab导航)// -------------------------// Give the tabs something to sit on.nav-tabs &#123; border-bottom: 1px solid @nav-tabs-border-color; &gt; li &#123; float: left; // Make the list-items overlay the bottom border margin-bottom: -1px; // Actual tabs (as links) &gt; a &#123; margin-right: 2px; line-height: @line-height-base; border: 1px solid transparent; border-radius: @border-radius-base @border-radius-base 0 0; &amp;:hover &#123; border-color: @nav-tabs-link-hover-border-color @nav-tabs-link-hover-border-color @nav-tabs-border-color; &#125; &#125; // Active state, and its :hover to override normal :hover &amp;.active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @nav-tabs-active-link-hover-color; background-color: @nav-tabs-active-link-hover-bg; border: 1px solid @nav-tabs-active-link-hover-border-color; border-bottom-color: transparent; cursor: default; &#125; &#125; &#125; // pulling this in mainly for less shorthand &amp;.nav-justified &#123; .nav-justified(); .nav-tabs-justified(); &#125;&#125;// Pills(胶囊形导航)// -------------------------.nav-pills &#123; &gt; li &#123; float: left; // Links rendered as pills &gt; a &#123; border-radius: @nav-pills-border-radius; &#125; + li &#123; margin-left: 2px; &#125; // Active state &amp;.active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @nav-pills-active-link-hover-color; background-color: @nav-pills-active-link-hover-bg; &#125; &#125; &#125;&#125;// Stacked pills(垂直堆叠的导航).nav-stacked &#123; &gt; li &#123; float: none; + li &#123; margin-top: 2px; margin-left: 0; // no need for this gap between nav items &#125; &#125;&#125;// Nav variations// --------------------------------------------------// Justified nav links(自适应导航)// -------------------------.nav-justified &#123; width: 100%; &gt; li &#123; float: none; &gt; a &#123; text-align: center; margin-bottom: 5px; &#125; &#125; &gt; .dropdown .dropdown-menu &#123; top: auto; left: auto; &#125; @media (min-width: @screen-sm-min) &#123; &gt; li &#123; display: table-cell; width: 1%; &gt; a &#123; margin-bottom: 0; &#125; &#125; &#125;&#125;// Move borders to anchors instead of bottom of list//// Mixin for adding on top the shared `.nav-justified` styles for our tabs.nav-tabs-justified &#123; border-bottom: 0; &gt; li &gt; a &#123; // Override margin from .nav-tabs margin-right: 0; border-radius: @border-radius-base; &#125; &gt; .active &gt; a, &gt; .active &gt; a:hover, &gt; .active &gt; a:focus &#123; border: 1px solid @nav-tabs-justified-link-border-color; &#125; @media (min-width: @screen-sm-min) &#123; &gt; li &gt; a &#123; border-bottom: 1px solid @nav-tabs-justified-link-border-color; border-radius: @border-radius-base @border-radius-base 0 0; &#125; &gt; .active &gt; a, &gt; .active &gt; a:hover, &gt; .active &gt; a:focus &#123; border-bottom-color: @nav-tabs-justified-active-link-border-color; &#125; &#125;&#125;// Tabbable tabs// -------------------------// Hide tabbable panes to start, show them when `.active`.tab-content &#123; &gt; .tab-pane &#123; display: none; &#125; &gt; .active &#123; display: block; &#125;&#125;// Dropdowns(二级导航)// -------------------------// Specific dropdowns.nav-tabs .dropdown-menu &#123; // make dropdown border overlap tab border margin-top: -1px; // Remove the top rounded corners here since there is a hard edge above the menu .border-top-radius(0);&#125; 1.2、navs.less应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;p&gt;标签式的导航菜单(float布局)&lt;/p&gt;&lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基本的胶囊式导航菜单&lt;/p&gt;&lt;ul class=&quot;nav nav-pills&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;垂直的胶囊式导航菜单&lt;/p&gt;&lt;ul class=&quot;nav nav-pills nav-stacked&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;两端对齐的导航元素(小屏垂直布局，宽屏table-cell)&lt;/p&gt;&lt;ul class=&quot;nav nav-pills nav-justified&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;ul class=&quot;nav nav-tabs nav-justified&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;带有下拉菜单的标签&lt;/p&gt;&lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt; Java &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Swing&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jMeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 2、pagination.less2.1、pagination.less源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// Pagination(分页导航)// --------------------------------------------------.pagination &#123; display: inline-block; padding-left: 0; margin: @line-height-computed 0; border-radius: @border-radius-base; &gt; li &#123; display: inline; // Remove list-style and block-level defaults &gt; a, &gt; span &#123; position: relative; float: left; // Collapse white-space padding: @padding-base-vertical @padding-base-horizontal; line-height: @line-height-base; text-decoration: none; color: @pagination-color; background-color: @pagination-bg; border: 1px solid @pagination-border; margin-left: -1px; &#125; &amp;:first-child &#123; &gt; a, &gt; span &#123; margin-left: 0; .border-left-radius(@border-radius-base); &#125; &#125; &amp;:last-child &#123; &gt; a, &gt; span &#123; .border-right-radius(@border-radius-base); &#125; &#125; &#125; &gt; li &gt; a, &gt; li &gt; span &#123; &amp;:hover, &amp;:focus &#123; z-index: 2; color: @pagination-hover-color; background-color: @pagination-hover-bg; border-color: @pagination-hover-border; &#125; &#125; &gt; .active &gt; a, &gt; .active &gt; span &#123; &amp;, &amp;:hover, &amp;:focus &#123; z-index: 3; color: @pagination-active-color; background-color: @pagination-active-bg; border-color: @pagination-active-border; cursor: default; &#125; &#125; &gt; .disabled &#123; &gt; span, &gt; span:hover, &gt; span:focus, &gt; a, &gt; a:hover, &gt; a:focus &#123; color: @pagination-disabled-color; background-color: @pagination-disabled-bg; border-color: @pagination-disabled-border; cursor: @cursor-disabled; &#125; &#125;&#125;// Sizing// --------------------------------------------------// Large.pagination-lg &#123; .pagination-size(@padding-large-vertical; @padding-large-horizontal; @font-size-large; @line-height-large; @border-radius-large);&#125;// Small.pagination-sm &#123; .pagination-size(@padding-small-vertical; @padding-small-horizontal; @font-size-small; @line-height-small; @border-radius-small);&#125; 2.2、pagination.less应用123456789101112&lt;!--pagination-lg: 分页大小--&gt;&lt;ul class=&quot;pagination pagination-lg&quot;&gt; &lt;!--display:inline 同行显示--&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;!--active/disabled: 分页的状态--&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 navbar 样式","slug":"bootstrap/navbar","date":"2017-11-11T11:26:51.000Z","updated":"2018-04-15T13:46:48.000Z","comments":true,"path":"bootstrap/navbar/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/navbar/","excerpt":"现在开始介绍 bootstrap 的导航条(navbar)样式。","text":"现在开始介绍 bootstrap 的导航条(navbar)样式。 一、源码1、navbar.less1.1、navbar.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642//// Navbars// --------------------------------------------------// Wrapper and base class(基础导航条)//// Provide a static navbar from which we expand to create full-width, fixed, and// other navbar variations..navbar &#123; position: relative; min-height: @navbar-height; // Ensure a navbar always shows (e.g., without a .navbar-brand in collapsed mode) margin-bottom: @navbar-margin-bottom; border: 1px solid transparent; // Prevent floats from breaking the navbar &amp;:extend(.clearfix all); @media (min-width: @grid-float-breakpoint) &#123; border-radius: @navbar-border-radius; &#125;&#125;// Navbar heading(导航条头部)//// Groups `.navbar-brand` and `.navbar-toggle` into a single component for easy// styling of responsive aspects..navbar-header &#123; &amp;:extend(.clearfix all); @media (min-width: @grid-float-breakpoint) &#123; float: left; &#125;&#125;// Navbar collapse(导航条折叠)//// Group your navbar content into this for easy collapsing and expanding across// various device sizes. By default, this content is collapsed when &lt;768px, but// will expand past that for a horizontal display.//// To start (on mobile devices) the navbar links, forms, and buttons are stacked// vertically and include a `max-height` to overflow in case you have too much// content for the user&apos;s viewport..navbar-collapse &#123; overflow-x: visible; padding-right: @navbar-padding-horizontal; padding-left: @navbar-padding-horizontal; border-top: 1px solid transparent; box-shadow: inset 0 1px 0 rgba(255,255,255,.1); &amp;:extend(.clearfix all); -webkit-overflow-scrolling: touch; &amp;.in &#123; overflow-y: auto; &#125; @media (min-width: @grid-float-breakpoint) &#123; width: auto; border-top: 0; box-shadow: none; &amp;.collapse &#123; display: block !important; height: auto !important; padding-bottom: 0; // Override default setting overflow: visible !important; &#125; &amp;.in &#123; overflow-y: visible; &#125; // Undo the collapse side padding for navbars with containers to ensure // alignment of right-aligned contents. .navbar-fixed-top &amp;, .navbar-static-top &amp;, .navbar-fixed-bottom &amp; &#123; padding-left: 0; padding-right: 0; &#125; &#125;&#125;.navbar-fixed-top,.navbar-fixed-bottom &#123; .navbar-collapse &#123; max-height: @navbar-collapse-max-height; @media (max-device-width: @screen-xs-min) and (orientation: landscape) &#123; max-height: 200px; &#125; &#125;&#125;// Both navbar header and collapse//// When a container is present, change the behavior of the header and collapse..container,.container-fluid &#123; &gt; .navbar-header, &gt; .navbar-collapse &#123; margin-right: -@navbar-padding-horizontal; margin-left: -@navbar-padding-horizontal; @media (min-width: @grid-float-breakpoint) &#123; margin-right: 0; margin-left: 0; &#125; &#125;&#125;//// Navbar alignment options//// Display the navbar across the entirety of the page or fixed it to the top or// bottom of the page.// Static top (unfixed, but 100% wide) navbar.navbar-static-top &#123; z-index: @zindex-navbar; border-width: 0 0 1px; @media (min-width: @grid-float-breakpoint) &#123; border-radius: 0; &#125;&#125;// Fix the top/bottom navbars when screen real estate supports it(固定导航条).navbar-fixed-top,.navbar-fixed-bottom &#123; position: fixed; right: 0; left: 0; z-index: @zindex-navbar-fixed; // Undo the rounded corners @media (min-width: @grid-float-breakpoint) &#123; border-radius: 0; &#125;&#125;.navbar-fixed-top &#123; top: 0; border-width: 0 0 1px;&#125;.navbar-fixed-bottom &#123; bottom: 0; margin-bottom: 0; // override .navbar defaults border-width: 1px 0 0;&#125;// Brand/project name(导航条标题).navbar-brand &#123; float: left; padding: @navbar-padding-vertical @navbar-padding-horizontal; font-size: @font-size-large; line-height: @line-height-computed; height: @navbar-height; &amp;:hover, &amp;:focus &#123; text-decoration: none; &#125; &gt; img &#123; display: block; &#125; @media (min-width: @grid-float-breakpoint) &#123; .navbar &gt; .container &amp;, .navbar &gt; .container-fluid &amp; &#123; margin-left: -@navbar-padding-horizontal; &#125; &#125;&#125;// Navbar toggle(响应式导航条触发)//// Custom button for toggling the `.navbar-collapse`, powered by the collapse// JavaScript plugin..navbar-toggle &#123; position: relative; float: right; margin-right: @navbar-padding-horizontal; padding: 9px 10px; .navbar-vertical-align(34px); background-color: transparent; background-image: none; // Reset unusual Firefox-on-Android default style; see https://github.com/necolas/normalize.css/issues/214 border: 1px solid transparent; border-radius: @border-radius-base; // We remove the `outline` here, but later compensate by attaching `:hover` // styles to `:focus`. &amp;:focus &#123; outline: 0; &#125; // Bars(响应式导航触发图标的bar) .icon-bar &#123; display: block; width: 22px; height: 2px; border-radius: 1px; &#125; .icon-bar + .icon-bar &#123; margin-top: 4px; &#125; @media (min-width: @grid-float-breakpoint) &#123; display: none; &#125;&#125;// Navbar nav links(导航条)//// Builds on top of the `.nav` components with its own modifier class to make// the nav the full height of the horizontal nav (above 768px)..navbar-nav &#123; margin: (@navbar-padding-vertical / 2) -@navbar-padding-horizontal; &gt; li &gt; a &#123; padding-top: 10px; padding-bottom: 10px; line-height: @line-height-computed; &#125; @media (max-width: @grid-float-breakpoint-max) &#123; // Dropdowns get custom display when collapsed .open .dropdown-menu &#123; position: static; float: none; width: auto; margin-top: 0; background-color: transparent; border: 0; box-shadow: none; &gt; li &gt; a, .dropdown-header &#123; padding: 5px 15px 5px 25px; &#125; &gt; li &gt; a &#123; line-height: @line-height-computed; &amp;:hover, &amp;:focus &#123; background-image: none; &#125; &#125; &#125; &#125; // Uncollapse the nav @media (min-width: @grid-float-breakpoint) &#123; float: left; margin: 0; &gt; li &#123; float: left; &gt; a &#123; padding-top: @navbar-padding-vertical; padding-bottom: @navbar-padding-vertical; &#125; &#125; &#125;&#125;// Navbar form(带表单的导航条)//// Extension of the `.form-inline` with some extra flavor for optimum display in// our navbars..navbar-form &#123; margin-left: -@navbar-padding-horizontal; margin-right: -@navbar-padding-horizontal; padding: 10px @navbar-padding-horizontal; border-top: 1px solid transparent; border-bottom: 1px solid transparent; @shadow: inset 0 1px 0 rgba(255,255,255,.1), 0 1px 0 rgba(255,255,255,.1); .box-shadow(@shadow); // Mixin behavior for optimum display .form-inline(); .form-group &#123; @media (max-width: @grid-float-breakpoint-max) &#123; margin-bottom: 5px; &amp;:last-child &#123; margin-bottom: 0; &#125; &#125; &#125; // Vertically center in expanded, horizontal navbar .navbar-vertical-align(@input-height-base); // Undo 100% width for pull classes @media (min-width: @grid-float-breakpoint) &#123; width: auto; border: 0; margin-left: 0; margin-right: 0; padding-top: 0; padding-bottom: 0; .box-shadow(none); &#125;&#125;// Dropdown menus(下拉菜单)// Menu position and menu carets.navbar-nav &gt; li &gt; .dropdown-menu &#123; margin-top: 0; .border-top-radius(0);&#125;// Menu position and menu caret support for dropups via extra dropup class.navbar-fixed-bottom .navbar-nav &gt; li &gt; .dropdown-menu &#123; margin-bottom: 0; .border-top-radius(@navbar-border-radius); .border-bottom-radius(0);&#125;// Buttons in navbars(导航条按钮)//// Vertically center a button within a navbar (when *not* in a form)..navbar-btn &#123; .navbar-vertical-align(@input-height-base); &amp;.btn-sm &#123; .navbar-vertical-align(@input-height-small); &#125; &amp;.btn-xs &#123; .navbar-vertical-align(22); &#125;&#125;// Text in navbars(导航条文本)//// Add a class to make any element properly align itself vertically within the navbars..navbar-text &#123; .navbar-vertical-align(@line-height-computed); @media (min-width: @grid-float-breakpoint) &#123; float: left; margin-left: @navbar-padding-horizontal; margin-right: @navbar-padding-horizontal; &#125;&#125;// Component alignment(表单对齐方式)//// Repurpose the pull utilities as their own navbar utilities to avoid specificity// issues with parents and chaining. Only do this when the navbar is uncollapsed// though so that navbar contents properly stack and align in mobile.//// Declared after the navbar components to ensure more specificity on the margins.@media (min-width: @grid-float-breakpoint) &#123; .navbar-left &#123; .pull-left(); &#125; .navbar-right &#123; .pull-right(); margin-right: -@navbar-padding-horizontal; ~ .navbar-right &#123; margin-right: 0; &#125; &#125;&#125;// Alternate navbars// --------------------------------------------------// Default navbar(默认导航条样式).navbar-default &#123; background-color: @navbar-default-bg; border-color: @navbar-default-border; .navbar-brand &#123; color: @navbar-default-brand-color; &amp;:hover, &amp;:focus &#123; color: @navbar-default-brand-hover-color; background-color: @navbar-default-brand-hover-bg; &#125; &#125; .navbar-text &#123; color: @navbar-default-color; &#125; .navbar-nav &#123; &gt; li &gt; a &#123; color: @navbar-default-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-hover-color; background-color: @navbar-default-link-hover-bg; &#125; &#125; &gt; .active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-active-color; background-color: @navbar-default-link-active-bg; &#125; &#125; &gt; .disabled &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-disabled-color; background-color: @navbar-default-link-disabled-bg; &#125; &#125; &#125; .navbar-toggle &#123; border-color: @navbar-default-toggle-border-color; &amp;:hover, &amp;:focus &#123; background-color: @navbar-default-toggle-hover-bg; &#125; .icon-bar &#123; background-color: @navbar-default-toggle-icon-bar-bg; &#125; &#125; .navbar-collapse, .navbar-form &#123; border-color: @navbar-default-border; &#125; // Dropdown menu items(下拉菜单) .navbar-nav &#123; // Remove background color from open dropdown &gt; .open &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; background-color: @navbar-default-link-active-bg; color: @navbar-default-link-active-color; &#125; &#125; @media (max-width: @grid-float-breakpoint-max) &#123; // Dropdowns get custom display when collapsed .open .dropdown-menu &#123; &gt; li &gt; a &#123; color: @navbar-default-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-hover-color; background-color: @navbar-default-link-hover-bg; &#125; &#125; &gt; .active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-active-color; background-color: @navbar-default-link-active-bg; &#125; &#125; &gt; .disabled &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-disabled-color; background-color: @navbar-default-link-disabled-bg; &#125; &#125; &#125; &#125; &#125; // Links in navbars(导航条链接) // // Add a class to ensure links outside the navbar nav are colored correctly. .navbar-link &#123; color: @navbar-default-link-color; &amp;:hover &#123; color: @navbar-default-link-hover-color; &#125; &#125; .btn-link &#123; color: @navbar-default-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-hover-color; &#125; &amp;[disabled], fieldset[disabled] &amp; &#123; &amp;:hover, &amp;:focus &#123; color: @navbar-default-link-disabled-color; &#125; &#125; &#125;&#125;// Inverse navbar(反色导航条).navbar-inverse &#123; background-color: @navbar-inverse-bg; border-color: @navbar-inverse-border; .navbar-brand &#123; color: @navbar-inverse-brand-color; &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-brand-hover-color; background-color: @navbar-inverse-brand-hover-bg; &#125; &#125; .navbar-text &#123; color: @navbar-inverse-color; &#125; .navbar-nav &#123; &gt; li &gt; a &#123; color: @navbar-inverse-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-hover-color; background-color: @navbar-inverse-link-hover-bg; &#125; &#125; &gt; .active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-active-color; background-color: @navbar-inverse-link-active-bg; &#125; &#125; &gt; .disabled &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-disabled-color; background-color: @navbar-inverse-link-disabled-bg; &#125; &#125; &#125; // Darken the responsive nav toggle .navbar-toggle &#123; border-color: @navbar-inverse-toggle-border-color; &amp;:hover, &amp;:focus &#123; background-color: @navbar-inverse-toggle-hover-bg; &#125; .icon-bar &#123; background-color: @navbar-inverse-toggle-icon-bar-bg; &#125; &#125; .navbar-collapse, .navbar-form &#123; border-color: darken(@navbar-inverse-bg, 7%); &#125; // Dropdowns .navbar-nav &#123; &gt; .open &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; background-color: @navbar-inverse-link-active-bg; color: @navbar-inverse-link-active-color; &#125; &#125; @media (max-width: @grid-float-breakpoint-max) &#123; // Dropdowns get custom display .open .dropdown-menu &#123; &gt; .dropdown-header &#123; border-color: @navbar-inverse-border; &#125; .divider &#123; background-color: @navbar-inverse-border; &#125; &gt; li &gt; a &#123; color: @navbar-inverse-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-hover-color; background-color: @navbar-inverse-link-hover-bg; &#125; &#125; &gt; .active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-active-color; background-color: @navbar-inverse-link-active-bg; &#125; &#125; &gt; .disabled &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-disabled-color; background-color: @navbar-inverse-link-disabled-bg; &#125; &#125; &#125; &#125; &#125; .navbar-link &#123; color: @navbar-inverse-link-color; &amp;:hover &#123; color: @navbar-inverse-link-hover-color; &#125; &#125; .btn-link &#123; color: @navbar-inverse-link-color; &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-hover-color; &#125; &amp;[disabled], fieldset[disabled] &amp; &#123; &amp;:hover, &amp;:focus &#123; color: @navbar-inverse-link-disabled-color; &#125; &#125; &#125;&#125; 1.2、navbar.less应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!--默认的导航栏--&gt;&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;!--响应式的导航栏--&gt;&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#example-navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;切换导航&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;example-navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;!--导航栏中的表单&amp;按钮&amp;文本&amp;链接&amp;对齐方式--&gt;&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p class=&quot;navbar-text&quot;&gt;Runoob 用户登录&lt;/p&gt; &lt;/div&gt; &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default navbar-btn&quot;&gt;导航栏按钮&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt; 注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-log-in&quot;&gt;&lt;/span&gt; 登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;&lt;!--固定到底部&amp;反色导航栏--&gt;&lt;nav class=&quot;navbar navbar-inverse navbar-fixed-bottom&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;!--静态的顶部(设置z-index为1000)--&gt;&lt;nav class=&quot;navbar navbar-default navbar-static-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 inputGroup & label 样式","slug":"bootstrap/inputGroup&label","date":"2017-11-07T16:01:40.000Z","updated":"2018-04-15T13:35:01.000Z","comments":true,"path":"bootstrap/inputGroup&label/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/inputGroup&label/","excerpt":"现在开始介绍 bootstrap 的输入框组(input-group)和标签(label) 样式。","text":"现在开始介绍 bootstrap 的输入框组(input-group)和标签(label) 样式。 一、源码1、input-groups.less1.1、input-groups.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171//// Input groups// --------------------------------------------------// Base styles// -------------------------.input-group &#123; position: relative; // For dropdowns display: table; border-collapse: separate; // prevent input groups from inheriting border styles from table cells when placed within a table // Undo padding and float of grid classes &amp;[class*=&quot;col-&quot;] &#123; float: none; padding-left: 0; padding-right: 0; &#125; .form-control &#123; // Ensure that the input is always above the *appended* addon button for // proper border colors. position: relative; z-index: 2; // IE9 fubars the placeholder attribute in text inputs and the arrows on // select elements in input groups. To fix it, we float the input. Details: // https://github.com/twbs/bootstrap/issues/11561#issuecomment-28936855 float: left; width: 100%; margin-bottom: 0; &amp;:focus &#123; z-index: 3; &#125; &#125;&#125;// Sizing options//// Remix the default form control sizing classes into new ones for easier// manipulation..input-group-lg &gt; .form-control,.input-group-lg &gt; .input-group-addon,.input-group-lg &gt; .input-group-btn &gt; .btn &#123; .input-lg();&#125;.input-group-sm &gt; .form-control,.input-group-sm &gt; .input-group-addon,.input-group-sm &gt; .input-group-btn &gt; .btn &#123; .input-sm();&#125;// Display as table-cell// -------------------------.input-group-addon,.input-group-btn,.input-group .form-control &#123; display: table-cell; &amp;:not(:first-child):not(:last-child) &#123; border-radius: 0; &#125;&#125;// Addon and addon wrapper for buttons.input-group-addon,.input-group-btn &#123; width: 1%; white-space: nowrap; vertical-align: middle; // Match the inputs&#125;// Text input groups// -------------------------.input-group-addon &#123; padding: @padding-base-vertical @padding-base-horizontal; font-size: @font-size-base; font-weight: normal; line-height: 1; color: @input-color; text-align: center; background-color: @input-group-addon-bg; border: 1px solid @input-group-addon-border-color; border-radius: @input-border-radius; // Sizing &amp;.input-sm &#123; padding: @padding-small-vertical @padding-small-horizontal; font-size: @font-size-small; border-radius: @input-border-radius-small; &#125; &amp;.input-lg &#123; padding: @padding-large-vertical @padding-large-horizontal; font-size: @font-size-large; border-radius: @input-border-radius-large; &#125; // Nuke default margins from checkboxes and radios to vertically center within. input[type=&quot;radio&quot;], input[type=&quot;checkbox&quot;] &#123; margin-top: 0; &#125;&#125;// Reset rounded corners.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child &gt; .btn,.input-group-btn:first-child &gt; .btn-group &gt; .btn,.input-group-btn:first-child &gt; .dropdown-toggle,.input-group-btn:last-child &gt; .btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child &gt; .btn-group:not(:last-child) &gt; .btn &#123; .border-right-radius(0);&#125;.input-group-addon:first-child &#123; border-right: 0;&#125;.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child &gt; .btn,.input-group-btn:last-child &gt; .btn-group &gt; .btn,.input-group-btn:last-child &gt; .dropdown-toggle,.input-group-btn:first-child &gt; .btn:not(:first-child),.input-group-btn:first-child &gt; .btn-group:not(:first-child) &gt; .btn &#123; .border-left-radius(0);&#125;.input-group-addon:last-child &#123; border-left: 0;&#125;// Button input groups// -------------------------.input-group-btn &#123; position: relative; // Jankily prevent input button groups from wrapping with `white-space` and // `font-size` in combination with `inline-block` on buttons. font-size: 0; white-space: nowrap; // Negative margin for spacing, position for bringing hovered/focused/actived // element above the siblings. &gt; .btn &#123; position: relative; + .btn &#123; margin-left: -1px; &#125; // Bring the &quot;active&quot; button to the front &amp;:hover, &amp;:focus, &amp;:active &#123; z-index: 2; &#125; &#125; // Negative margin to only have a 1px border between the two &amp;:first-child &#123; &gt; .btn, &gt; .btn-group &#123; margin-right: -1px; &#125; &#125; &amp;:last-child &#123; &gt; .btn, &gt; .btn-group &#123; z-index: 2; margin-left: -1px; &#125; &#125;&#125; 1.2、input-groups.less 应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!--输入框组(使用 table 布局，使得 input 宽度为 100%)--&gt;&lt;div style=&quot;padding: 100px 100px 10px;&quot;&gt; &lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;input-group input-group-lg&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;twitterhandle&quot;&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&quot;input-group input-group-sm&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;$&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt; &lt;/div&gt; &lt;br&gt; &lt;!--复选框--&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;br&gt; &lt;!--单选框--&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;radio&quot;&gt; &lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;br&gt; &lt;!--按钮--&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot;&gt;Go!&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;br&gt; &lt;!--带有下拉菜单的按钮--&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; 下拉菜单&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu pull-right&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;!--分割的下拉菜单按钮--&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; tabindex=&quot;-1&quot;&gt;下拉菜单&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; tabindex=&quot;-1&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;切换下拉菜单&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu pull-right&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 2、labels.less2.1、labels.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Labels(标签)// --------------------------------------------------.label &#123; display: inline; padding: .2em .6em .3em; font-size: 75%; font-weight: bold; line-height: 1; color: @label-color; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em; // Add hover effects, but only for links a&amp; &#123; &amp;:hover, &amp;:focus &#123; color: @label-link-hover-color; text-decoration: none; cursor: pointer; &#125; &#125; // Empty labels collapse automatically (not available in IE8) &amp;:empty &#123; display: none; &#125; // Quick fix for labels in buttons .btn &amp; &#123; position: relative; top: -1px; &#125;&#125;// Colors// Contextual variations (linked labels get darker on :hover).label-default &#123; .label-variant(@label-default-bg);&#125;.label-primary &#123; .label-variant(@label-primary-bg);&#125;.label-success &#123; .label-variant(@label-success-bg);&#125;.label-info &#123; .label-variant(@label-info-bg);&#125;.label-warning &#123; .label-variant(@label-warning-bg);&#125;.label-danger &#123; .label-variant(@label-danger-bg);&#125; 2.2、labels.less应用123456&lt;span class=&quot;label label-default&quot;&gt;默认标签&lt;/span&gt;&lt;span class=&quot;label label-primary&quot;&gt;主要标签&lt;/span&gt;&lt;span class=&quot;label label-success&quot;&gt;成功标签&lt;/span&gt;&lt;span class=&quot;label label-info&quot;&gt;信息标签&lt;/span&gt;&lt;span class=&quot;label label-warning&quot;&gt;警告标签&lt;/span&gt;&lt;span class=&quot;label label-danger&quot;&gt;危险标签&lt;/span&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 form 样式","slug":"bootstrap/forms","date":"2017-11-06T15:51:20.000Z","updated":"2018-04-15T13:34:58.000Z","comments":true,"path":"bootstrap/forms/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/forms/","excerpt":"现在开始介绍 bootstrap 的表单(forms)样式。","text":"现在开始介绍 bootstrap 的表单(forms)样式。 一、源码1、forms.less1.1、forms.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591//// Forms(表单)// --------------------------------------------------// Normalize non-controls(定制非表单控件)//// Restyle and baseline non-control form elements.fieldset &#123; padding: 0; margin: 0; border: 0; // Chrome and Firefox set a `min-width: min-content;` on fieldsets, // so we reset that to ensure it behaves more like a standard block element. // See https://github.com/twbs/bootstrap/issues/12359. min-width: 0;&#125;legend &#123; display: block; width: 100%; padding: 0; margin-bottom: @line-height-computed; font-size: (@font-size-base * 1.5); line-height: inherit; color: @legend-color; border: 0; border-bottom: 1px solid @legend-border-color;&#125;label &#123; display: inline-block; max-width: 100%; // Force IE8 to wrap long content (see https://github.com/twbs/bootstrap/issues/13141) margin-bottom: 5px; font-weight: bold;&#125;// Normalize form controls(定制表单控件)//// While most of our form styles require extra classes, some basic normalization// is required to ensure optimum display with or without those classes to better// address browser inconsistencies.// Override content-box in Normalize (* isn&apos;t specific enough)input[type=&quot;search&quot;] &#123; .box-sizing(border-box);&#125;// Position radios and checkboxes betterinput[type=&quot;radio&quot;],input[type=&quot;checkbox&quot;] &#123; margin: 4px 0 0; margin-top: 1px \\9; // IE8-9 line-height: normal;&#125;input[type=&quot;file&quot;] &#123; display: block;&#125;// Make range inputs behave like textual form controlsinput[type=&quot;range&quot;] &#123; display: block; width: 100%;&#125;// Make multiple select elements height not fixedselect[multiple],select[size] &#123; height: auto;&#125;// Focus for file, radio, and checkboxinput[type=&quot;file&quot;]:focus,input[type=&quot;radio&quot;]:focus,input[type=&quot;checkbox&quot;]:focus &#123; .tab-focus();&#125;// Adjust output elementoutput &#123; display: block; padding-top: (@padding-base-vertical + 1); font-size: @font-size-base; line-height: @line-height-base; color: @input-color;&#125;// Common form controls(普通的表单控件)//// Shared size and type resets for form controls. Apply `.form-control` to any// of the following form controls://// select// textarea// input[type=&quot;text&quot;]// input[type=&quot;password&quot;]// input[type=&quot;datetime&quot;]// input[type=&quot;datetime-local&quot;]// input[type=&quot;date&quot;]// input[type=&quot;month&quot;]// input[type=&quot;time&quot;]// input[type=&quot;week&quot;]// input[type=&quot;number&quot;]// input[type=&quot;email&quot;]// input[type=&quot;url&quot;]// input[type=&quot;search&quot;]// input[type=&quot;tel&quot;]// input[type=&quot;color&quot;].form-control &#123; display: block; width: 100%; height: @input-height-base; // Make inputs at least the height of their button counterpart (base line-height + padding + border) padding: @padding-base-vertical @padding-base-horizontal; font-size: @font-size-base; line-height: @line-height-base; color: @input-color; background-color: @input-bg; background-image: none; // Reset unusual Firefox-on-Android default style; see https://github.com/necolas/normalize.css/issues/214 border: 1px solid @input-border; border-radius: @input-border-radius; // Note: This has no effect on &lt;select&gt;s in some browsers, due to the limited stylability of &lt;select&gt;s in CSS. .box-shadow(inset 0 1px 1px rgba(0,0,0,.075)); .transition(~&quot;border-color ease-in-out .15s, box-shadow ease-in-out .15s&quot;); // Customize the `:focus` state to imitate native WebKit styles. .form-control-focus(); // Placeholder .placeholder(); // Unstyle the caret on `&lt;select&gt;`s in IE10+. &amp;::-ms-expand &#123; border: 0; background-color: transparent; &#125; // Disabled and read-only inputs // // HTML5 says that controls under a fieldset &gt; legend:first-child won&apos;t be // disabled if the fieldset is disabled. Due to implementation difficulty, we // don&apos;t honor that edge case; we style them as disabled anyway. &amp;[disabled], &amp;[readonly], fieldset[disabled] &amp; &#123; background-color: @input-bg-disabled; opacity: 1; // iOS fix for unreadable disabled content; see https://github.com/twbs/bootstrap/issues/11655 &#125; &amp;[disabled], fieldset[disabled] &amp; &#123; cursor: @cursor-disabled; &#125; // Reset height for `textarea`s textarea&amp; &#123; height: auto; &#125;&#125;// Search inputs in iOS//// This overrides the extra rounded corners on search inputs in iOS so that our// `.form-control` class can properly style them. Note that this cannot simply// be added to `.form-control` as it&apos;s not specific enough. For details, see// https://github.com/twbs/bootstrap/issues/11586.input[type=&quot;search&quot;] &#123; -webkit-appearance: none;&#125;// Special styles for iOS temporal inputs//// In Mobile Safari, setting `display: block` on temporal inputs causes the// text within the input to become vertically misaligned. As a workaround, we// set a pixel line-height that matches the given height of the input, but only// for Safari. See https://bugs.webkit.org/show_bug.cgi?id=139848//// Note that as of 9.3, iOS doesn&apos;t support `week`.@media screen and (-webkit-min-device-pixel-ratio: 0) &#123; input[type=&quot;date&quot;], input[type=&quot;time&quot;], input[type=&quot;datetime-local&quot;], input[type=&quot;month&quot;] &#123; &amp;.form-control &#123; line-height: @input-height-base; &#125; &amp;.input-sm, .input-group-sm &amp; &#123; line-height: @input-height-small; &#125; &amp;.input-lg, .input-group-lg &amp; &#123; line-height: @input-height-large; &#125; &#125;&#125;// Form groups(表单组)//// Designed to help with the organization and spacing of vertical forms. For// horizontal forms, use the predefined grid classes..form-group &#123; margin-bottom: @form-group-margin-bottom;&#125;// Checkboxes and radios(表单控件:复选框checkbox和单选框radio)//// Indent the labels to position radios/checkboxes as hanging controls..radio,.checkbox &#123; position: relative; display: block; margin-top: 10px; margin-bottom: 10px; label &#123; min-height: @line-height-computed; // Ensure the input doesn&apos;t jump when there is no text padding-left: 20px; margin-bottom: 0; font-weight: normal; cursor: pointer; &#125;&#125;.radio input[type=&quot;radio&quot;],.radio-inline input[type=&quot;radio&quot;],.checkbox input[type=&quot;checkbox&quot;],.checkbox-inline input[type=&quot;checkbox&quot;] &#123; position: absolute; margin-left: -20px; margin-top: 4px \\9;&#125;.radio + .radio,.checkbox + .checkbox &#123; margin-top: -5px; // Move up sibling radios or checkboxes for tighter spacing&#125;// Radios and checkboxes on same line(复选框和单选框水平排列).radio-inline,.checkbox-inline &#123; position: relative; display: inline-block; padding-left: 20px; margin-bottom: 0; vertical-align: middle; font-weight: normal; cursor: pointer;&#125;.radio-inline + .radio-inline,.checkbox-inline + .checkbox-inline &#123; margin-top: 0; margin-left: 10px; // space out consecutive inline controls&#125;// Apply same disabled cursor tweak as for inputs(添加disable样式)// Some special care is needed because &lt;label&gt;s don&apos;t inherit their parent&apos;s `cursor`.//// Note: Neither radios nor checkboxes can be readonly.input[type=&quot;radio&quot;],input[type=&quot;checkbox&quot;] &#123; &amp;[disabled], &amp;.disabled, fieldset[disabled] &amp; &#123; cursor: @cursor-disabled; &#125;&#125;// These classes are used directly on &lt;label&gt;s.radio-inline,.checkbox-inline &#123; &amp;.disabled, fieldset[disabled] &amp; &#123; cursor: @cursor-disabled; &#125;&#125;// These classes are used on elements with &lt;label&gt; descendants.radio,.checkbox &#123; &amp;.disabled, fieldset[disabled] &amp; &#123; label &#123; cursor: @cursor-disabled; &#125; &#125;&#125;// Static form control text(静态表单控制文本)//// Apply class to a `p` element to make any string of text align with labels in// a horizontal form layout..form-control-static &#123; // Size it appropriately next to real form controls padding-top: (@padding-base-vertical + 1); padding-bottom: (@padding-base-vertical + 1); // Remove default margin from `p` margin-bottom: 0; min-height: (@line-height-computed + @font-size-base); &amp;.input-lg, &amp;.input-sm &#123; padding-left: 0; padding-right: 0; &#125;&#125;// Form control sizing(表单控件大小)//// Build on `.form-control` with modifier classes to decrease or increase the// height and font-size of form controls.//// The `.form-group-* form-control` variations are sadly duplicated to avoid the// issue documented in https://github.com/twbs/bootstrap/issues/15074..input-sm &#123; .input-size(@input-height-small; @padding-small-vertical; @padding-small-horizontal; @font-size-small; @line-height-small; @input-border-radius-small);&#125;.form-group-sm &#123; .form-control &#123; height: @input-height-small; padding: @padding-small-vertical @padding-small-horizontal; font-size: @font-size-small; line-height: @line-height-small; border-radius: @input-border-radius-small; &#125; select.form-control &#123; height: @input-height-small; line-height: @input-height-small; &#125; textarea.form-control, select[multiple].form-control &#123; height: auto; &#125; .form-control-static &#123; height: @input-height-small; min-height: (@line-height-computed + @font-size-small); padding: (@padding-small-vertical + 1) @padding-small-horizontal; font-size: @font-size-small; line-height: @line-height-small; &#125;&#125;.input-lg &#123; .input-size(@input-height-large; @padding-large-vertical; @padding-large-horizontal; @font-size-large; @line-height-large; @input-border-radius-large);&#125;.form-group-lg &#123; .form-control &#123; height: @input-height-large; padding: @padding-large-vertical @padding-large-horizontal; font-size: @font-size-large; line-height: @line-height-large; border-radius: @input-border-radius-large; &#125; select.form-control &#123; height: @input-height-large; line-height: @input-height-large; &#125; textarea.form-control, select[multiple].form-control &#123; height: auto; &#125; .form-control-static &#123; height: @input-height-large; min-height: (@line-height-computed + @font-size-large); padding: (@padding-large-vertical + 1) @padding-large-horizontal; font-size: @font-size-large; line-height: @line-height-large; &#125;&#125;// Form control feedback states(验证状态)//// Apply contextual and semantic states to individual form controls..has-feedback &#123; // Enable absolute positioning position: relative; // Ensure icons don&apos;t overlap text .form-control &#123; padding-right: (@input-height-base * 1.25); &#125;&#125;// Feedback icon (requires .glyphicon classes).form-control-feedback &#123; position: absolute; top: 0; right: 0; z-index: 2; // Ensure icon is above input groups display: block; width: @input-height-base; height: @input-height-base; line-height: @input-height-base; text-align: center; pointer-events: none;&#125;.input-lg + .form-control-feedback,.input-group-lg + .form-control-feedback,.form-group-lg .form-control + .form-control-feedback &#123; width: @input-height-large; height: @input-height-large; line-height: @input-height-large;&#125;.input-sm + .form-control-feedback,.input-group-sm + .form-control-feedback,.form-group-sm .form-control + .form-control-feedback &#123; width: @input-height-small; height: @input-height-small; line-height: @input-height-small;&#125;// Feedback states.has-success &#123; .form-control-validation(@state-success-text; @state-success-text; @state-success-bg);&#125;.has-warning &#123; .form-control-validation(@state-warning-text; @state-warning-text; @state-warning-bg);&#125;.has-error &#123; .form-control-validation(@state-danger-text; @state-danger-text; @state-danger-bg);&#125;// Reposition feedback icon if input has visible label above.has-feedback label &#123; &amp; ~ .form-control-feedback &#123; top: (@line-height-computed + 5); // Height of the `label` and its margin &#125; &amp;.sr-only ~ .form-control-feedback &#123; top: 0; &#125;&#125;// Help text(提示信息)//// Apply to any element you wish to create light text for placement immediately// below a form control. Use for general help, formatting, or instructional text..help-block &#123; display: block; // account for any element using help-block margin-top: 5px; margin-bottom: 10px; color: lighten(@text-color, 25%); // lighten the text some for contrast&#125;// Inline forms(内联表单)//// Make forms appear inline(-block) by adding the `.form-inline` class. Inline// forms begin stacked on extra small (mobile) devices and then go inline when// viewports reach &lt;768px.//// Requires wrapping inputs and labels with `.form-group` for proper display of// default HTML form controls and our custom form controls (e.g., input groups).//// Heads up! This is mixin-ed into `.navbar-form` in navbars.less..form-inline &#123; // Kick in the inline @media (min-width: @screen-sm-min) &#123; // Inline-block all the things for &quot;inline&quot; .form-group &#123; display: inline-block; margin-bottom: 0; vertical-align: middle; &#125; // In navbar-form, allow folks to *not* use `.form-group` .form-control &#123; display: inline-block; width: auto; // Prevent labels from stacking above inputs in `.form-group` vertical-align: middle; &#125; // Make static controls behave like regular ones .form-control-static &#123; display: inline-block; &#125; .input-group &#123; display: inline-table; vertical-align: middle; .input-group-addon, .input-group-btn, .form-control &#123; width: auto; &#125; &#125; // Input groups need that 100% width though .input-group &gt; .form-control &#123; width: 100%; &#125; .control-label &#123; margin-bottom: 0; vertical-align: middle; &#125; // Remove default margin on radios/checkboxes that were used for stacking, and // then undo the floating of radios and checkboxes to match. .radio, .checkbox &#123; display: inline-block; margin-top: 0; margin-bottom: 0; vertical-align: middle; label &#123; padding-left: 0; &#125; &#125; .radio input[type=&quot;radio&quot;], .checkbox input[type=&quot;checkbox&quot;] &#123; position: relative; margin-left: 0; &#125; // Re-override the feedback icon. .has-feedback .form-control-feedback &#123; top: 0; &#125; &#125;&#125;// Horizontal forms(水平表单)//// Horizontal forms are built on grid classes and allow you to create forms with// labels on the left and inputs on the right..form-horizontal &#123; // Consistent vertical alignment of radios and checkboxes // // Labels also get some reset styles, but that is scoped to a media query below. .radio, .checkbox, .radio-inline, .checkbox-inline &#123; margin-top: 0; margin-bottom: 0; padding-top: (@padding-base-vertical + 1); // Default padding plus a border &#125; // Account for padding we&apos;re adding to ensure the alignment and of help text // and other content below items .radio, .checkbox &#123; min-height: (@line-height-computed + (@padding-base-vertical + 1)); &#125; // Make form groups behave like rows .form-group &#123; .make-row(); &#125; // Reset spacing and right align labels, but scope to media queries so that // labels on narrow viewports stack the same as a default form example. @media (min-width: @screen-sm-min) &#123; .control-label &#123; text-align: right; margin-bottom: 0; padding-top: (@padding-base-vertical + 1); // Default padding plus a border &#125; &#125; // Validation states // // Reposition the icon because it&apos;s now within a grid column and columns have // `position: relative;` on them. Also accounts for the grid gutter padding. .has-feedback .form-control-feedback &#123; right: floor((@grid-gutter-width / 2)); &#125; // Form group sizes // // Quick utility class for applying `.input-lg` and `.input-sm` styles to the // inputs and labels within a `.form-group`. .form-group-lg &#123; @media (min-width: @screen-sm-min) &#123; .control-label &#123; padding-top: (@padding-large-vertical + 1); font-size: @font-size-large; &#125; &#125; &#125; .form-group-sm &#123; @media (min-width: @screen-sm-min) &#123; .control-label &#123; padding-top: (@padding-small-vertical + 1); font-size: @font-size-small; &#125; &#125; &#125;&#125; 1.2、forms.less应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!--默认垂直表单--&gt;&lt;form role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name1&quot;&gt;名称&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name1&quot; placeholder=&quot;请输入名称&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputfile1&quot;&gt;文件输入&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;inputfile1&quot;&gt; &lt;p class=&quot;help-block&quot;&gt;这里是块级帮助文本的实例。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;请打勾 &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;!--内联表单--&gt;&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;name2&quot;&gt;名称&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name2&quot; placeholder=&quot;请输入名称&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;sr-only&quot; for=&quot;inputfile2&quot;&gt;文件输入&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;inputfile2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;请打勾 &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;!--水平表单--&gt;&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt; &lt;!--表单帮助文本--&gt; &lt;label&gt;帮助文本实例&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; placeholder=&quot;&quot;&gt; &lt;span class=&quot;help-block&quot;&gt;一个较长的帮助文本块，超过一行， 需要扩展到下一行。本实例中的帮助文本总共有两行。&lt;/span&gt; &lt;!--在一个水平表单内的表单标签后放置纯文本--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;firstname&quot; class=&quot;col-sm-2 control-label&quot;&gt;名字&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;firstname&quot; placeholder=&quot;请输入名字&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;lastname&quot; class=&quot;col-sm-2 control-label&quot;&gt;姓&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;lastname&quot; placeholder=&quot;请输入姓&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;请记住我 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;!--表单控件状态--&gt;&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;聚焦&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input class=&quot;form-control&quot; id=&quot;focusedInput&quot; type=&quot;text&quot; value=&quot;该输入框获得焦点...&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledInput&quot; class=&quot;col-sm-2 control-label&quot;&gt;禁用&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;!--禁用的输入框 input--&gt; &lt;input class=&quot;form-control&quot; id=&quot;disabledInput&quot; type=&quot;text&quot; placeholder=&quot;该输入框禁止输入...&quot; disabled&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--禁用的字段集 fieldset--&gt; &lt;fieldset disabled&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledTextInput&quot; class=&quot;col-sm-2 control-label&quot;&gt;禁用输入（Fieldset disabled）&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;disabledTextInput&quot; class=&quot;form-control&quot; placeholder=&quot;禁止输入&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledSelect&quot; class=&quot;col-sm-2 control-label&quot;&gt;禁用选择菜单（Fieldset disabled）&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;select id=&quot;disabledSelect&quot; class=&quot;form-control&quot;&gt; &lt;option&gt;禁止选择&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;!--验证状态--&gt; &lt;div class=&quot;form-group has-success&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot; for=&quot;inputSuccess&quot;&gt;输入成功&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputSuccess&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group has-warning&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot; for=&quot;inputWarning&quot;&gt;输入警告&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputWarning&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group has-error&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot; for=&quot;inputError&quot;&gt;输入错误&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputError&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 bootstrap & type 样式","slug":"bootstrap/base&type","date":"2017-11-06T15:30:39.000Z","updated":"2018-04-15T12:56:50.000Z","comments":true,"path":"bootstrap/base&type/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/base&type/","excerpt":"现在开始介绍 bootstrap 的基础和排版(type)样式。","text":"现在开始介绍 bootstrap 的基础和排版(type)样式。 一、源码1、bootstrap.less1.1、bootstrap.less 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */// Core variables and mixins(全局变量和宏)@import &quot;variables.less&quot;;@import &quot;mixins.less&quot;;// Reset and dependencies(重置全局默认样式)@import &quot;normalize.less&quot;;// 设置打印样式，使用媒体查询(@media print)@import &quot;print.less&quot;;// 引用字体图标样式@import &quot;glyphicons.less&quot;;// Core CSS(核心CSS)// 设置全局基础样式@import &quot;scaffolding.less&quot;;// 排版样式@import &quot;type.less&quot;;// 代码@import &quot;code.less&quot;;// 网格系统@import &quot;grid.less&quot;;// 表格@import &quot;tables.less&quot;;// 表单@import &quot;forms.less&quot;;// 按钮@import &quot;buttons.less&quot;;// Components(组件)// 组件动画@import &quot;component-animations.less&quot;;// 下拉菜单@import &quot;dropdowns.less&quot;;// 按钮组@import &quot;button-groups.less&quot;;@import &quot;input-groups.less&quot;;// 导航@import &quot;navs.less&quot;;// 导航条@import &quot;navbar.less&quot;;// 面包屑式导航@import &quot;breadcrumbs.less&quot;;// 分页导航@import &quot;pagination.less&quot;;// 翻页分页导航@import &quot;pager.less&quot;;// 标签@import &quot;labels.less&quot;;// 徽章@import &quot;badges.less&quot;;@import &quot;jumbotron.less&quot;;// 缩略图@import &quot;thumbnails.less&quot;;// 警示框@import &quot;alerts.less&quot;;// 进度条@import &quot;progress-bars.less&quot;;// 媒体对象@import &quot;media.less&quot;;// 列表组@import &quot;list-group.less&quot;;// 面板@import &quot;panels.less&quot;;@import &quot;responsive-embed.less&quot;;@import &quot;wells.less&quot;;@import &quot;close.less&quot;;// Components w/ JavaScript// 静态弹出框@import &quot;modals.less&quot;;// 提示框@import &quot;tooltip.less&quot;;// 弹出框@import &quot;popovers.less&quot;;// 图片轮播@import &quot;carousel.less&quot;;// Utility classes(工具样式)@import &quot;utilities.less&quot;;@import &quot;responsive-utilities.less&quot;; 2、type.less2.1、type.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307//// Typography(排版)// --------------------------------------------------// Headings(标题)// -------------------------// 常常会碰到在一个标题后面紧跟着一行小的副标题(small)h1, h2, h3, h4, h5, h6,.h1, .h2, .h3, .h4, .h5, .h6 &#123; font-family: @headings-font-family; font-weight: @headings-font-weight; line-height: @headings-line-height; color: @headings-color; small, .small &#123; font-weight: normal; line-height: 1; color: @headings-small-color; &#125;&#125;h1, .h1,h2, .h2,h3, .h3 &#123; margin-top: @line-height-computed; margin-bottom: (@line-height-computed / 2); small, .small &#123; font-size: 65%; &#125;&#125;h4, .h4,h5, .h5,h6, .h6 &#123; margin-top: (@line-height-computed / 2); margin-bottom: (@line-height-computed / 2); small, .small &#123; font-size: 75%; &#125;&#125;h1, .h1 &#123; font-size: @font-size-h1; &#125;h2, .h2 &#123; font-size: @font-size-h2; &#125;h3, .h3 &#123; font-size: @font-size-h3; &#125;h4, .h4 &#123; font-size: @font-size-h4; &#125;h5, .h5 &#123; font-size: @font-size-h5; &#125;h6, .h6 &#123; font-size: @font-size-h6; &#125;// Body text(正文文本)// -------------------------p &#123; margin: 0 0 (@line-height-computed / 2);&#125;// 处理一个段落的文字，让其显示效果显著，强调内容.lead &#123; margin-bottom: @line-height-computed; font-size: floor((@font-size-base * 1.15)); font-weight: 300; line-height: 1.4; //大中型浏览器字体稍大 @media (min-width: @screen-sm-min) &#123; font-size: (@font-size-base * 1.5); &#125;&#125;// Emphasis &amp; misc 强调突出// -------------------------// Ex: (12px small font / 14px base font) * 100% = about 85%small,.small &#123; font-size: floor((100% * @font-size-small / @font-size-base));&#125;mark,.mark &#123; background-color: @state-warning-bg; padding: .2em;&#125;// Alignment(对齐).text-left &#123; text-align: left; &#125;.text-right &#123; text-align: right; &#125;.text-center &#123; text-align: center; &#125;// 适用于长文本排版，不过目前两端对齐在各浏览器下解析各有不同，特别是应用于中文文本的时候，所以项目中慎用.text-justify &#123; text-align: justify; &#125;.text-nowrap &#123; white-space: nowrap; &#125;// Transformation(文本大小写转换).text-lowercase &#123; text-transform: lowercase; &#125;.text-uppercase &#123; text-transform: uppercase; &#125;.text-capitalize &#123; text-transform: capitalize; &#125;// Contextual colors(文本颜色).text-muted &#123; //提示 color: @text-muted;&#125;.text-primary &#123; //主要 .text-emphasis-variant(@brand-primary);&#125;.text-success &#123; //成功 .text-emphasis-variant(@state-success-text);&#125;.text-info &#123; //通知信息 .text-emphasis-variant(@state-info-text);&#125;.text-warning &#123; //警告 .text-emphasis-variant(@state-warning-text);&#125;.text-danger &#123; //危险 .text-emphasis-variant(@state-danger-text);&#125;// Contextual backgrounds(文本背景)// For now(目前，暂时) we&apos;ll leave these alongside the text classes until v4 when we can// safely shift things around (per SemVer rules)..bg-primary &#123; // Given the contrast(对比) here, this is the only class to have its color inverted // automatically. color: #fff; .bg-variant(@brand-primary);&#125;.bg-success &#123; .bg-variant(@state-success-bg);&#125;.bg-info &#123; .bg-variant(@state-info-bg);&#125;.bg-warning &#123; .bg-variant(@state-warning-bg);&#125;.bg-danger &#123; .bg-variant(@state-danger-bg);&#125;// Page header(页面标题)// -------------------------.page-header &#123; padding-bottom: ((@line-height-computed / 2) - 1); margin: (@line-height-computed * 2) 0 @line-height-computed; border-bottom: 1px solid @page-header-border-color;&#125;// Lists(列表)// -------------------------// Unordered and Ordered listsul,ol &#123; margin-top: 0; margin-bottom: (@line-height-computed / 2); ul, ol &#123; margin-bottom: 0; &#125;&#125;// List options// Unstyled keeps list items block level, just removes default browser padding and list-style(去点列表).list-unstyled &#123; padding-left: 0; list-style: none;&#125;// Inline turns list items into inline-block() (内联列表，为制作水平导航而生).list-inline &#123; .list-unstyled(); margin-left: -5px; &gt; li &#123; display: inline-block; padding-left: 5px; padding-right: 5px; &#125;&#125;// Description Lists (定义列表)dl &#123; margin-top: 0; // Remove browser default margin-bottom: @line-height-computed;&#125;dt,dd &#123; line-height: @line-height-base;&#125;dt &#123; font-weight: bold;&#125;dd &#123; margin-left: 0; // Undo browser default&#125;// Horizontal description lists (水平定义列表)//// Defaults to being stacked without any of the below styles applied, until the// grid breakpoint is reached (default of ~768px)..dl-horizontal &#123; dd &#123; &amp;:extend(.clearfix all); // Clear the floated `dt` if an empty `dd` is present &#125; @media (min-width: @dl-horizontal-breakpoint) &#123; dt &#123; float: left; width: (@dl-horizontal-offset - 20); clear: left; text-align: right; .text-overflow(); &#125; dd &#123; margin-left: @dl-horizontal-offset; &#125; &#125;&#125;// Misc// -------------------------// Abbreviations and acronyms(缩略词)abbr[title],// Add data-* attribute to help out our tooltip plugin, per https://github.com/twbs/bootstrap/issues/5257abbr[data-original-title] &#123; cursor: help; border-bottom: 1px dotted @abbr-border-color;&#125;// 词首字母缩略词.initialism &#123; font-size: 90%; .text-uppercase();&#125;// Blockquotes(引用)blockquote &#123; padding: (@line-height-computed / 2) @line-height-computed; margin: 0 0 @line-height-computed; font-size: @blockquote-font-size; border-left: 5px solid @blockquote-border-color; p, ul, ol &#123; &amp;:last-child &#123; margin-bottom: 0; &#125; &#125; // Note: Deprecated small and .small as of v3.1.0 // Context: https://github.com/twbs/bootstrap/issues/11660 footer, small, .small &#123; display: block; font-size: 80%; // back to default font-size line-height: @line-height-base; color: @blockquote-small-color; &amp;:before &#123; content: &apos;\\2014 \\00A0&apos;; // em dash, nbsp &#125; &#125;&#125;// Opposite alignment of blockquote//// Heads up: `blockquote.pull-right` has been deprecated as of v3.1.0..blockquote-reverse,blockquote.pull-right &#123; padding-right: 15px; padding-left: 0; border-right: 5px solid @blockquote-border-color; border-left: 0; text-align: right; // Account for citation footer, small, .small &#123; &amp;:before &#123; content: &apos;&apos;; &#125; &amp;:after &#123; content: &apos;\\00A0 \\2014&apos;; // nbsp, em dash &#125; &#125;&#125;// Addressesaddress &#123; margin-bottom: @line-height-computed; font-style: normal; line-height: @line-height-base;&#125; 2.2、type.less 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!--标题&amp;内联子标题--&gt;&lt;h1&gt;我是标题1 h1. &lt;small&gt;我是副标题1 h1&lt;/small&gt;&lt;/h1&gt;&lt;h2&gt;我是标题2 h2. &lt;small&gt;我是副标题2 h2&lt;/small&gt;&lt;/h2&gt;&lt;h3&gt;我是标题3 h3. &lt;small&gt;我是副标题3 h3&lt;/small&gt;&lt;/h3&gt;&lt;h4&gt;我是标题4 h4. &lt;small&gt;我是副标题4 h4&lt;/small&gt;&lt;/h4&gt;&lt;h5&gt;我是标题5 h5. &lt;small&gt;我是副标题5 h5&lt;/small&gt;&lt;/h5&gt;&lt;h6&gt;我是标题6 h6. &lt;small&gt;我是副标题6 h6&lt;/small&gt;&lt;/h6&gt;&lt;!--引导主体副本--&gt;&lt;h2&gt;引导主体副本&lt;/h2&gt;&lt;p class=&quot;lead&quot;&gt;这是一个演示引导主体副本用法的实例。这是一个演示引导主体副本用法的实例。。&lt;/p&gt;&lt;!--强调--&gt;&lt;small&gt;本行内容是在标签内&lt;/small&gt;&lt;br&gt;&lt;strong&gt;本行内容是在标签内&lt;/strong&gt;&lt;br&gt;&lt;em&gt;本行内容是在标签内，并呈现为斜体&lt;/em&gt;&lt;br&gt;&lt;p class=&quot;text-left&quot;&gt;向左对齐文本&lt;/p&gt;&lt;p class=&quot;text-center&quot;&gt;居中对齐文本&lt;/p&gt;&lt;p class=&quot;text-right&quot;&gt;向右对齐文本&lt;/p&gt;&lt;!--文本颜色，同文本背景--&gt;&lt;p class=&quot;text-muted bg-success&quot;&gt;本行内容是减弱的&lt;/p&gt;&lt;p class=&quot;text-primary&quot;&gt;本行内容带有一个 primary class&lt;/p&gt;&lt;p class=&quot;text-success&quot;&gt;本行内容带有一个 success class&lt;/p&gt;&lt;p class=&quot;text-info&quot;&gt;本行内容带有一个 info class&lt;/p&gt;&lt;p class=&quot;text-warning&quot;&gt;本行内容带有一个 warning class&lt;/p&gt;&lt;p class=&quot;text-danger&quot;&gt;本行内容带有一个 danger class&lt;/p&gt;&lt;!--缩写--&gt;&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;&lt;br&gt;&lt;abbr title=&quot;Real Simple Syndication&quot; class=&quot;initialism&quot;&gt;RSS&lt;/abbr&gt;&lt;!--地址--&gt;&lt;address&gt; &lt;strong&gt;Some Company, Inc.&lt;/strong&gt;&lt;br&gt; 007 street&lt;br&gt; Some City, State XXXXX&lt;br&gt; &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt; (123) 456-7890&lt;/address&gt;&lt;address&gt; &lt;strong&gt;Full Name&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;mailto:#&quot;&gt;mailto@somedomain.com&lt;/a&gt;&lt;/address&gt;&lt;!--引用--&gt;&lt;blockquote&gt; &lt;p&gt; 这是一个默认的引用实例。这是一个默认的引用实例。这是一个默认的引用实例。这是一个默认的引用实例。 &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; 这是一个带有源标题的引用。 &lt;small&gt;Someone famous in &lt;cite title=&quot;Source Title&quot;&gt;Source Title&lt;/cite&gt;&lt;/small&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;pull-right&quot;&gt; 这是一个向右对齐的引用。 &lt;small&gt;Someone famous in &lt;cite title=&quot;Source Title&quot;&gt;Source Title&lt;/cite&gt;&lt;/small&gt;&lt;/blockquote&gt;&lt;!--列表--&gt;&lt;h4&gt;有序列表&lt;/h4&gt;&lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;无序列表&lt;/h4&gt;&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;未定义样式列表&lt;/h4&gt;&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;内联列表&lt;/h4&gt;&lt;ul class=&quot;list-inline&quot;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;定义列表&lt;/h4&gt;&lt;dl&gt; &lt;dt&gt;Description 1&lt;/dt&gt; &lt;dd&gt;Item 1&lt;/dd&gt; &lt;dt&gt;Description 2&lt;/dt&gt; &lt;dd&gt;Item 2&lt;/dd&gt;&lt;/dl&gt;&lt;h4&gt;水平的定义列表&lt;/h4&gt;&lt;dl class=&quot;dl-horizontal&quot;&gt; &lt;dt&gt;Description 1&lt;/dt&gt; &lt;dd&gt;Item 1&lt;/dd&gt; &lt;dt&gt;Description 2&lt;/dt&gt; &lt;dd&gt;Item 2&lt;/dd&gt;&lt;/dl&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 scaffolding & tables 样式","slug":"bootstrap/scaffolding&tables","date":"2017-11-06T15:04:38.000Z","updated":"2018-04-15T13:53:27.000Z","comments":true,"path":"bootstrap/scaffolding&tables/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/scaffolding&tables/","excerpt":"现在开始介绍 bootstrap 的 scaffolding(脚手架) 和 tables(表格)，包括 scaffolding.less、tables.less。","text":"现在开始介绍 bootstrap 的 scaffolding(脚手架) 和 tables(表格)，包括 scaffolding.less、tables.less。 一、源码1、scaffolding.less1.1、scaffolding.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//// Scaffolding(脚手架)// --------------------------------------------------// Reset the box-sizing(content-box:标准盒模型；border-box:IE低版本/怪异模式)//// Heads up! This reset may cause conflicts with some third-party widgets.// For recommendations on resolving such conflicts, see// http://getbootstrap.com/getting-started/#third-box-sizing* &#123; .box-sizing(border-box);&#125;*:before,*:after &#123; .box-sizing(border-box);&#125;// Body resethtml &#123; font-size: 10px; -webkit-tap-highlight-color: rgba(0,0,0,0);&#125;body &#123; font-family: @font-family-base; font-size: @font-size-base; line-height: @line-height-base; color: @text-color; background-color: @body-bg;&#125;// Reset fonts for relevant elementsinput,button,select,textarea &#123; font-family: inherit; font-size: inherit; line-height: inherit;&#125;// Linksa &#123; color: @link-color; text-decoration: none; &amp;:hover, &amp;:focus &#123; color: @link-hover-color; text-decoration: @link-hover-decoration; &#125; &amp;:focus &#123; .tab-focus(); &#125;&#125;// Figures//// We reset this here because previously Normalize had no `figure` margins. This// ensures we don&apos;t break anyone&apos;s use of the element.figure &#123; margin: 0;&#125;// Images(图像)img &#123; vertical-align: middle;&#125;// Responsive images (ensure images don&apos;t scale beyond their parents，响应式图片展示防止图片拉伸超出父元素).img-responsive &#123; .img-responsive();&#125;// Rounded corners(圆角).img-rounded &#123; border-radius: @border-radius-large;&#125;// Image thumbnails(缩略图)//// Heads up! This is mixin-ed into thumbnails.less for `.thumbnail`..img-thumbnail&#123; padding: @thumbnail-padding; line-height: @line-height-base; background-color: @thumbnail-bg; border: 1px solid @thumbnail-border; border-radius: @thumbnail-border-radius; .transition(all .2s ease-in-out); // Keep them at most 100% wide .img-responsive(inline-block);&#125;// Perfect circle(圆图片，设置border-radius为50%).img-circle &#123; border-radius: 50%; // set radius in percents&#125;// Horizontal ruleshr &#123; margin-top: @line-height-computed; margin-bottom: @line-height-computed; border: 0; border-top: 1px solid @hr-border;&#125;// Only display content to screen readers//// 只在屏幕阅读器上使用// See: http://a11yproject.com/posts/how-to-hide-content.sr-only &#123; position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0,0,0,0); border: 0;&#125;// Use in conjunction(联合，连接) with .sr-only to only display content when it&apos;s focused.// Useful for &quot;Skip to main content&quot; links; see http://www.w3.org/TR/2013/NOTE-WCAG20-TECHS-20130905/G1// Credit: HTML5 Boilerplate.sr-only-focusable &#123; &amp;:active, &amp;:focus &#123; position: static; width: auto; height: auto; margin: 0; overflow: visible; clip: auto; &#125;&#125;// iOS &quot;clickable elements&quot; fix for role=&quot;button&quot;//// 修复iOS的addEventListener监听click事件在不是交互元素上不触发的bug// 方案:1、设置cursor: pointer；2、添加onclick属性；3、使用交互性的元素如a；4、不使用click，使用事件委托到父元素// Fixes &quot;clickability&quot; issue (and more generally(更普遍地，更概括地), the firing of events such as focus as well)// for traditionally non-focusable elements with role=&quot;button&quot;// see https://developer.mozilla.org/en-US/docs/Web/Events/click#Safari_Mobile[role=&quot;button&quot;] &#123; cursor: pointer;&#125; 1.2、scaffolding.less应用12345&lt;!--这里需要介绍图像 img 的应用--&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/06/download.png&quot; class=&quot;img-rounded&quot;&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/06/download.png&quot; class=&quot;img-circle&quot;&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/06/download.png&quot; class=&quot;img-thumbnail&quot;&gt;&lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2014/06/download.png&quot; class=&quot;img-responsive&quot;&gt; 2、tables.less2.1、tables.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//// Tables 表格// --------------------------------------------------table &#123; background-color: @table-bg;&#125;caption &#123; padding-top: @table-cell-padding; padding-bottom: @table-cell-padding; color: @text-muted; text-align: left;&#125;th &#123; text-align: left;&#125;// Baseline styles(基础表格).table &#123; width: 100%; max-width: 100%; margin-bottom: @line-height-computed; // Cells &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th, &gt; td &#123; padding: @table-cell-padding; line-height: @line-height-base; vertical-align: top; border-top: 1px solid @table-border-color; &#125; &#125; &#125; // Bottom align for column headings &gt; thead &gt; tr &gt; th &#123; vertical-align: bottom; border-bottom: 2px solid @table-border-color; &#125; // Remove top border from thead by default &gt; caption + thead, &gt; colgroup + thead, &gt; thead:first-child &#123; &gt; tr:first-child &#123; &gt; th, &gt; td &#123; border-top: 0; &#125; &#125; &#125; // Account for multiple tbody instances(+: 相邻选择符) &gt; tbody + tbody &#123; border-top: 2px solid @table-border-color; &#125; // Nesting .table &#123; background-color: @body-bg; &#125;&#125;// Condensed table w/ half padding(紧凑型表格).table-condensed &#123; &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th, &gt; td &#123; padding: @table-condensed-cell-padding; &#125; &#125; &#125;&#125;// Bordered version(带边框表格)//// Add borders all around the table and between all the columns..table-bordered &#123; border: 1px solid @table-border-color; &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th, &gt; td &#123; border: 1px solid @table-border-color; &#125; &#125; &#125; &gt; thead &gt; tr &#123; &gt; th, &gt; td &#123; border-bottom-width: 2px; &#125; &#125;&#125;// Zebra-striping(斑马线表格)//// Default zebra-stripe styles (alternating gray and transparent backgrounds).table-striped &#123; &gt; tbody &gt; tr:nth-of-type(odd) &#123; background-color: @table-bg-accent; &#125;&#125;// Hover effect(鼠标悬浮高亮的表格)//// Placed here since it has to come after the potential zebra striping.table-hover &#123; &gt; tbody &gt; tr:hover &#123; background-color: @table-bg-hover; &#125;&#125;// Table cell sizing//// Reset default table behavior(&apos;class*=&apos;: 选择所有类名中含有&apos;col-&apos;的元素; ^=: 表示开头; $=: 表示结尾)table col[class*=&quot;col-&quot;] &#123; position: static; // Prevent border hiding in Firefox and IE9-11 (see https://github.com/twbs/bootstrap/issues/11623) float: none; display: table-column;&#125;table &#123; td, th &#123; &amp;[class*=&quot;col-&quot;] &#123; position: static; // Prevent border hiding in Firefox and IE9-11 (see https://github.com/twbs/bootstrap/issues/11623) float: none; display: table-cell; &#125; &#125;&#125;// Table backgrounds//// Exact selectors below required to override `.table-striped` and prevent// inheritance to nested tables.// Generate the contextual variants// 当前活动.table-row-variant(active; @table-bg-active);// 成功或者正确的行为.table-row-variant(success; @state-success-bg);// 中立的信息或行为.table-row-variant(info; @state-info-bg);// 表示警告，需要特别注意.table-row-variant(warning; @state-warning-bg);// 表示危险或者可能是错误的行为.table-row-variant(danger; @state-danger-bg);// Responsive tables(响应式表格)//// Wrap your tables in `.table-responsive` and we&apos;ll make them mobile friendly// by enabling horizontal scrolling. Only applies &lt;768px. Everything above that// will display normally..table-responsive &#123; overflow-x: auto; min-height: 0.01%; // Workaround for IE9 bug (see https://github.com/twbs/bootstrap/issues/14837) @media screen and (max-width: @screen-xs-max) &#123; width: 100%; margin-bottom: (@line-height-computed * 0.75); overflow-y: hidden; -ms-overflow-style: -ms-autohiding-scrollbar; border: 1px solid @table-border-color; // Tighten up spacing &gt; .table &#123; margin-bottom: 0; // Ensure the content doesn&apos;t wrap &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th, &gt; td &#123; white-space: nowrap; &#125; &#125; &#125; &#125; // Special overrides for the bordered tables &gt; .table-bordered &#123; border: 0; // Nuke the appropriate borders so that the parent can handle them &gt; thead, &gt; tbody, &gt; tfoot &#123; &gt; tr &#123; &gt; th:first-child, &gt; td:first-child &#123; border-left: 0; &#125; &gt; th:last-child, &gt; td:last-child &#123; border-right: 0; &#125; &#125; &#125; // Only nuke the last row&apos;s bottom-border in `tbody` and `tfoot` since // chances are there will be only one `tr` in a `thead` and that would // remove the border altogether. &gt; tbody, &gt; tfoot &#123; &gt; tr:last-child &#123; &gt; th, &gt; td &#123; border-bottom: 0; &#125; &#125; &#125; &#125; &#125;&#125; 2.2、tables.less应用12345678910111213141516171819202122232425262728&lt;!--table-responsive:响应式表格；上下文类：active等；table-bordered：边框表格；table-condensed：精简表格；table-hover：悬停表格；table-striped：条纹表格--&gt;&lt;table class=&quot;table table-responsive table-bordered table-condensed table-hover&quot;&gt; &lt;caption&gt;表格布局&lt;/caption&gt; &lt;thead&gt; &lt;tr class=&quot;active&quot;&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;城市&lt;/th&gt; &lt;th&gt;邮编&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;success&quot;&gt; &lt;td&gt;Tanmay&lt;/td&gt; &lt;td&gt;Bangalore&lt;/td&gt; &lt;td&gt;560001&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;danger&quot;&gt; &lt;td&gt;Sachin&lt;/td&gt; &lt;td&gt;Mumbai&lt;/td&gt; &lt;td&gt;400003&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;warning&quot;&gt; &lt;td&gt;Uma&lt;/td&gt; &lt;td&gt;Pune&lt;/td&gt; &lt;td&gt;411027&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 code & grid 样式","slug":"bootstrap/code&grid","date":"2017-11-06T15:04:38.000Z","updated":"2018-04-15T13:34:48.000Z","comments":true,"path":"bootstrap/code&grid/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/code&grid/","excerpt":"现在开始介绍 bootstrap 的 code(代码) 和 grid(栅格)，包括 code.less、grid.less。","text":"现在开始介绍 bootstrap 的 code(代码) 和 grid(栅格)，包括 code.less、grid.less。 一、源码1、code.less1.1、code.less 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Code (inline and block) 代码// --------------------------------------------------// Inline and block code stylescode,kbd,pre,samp &#123; font-family: @font-family-monospace;&#125;// Inline code 显示单行内联代码code &#123; padding: 2px 4px; font-size: 90%; color: @code-color; background-color: @code-bg; border-radius: @border-radius-base;&#125;// User input typically entered via keyboard 显示用户输入代码kbd &#123; padding: 2px 4px; font-size: 90%; color: @kbd-color; background-color: @kbd-bg; border-radius: @border-radius-small; box-shadow: inset 0 -1px 0 rgba(0,0,0,.25); kbd &#123; padding: 0; font-size: 100%; font-weight: bold; box-shadow: none; &#125;&#125;// Blocks of code 显示多行块代码pre &#123; display: block; padding: ((@line-height-computed - 1) / 2); margin: 0 0 (@line-height-computed / 2); font-size: (@font-size-base - 1); // 14px to 13px line-height: @line-height-base; word-break: break-all; word-wrap: break-word; color: @pre-color; background-color: @pre-bg; border: 1px solid @pre-border-color; border-radius: @border-radius-base; // Account for some code outputs that place code tags in pre tags code &#123; padding: 0; font-size: inherit; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0; &#125;&#125;// Enable scrollable blocks of code.pre-scrollable &#123; max-height: @pre-scrollable-max-height; overflow-y: scroll;&#125; 1.2、code.less 应用123456789101112131415161718192021222324252627282930&lt;!--code&amp;pre--&gt;&lt;p&gt;&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 作为内联元素被包围。&lt;/p&gt;&lt;p&gt;如果需要把代码显示为一个独立的块元素，请使用 &amp;lt;pre&amp;gt; 标签：&lt;/p&gt;&lt;pre&gt;&amp;lt;article&amp;gt; &amp;lt;h1&amp;gt;Article Heading&amp;lt;/h1&amp;gt;&amp;lt;/article&amp;gt;&lt;/pre&gt;&lt;!--kbd--&gt;&lt;p&gt;使用 kbd 元素表示按键输入:&lt;/p&gt;&lt;p&gt;使用 &lt;kbd&gt;ctrl + p&lt;/kbd&gt; 来打开打印窗口。&lt;/p&gt;&lt;!--samp--&gt;&lt;p&gt;使用 samp 元素包含电脑输出的内容:&lt;/p&gt;&lt;p&gt;&lt;samp&gt;This text is output from a computer program....&lt;/samp&gt;&lt;/p&gt;&lt;!--pre-scrollable--&gt;&lt;div class=&quot;container&quot;&gt; &lt;h2&gt;代码&lt;/h2&gt; &lt;p&gt;使用 pre 元素输出多行:&lt;/p&gt; &lt;pre&gt;在 pre 元素中的文本 宽度的显示与文本的宽度一样， 保留了 空 格 和 换行。&lt;/pre&gt; &lt;p&gt;如果你添加 .pre-scrollable 类, pre 元素最大的高度 max-height 为 350px ，并生成一个 Y 轴的滚动条:&lt;/p&gt; &lt;pre class=&quot;pre-scrollable&quot;&gt;在 pre 元素中的文本 宽度的显示与文本的宽度一样， 保留了 空 格 和 换行。&lt;/pre&gt;&lt;/div&gt; 2、grid.less2.1、grid.less 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Grid system(网格系统)// --------------------------------------------------// Container widths(容器宽度)//// Set the container width, and override it for fixed navbars in media queries..container &#123; .container-fixed(); @media (min-width: @screen-sm-min) &#123; width: @container-sm; &#125; @media (min-width: @screen-md-min) &#123; width: @container-md; &#125; @media (min-width: @screen-lg-min) &#123; width: @container-lg; &#125;&#125;// Fluid container//// Utilizes the mixin meant for fixed width containers, but without any defined// width for fluid, full width layouts..container-fluid &#123; .container-fixed();&#125;// Row(行容器)//// Rows contain and clear the floats of your columns..row &#123; .make-row();&#125;// Columns(网格列)//// Common styles for small and large grid columns.make-grid-columns();// Extra small grid(生成超小网格)//// Columns, offsets, pushes, and pulls for extra small devices like// smartphones..make-grid(xs);// Small grid(生成小网格)//// Columns, offsets, pushes, and pulls for the small device range, from phones// to tablets.@media (min-width: @screen-sm-min) &#123; .make-grid(sm);&#125;// Medium grid(生成中等网格)//// Columns, offsets, pushes, and pulls for the desktop device range.@media (min-width: @screen-md-min) &#123; .make-grid(md);&#125;// Large grid(生成大网格)//// Columns, offsets, pushes, and pulls for the large desktop device range.@media (min-width: @screen-lg-min) &#123; .make-grid(lg);&#125; 2.2、grid.less 应用123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot; &gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;clearfix visible-xs&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8; box-shadow:inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.3、grid.less 工作原理1、行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。2、使用行来创建列的水平组。3、内容应该放置在列内，且唯有列可以是行的直接子元素。4、预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。5、列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。6、网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4。","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 carousel","slug":"bootstrap/carousel","date":"2017-11-05T07:23:03.000Z","updated":"2018-04-15T13:34:43.000Z","comments":true,"path":"bootstrap/carousel/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/carousel/","excerpt":"这节介绍下 carousel(轮播)模块的源码实现。","text":"这节介绍下 carousel(轮播)模块的源码实现。 一、源码1、carousel.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268//// Carousel(图片轮播)// --------------------------------------------------// Wrapper for the slide container and indicators(轮播图容器).carousel &#123; position: relative;&#125;// 轮播图片播放区.carousel-inner &#123; position: relative; overflow: hidden; width: 100%; &gt; .item &#123; display: none; position: relative; .transition(.6s ease-in-out left); // Account for jankitude on images &gt; img, &gt; a &gt; img &#123; &amp;:extend(.img-responsive); line-height: 1; &#125; // WebKit CSS3 transforms for supported devices @media all and (transform-3d), (-webkit-transform-3d) &#123; .transition-transform(~&apos;0.6s ease-in-out&apos;); .backface-visibility(~&apos;hidden&apos;); .perspective(1000px); &amp;.next, &amp;.active.right &#123; .translate3d(100%, 0, 0); left: 0; &#125; &amp;.prev, &amp;.active.left &#123; .translate3d(-100%, 0, 0); left: 0; &#125; &amp;.next.left, &amp;.prev.right, &amp;.active &#123; .translate3d(0, 0, 0); left: 0; &#125; &#125; &#125; &gt; .active, &gt; .next, &gt; .prev &#123; display: block; &#125; &gt; .active &#123; left: 0; &#125; &gt; .next, &gt; .prev &#123; position: absolute; top: 0; width: 100%; &#125; &gt; .next &#123; left: 100%; &#125; &gt; .prev &#123; left: -100%; &#125; &gt; .next.left, &gt; .prev.right &#123; left: 0; &#125; &gt; .active.left &#123; left: -100%; &#125; &gt; .active.right &#123; left: 100%; &#125;&#125;// Left/right controls for nav(轮播图片控制器)// ---------------------------.carousel-control &#123; position: absolute; top: 0; left: 0; bottom: 0; width: @carousel-control-width; .opacity(@carousel-control-opacity); font-size: @carousel-control-font-size; color: @carousel-control-color; text-align: center; text-shadow: @carousel-text-shadow; background-color: rgba(0, 0, 0, 0); // Fix IE9 click-thru bug // We can&apos;t have this transition here because WebKit cancels the carousel // animation if you trip this while in the middle of another animation. // Set gradients for backgrounds &amp;.left &#123; #gradient &gt; .horizontal(@start-color: rgba(0,0,0,.5); @end-color: rgba(0,0,0,.0001)); &#125; &amp;.right &#123; left: auto; right: 0; #gradient &gt; .horizontal(@start-color: rgba(0,0,0,.0001); @end-color: rgba(0,0,0,.5)); &#125; // Hover/focus state &amp;:hover, &amp;:focus &#123; outline: 0; color: @carousel-control-color; text-decoration: none; .opacity(.9); &#125; // Toggles .icon-prev, .icon-next, .glyphicon-chevron-left, .glyphicon-chevron-right &#123; position: absolute; top: 50%; margin-top: -10px; z-index: 5; display: inline-block; &#125; .icon-prev, .glyphicon-chevron-left &#123; left: 50%; margin-left: -10px; &#125; .icon-next, .glyphicon-chevron-right &#123; right: 50%; margin-right: -10px; &#125; .icon-prev, .icon-next &#123; width: 20px; height: 20px; line-height: 1; font-family: serif; &#125; .icon-prev &#123; &amp;:before &#123; content: &apos;\\2039&apos;;// SINGLE LEFT-POINTING ANGLE QUOTATION MARK (U+2039) &#125; &#125; .icon-next &#123; &amp;:before &#123; content: &apos;\\203a&apos;;// SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (U+203A) &#125; &#125;&#125;// Optional indicator pips(轮播图片计数器)//// Add an unordered list with the following class and add a list item for each// slide your carousel holds..carousel-indicators &#123; position: absolute; bottom: 10px; left: 50%; z-index: 15; width: 60%; margin-left: -30%; padding-left: 0; list-style: none; text-align: center; li &#123; display: inline-block; width: 10px; height: 10px; margin: 1px; text-indent: -999px; border: 1px solid @carousel-indicator-border-color; border-radius: 10px; cursor: pointer; // IE8-9 hack for event handling // // Internet Explorer 8-9 does not support clicks on elements without a set // `background-color`. We cannot use `filter` since that&apos;s not viewed as a // background color by the browser. Thus, a hack is needed. // See https://developer.mozilla.org/en-US/docs/Web/Events/click#Internet_Explorer // // For IE8, we set solid black as it doesn&apos;t support `rgba()`. For IE9, we // set alpha transparency for the best results possible. background-color: #000 \\9; // IE8 background-color: rgba(0,0,0,0); // IE9 &#125; .active &#123; margin: 0; width: 12px; height: 12px; background-color: @carousel-indicator-active-bg; &#125;&#125;// Optional captions(图片对应标题和描述内容)// -----------------------------// Hidden by default for smaller viewports.carousel-caption &#123; position: absolute; left: 15%; right: 15%; bottom: 20px; z-index: 10; padding-top: 20px; padding-bottom: 20px; color: @carousel-caption-color; text-align: center; text-shadow: @carousel-text-shadow; &amp; .btn &#123; text-shadow: none; // No shadow for button elements in carousel-caption &#125;&#125;// Scale up controls for tablets and up(对于大屏设备放大一点控制器)@media screen and (min-width: @screen-sm-min) &#123; // Scale up the controls a smidge(一点点) .carousel-control &#123; .glyphicon-chevron-left, .glyphicon-chevron-right, .icon-prev, .icon-next &#123; width: (@carousel-control-font-size * 1.5); height: (@carousel-control-font-size * 1.5); margin-top: (@carousel-control-font-size / -2); font-size: (@carousel-control-font-size * 1.5); &#125; .glyphicon-chevron-left, .icon-prev &#123; margin-left: (@carousel-control-font-size / -2); &#125; .glyphicon-chevron-right, .icon-next &#123; margin-right: (@carousel-control-font-size / -2); &#125; &#125; // Show and left align the captions .carousel-caption &#123; left: 20%; right: 20%; padding-bottom: 30px; &#125; // Move up the indicators .carousel-indicators &#123; bottom: 20px; &#125;&#125; 2、carousel.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251/* ======================================================================== * Bootstrap: carousel.js v3.3.7(图片轮播) * http://getbootstrap.com/javascript/#carousel * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // CAROUSEL CLASS DEFINITION // ========================= var Carousel = function (element, options) &#123; this.$element = $(element); this.$indicators = this.$element.find(&apos;.carousel-indicators&apos;); this.options = options; this.paused = null; this.sliding = null; // 判断是否正在轮播项滚动 this.interval = null; // 轮播循环播放定时器 this.$active = null; this.$items = null; // 如果options.keyboard == true，则监听键盘事件 this.options.keyboard &amp;&amp; this.$element.on(&apos;keydown.bs.carousel&apos;, $.proxy(this.keydown, this)); // 不是移动设备(不存在ontouchstart事件)，那么当options.pause == &apos;hover&apos;时实现鼠标的悬浮暂停 this.options.pause == &apos;hover&apos; &amp;&amp; !(&apos;ontouchstart&apos; in document.documentElement) &amp;&amp; this.$element .on(&apos;mouseenter.bs.carousel&apos;, $.proxy(this.pause, this)) .on(&apos;mouseleave.bs.carousel&apos;, $.proxy(this.cycle, this)) &#125;; Carousel.VERSION = &apos;3.3.7&apos;; Carousel.TRANSITION_DURATION = 600; Carousel.DEFAULTS = &#123; interval: 5000, pause: &apos;hover&apos;, wrap: true, keyboard: true &#125;; // 键盘事件，做出相应操作 Carousel.prototype.keydown = function (e) &#123; if (/input|textarea/i.test(e.target.tagName)) return; switch (e.which) &#123; case 37: this.prev(); break; case 39: this.next(); break; default: return &#125; e.preventDefault() &#125;; // 循环轮播，清除定时器并重新设置定时器 Carousel.prototype.cycle = function (e) &#123; e || (this.paused = false); this.interval &amp;&amp; clearInterval(this.interval); this.options.interval &amp;&amp; !this.paused &amp;&amp; (this.interval = setInterval($.proxy(this.next, this), this.options.interval)); return this &#125;; // 获取轮播项索引值 Carousel.prototype.getItemIndex = function (item) &#123; this.$items = item.parent().children(&apos;.item&apos;); return this.$items.index(item || this.$active) &#125;; // 获取方向上的轮播项 Carousel.prototype.getItemForDirection = function (direction, active) &#123; var activeIndex = this.getItemIndex(active); var willWrap = (direction == &apos;prev&apos; &amp;&amp; activeIndex === 0) || (direction == &apos;next&apos; &amp;&amp; activeIndex == (this.$items.length - 1)); if (willWrap &amp;&amp; !this.options.wrap) return active; var delta = direction == &apos;prev&apos; ? -1 : 1; // 如果itemIndex为负数-1，不需要做处理，因为eq函数参数为负数时从集合最后一个元素开始倒数 var itemIndex = (activeIndex + delta) % this.$items.length; return this.$items.eq(itemIndex) &#125;; // 滚动到指定轮播项 Carousel.prototype.to = function (pos) &#123; var that = this var activeIndex = this.getItemIndex(this.$active = this.$element.find(&apos;.item.active&apos;)); if (pos &gt; (this.$items.length - 1) || pos &lt; 0) return; // 如果轮播图正在滚动切换，那么滚动到指定轮播项需要等到滚动切换结束(即监听到slid.bs.carousel)时才能继续操作 if (this.sliding) return this.$element.one(&apos;slid.bs.carousel&apos;, function () &#123; that.to(pos) &#125;); // yes, &quot;slid&quot; if (activeIndex == pos) return this.pause().cycle(); return this.slide(pos &gt; activeIndex ? &apos;next&apos; : &apos;prev&apos;, this.$items.eq(pos)) &#125;; // 暂停轮播，清除定时器 Carousel.prototype.pause = function (e) &#123; e || (this.paused = true); // 如果刚好为轮播添加了next/prev类即将开始滚动并且浏览器支持动画，鼠标移入，那么直接触发动画结束自定义事件 if (this.$element.find(&apos;.next, .prev&apos;).length &amp;&amp; $.support.transition) &#123; this.$element.trigger($.support.transition.end); this.cycle(true) &#125; this.interval = clearInterval(this.interval); return this &#125;; // 下一个轮播图 Carousel.prototype.next = function () &#123; // 如果轮播图正在滚动切换，那么上下轮播切换不做任何操作 if (this.sliding) return; return this.slide(&apos;next&apos;) &#125;; // 上一个轮播图 Carousel.prototype.prev = function () &#123; if (this.sliding) return; return this.slide(&apos;prev&apos;) &#125;; // 滚动函数 Carousel.prototype.slide = function (type, next) &#123; var $active = this.$element.find(&apos;.item.active&apos;); var $next = next || this.getItemForDirection(type, $active); var isCycling = this.interval; var direction = type == &apos;next&apos; ? &apos;left&apos; : &apos;right&apos;; var that = this; if ($next.hasClass(&apos;active&apos;)) return (this.sliding = false); var relatedTarget = $next[0]; // 触发轮播即将开始自定义事件 var slideEvent = $.Event(&apos;slide.bs.carousel&apos;, &#123; relatedTarget: relatedTarget, direction: direction &#125;); this.$element.trigger(slideEvent); if (slideEvent.isDefaultPrevented()) return; this.sliding = true; isCycling &amp;&amp; this.pause(); // 为计数器切换active类 if (this.$indicators.length) &#123; this.$indicators.find(&apos;.active&apos;).removeClass(&apos;active&apos;); var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]); $nextIndicator &amp;&amp; $nextIndicator.addClass(&apos;active&apos;) &#125; var slidEvent = $.Event(&apos;slid.bs.carousel&apos;, &#123; relatedTarget: relatedTarget, direction: direction &#125;); // yes, &quot;slid&quot; if ($.support.transition &amp;&amp; this.$element.hasClass(&apos;slide&apos;)) &#123; $next.addClass(type); $next[0].offsetWidth // force reflow $active.addClass(direction); $next.addClass(direction); $active .one(&apos;bsTransitionEnd&apos;, function () &#123; $next.removeClass([type, direction].join(&apos; &apos;)).addClass(&apos;active&apos;); $active.removeClass([&apos;active&apos;, direction].join(&apos; &apos;)); that.sliding = false; setTimeout(function () &#123; that.$element.trigger(slidEvent) &#125;, 0) &#125;) .emulateTransitionEnd(Carousel.TRANSITION_DURATION) &#125; else &#123; $active.removeClass(&apos;active&apos;); $next.addClass(&apos;active&apos;); this.sliding = false; this.$element.trigger(slidEvent) &#125; isCycling &amp;&amp; this.cycle(); return this &#125;; // CAROUSEL PLUGIN DEFINITION // ========================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this); var data = $this.data(&apos;bs.carousel&apos;); var options = $.extend(&#123;&#125;, Carousel.DEFAULTS, $this.data(), typeof option == &apos;object&apos; &amp;&amp; option); var action = typeof option == &apos;string&apos; ? option : options.slide; if (!data) $this.data(&apos;bs.carousel&apos;, (data = new Carousel(this, options))); // js方法直接触发轮播，跳转到指定轮播页 if (typeof option == &apos;number&apos;) data.to(option); // 在点击上、下一个时触发轮播 else if (action) data[action](); // 初始化加载，在data-ride=&quot;carousel&quot;且data-interval==true情况下触发轮播 else if (options.interval) data.pause().cycle() &#125;) &#125; var old = $.fn.carousel; $.fn.carousel = Plugin; $.fn.carousel.Constructor = Carousel; // CAROUSEL NO CONFLICT // ==================== $.fn.carousel.noConflict = function () &#123; $.fn.carousel = old; return this &#125;; // CAROUSEL DATA-API // ================= var clickHandler = function (e) &#123; var href; var $this = $(this); var $target = $($this.attr(&apos;data-target&apos;) || (href = $this.attr(&apos;href&apos;)) &amp;&amp; href.replace(/.*(?=#[^\\s]+$)/, &apos;&apos;)); // strip for ie7 // 如果目标元素没有carousel类，说明不是carousel容器，不做任何处理 if (!$target.hasClass(&apos;carousel&apos;)) return; var options = $.extend(&#123;&#125;, $target.data(), $this.data()); var slideIndex = $this.attr(&apos;data-slide-to&apos;); if (slideIndex) options.interval = false; Plugin.call($target, options); if (slideIndex) &#123; $target.data(&apos;bs.carousel&apos;).to(slideIndex) &#125; // 防止使用a标签改变了链接地址等，阻止默认事件发生 e.preventDefault() &#125;; $(document) .on(&apos;click.bs.carousel.data-api&apos;, &apos;[data-slide]&apos;, clickHandler) .on(&apos;click.bs.carousel.data-api&apos;, &apos;[data-slide-to]&apos;, clickHandler); $(window).on(&apos;load&apos;, function () &#123; $(&apos;[data-ride=&quot;carousel&quot;]&apos;).each(function () &#123; var $carousel = $(this) Plugin.call($carousel, $carousel.data()) &#125;) &#125;)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;div id=&quot;myCarousel&quot; class=&quot;carousel slide&quot;&gt; &lt;!-- 轮播（Carousel）指标 --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#myCarousel&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#myCarousel&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#myCarousel&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 轮播（Carousel）项目 --&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;/wp-content/uploads/2014/07/slide1.png&quot; alt=&quot;First slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;/wp-content/uploads/2014/07/slide2.png&quot; alt=&quot;Second slide&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;/wp-content/uploads/2014/07/slide3.png&quot; alt=&quot;Third slide&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 轮播（Carousel）导航 --&gt; &lt;a class=&quot;carousel-control left&quot; href=&quot;#myCarousel&quot; data-slide=&quot;prev&quot;&gt;&amp;lsaquo;&lt;/a&gt; &lt;a class=&quot;carousel-control right&quot; href=&quot;#myCarousel&quot; data-slide=&quot;next&quot;&gt;&amp;rsaquo;&lt;/a&gt; &lt;!-- 控制按钮 --&gt; &lt;div style=&quot;text-align:center;&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn start-slide&quot; value=&quot;Start&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn pause-slide&quot; value=&quot;Pause&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn prev-slide&quot; value=&quot;Previous Slide&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn next-slide&quot; value=&quot;Next Slide&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn slide-one&quot; value=&quot;Slide 1&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn slide-two&quot; value=&quot;Slide 2&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn slide-three&quot; value=&quot;Slide 3&quot;&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;$(function()&#123; // 初始化轮播 $(&quot;.start-slide&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(&apos;cycle&apos;); &#125;); // 停止轮播 $(&quot;.pause-slide&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(&apos;pause&apos;); &#125;); // 循环轮播到上一个项目 $(&quot;.prev-slide&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(&apos;prev&apos;); &#125;); // 循环轮播到下一个项目 $(&quot;.next-slide&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(&apos;next&apos;); &#125;); // 循环轮播到某个特定的帧 $(&quot;.slide-one&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(0); &#125;); $(&quot;.slide-two&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(1); &#125;); $(&quot;.slide-three&quot;).click(function()&#123; $(&quot;#myCarousel&quot;).carousel(2); &#125;); &#125;);&lt;/script&gt; 2、源码分析2.1、carousel.less1、carousel(相对定位) 分为 carousel-indicators(指示器)、carousel-inner(轮播项目)、carousel-control(轮播导航)；2、为 carousel-inner 内的 item(轮播项)设置 left、active、right 等样式，操作 left 或者 translate3d(如果支持动画效果的话)设置轮播项的位置；3、carousel-control(绝对定位) 分为 left、right 两种状态，并设置 hover、focus、icon 等样式；4、carousel-indicators、carousel-caption 均为绝对布局，并为大屏设置做了一点调整 2.2、modal.js1、通过 data-ride=”carousel” 或 $(“#myCarousel”).carousel() 进行轮播初始化；2、监听 data-slide-to 和 data-slide 属性值或者调用 carousel(option) 方法，做出相应滚动操作；3、支持键盘操作，监听键盘事件，执行 keydown 函数滚动；4、最为核心的方法是 slide，先找到当前页，然后获取下一页和滚动方向，通过设置切换轮播项的 class 达到滚动的目的","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 modal","slug":"bootstrap/modal","date":"2017-10-31T15:26:07.000Z","updated":"2018-04-15T13:41:11.000Z","comments":true,"path":"bootstrap/modal/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/modal/","excerpt":"这节介绍下 modal(模态弹窗)模块的源码实现。","text":"这节介绍下 modal(模态弹窗)模块的源码实现。 一、源码1、modals.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//// Modals(静态弹出框)// --------------------------------------------------// .modal-open - body class for killing the scroll// .modal - container to scroll within// .modal-dialog - positioning shell for the actual modal// .modal-content - actual modal w/ bg and corners and shit// Kill the scroll on the body(让body不发生滚动).modal-open &#123; overflow: hidden;&#125;// Container that the modal scrolls within(容器).modal &#123; display: none; overflow: hidden; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: @zindex-modal; -webkit-overflow-scrolling: touch; // Prevent Chrome on Windows from adding a focus outline. For details, see // https://github.com/twbs/bootstrap/pull/10951. outline: 0; // When fading in the modal, animate it to slide down(模态框动态效果) &amp;.fade .modal-dialog &#123; .translate(0, -25%); .transition-transform(~&quot;0.3s ease-out&quot;); &#125; &amp;.in .modal-dialog &#123; .translate(0, 0) &#125;&#125;.modal-open .modal &#123; overflow-x: hidden; overflow-y: auto;&#125;// Shell div to position the modal with bottom padding(模态对话框,水平居中).modal-dialog &#123; position: relative; width: auto; margin: 10px;&#125;// Actual modal(模态框主体容器).modal-content &#123; position: relative; background-color: @modal-content-bg; border: 1px solid @modal-content-fallback-border-color; //old browsers fallback (ie8 etc) border: 1px solid @modal-content-border-color; border-radius: @border-radius-large; .box-shadow(0 3px 9px rgba(0,0,0,.5)); background-clip: padding-box; // Remove focus outline from opened modal outline: 0;&#125;// Modal background(模态框遮罩层).modal-backdrop &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: @zindex-modal-background; background-color: @modal-backdrop-bg; // Fade for backdrop(遮罩层动画效果) &amp;.fade &#123; .opacity(0); &#125; &amp;.in &#123; .opacity(@modal-backdrop-opacity); &#125;&#125;// Modal header(弹出框头部)// Top section of the modal w/ title and dismiss.modal-header &#123; padding: @modal-title-padding; border-bottom: 1px solid @modal-header-border-color; &amp;:extend(.clearfix all);&#125;// Close icon(弹出框头部关闭图标).modal-header .close &#123; margin-top: -2px;&#125;// Title text within header(弹出框头部标题).modal-title &#123; margin: 0; line-height: @modal-title-line-height;&#125;// Modal body(弹窗框主体)// Where all modal content resides (sibling of .modal-header and .modal-footer).modal-body &#123; position: relative; padding: @modal-inner-padding;&#125;// Footer (for actions)(弹出框脚部).modal-footer &#123; padding: @modal-inner-padding; text-align: right; // right align buttons border-top: 1px solid @modal-footer-border-color; &amp;:extend(.clearfix all); // clear it in case folks use .pull-* classes on buttons // Properly space out buttons .btn + .btn &#123; margin-left: 5px; margin-bottom: 0; // account for input[type=&quot;submit&quot;] which gets the bottom margin like all other inputs &#125; // but override that for button groups .btn-group .btn + .btn &#123; margin-left: -1px; &#125; // and override it for block buttons as well .btn-block + .btn-block &#123; margin-left: 0; &#125;&#125;// Measure scrollbar width for padding body during modal show/hide(测量滚动条宽度).modal-scrollbar-measure &#123; position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;&#125;// Scale up the modal(响应式模态框大小)@media (min-width: @screen-sm-min) &#123; // Automatically set modal&apos;s width for larger viewports .modal-dialog &#123; width: @modal-md; margin: 30px auto; &#125; .modal-content &#123; .box-shadow(0 5px 15px rgba(0,0,0,.5)); &#125; // Modal sizes .modal-sm &#123; width: @modal-sm; &#125;&#125;@media (min-width: @screen-md-min) &#123; .modal-lg &#123; width: @modal-lg; &#125;&#125; 2、modal.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368/* ======================================================================== * Bootstrap: modal.js v3.3.7(模态弹窗) * http://getbootstrap.com/javascript/#modals * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // MODAL CLASS DEFINITION(模态框构造函数) // ====================== var Modal = function (element, options) &#123; this.options = options this.$body = $(document.body) this.$element = $(element) this.$dialog = this.$element.find(&apos;.modal-dialog&apos;) this.$backdrop = null this.isShown = null this.originalBodyPad = null this.scrollbarWidth = 0 this.ignoreBackdropClick = false if (this.options.remote) &#123; this.$element .find(&apos;.modal-content&apos;) .load(this.options.remote, $.proxy(function () &#123; this.$element.trigger(&apos;loaded.bs.modal&apos;) &#125;, this)) &#125; &#125; Modal.VERSION = &apos;3.3.7&apos; Modal.TRANSITION_DURATION = 300 Modal.BACKDROP_TRANSITION_DURATION = 150 // Modules自定义属性，show: 第一次点击时是显示还是隐藏 Modal.DEFAULTS = &#123; backdrop: true, keyboard: true, show: true &#125; // 模态框显示隐藏切换方法 Modal.prototype.toggle = function (_relatedTarget) &#123; return this.isShown ? this.hide() : this.show(_relatedTarget) &#125; // 模态框显示 Modal.prototype.show = function (_relatedTarget) &#123; var that = this // 创建自定义事件 show.bs.modal 并触发 var e = $.Event(&apos;show.bs.modal&apos;, &#123; relatedTarget: _relatedTarget &#125;) this.$element.trigger(e) // 判断是否已经成显示状态或者阻止默认事件发生 if (this.isShown || e.isDefaultPrevented()) return this.isShown = true this.checkScrollbar() this.setScrollbar() this.$body.addClass(&apos;modal-open&apos;) this.escape() this.resize() // 为模态框上的 &apos;X&apos; 添加关闭回调函数 this.$element.on(&apos;click.dismiss.bs.modal&apos;, &apos;[data-dismiss=&quot;modal&quot;]&apos;, $.proxy(this.hide, this)) // 存在在dialog点下按钮然后移动鼠标到backdrop上松开鼠标情况，防止这种情况导致backdrop隐藏 this.$dialog.on(&apos;mousedown.dismiss.bs.modal&apos;, function () &#123; that.$element.one(&apos;mouseup.dismiss.bs.modal&apos;, function (e) &#123; if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true &#125;) &#125;) // 添加回调函数，等背景加载完全再执行回调函数 this.backdrop(function () &#123; var transition = $.support.transition &amp;&amp; that.$element.hasClass(&apos;fade&apos;) // 没有父元素(例: 还未append的$(&quot;&lt;div&gt;&lt;/div&gt;&quot;))，则将model附加到body上, if (!that.$element.parent().length) &#123; that.$element.appendTo(that.$body) // don&apos;t move modals dom position &#125; // 显示模态框并设置滚动到头部 that.$element .show() .scrollTop(0) // 调整对话框 that.adjustDialog() // 强制回流准备动画 if (transition) &#123; that.$element[0].offsetWidth // force reflow &#125; // 显示模态框 that.$element.addClass(&apos;in&apos;) // 获取焦点 that.enforceFocus() var e = $.Event(&apos;shown.bs.modal&apos;, &#123; relatedTarget: _relatedTarget &#125;) transition ? that.$dialog // wait for modal to slide in .one(&apos;bsTransitionEnd&apos;, function () &#123; that.$element.trigger(&apos;focus&apos;).trigger(e) &#125;) .emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger(&apos;focus&apos;).trigger(e) &#125;) &#125; // 模态框隐藏 Modal.prototype.hide = function (e) &#123; if (e) e.preventDefault() e = $.Event(&apos;hide.bs.modal&apos;) this.$element.trigger(e) if (!this.isShown || e.isDefaultPrevented()) return this.isShown = false this.escape() this.resize() $(document).off(&apos;focusin.bs.modal&apos;) this.$element .removeClass(&apos;in&apos;) .off(&apos;click.dismiss.bs.modal&apos;) .off(&apos;mouseup.dismiss.bs.modal&apos;) this.$dialog.off(&apos;mousedown.dismiss.bs.modal&apos;) $.support.transition &amp;&amp; this.$element.hasClass(&apos;fade&apos;) ? this.$element .one(&apos;bsTransitionEnd&apos;, $.proxy(this.hideModal, this)) .emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal() &#125; // 强制让model获取焦点 Modal.prototype.enforceFocus = function () &#123; $(document) .off(&apos;focusin.bs.modal&apos;) // guard against infinite focus loop .on(&apos;focusin.bs.modal&apos;, $.proxy(function (e) &#123; if (document !== e.target &amp;&amp; this.$element[0] !== e.target &amp;&amp; !this.$element.has(e.target).length) &#123; this.$element.trigger(&apos;focus&apos;) &#125; &#125;, this)) &#125; // 按下esc键时，隐藏model功能 Modal.prototype.escape = function () &#123; if (this.isShown &amp;&amp; this.options.keyboard) &#123; this.$element.on(&apos;keydown.dismiss.bs.modal&apos;, $.proxy(function (e) &#123; e.which == 27 &amp;&amp; this.hide() &#125;, this)) &#125; else if (!this.isShown) &#123; this.$element.off(&apos;keydown.dismiss.bs.modal&apos;) &#125; &#125; // 窗口大小重新调整时，设置监听函数 Modal.prototype.resize = function () &#123; if (this.isShown) &#123; $(window).on(&apos;resize.bs.modal&apos;, $.proxy(this.handleUpdate, this)) &#125; else &#123; $(window).off(&apos;resize.bs.modal&apos;) &#125; &#125; // 执行模态框隐藏函数，并移除backdrop Modal.prototype.hideModal = function () &#123; var that = this this.$element.hide() this.backdrop(function () &#123; that.$body.removeClass(&apos;modal-open&apos;) that.resetAdjustments() that.resetScrollbar() that.$element.trigger(&apos;hidden.bs.modal&apos;) &#125;) &#125; // 移除backdrop的dom，并且设置$backdrop为null Modal.prototype.removeBackdrop = function () &#123; this.$backdrop &amp;&amp; this.$backdrop.remove() this.$backdrop = null &#125; // backdrop显示隐藏逻辑 Modal.prototype.backdrop = function (callback) &#123; var that = this var animate = this.$element.hasClass(&apos;fade&apos;) ? &apos;fade&apos; : &apos;&apos; if (this.isShown &amp;&amp; this.options.backdrop) &#123; // 判断是否支持动画效果，如果$.support.transition返回false，说明不支持CSS动画 var doAnimate = $.support.transition &amp;&amp; animate this.$backdrop = $(document.createElement(&apos;div&apos;)) .addClass(&apos;modal-backdrop &apos; + animate) .appendTo(this.$body) // 为模态框添加监听函数 this.$element.on(&apos;click.dismiss.bs.modal&apos;, $.proxy(function (e) &#123; if (this.ignoreBackdropClick) &#123; this.ignoreBackdropClick = false return &#125; // 如果点击模态框而不是遮罩层，不做任何操作 if (e.target !== e.currentTarget) return // 如果backdrop为&apos;static&apos;，则不隐藏模态框而是让模态框获取焦点 this.options.backdrop == &apos;static&apos; ? this.$element[0].focus() : this.hide() &#125;, this)) if (doAnimate) this.$backdrop[0].offsetWidth // 强制回流准备动画效果 this.$backdrop.addClass(&apos;in&apos;) // 如果没有回调函数则直接返回 if (!callback) return // 如果有回调函数，则判断是否支持动画效果，如果支持动画效果则在动画执行完再进行回调，否则直接处理 doAnimate ? this.$backdrop .one(&apos;bsTransitionEnd&apos;, callback) .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback() &#125; else if (!this.isShown &amp;&amp; this.$backdrop) &#123; // 移除class in，使得执行遮罩层淡出动画 this.$backdrop.removeClass(&apos;in&apos;) var callbackRemove = function () &#123; that.removeBackdrop() callback &amp;&amp; callback() &#125; // 遮罩层淡出动画结束后移除遮罩层dom，再执行回调函数 $.support.transition &amp;&amp; this.$element.hasClass(&apos;fade&apos;) ? this.$backdrop .one(&apos;bsTransitionEnd&apos;, callbackRemove) .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove() &#125; else if (callback) &#123; callback() &#125; &#125; // these following methods are used to handle overflowing modals(处理模态框溢出) Modal.prototype.handleUpdate = function () &#123; this.adjustDialog() &#125; // 主要是处理窗口更新时滚动条出现 Modal.prototype.adjustDialog = function () &#123; // 如果有水平滚动条 var modalIsOverflowing = this.$element[0].scrollHeight &gt; document.documentElement.clientHeight this.$element.css(&#123; paddingLeft: !this.bodyIsOverflowing &amp;&amp; modalIsOverflowing ? this.scrollbarWidth : &apos;&apos;, paddingRight: this.bodyIsOverflowing &amp;&amp; !modalIsOverflowing ? this.scrollbarWidth : &apos;&apos; &#125;) &#125; // 重置之前为了scrollbar而做的padding处理 Modal.prototype.resetAdjustments = function () &#123; this.$element.css(&#123; paddingLeft: &apos;&apos;, paddingRight: &apos;&apos; &#125;) &#125; // 判断是否有垂直滚动条，以及测量获取滚动条宽度 Modal.prototype.checkScrollbar = function () &#123; var fullWindowWidth = window.innerWidth if (!fullWindowWidth) &#123; // workaround for missing window.innerWidth in IE8 var documentElementRect = document.documentElement.getBoundingClientRect() fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left) &#125; // 判断如果body标签的宽度小于window窗口宽度，则bodyIsOverflowing为true this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth this.scrollbarWidth = this.measureScrollbar() &#125; // 设置滚动条，为body设置padding-right抵消掉滚动条宽度，因为overflow会被设置为hidden而没有了滚动条 Modal.prototype.setScrollbar = function () &#123; var bodyPad = parseInt((this.$body.css(&apos;padding-right&apos;) || 0), 10) this.originalBodyPad = document.body.style.paddingRight || &apos;&apos; if (this.bodyIsOverflowing) this.$body.css(&apos;padding-right&apos;, bodyPad + this.scrollbarWidth) &#125; // 重置body为原先的padding Modal.prototype.resetScrollbar = function () &#123; this.$body.css(&apos;padding-right&apos;, this.originalBodyPad) &#125; // 测量获取滚动条宽度 Modal.prototype.measureScrollbar = function () &#123; // thx walsh var scrollDiv = document.createElement(&apos;div&apos;) scrollDiv.className = &apos;modal-scrollbar-measure&apos; this.$body.append(scrollDiv) var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth this.$body[0].removeChild(scrollDiv) return scrollbarWidth &#125; // MODAL PLUGIN DEFINITION(模态框插件定义) // ======================= function Plugin(option, _relatedTarget) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.modal&apos;) var options = $.extend(&#123;&#125;, Modal.DEFAULTS, $this.data(), typeof option == &apos;object&apos; &amp;&amp; option) if (!data) $this.data(&apos;bs.modal&apos;, (data = new Modal(this, options))) if (typeof option == &apos;string&apos;) data[option](_relatedTarget) else if (options.show) data.show(_relatedTarget) &#125;) &#125; var old = $.fn.modal $.fn.modal = Plugin $.fn.modal.Constructor = Modal // MODAL NO CONFLICT(有冲突时，还原$.fn.modal的引用，然后返回自己) // ================= $.fn.modal.noConflict = function () &#123; $.fn.modal = old return this &#125; // MODAL DATA-API(使用&apos;data-*&apos;自定义属性触发或者使用a标签触发) // ============== $(document).on(&apos;click.bs.modal.data-api&apos;, &apos;[data-toggle=&quot;modal&quot;]&apos;, function (e) &#123; var $this = $(this) var href = $this.attr(&apos;href&apos;) // href.replace(/.*(?=#[^\\s]+$)/, &apos;&apos;): 截取&apos;#&apos;号后面的字符，比如 http://www.baidu.com?p1=1&amp;p2=2#ss =&gt; #ss var $target = $($this.attr(&apos;data-target&apos;) || (href &amp;&amp; href.replace(/.*(?=#[^\\s]+$)/, &apos;&apos;))) // strip for ie7 // !/#/.test(href): 链接中没有&apos;#&apos; var option = $target.data(&apos;bs.modal&apos;) ? &apos;toggle&apos; : $.extend(&#123; remote: !/#/.test(href) &amp;&amp; href &#125;, $target.data(), $this.data()) if ($this.is(&apos;a&apos;)) e.preventDefault() $target.one(&apos;show.bs.modal&apos;, function (showEvent) &#123; if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown $target.one(&apos;hidden.bs.modal&apos;, function () &#123; $this.is(&apos;:visible&apos;) &amp;&amp; $this.trigger(&apos;focus&apos;) &#125;) &#125;) Plugin.call($target, option, this) &#125;)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用12345678910111213141516171819&lt;h2&gt;创建模态框（Modal）&lt;/h2&gt;&lt;!-- 按钮触发模态框 --&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;模态框（Modal）标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;在这里添加一些文本&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;提交更改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal-modal --&gt; 2、源码分析2.1、modals.less1、可在 modal 最外层容器添加 fade 类实现动画效果2、modal 为最外层容器，fixed 布局充满屏幕；modal-dialog 为对话框显示内容，水平居中；modal-content 为对话框内容容器；modal-header 为对话框头部容器，可添加 modal-title 内容标题和 close 图标；modal-body 为内容文本；modal-footer 为对话框底部容器，可添加 btn 操作按钮 2.2、modal.js1、不依赖于 js 触发，直接通过 data-toggle=”modal” 属性来初始化modal，当然也可以通过 js 触发；2、data-target 属性值为目标 modal 的 CSS 选择器，同时为 data-dismiss 设置监听函数，点击执行隐藏操作；3、如果存在自定义属性 keyboard，那么监听 esc 按键，当模态框弹出时，按键隐藏；4、modal 显示时，先加载 backdrop 背景完全(等待动画执行完成)再执行 modal显示(默认使用 translate 移动到 Y 轴上部，显示时设置 y = 0 )动画；隐藏时则相反","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 popover","slug":"bootstrap/popover","date":"2017-10-30T15:23:14.000Z","updated":"2018-04-15T13:50:27.000Z","comments":true,"path":"bootstrap/popover/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/popover/","excerpt":"这节介绍下 popover(弹出框)模块的源码实现。","text":"这节介绍下 popover(弹出框)模块的源码实现。 一、源码1、popovers.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//// Popovers(弹出框)// --------------------------------------------------.popover &#123; position: absolute; top: 0; left: 0; z-index: @zindex-popover; display: none; max-width: @popover-max-width; padding: 1px; // Our parent element can be arbitrary since popovers are by default inserted as a sibling of their target element. // So reset our font and text properties to avoid inheriting weird values. .reset-text(); font-size: @font-size-base; background-color: @popover-bg; background-clip: padding-box; border: 1px solid @popover-fallback-border-color; border: 1px solid @popover-border-color; border-radius: @border-radius-large; .box-shadow(0 5px 10px rgba(0,0,0,.2)); // Offset the popover to account for the popover arrow &amp;.top &#123; margin-top: -@popover-arrow-width; &#125; &amp;.right &#123; margin-left: @popover-arrow-width; &#125; &amp;.bottom &#123; margin-top: @popover-arrow-width; &#125; &amp;.left &#123; margin-left: -@popover-arrow-width; &#125;&#125;.popover-title &#123; margin: 0; // reset heading margin padding: 8px 14px; font-size: @font-size-base; background-color: @popover-title-bg; border-bottom: 1px solid darken(@popover-title-bg, 5%); border-radius: (@border-radius-large - 1) (@border-radius-large - 1) 0 0;&#125;.popover-content &#123; padding: 9px 14px;&#125;// Arrows//// .arrow is outer, .arrow:after is inner.popover &gt; .arrow &#123; &amp;, &amp;:after &#123; position: absolute; display: block; width: 0; height: 0; border-color: transparent; border-style: solid; &#125;&#125;.popover &gt; .arrow &#123; border-width: @popover-arrow-outer-width;&#125;.popover &gt; .arrow:after &#123; border-width: @popover-arrow-width; content: &quot;&quot;;&#125;.popover &#123; &amp;.top &gt; .arrow &#123; left: 50%; margin-left: -@popover-arrow-outer-width; border-bottom-width: 0; border-top-color: @popover-arrow-outer-fallback-color; // IE8 fallback border-top-color: @popover-arrow-outer-color; bottom: -@popover-arrow-outer-width; &amp;:after &#123; content: &quot; &quot;; bottom: 1px; margin-left: -@popover-arrow-width; border-bottom-width: 0; border-top-color: @popover-arrow-color; &#125; &#125; &amp;.right &gt; .arrow &#123; top: 50%; left: -@popover-arrow-outer-width; margin-top: -@popover-arrow-outer-width; border-left-width: 0; border-right-color: @popover-arrow-outer-fallback-color; // IE8 fallback border-right-color: @popover-arrow-outer-color; &amp;:after &#123; content: &quot; &quot;; left: 1px; bottom: -@popover-arrow-width; border-left-width: 0; border-right-color: @popover-arrow-color; &#125; &#125; &amp;.bottom &gt; .arrow &#123; left: 50%; margin-left: -@popover-arrow-outer-width; border-top-width: 0; border-bottom-color: @popover-arrow-outer-fallback-color; // IE8 fallback border-bottom-color: @popover-arrow-outer-color; top: -@popover-arrow-outer-width; &amp;:after &#123; content: &quot; &quot;; top: 1px; margin-left: -@popover-arrow-width; border-top-width: 0; border-bottom-color: @popover-arrow-color; &#125; &#125; &amp;.left &gt; .arrow &#123; top: 50%; right: -@popover-arrow-outer-width; margin-top: -@popover-arrow-outer-width; border-right-width: 0; border-left-color: @popover-arrow-outer-fallback-color; // IE8 fallback border-left-color: @popover-arrow-outer-color; &amp;:after &#123; content: &quot; &quot;; right: 1px; border-right-width: 0; border-left-color: @popover-arrow-color; bottom: -@popover-arrow-width; &#125; &#125;&#125; 2、popover.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* ======================================================================== * Bootstrap: popover.js v3.3.7(弹出框) * http://getbootstrap.com/javascript/#popovers * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // POPOVER PUBLIC CLASS DEFINITION // =============================== var Popover = function (element, options) &#123; this.init(&apos;popover&apos;, element, options) &#125; if (!$.fn.tooltip) throw new Error(&apos;Popover requires tooltip.js&apos;) Popover.VERSION = &apos;3.3.7&apos; Popover.DEFAULTS = $.extend(&#123;&#125;, $.fn.tooltip.Constructor.DEFAULTS, &#123; placement: &apos;right&apos;, trigger: &apos;click&apos;, content: &apos;&apos;, template: &apos;&lt;div class=&quot;popover&quot; role=&quot;tooltip&quot;&gt;&lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;&lt;h3 class=&quot;popover-title&quot;&gt;&lt;/h3&gt;&lt;div class=&quot;popover-content&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos; &#125;) // NOTE: POPOVER EXTENDS tooltip.js // ================================ Popover.prototype = $.extend(&#123;&#125;, $.fn.tooltip.Constructor.prototype) Popover.prototype.constructor = Popover Popover.prototype.getDefaults = function () &#123; return Popover.DEFAULTS &#125; Popover.prototype.setContent = function () &#123; var $tip = this.tip() var title = this.getTitle() var content = this.getContent() $tip.find(&apos;.popover-title&apos;)[this.options.html ? &apos;html&apos; : &apos;text&apos;](title) $tip.find(&apos;.popover-content&apos;).children().detach().end()[ // we use append for html objects to maintain js events this.options.html ? (typeof content == &apos;string&apos; ? &apos;html&apos; : &apos;append&apos;) : &apos;text&apos; ](content) $tip.removeClass(&apos;fade top bottom left right in&apos;) // IE8 doesn&apos;t accept hiding via the `:empty` pseudo selector, we have to do // this manually by checking the contents. if (!$tip.find(&apos;.popover-title&apos;).html()) $tip.find(&apos;.popover-title&apos;).hide() &#125; Popover.prototype.hasContent = function () &#123; return this.getTitle() || this.getContent() &#125; Popover.prototype.getContent = function () &#123; var $e = this.$element var o = this.options return $e.attr(&apos;data-content&apos;) || (typeof o.content == &apos;function&apos; ? o.content.call($e[0]) : o.content) &#125; Popover.prototype.arrow = function () &#123; return (this.$arrow = this.$arrow || this.tip().find(&apos;.arrow&apos;)) &#125; // POPOVER PLUGIN DEFINITION // ========================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.popover&apos;) var options = typeof option == &apos;object&apos; &amp;&amp; option if (!data &amp;&amp; /destroy|hide/.test(option)) return if (!data) $this.data(&apos;bs.popover&apos;, (data = new Popover(this, options))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.popover $.fn.popover = Plugin $.fn.popover.Constructor = Popover // POPOVER NO CONFLICT // =================== $.fn.popover.noConflict = function () &#123; $.fn.popover = old return this &#125;&#125;(jQuery); 二、应用 &amp; 源码分析1、应用1234567891011&lt;button type=&quot;button&quot; class=&quot;btnbtn-default&quot; data-container=&quot;body&quot; data-placement=&quot;bottom&quot; data-toggle=&quot;popover&quot; data-original-title=&quot;Bootstrap弹出框标题&quot; data-content=&quot;Bootstrap弹出框的内容&quot;&gt;猛击我吧&lt;/button&gt;&lt;a href=&quot;#&quot; class=&quot;btnbtn-default&quot; data-container=&quot;body&quot; data-placement=&quot;right&quot; data-toggle=&quot;popover&quot; title=&quot;Bootstrap弹出框标题&quot; data-content=&quot;Bootstrap弹出框的内容&quot;&gt;猛击我吧&lt;/a&gt;// 不能直接通过自定义属性data-来触发，需依赖于JavaScript&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&apos;[data-toggle=&quot;popover&quot;]&apos;).popover(); &#125;);&lt;/script&gt; 2、源码分析2.1、popovers.less1、弹出框 popover 模板与 tooltip 不同，不仅有标题，还可以设置内容 2.2、popover.js1、popover 继承了 tooltip 的原型，只不过覆盖了部分布局方法2、提示框 tooltip 的默认触发事件是 hover 和 focus，而弹出框 popover 是 click","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 tooltip","slug":"bootstrap/tooltip","date":"2017-10-30T12:53:42.000Z","updated":"2018-04-15T13:57:46.000Z","comments":true,"path":"bootstrap/tooltip/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/tooltip/","excerpt":"这节介绍下 tooltip(提示框)模块的源码实现。","text":"这节介绍下 tooltip(提示框)模块的源码实现。 一、源码1、tooltip.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// Tooltips(提示框)// --------------------------------------------------// Base class(基础样式).tooltip &#123; position: absolute; z-index: @zindex-tooltip; display: block; // Our parent element can be arbitrary since tooltips are by default inserted as a sibling of their target element. // So reset our font and text properties to avoid inheriting weird values. .reset-text(); font-size: @font-size-small; .opacity(0); &amp;.in &#123; .opacity(@tooltip-opacity); &#125; &amp;.top &#123; margin-top: -3px; padding: @tooltip-arrow-width 0; &#125; &amp;.right &#123; margin-left: 3px; padding: 0 @tooltip-arrow-width; &#125; &amp;.bottom &#123; margin-top: 3px; padding: @tooltip-arrow-width 0; &#125; &amp;.left &#123; margin-left: -3px; padding: 0 @tooltip-arrow-width; &#125;&#125;// Wrapper for the tooltip content(提示框文本内容).tooltip-inner &#123; max-width: @tooltip-max-width; padding: 3px 8px; color: @tooltip-color; text-align: center; background-color: @tooltip-bg; border-radius: @border-radius-base;&#125;// Arrows(提示框箭头).tooltip-arrow &#123; position: absolute; width: 0; height: 0; border-color: transparent; border-style: solid;&#125;// Note: Deprecated .top-left, .top-right, .bottom-left, and .bottom-right as of v3.3.1(提示框不同方向的箭头指向).tooltip &#123; &amp;.top .tooltip-arrow &#123; bottom: 0; left: 50%; margin-left: -@tooltip-arrow-width; border-width: @tooltip-arrow-width @tooltip-arrow-width 0; border-top-color: @tooltip-arrow-color; &#125; &amp;.top-left .tooltip-arrow &#123; bottom: 0; right: @tooltip-arrow-width; margin-bottom: -@tooltip-arrow-width; border-width: @tooltip-arrow-width @tooltip-arrow-width 0; border-top-color: @tooltip-arrow-color; &#125; &amp;.top-right .tooltip-arrow &#123; bottom: 0; left: @tooltip-arrow-width; margin-bottom: -@tooltip-arrow-width; border-width: @tooltip-arrow-width @tooltip-arrow-width 0; border-top-color: @tooltip-arrow-color; &#125; &amp;.right .tooltip-arrow &#123; top: 50%; left: 0; margin-top: -@tooltip-arrow-width; border-width: @tooltip-arrow-width @tooltip-arrow-width @tooltip-arrow-width 0; border-right-color: @tooltip-arrow-color; &#125; &amp;.left .tooltip-arrow &#123; top: 50%; right: 0; margin-top: -@tooltip-arrow-width; border-width: @tooltip-arrow-width 0 @tooltip-arrow-width @tooltip-arrow-width; border-left-color: @tooltip-arrow-color; &#125; &amp;.bottom .tooltip-arrow &#123; top: 0; left: 50%; margin-left: -@tooltip-arrow-width; border-width: 0 @tooltip-arrow-width @tooltip-arrow-width; border-bottom-color: @tooltip-arrow-color; &#125; &amp;.bottom-left .tooltip-arrow &#123; top: 0; right: @tooltip-arrow-width; margin-top: -@tooltip-arrow-width; border-width: 0 @tooltip-arrow-width @tooltip-arrow-width; border-bottom-color: @tooltip-arrow-color; &#125; &amp;.bottom-right .tooltip-arrow &#123; top: 0; left: @tooltip-arrow-width; margin-top: -@tooltip-arrow-width; border-width: 0 @tooltip-arrow-width @tooltip-arrow-width; border-bottom-color: @tooltip-arrow-color; &#125;&#125; 2、tooltip.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590/* ======================================================================== * Bootstrap: tooltip.js v3.3.7(提示框) * http://getbootstrap.com/javascript/#tooltip * Inspired by the original jQuery.tipsy by Jason Frame * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // TOOLTIP PUBLIC CLASS DEFINITION(提示框定义) // =============================== var Tooltip = function (element, options) &#123; this.type = null // 插件类型 this.options = null // 自定义属性 this.enabled = null // 标志量，控制tooltip是否可以显示 this.timeout = null // 定时器 this.hoverState = null // 提示框显示状态 this.$element = null // 对象绑定的元素 this.inState = null // 操作状态 this.init(&apos;tooltip&apos;, element, options) &#125; Tooltip.VERSION = &apos;3.3.7&apos; Tooltip.TRANSITION_DURATION = 150 // 提示框默认设置 Tooltip.DEFAULTS = &#123; animation: true, // 是否使用动画 placement: &apos;top&apos;, // 设置提示框内容位置信息 selector: false, // CSS选择器，用于事件委托 template: &apos;&lt;div class=&quot;tooltip&quot; role=&quot;tooltip&quot;&gt;&lt;div class=&quot;tooltip-arrow&quot;&gt;&lt;/div&gt;&lt;div class=&quot;tooltip-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos;, // 提示框模板 trigger: &apos;hover focus&apos;, // 触发方法 title: &apos;&apos;, // 提示框标题内容 delay: 0, // 提示框显示隐藏延时时间 html: false, // 设置&apos;tooltip-inner&apos;内内容html片段还是text纯文本 container: false, // 提示框容器 viewport: &#123; selector: &apos;body&apos;, padding: 0 &#125; &#125; // 提示框初始化 Tooltip.prototype.init = function (type, element, options) &#123; this.enabled = true this.type = type this.$element = $(element) // 获取自定义选项 this.options = this.getOptions(options) // 获取视口，保证提示框在元素的边缘内 this.$viewport = this.options.viewport &amp;&amp; $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport)) // 显示条件存储对象 this.inState = &#123; click: false, hover: false, focus: false &#125; // 不能直接为document添加提示框，需要添加CSS选择符来选中document的子元素 if (this.$element[0] instanceof document.constructor &amp;&amp; !this.options.selector) &#123; throw new Error(&apos;`selector` option must be specified when initializing &apos; + this.type + &apos; on the window.document object!&apos;) &#125; // 处理不同触发情况 var triggers = this.options.trigger.split(&apos; &apos;) for (var i = triggers.length; i--;) &#123; var trigger = triggers[i] if (trigger == &apos;click&apos;) &#123; // 点击触发调用toggle方法 this.$element.on(&apos;click.&apos; + this.type, this.options.selector, $.proxy(this.toggle, this)) &#125; else if (trigger != &apos;manual&apos;) &#123; var eventIn = trigger == &apos;hover&apos; ? &apos;mouseenter&apos; : &apos;focusin&apos; var eventOut = trigger == &apos;hover&apos; ? &apos;mouseleave&apos; : &apos;focusout&apos; // hover或者focus触发调用enter/leave方法 this.$element.on(eventIn + &apos;.&apos; + this.type, this.options.selector, $.proxy(this.enter, this)) this.$element.on(eventOut + &apos;.&apos; + this.type, this.options.selector, $.proxy(this.leave, this)) &#125; &#125; this.options.selector ? (this._options = $.extend(&#123;&#125;, this.options, &#123; trigger: &apos;manual&apos;, selector: &apos;&apos; &#125;)) : this.fixTitle() &#125; // 返回默认自定义选项 Tooltip.prototype.getDefaults = function () &#123; return Tooltip.DEFAULTS &#125; // 获取自定义选项 Tooltip.prototype.getOptions = function (options) &#123; options = $.extend(&#123;&#125;, this.getDefaults(), this.$element.data(), options) if (options.delay &amp;&amp; typeof options.delay == &apos;number&apos;) &#123; options.delay = &#123; show: options.delay, hide: options.delay &#125; &#125; return options &#125; // 获取委托的自定义选项 Tooltip.prototype.getDelegateOptions = function () &#123; var options = &#123;&#125; var defaults = this.getDefaults() this._options &amp;&amp; $.each(this._options, function (key, value) &#123; if (defaults[key] != value) options[key] = value &#125;) return options &#125; // 提示框显示 Tooltip.prototype.enter = function (obj) &#123; // 要不通过toggle方法来触发的enter，要不通过hover/focus触发的，所以obj要不为event对象，要不为tooltip实例对象 var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data(&apos;bs.&apos; + this.type) // 如果不存在self，说明是hover/focus触发，而且是委托 if (!self) &#123; self = new this.constructor(obj.currentTarget, this.getDelegateOptions()) $(obj.currentTarget).data(&apos;bs.&apos; + this.type, self) &#125; // 如果是obj是event对象，那么切换focus/hover状态 if (obj instanceof $.Event) &#123; self.inState[obj.type == &apos;focusin&apos; ? &apos;focus&apos; : &apos;hover&apos;] = true &#125; // 如果提示框模板元素已经显示，那么不做任何操作直接返回 if (self.tip().hasClass(&apos;in&apos;) || self.hoverState == &apos;in&apos;) &#123; self.hoverState = &apos;in&apos; return &#125; clearTimeout(self.timeout) self.hoverState = &apos;in&apos; if (!self.options.delay || !self.options.delay.show) return self.show() // 根据定时器时间来执行提示框显示操作 self.timeout = setTimeout(function () &#123; // 如果定时器执行时，状态已经被切换了，那么需要重新根据状态判断是否继续进行操作 if (self.hoverState == &apos;in&apos;) self.show() &#125;, self.options.delay.show) &#125; // 判断是否存在显示条件 Tooltip.prototype.isInStateTrue = function () &#123; for (var key in this.inState) &#123; if (this.inState[key]) return true &#125; return false &#125; // 提示框隐藏 Tooltip.prototype.leave = function (obj) &#123; // 要不通过toggle方法来触发的leave，要不通过hover/focus触发的，所以obj要不为event对象，要不为tooltip实例对象 var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data(&apos;bs.&apos; + this.type) // 如果不存在self，说明是hover/focus触发，而且是委托 if (!self) &#123; self = new this.constructor(obj.currentTarget, this.getDelegateOptions()) $(obj.currentTarget).data(&apos;bs.&apos; + this.type, self) &#125; // 如果是obj是event对象，那么切换focus/hover状态 if (obj instanceof $.Event) &#123; self.inState[obj.type == &apos;focusout&apos; ? &apos;focus&apos; : &apos;hover&apos;] = false &#125; // 如果存在还显示的状态，那么直接返回 if (self.isInStateTrue()) return clearTimeout(self.timeout) self.hoverState = &apos;out&apos; if (!self.options.delay || !self.options.delay.hide) return self.hide() self.timeout = setTimeout(function () &#123; // 如果定时器执行时，状态已经被切换了，那么需要重新根据状态判断是否继续进行操作 if (self.hoverState == &apos;out&apos;) self.hide() &#125;, self.options.delay.hide) &#125; // 显示提示框具体操作 Tooltip.prototype.show = function () &#123; // 自定义事件 var e = $.Event(&apos;show.bs.&apos; + this.type) // 如果存在显示标题内容而且显示控制标志量enabled为true if (this.hasContent() &amp;&amp; this.enabled) &#123; this.$element.trigger(e) // 判断对象对应的dom是否在文档内 var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]) if (e.isDefaultPrevented() || !inDom) return var that = this var $tip = this.tip() // 获取提示框DOM元素 var tipId = this.getUID(this.type) // 获取不存在于document中的ID this.setContent() // 设置标题模板内容 $tip.attr(&apos;id&apos;, tipId) // 设置模板id this.$element.attr(&apos;aria-describedby&apos;, tipId) // 设置触发元素aria-describedby属性 if (this.options.animation) $tip.addClass(&apos;fade&apos;) // 如果使用动画，添加fade类 // 获取提示框位置信息 var placement = typeof this.options.placement == &apos;function&apos; ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement // 如果使用auto，尽量会被替换掉，默认替换为top；如果同时存在其他方向，默认使用其他方向 var autoToken = /\\s?auto?\\s?/i var autoPlace = autoToken.test(placement) if (autoPlace) placement = placement.replace(autoToken, &apos;&apos;) || &apos;top&apos; // 设置提示框样式 $tip .detach() // detach() 删除匹配的对象；与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来 .css(&#123; top: 0, left: 0, display: &apos;block&apos; &#125;) .addClass(placement) .data(&apos;bs.&apos; + this.type, this) // 将提示框添加到文档中 this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element) // 触发自定义事件&apos;inserted.bs.tooltip&apos; this.$element.trigger(&apos;inserted.bs.&apos; + this.type) // 位置对象pos = &#123;top: , right: , bottom: , left: , width: ,scroll:&#125; var pos = this.getPosition() // 提示框自身实际的 width height var actualWidth = $tip[0].offsetWidth var actualHeight = $tip[0].offsetHeight // 如果出现了auto，那么根据viewport动态调整placement if (autoPlace) &#123; var orgPlacement = placement var viewportDim = this.getPosition(this.$viewport) placement = placement == &apos;bottom&apos; &amp;&amp; pos.bottom + actualHeight &gt; viewportDim.bottom ? &apos;top&apos; : placement == &apos;top&apos; &amp;&amp; pos.top - actualHeight &lt; viewportDim.top ? &apos;bottom&apos; : placement == &apos;right&apos; &amp;&amp; pos.right + actualWidth &gt; viewportDim.width ? &apos;left&apos; : placement == &apos;left&apos; &amp;&amp; pos.left - actualWidth &lt; viewportDim.left ? &apos;right&apos; : placement $tip .removeClass(orgPlacement) .addClass(placement) &#125; // 计算提示框的偏移量 &#123;top: , left: &#125; var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight) // 应用并设置偏移量 this.applyPlacement(calculatedOffset, placement) var complete = function () &#123; var prevHoverState = that.hoverState that.$element.trigger(&apos;shown.bs.&apos; + that.type) that.hoverState = null // 其实这里不太需要，因为就算连续点击两次，后面hide方法会将hoverState设置为null；就算改成prevHoverState==null也只是连续执行两次leave if (prevHoverState == &apos;out&apos;) that.leave(that) &#125; $.support.transition &amp;&amp; this.$tip.hasClass(&apos;fade&apos;) ? $tip .one(&apos;bsTransitionEnd&apos;, complete) .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete() &#125; &#125; // 应用并设置偏移量 Tooltip.prototype.applyPlacement = function (offset, placement) &#123; var $tip = this.tip() var width = $tip[0].offsetWidth var height = $tip[0].offsetHeight // manually read margins because getBoundingClientRect includes difference // 获得提示框自身的外边距的值 var marginTop = parseInt($tip.css(&apos;margin-top&apos;), 10) var marginLeft = parseInt($tip.css(&apos;margin-left&apos;), 10) // we must check for NaN for ie 8/9(是否是非数字) if (isNaN(marginTop)) marginTop = 0 if (isNaN(marginLeft)) marginLeft = 0 // 计算的偏移量 + 自身的外边距 offset.top += marginTop offset.left += marginLeft // $.fn.offset doesn&apos;t round pixel values // so we use setOffset directly with our own function B-0 // 应用了offset.setOffset方法，传入了using参数，因为offset设置值的时候，不能四舍五入 $.offset.setOffset($tip[0], $.extend(&#123; using: function (props) &#123; $tip.css(&#123; top: Math.round(props.top), left: Math.round(props.left) &#125;) &#125; &#125;, offset), 0) // 添加 in class 让提示框显示 $tip.addClass(&apos;in&apos;) // check to see if placing tip in new offset caused the tip to resize itself // 获取显示后的提示框的宽和高，检查是否调整了自身的大小 var actualWidth = $tip[0].offsetWidth var actualHeight = $tip[0].offsetHeight if (placement == &apos;top&apos; &amp;&amp; actualHeight != height) &#123; offset.top = offset.top + height - actualHeight &#125; // 根据viewport调整位置 var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight) if (delta.left) offset.left += delta.left else offset.top += delta.top var isVertical = /top|bottom/.test(placement) var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight var arrowOffsetPosition = isVertical ? &apos;offsetWidth&apos; : &apos;offsetHeight&apos; $tip.offset(offset) this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical) &#125; // 更新箭头位置 Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) &#123; this.arrow() .css(isVertical ? &apos;left&apos; : &apos;top&apos;, 50 * (1 - delta / dimension) + &apos;%&apos;) .css(isVertical ? &apos;top&apos; : &apos;left&apos;, &apos;&apos;) &#125; // 设置内容，并移除上面的 Tooltip.prototype.setContent = function () &#123; var $tip = this.tip() var title = this.getTitle() $tip.find(&apos;.tooltip-inner&apos;)[this.options.html ? &apos;html&apos; : &apos;text&apos;](title) $tip.removeClass(&apos;fade in top bottom left right&apos;) &#125; // 隐藏提示框具体操作 Tooltip.prototype.hide = function (callback) &#123; var that = this var $tip = $(this.$tip) var e = $.Event(&apos;hide.bs.&apos; + this.type) function complete() &#123; // 如果在提示框显示时，连续两次点击(假设元素触发方法为click，而且点击快速在动画时间内)，那么不销毁提示框模板元素，如果销毁会有问题 if (that.hoverState != &apos;in&apos;) $tip.detach() if (that.$element) &#123; // TODO: Check whether guarding this code with this `if` is really necessary. that.$element .removeAttr(&apos;aria-describedby&apos;) .trigger(&apos;hidden.bs.&apos; + that.type) &#125; callback &amp;&amp; callback() &#125; this.$element.trigger(e) if (e.isDefaultPrevented()) return $tip.removeClass(&apos;in&apos;) $.support.transition &amp;&amp; $tip.hasClass(&apos;fade&apos;) ? $tip .one(&apos;bsTransitionEnd&apos;, complete) .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete() this.hoverState = null return this &#125; // 默认使用title属性作为提示框内容 Tooltip.prototype.fixTitle = function () &#123; var $e = this.$element if ($e.attr(&apos;title&apos;) || typeof $e.attr(&apos;data-original-title&apos;) != &apos;string&apos;) &#123; $e.attr(&apos;data-original-title&apos;, $e.attr(&apos;title&apos;) || &apos;&apos;).attr(&apos;title&apos;, &apos;&apos;) &#125; &#125; // 是否有显示内容 Tooltip.prototype.hasContent = function () &#123; return this.getTitle() &#125; // 获取位置 Tooltip.prototype.getPosition = function ($element) &#123; // 不传入则为当前点击元素 $element = $element || this.$element // 转换为DOM对象 var el = $element[0] // 是否是body元素 var isBody = el.tagName == &apos;BODY&apos; // 获取元素各边与页面上边和左边的距离 left right top bottom height width var elRect = el.getBoundingClientRect() //兼容IE8 没有 width height 则计算 if (elRect.width == null) &#123; // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093 elRect = $.extend(&#123;&#125;, elRect, &#123; width: elRect.right - elRect.left, height: elRect.bottom - elRect.top &#125;) &#125; var isSvg = window.SVGElement &amp;&amp; el instanceof window.SVGElement // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3. // See https://github.com/twbs/bootstrap/issues/20280 // 当前元素相对于文档的偏移量(因为SVG上得不到正确的offset结果，所以返回null) var elOffset = isBody ? &#123; top: 0, left: 0 &#125; : (isSvg ? null : $element.offset()) // 垂直滚动条的距离(document.documentElement.scrollTop和document.body.scrollTop 浏览器兼容) var scroll = &#123; scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() &#125; var outerDims = isBody ? &#123; width: $(window).width(), height: $(window).height() &#125; : null // 合并 return $.extend(&#123;&#125;, elRect, scroll, outerDims, elOffset) &#125; // 计算偏移量 Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) &#123; return placement == &apos;bottom&apos; ? &#123; top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 &#125; : placement == &apos;top&apos; ? &#123; top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 &#125; : placement == &apos;left&apos; ? &#123; top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth &#125; : /* placement == &apos;right&apos; */ &#123; top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width &#125; &#125; // 根据视口调节 Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) &#123; var delta = &#123; top: 0, left: 0 &#125; //默认的话，this.$viewport = &apos;body&apos; if (!this.$viewport) return delta var viewportPadding = this.options.viewport &amp;&amp; this.options.viewport.padding || 0 //this.$viewport = &apos;body&apos; width height为window的 var viewportDimensions = this.getPosition(this.$viewport) if (/right|left/.test(placement)) &#123; var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight if (topEdgeOffset &lt; viewportDimensions.top) &#123; // top overflow delta.top = viewportDimensions.top - topEdgeOffset &#125; else if (bottomEdgeOffset &gt; viewportDimensions.top + viewportDimensions.height) &#123; // bottom overflow delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset &#125; &#125; else &#123; var leftEdgeOffset = pos.left - viewportPadding var rightEdgeOffset = pos.left + viewportPadding + actualWidth if (leftEdgeOffset &lt; viewportDimensions.left) &#123; // left overflow delta.left = viewportDimensions.left - leftEdgeOffset &#125; else if (rightEdgeOffset &gt; viewportDimensions.right) &#123; // right overflow delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset &#125; &#125; return delta &#125; // 获取标题内容 Tooltip.prototype.getTitle = function () &#123; var title var $e = this.$element var o = this.options title = $e.attr(&apos;data-original-title&apos;) || (typeof o.title == &apos;function&apos; ? o.title.call($e[0]) : o.title) return title &#125; // 获取&apos;tooltipxxx&apos;格式的id(用do..while得到不存在于document中的ID) Tooltip.prototype.getUID = function (prefix) &#123; do prefix += ~~(Math.random() * 1000000) while (document.getElementById(prefix)) return prefix &#125; // 获取提示模板元素 Tooltip.prototype.tip = function () &#123; if (!this.$tip) &#123; this.$tip = $(this.options.template) if (this.$tip.length != 1) &#123; throw new Error(this.type + &apos; `template` option must consist of exactly 1 top-level element!&apos;) &#125; &#125; return this.$tip &#125; // 获取提示箭头(tooltip-arrow类) Tooltip.prototype.arrow = function () &#123; return (this.$arrow = this.$arrow || this.tip().find(&apos;.tooltip-arrow&apos;)) &#125; // 设置enabled为true，使得提示框能够正常显示 Tooltip.prototype.enable = function () &#123; this.enabled = true &#125; // 与enable相反 Tooltip.prototype.disable = function () &#123; this.enabled = false &#125; // 切换enabled Tooltip.prototype.toggleEnabled = function () &#123; this.enabled = !this.enabled &#125; // 切换提示框显示状态 Tooltip.prototype.toggle = function (e) &#123; var self = this if (e) &#123; // 如果是事件委托的话，那么提示框元素并不会存储bs.tooltip属性对象，而是存储到委托元素上去了，所以重新为提示框元素初始化 self = $(e.currentTarget).data(&apos;bs.&apos; + this.type) if (!self) &#123; // getDelegateOptions: 重置CSS选择器，并将触发器设置为manual，并不设置监听，而是继续使用委托 self = new this.constructor(e.currentTarget, this.getDelegateOptions()) $(e.currentTarget).data(&apos;bs.&apos; + this.type, self) &#125; &#125; if (e) &#123; // 切换点击状态，判断是否存在显示条件，并执行相应操作 self.inState.click = !self.inState.click if (self.isInStateTrue()) self.enter(self) else self.leave(self) &#125; else &#123; // 如果不存在参数e(JS调用toggle触发)，那么动态判断当前点击提示框是否显示，并执行相应操作 self.tip().hasClass(&apos;in&apos;) ? self.leave(self) : self.enter(self) &#125; &#125; // 销毁tooltip实例 Tooltip.prototype.destroy = function () &#123; var that = this clearTimeout(this.timeout) this.hide(function () &#123; that.$element.off(&apos;.&apos; + that.type).removeData(&apos;bs.&apos; + that.type) if (that.$tip) &#123; that.$tip.detach() &#125; that.$tip = null that.$arrow = null that.$viewport = null that.$element = null &#125;) &#125; // TOOLTIP PLUGIN DEFINITION // ========================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.tooltip&apos;) var options = typeof option == &apos;object&apos; &amp;&amp; option // 如果没有tooltip初始化，那么直接指向destroy|hide方法不进行任何操作 if (!data &amp;&amp; /destroy|hide/.test(option)) return if (!data) $this.data(&apos;bs.tooltip&apos;, (data = new Tooltip(this, options))) if (typeof option == &apos;string&apos;) data[option]() &#125;) &#125; var old = $.fn.tooltip $.fn.tooltip = Plugin $.fn.tooltip.Constructor = Tooltip // TOOLTIP NO CONFLICT // =================== $.fn.tooltip.noConflict = function () &#123; $.fn.tooltip = old return this &#125;&#125;(jQuery); 二、应用 &amp; 源码分析1、应用123456这是一个 &lt;a href=&quot;#&quot; class=&quot;tooltip-test&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;left&quot; title=&quot;左侧的 Tooltip&quot;&gt;左侧的 Tooltip&lt;/a&gt;.&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;left&quot; title=&quot;左侧的 Tooltip&quot;&gt;左侧的 Tooltip&lt;/button&gt;// 不能直接通过自定义属性data-来触发，需依赖于JavaScript&lt;script&gt; $(function () &#123; $(&quot;[data-toggle=&apos;tooltip&apos;]&quot;).tooltip(); &#125;);&lt;/script&gt; 2、源码分析2.1、tooltip.less1、容器为绝对布局，默认 opacity 为 0 ，即隐藏2、提示框模板内容也很简单，只含有箭头和内容文本，箭头根据提示框出现方向进行调整显示 2.2、tooltip.js1、有多种触发方式，设置 inState = { click: false, hover: false, focus: false } 对象，切换对象中属性，只要对象中有一个属性为true那么显示提示框2、含 selector 选择器，如果存在selector，那么使用事件委托进行处理3、显示时，动态生成提示框内容并插入到文档中，然后再经过一系列的计算得到并设置提示框的 top、 left(个人觉得插入到触发元素中更简单快捷，但是语义化不符合要求)4、通过 while (document.getElementById(prefix)) 可以得到一个文档中没有的ID5、需要注意如果连续触发而且存在动画的情况，需要判断处理显示隐藏问题，源码中通过hoverState做限制","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 dropdown","slug":"bootstrap/dropdown","date":"2017-10-29T15:48:57.000Z","updated":"2018-04-15T13:34:55.000Z","comments":true,"path":"bootstrap/dropdown/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/dropdown/","excerpt":"这节介绍下 dropdown(下拉菜单)模块的源码实现。","text":"这节介绍下 dropdown(下拉菜单)模块的源码实现。 一、源码1、dropdowns.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214//// Dropdown menus(下拉菜单)// --------------------------------------------------// Dropdown arrow/caret(下拉菜单箭头).caret &#123; display: inline-block; width: 0; height: 0; margin-left: 2px; vertical-align: middle; border-top: @caret-width-base dashed; border-top: @caret-width-base solid ~&quot;\\9&quot;; // IE8 border-right: @caret-width-base solid transparent; border-left: @caret-width-base solid transparent;&#125;// The dropdown wrapper (div: 下拉菜单容器).dropup,.dropdown &#123; position: relative;&#125;// Prevent the focus on the dropdown toggle when closing dropdowns.dropdown-toggle:focus &#123; outline: 0;&#125;// The dropdown menu (ul: 下拉菜单).dropdown-menu &#123; position: absolute; top: 100%; left: 0; z-index: @zindex-dropdown; display: none; // none by default, but block on &quot;open&quot; of the menu float: left; min-width: 160px; padding: 5px 0; margin: 2px 0 0; // override default ul list-style: none; font-size: @font-size-base; text-align: left; // Ensures proper alignment if parent has it changed (e.g., modal footer) background-color: @dropdown-bg; border: 1px solid @dropdown-fallback-border; // IE8 fallback border: 1px solid @dropdown-border; border-radius: @border-radius-base; .box-shadow(0 6px 12px rgba(0,0,0,.175)); background-clip: padding-box; // Aligns the dropdown menu to right(下拉菜单右对齐) // // Deprecated as of 3.1.0 in favor of `.dropdown-menu-[dir]` &amp;.pull-right &#123; right: 0; left: auto; &#125; // Dividers (basically an hr) within the dropdown(下拉分割线) .divider &#123; .nav-divider(@dropdown-divider-bg); &#125; // Links within the dropdown menu(下拉菜单链接) &gt; li &gt; a &#123; display: block; padding: 3px 20px; clear: both; font-weight: normal; line-height: @line-height-base; color: @dropdown-link-color; white-space: nowrap; // prevent links from randomly breaking onto new lines &#125;&#125;// Hover/Focus state(菜单项状态: 悬浮状态、焦点状态).dropdown-menu &gt; li &gt; a &#123; &amp;:hover, &amp;:focus &#123; text-decoration: none; color: @dropdown-link-hover-color; background-color: @dropdown-link-hover-bg; &#125;&#125;// Active state(当前状态).dropdown-menu &gt; .active &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @dropdown-link-active-color; text-decoration: none; outline: 0; background-color: @dropdown-link-active-bg; &#125;&#125;// Disabled state(禁用状态)//// Gray out text and ensure the hover/focus state remains gray.dropdown-menu &gt; .disabled &gt; a &#123; &amp;, &amp;:hover, &amp;:focus &#123; color: @dropdown-link-disabled-color; &#125; // Nuke hover/focus effects &amp;:hover, &amp;:focus &#123; text-decoration: none; background-color: transparent; background-image: none; // Remove CSS gradient .reset-filter(); cursor: @cursor-disabled; &#125;&#125;// Open state for the dropdown(展开下拉菜单).open &#123; // Show the menu &gt; .dropdown-menu &#123; display: block; &#125; // Remove the outline when :focus is triggered &gt; a &#123; outline: 0; &#125;&#125;// Menu positioning(下拉菜单对齐方式)//// Add extra class to `.dropdown-menu` to flip the alignment of the dropdown// menu with the parent.(右对齐).dropdown-menu-right &#123; left: auto; // Reset the default from `.dropdown-menu` right: 0;&#125;// With v3, we enabled auto-flipping if you have a dropdown within a right// aligned nav component. To enable the undoing of that, we provide an override// to restore the default dropdown menu alignment.//// This is only for left-aligning a dropdown menu within a `.navbar-right` or// `.pull-right` nav component.(左对齐).dropdown-menu-left &#123; left: 0; right: auto;&#125;// Dropdown section headers(下拉菜单标题).dropdown-header &#123; display: block; padding: 3px 20px; font-size: @font-size-small; line-height: @line-height-base; color: @dropdown-header-color; white-space: nowrap; // as with &gt; li &gt; a&#125;// Backdrop to catch body clicks on mobile, etc.(背景遮罩层).dropdown-backdrop &#123; position: fixed; left: 0; right: 0; bottom: 0; top: 0; z-index: (@zindex-dropdown - 10);&#125;// Right aligned dropdowns(右对齐下拉菜单).pull-right &gt; .dropdown-menu &#123; right: 0; left: auto;&#125;// Allow for dropdowns to go bottom up (aka, dropup-menu)//// Just add .dropup after the standard .dropdown class and you&apos;re set, bro.// TODO: abstract this so that the navbar fixed styles are not placed here?.dropup,.navbar-fixed-bottom .dropdown &#123; // Reverse the caret .caret &#123; border-top: 0; border-bottom: @caret-width-base dashed; border-bottom: @caret-width-base solid ~&quot;\\9&quot;; // IE8 content: &quot;&quot;; &#125; // Different positioning for bottom up menu .dropdown-menu &#123; top: auto; bottom: 100%; margin-bottom: 2px; &#125;&#125;// Component alignment//// Reiterate per navbar.less and the modified component alignment there.@media (min-width: @grid-float-breakpoint) &#123; .navbar-right &#123; .dropdown-menu &#123; .dropdown-menu-right(); &#125; // Necessary for overrides of the default right aligned menu. // Will remove come v4 in all likelihood. .dropdown-menu-left &#123; .dropdown-menu-left(); &#125; &#125;&#125; 2、dropdown.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* ======================================================================== * Bootstrap: dropdown.js v3.3.7(下拉菜单) * http://getbootstrap.com/javascript/#dropdowns * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // DROPDOWN CLASS DEFINITION // ========================= var backdrop = &apos;.dropdown-backdrop&apos; var toggle = &apos;[data-toggle=&quot;dropdown&quot;]&apos; var Dropdown = function (element) &#123; $(element).on(&apos;click.bs.dropdown&apos;, this.toggle) &#125; Dropdown.VERSION = &apos;3.3.7&apos; // 获取触发按钮或链接的目标元素 function getParent($this) &#123; var selector = $this.attr(&apos;data-target&apos;) // 如果不存在data-target，那么获取href属性并将格式处理为CSS选择器 if (!selector) &#123; selector = $this.attr(&apos;href&apos;) selector = selector &amp;&amp; /#[A-Za-z]/.test(selector) &amp;&amp; selector.replace(/.*(?=#[^\\s]*$)/, &apos;&apos;) // strip for ie7 &#125; // 如果存在目标元素，那么直接选中 var $parent = selector &amp;&amp; $(selector) // 否则默认使用触发元素的父元素 return $parent &amp;&amp; $parent.length ? $parent : $this.parent() &#125; // 隐藏下拉菜单 function clearMenus(e) &#123; // 如果鼠标右键点击不做任何处理 if (e &amp;&amp; e.which === 3) return // 移除背景 $(backdrop).remove() $(toggle).each(function () &#123; var $this = $(this) var $parent = getParent($this) var relatedTarget = &#123; relatedTarget: this &#125; // 如果不是下拉菜单已经展开菜单了，那么不做任何处理 if (!$parent.hasClass(&apos;open&apos;)) return // 如果事件发生在目标元素中的input/textarea元素中，那么不做任何处理 if (e &amp;&amp; e.type == &apos;click&apos; &amp;&amp; /input|textarea/i.test(e.target.tagName) &amp;&amp; $.contains($parent[0], e.target)) return // 触发开始隐藏菜单事件 $parent.trigger(e = $.Event(&apos;hide.bs.dropdown&apos;, relatedTarget)) if (e.isDefaultPrevented()) return $this.attr(&apos;aria-expanded&apos;, &apos;false&apos;) // 触发已经隐藏菜单事件 $parent.removeClass(&apos;open&apos;).trigger($.Event(&apos;hidden.bs.dropdown&apos;, relatedTarget)) &#125;) &#125; // 切换下拉菜单显示状态 Dropdown.prototype.toggle = function (e) &#123; var $this = $(this) if ($this.is(&apos;.disabled, :disabled&apos;)) return var $parent = getParent($this) var isActive = $parent.hasClass(&apos;open&apos;) clearMenus() // 显示下拉菜单 if (!isActive) &#123; // 如果是在移动设备上，那么点击后添加遮罩层 if (&apos;ontouchstart&apos; in document.documentElement &amp;&amp; !$parent.closest(&apos;.navbar-nav&apos;).length) &#123; // if mobile we use a backdrop because click events don&apos;t delegate $(document.createElement(&apos;div&apos;)) .addClass(&apos;dropdown-backdrop&apos;) .insertAfter($(this)) .on(&apos;click&apos;, clearMenus) &#125; var relatedTarget = &#123; relatedTarget: this &#125; $parent.trigger(e = $.Event(&apos;show.bs.dropdown&apos;, relatedTarget)) if (e.isDefaultPrevented()) return $this .trigger(&apos;focus&apos;) .attr(&apos;aria-expanded&apos;, &apos;true&apos;) $parent .toggleClass(&apos;open&apos;) .trigger($.Event(&apos;shown.bs.dropdown&apos;, relatedTarget)) &#125; // 返回false，阻止冒泡和默认事件发生；如果是用JS直接触发，而且JS绑定的元素是document的子元素就可以避免绑定触发多次的问题，因为这里返回了false return false &#125; // 键盘事件处理函数 Dropdown.prototype.keydown = function (e) &#123; // 38:Up Arrow; 40:Down Arrow; 27:Esc; 32:Spacebar if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return var $this = $(this) e.preventDefault() e.stopPropagation() if ($this.is(&apos;.disabled, :disabled&apos;)) return var $parent = getParent($this) var isActive = $parent.hasClass(&apos;open&apos;) if (!isActive &amp;&amp; e.which != 27 || isActive &amp;&amp; e.which == 27) &#123; // 如果菜单处于展开状态而且点击esc键盘按钮，那么让触发元素获取焦点 if (e.which == 27) $parent.find(toggle).trigger(&apos;focus&apos;) // 触发元素上触发点击事件 return $this.trigger(&apos;click&apos;) &#125; var desc = &apos; li:not(.disabled):visible a&apos; var $items = $parent.find(&apos;.dropdown-menu&apos; + desc) // 如果$items.length == false，说明拓展菜单隐藏，不执行下面操作；否则执行下拉菜单选择，选中菜单触发focus事件 if (!$items.length) return var index = $items.index(e.target) if (e.which == 38 &amp;&amp; index &gt; 0) index-- // up if (e.which == 40 &amp;&amp; index &lt; $items.length - 1) index++ // down if (!~index) index = 0 $items.eq(index).trigger(&apos;focus&apos;) &#125; // DROPDOWN PLUGIN DEFINITION // ========================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this) var data = $this.data(&apos;bs.dropdown&apos;) if (!data) $this.data(&apos;bs.dropdown&apos;, (data = new Dropdown(this))) if (typeof option == &apos;string&apos;) data[option].call($this) &#125;) &#125; var old = $.fn.dropdown $.fn.dropdown = Plugin $.fn.dropdown.Constructor = Dropdown // DROPDOWN NO CONFLICT // ==================== $.fn.dropdown.noConflict = function () &#123; $.fn.dropdown = old return this &#125; // APPLY TO STANDARD DROPDOWN ELEMENTS // =================================== $(document) // 如果点击发生在document上，那么隐藏拓展开的菜单 .on(&apos;click.bs.dropdown.data-api&apos;, clearMenus) // 如果点击事件发生在下拉菜单元素上，那么阻止冒泡到document上 .on(&apos;click.bs.dropdown.data-api&apos;, &apos;.dropdown form&apos;, function (e) &#123; e.stopPropagation() &#125;) // 如果点击在触发元素上，触发Dropdown.prototype.toggle事件 .on(&apos;click.bs.dropdown.data-api&apos;, toggle, Dropdown.prototype.toggle) // 在触发元素上设置键盘监听函数 .on(&apos;keydown.bs.dropdown.data-api&apos;, toggle, Dropdown.prototype.keydown) // 如果是展开状态(只有展开状态才有.dropdown-menu)，那么则在展开菜单上也设置监听函数 .on(&apos;keydown.bs.dropdown.data-api&apos;, &apos;.dropdown-menu&apos;, Dropdown.prototype.keydown)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用1234567891011121314151617181920212223242526272829&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Java &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu pull-right&quot;&gt; &lt;li role=&quot;presentation&quot; class=&quot;dropdown-header&quot;&gt;下拉菜单标题&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;EJB&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Jasper Report&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;另一个分离的链接&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 2、源码分析2.1、dropdowns.less1、可通过向 .dropdown-menu 添加 class .pull-right 或 .dropdown-menu-right 来向右对齐下拉菜单，默认左对齐2、可使用 class dropdown-header 向下拉菜单的标签区域添加标题3、可使用 class disabled 向下拉菜单的标签区域设置禁用项4、可使用 class divider 向下拉菜单的标签区域设置分割线 2.2、dropdown.js1、如果点击事件发生在 document ，那么执行 clearMenus 隐藏下拉框2、监听属性 data-toggle=”dropdown” 的点击事件，触发下拉菜单显示隐藏切换，并返回false，阻止事件冒泡到 document 上3、在 data-toggle=”dropdown” 和 class dropdown-menu 元素上监听键盘事件，执行相应操作","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 alert","slug":"bootstrap/alert","date":"2017-10-29T14:52:15.000Z","updated":"2018-04-15T09:54:08.000Z","comments":true,"path":"bootstrap/alert/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/alert/","excerpt":"这节介绍下 alert(警示框)的源码实现。","text":"这节介绍下 alert(警示框)的源码实现。 一、源码1、alerts.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// Alerts(警示框)// --------------------------------------------------// Base styles// -------------------------.alert &#123; padding: @alert-padding; margin-bottom: @line-height-computed; border: 1px solid transparent; border-radius: @alert-border-radius; // Headings for larger alerts h4 &#123; margin-top: 0; // Specified for the h4 to prevent conflicts of changing @headings-color color: inherit; &#125; // Provide class for links that match alerts(警示框的链接) .alert-link &#123; font-weight: @alert-link-font-weight; &#125; // Improve alignment and spacing of inner content &gt; p, &gt; ul &#123; margin-bottom: 0; &#125; &gt; p + p &#123; margin-top: 5px; &#125;&#125;// Dismissible alerts(可关闭的警示框)//// Expand the right padding and account for the close button&apos;s positioning..alert-dismissable, // The misspelled .alert-dismissable was deprecated in 3.2.0..alert-dismissible &#123; padding-right: (@alert-padding + 20); // Adjust close link position .close &#123; position: relative; top: -2px; right: -21px; color: inherit; &#125;&#125;// Alternate styles(警示框风格)//// Generate contextual modifier classes for colorizing the alert..alert-success &#123; .alert-variant(@alert-success-bg; @alert-success-border; @alert-success-text);&#125;.alert-info &#123; .alert-variant(@alert-info-bg; @alert-info-border; @alert-info-text);&#125;.alert-warning &#123; .alert-variant(@alert-warning-bg; @alert-warning-border; @alert-warning-text);&#125;.alert-danger &#123; .alert-variant(@alert-danger-bg; @alert-danger-border; @alert-danger-text);&#125; 2、alert.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* ======================================================================== * Bootstrap: alert.js v3.3.7(警告框) * http://getbootstrap.com/javascript/#alerts * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // ALERT CLASS DEFINITION // ====================== var dismiss = &apos;[data-dismiss=&quot;alert&quot;]&apos;; var Alert = function (el) &#123; $(el).on(&apos;click&apos;, dismiss, this.close) &#125;; Alert.VERSION = &apos;3.3.7&apos;; Alert.TRANSITION_DURATION = 150; Alert.prototype.close = function (e) &#123; var $this = $(this); var selector = $this.attr(&apos;data-target&apos;); if (!selector) &#123; selector = $this.attr(&apos;href&apos;); selector = selector &amp;&amp; selector.replace(/.*(?=#[^\\s]*$)/, &apos;&apos;) // strip for ie7 &#125; var $parent = $(selector === &apos;#&apos; ? [] : selector); if (e) e.preventDefault(); if (!$parent.length) &#123; $parent = $this.closest(&apos;.alert&apos;) &#125; $parent.trigger(e = $.Event(&apos;close.bs.alert&apos;)); if (e.isDefaultPrevented()) return; $parent.removeClass(&apos;in&apos;); function removeElement() &#123; // detach from parent, fire event then clean up data $parent.detach().trigger(&apos;closed.bs.alert&apos;).remove() &#125; $.support.transition &amp;&amp; $parent.hasClass(&apos;fade&apos;) ? $parent .one(&apos;bsTransitionEnd&apos;, removeElement) .emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement() &#125;; // ALERT PLUGIN DEFINITION // ======================= function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this); var data = $this.data(&apos;bs.alert&apos;); if (!data) $this.data(&apos;bs.alert&apos;, (data = new Alert(this))); if (typeof option == &apos;string&apos;) data[option].call($this); &#125;) &#125; var old = $.fn.alert; $.fn.alert = Plugin; $.fn.alert.Constructor = Alert; // ALERT NO CONFLICT // ================= $.fn.alert.noConflict = function () &#123; $.fn.alert = old; return this &#125;; // ALERT DATA-API // ============== $(document).on(&apos;click.bs.alert.data-api&apos;, dismiss, Alert.prototype.close);&#125;(jQuery); 二、应用 &amp; 源码分析1、应用12345678&lt;div class=&quot;alert alert-success&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/a&gt; &lt;strong&gt;成功！&lt;/strong&gt;结果是成功的。&lt;/div&gt;&lt;div class=&quot;alert alert-warning&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/a&gt; &lt;strong&gt;警告！&lt;/strong&gt;您的网络连接有问题。&lt;/div&gt; 2、源码分析2.1、alerts.less共有四种风格alert-success、alert-info、alert-warning、alert-danger 2.2、alert.js监听存在属性data-dismiss=&quot;alert&quot;的元素点击事件，触发close事件，并判断是否存在动画fade。","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 buttonJs","slug":"bootstrap/buttonJs","date":"2017-10-29T09:02:42.000Z","updated":"2018-04-15T13:02:16.000Z","comments":true,"path":"bootstrap/buttonJs/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/buttonJs/","excerpt":"上节介绍了 button 模块的样式，这节介绍 button.js。","text":"上节介绍了 button 模块的样式，这节介绍 button.js。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* ======================================================================== * Bootstrap: button.js v3.3.7(按钮) * http://getbootstrap.com/javascript/#buttons * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // BUTTON PUBLIC CLASS DEFINITION // ============================== var Button = function (element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Button.DEFAULTS, options); this.isLoading = false &#125;; Button.VERSION = &apos;3.3.7&apos;; Button.DEFAULTS = &#123; loadingText: &apos;loading...&apos; &#125;; // 处理按钮状态 Button.prototype.setState = function (state) &#123; var d = &apos;disabled&apos;; var $el = this.$element; var val = $el.is(&apos;input&apos;) ? &apos;val&apos; : &apos;html&apos;; var data = $el.data(); state += &apos;Text&apos;; // 存储按钮初始值，为了以后重置 if (data.resetText == null) $el.data(&apos;resetText&apos;, $el[val]()); // push to event loop to allow forms to submit setTimeout($.proxy(function () &#123; $el[val](data[state] == null ? this.options[state] : data[state]); if (state == &apos;loadingText&apos;) &#123; this.isLoading = true; $el.addClass(d).attr(d, d).prop(d, true) &#125; else if (this.isLoading) &#123; this.isLoading = false; $el.removeClass(d).removeAttr(d).prop(d, false) &#125; &#125;, this), 0) &#125;; // 处理单选、多选 Button.prototype.toggle = function () &#123; var changed = true; var $parent = this.$element.closest(&apos;[data-toggle=&quot;buttons&quot;]&apos;); if ($parent.length) &#123; var $input = this.$element.find(&apos;input&apos;); if ($input.prop(&apos;type&apos;) == &apos;radio&apos;) &#123; if ($input.prop(&apos;checked&apos;)) changed = false; $parent.find(&apos;.active&apos;).removeClass(&apos;active&apos;); this.$element.addClass(&apos;active&apos;) &#125; else if ($input.prop(&apos;type&apos;) == &apos;checkbox&apos;) &#123; // 处理checkbox默认被checked情况，这个时候再被选中只是改变下样式 if (($input.prop(&apos;checked&apos;)) !== this.$element.hasClass(&apos;active&apos;)) changed = false; this.$element.toggleClass(&apos;active&apos;) &#125; $input.prop(&apos;checked&apos;, this.$element.hasClass(&apos;active&apos;)); if (changed) $input.trigger(&apos;change&apos;) &#125; else &#123; this.$element.attr(&apos;aria-pressed&apos;, !this.$element.hasClass(&apos;active&apos;)); this.$element.toggleClass(&apos;active&apos;) &#125; &#125;; // BUTTON PLUGIN DEFINITION // ======================== function Plugin(option) &#123; return this.each(function () &#123; var $this = $(this); var data = $this.data(&apos;bs.button&apos;); var options = typeof option == &apos;object&apos; &amp;&amp; option; if (!data) $this.data(&apos;bs.button&apos;, (data = new Button(this, options))); if (option == &apos;toggle&apos;) data.toggle(); else if (option) data.setState(option) &#125;) &#125; var old = $.fn.button; $.fn.button = Plugin; $.fn.button.Constructor = Button; // BUTTON NO CONFLICT // ================== $.fn.button.noConflict = function () &#123; $.fn.button = old; return this &#125;; // BUTTON DATA-API // =============== $(document) .on(&apos;click.bs.button.data-api&apos;, &apos;[data-toggle^=&quot;button&quot;]&apos;, function (e) &#123; var $btn = $(e.target).closest(&apos;.btn&apos;); Plugin.call($btn, &apos;toggle&apos;); if (!($(e.target).is(&apos;input[type=&quot;radio&quot;], input[type=&quot;checkbox&quot;]&apos;))) &#123; // Prevent double click on radios, and the double selections (so cancellation) on checkboxes e.preventDefault(); // The target component still receive the focus if ($btn.is(&apos;input,button&apos;)) $btn.trigger(&apos;focus&apos;); else $btn.find(&apos;input:visible,button:visible&apos;).first().trigger(&apos;focus&apos;) &#125; &#125;) .on(&apos;focus.bs.button.data-api blur.bs.button.data-api&apos;, &apos;[data-toggle^=&quot;button&quot;]&apos;, function (e) &#123; $(e.target).closest(&apos;.btn&apos;).toggleClass(&apos;focus&apos;, /^focus(in)?$/.test(e.type)) &#125;)&#125;(jQuery); 二、应用 &amp; 源码分析1、应用123456789101112131415161718192021222324252627282930// 切换状态$(&quot;#loaddingBtn&quot;).click(function () &#123; $(this).button(&quot;loading&quot;);&#125;);// 复选框&lt;div class=&quot;btn-group&quot; data-toggle=&quot;buttons&quot;&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 选项 1 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 选项 2 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; 选项 3 &lt;/label&gt;&lt;/div&gt;// 单选框&lt;div class=&quot;btn-group&quot; data-toggle=&quot;buttons&quot;&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;options&quot; id=&quot;option1&quot;&gt; 选项 1 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;options&quot; id=&quot;option2&quot;&gt; 选项 2 &lt;/label&gt; &lt;label class=&quot;btn btn-primary&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;options&quot; id=&quot;option3&quot;&gt; 选项 3 &lt;/label&gt;&lt;/div&gt; 2、源码分析1、setState设置按钮状态，处理按钮状态切换2、toggle切换单选、多选按钮激活状态3、[data-toggle^=&quot;button&quot;]应用正则表达式监听 data-toggle=”button” 和 data-toggle=”buttons” 元素","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 button 样式","slug":"bootstrap/buttonStyle","date":"2017-10-29T07:56:59.000Z","updated":"2018-04-15T13:34:40.000Z","comments":true,"path":"bootstrap/buttonStyle/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/buttonStyle/","excerpt":"现在开始介绍 bootstrap 的 button 模块样式，包括 buttons.less、button-groups.less。","text":"现在开始介绍 bootstrap 的 button 模块样式，包括 buttons.less、button-groups.less。 一、源码1、buttons.less1.1、buttons.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//// Buttons(按钮)// --------------------------------------------------// Base styles(基础样式)// --------------------------------------------------.btn &#123; display: inline-block; margin-bottom: 0; // For input.btn font-weight: @btn-font-weight; text-align: center; vertical-align: middle; touch-action: manipulation; cursor: pointer; background-image: none; // Reset unusual Firefox-on-Android default style; see https://github.com/necolas/normalize.css/issues/214 border: 1px solid transparent; white-space: nowrap; .button-size(@padding-base-vertical; @padding-base-horizontal; @font-size-base; @line-height-base; @btn-border-radius-base); .user-select(none); &amp;, &amp;:active, &amp;.active &#123; &amp;:focus, &amp;.focus &#123; .tab-focus(); &#125; &#125; &amp;:hover, &amp;:focus, &amp;.focus &#123; color: @btn-default-color; text-decoration: none; &#125; &amp;:active, &amp;.active &#123; outline: 0; background-image: none; .box-shadow(inset 0 3px 5px rgba(0,0,0,.125)); &#125; &amp;.disabled, &amp;[disabled], fieldset[disabled] &amp; &#123; cursor: @cursor-disabled; .opacity(.65); .box-shadow(none); &#125; a&amp; &#123; &amp;.disabled, fieldset[disabled] &amp; &#123; pointer-events: none; // Future-proof disabling of clicks on `&lt;a&gt;` elements &#125; &#125;&#125;// Alternate buttons(交互式按钮)// --------------------------------------------------.btn-default &#123; .button-variant(@btn-default-color; @btn-default-bg; @btn-default-border);&#125;.btn-primary &#123; .button-variant(@btn-primary-color; @btn-primary-bg; @btn-primary-border);&#125;// Success appears as green.btn-success &#123; .button-variant(@btn-success-color; @btn-success-bg; @btn-success-border);&#125;// Info appears as blue-green.btn-info &#123; .button-variant(@btn-info-color; @btn-info-bg; @btn-info-border);&#125;// Warning appears as orange.btn-warning &#123; .button-variant(@btn-warning-color; @btn-warning-bg; @btn-warning-border);&#125;// Danger and error appear as red.btn-danger &#123; .button-variant(@btn-danger-color; @btn-danger-bg; @btn-danger-border);&#125;// Link buttons(链接按钮)// -------------------------// Make a button look and behave like a link.btn-link &#123; color: @link-color; font-weight: normal; border-radius: 0; &amp;, &amp;:active, &amp;.active, &amp;[disabled], fieldset[disabled] &amp; &#123; background-color: transparent; .box-shadow(none); &#125; &amp;, &amp;:hover, &amp;:focus, &amp;:active &#123; border-color: transparent; &#125; &amp;:hover, &amp;:focus &#123; color: @link-hover-color; text-decoration: @link-hover-decoration; background-color: transparent; &#125; &amp;[disabled], fieldset[disabled] &amp; &#123; &amp;:hover, &amp;:focus &#123; color: @btn-link-disabled-color; text-decoration: none; &#125; &#125;&#125;// Button Sizes(按钮大小)// --------------------------------------------------.btn-lg &#123; // line-height: ensure even-numbered height of button next to large input .button-size(@padding-large-vertical; @padding-large-horizontal; @font-size-large; @line-height-large; @btn-border-radius-large);&#125;.btn-sm &#123; // line-height: ensure proper height of button next to small input .button-size(@padding-small-vertical; @padding-small-horizontal; @font-size-small; @line-height-small; @btn-border-radius-small);&#125;.btn-xs &#123; .button-size(@padding-xs-vertical; @padding-xs-horizontal; @font-size-small; @line-height-small; @btn-border-radius-small);&#125;// Block button(块状按钮)// --------------------------------------------------.btn-block &#123; display: block; width: 100%;&#125;// Vertically space out multiple block buttons.btn-block + .btn-block &#123; margin-top: 5px;&#125;// Specificity overridesinput[type=&quot;submit&quot;],input[type=&quot;reset&quot;],input[type=&quot;button&quot;] &#123; &amp;.btn-block &#123; width: 100%; &#125;&#125; 1.2、buttons.less应用123456789101112131415// 按钮动作 &amp; 按钮大小 &amp; 按钮状态&lt;!-- 标准的按钮 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg active&quot;&gt;默认大激活按钮&lt;/button&gt;&lt;!-- 提供额外的视觉效果，标识一组按钮中的原始动作 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary disabled&quot;&gt;原始默认大小禁用按钮&lt;/button&gt;&lt;!-- 表示一个成功的或积极的动作 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success btn-sm&quot;&gt;成功小按钮&lt;/button&gt;&lt;!-- 信息警告消息的上下文按钮 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-info btn-xs&quot;&gt;信息特小按钮&lt;/button&gt;&lt;!-- 表示应谨慎采取的动作 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning btn-lg btn-block&quot;&gt;警告块级按钮&lt;/button&gt;&lt;!-- 表示一个危险的或潜在的负面动作 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;危险默认大小按钮&lt;/button&gt;&lt;!-- 并不强调是一个按钮，看起来像一个链接，但同时保持按钮的行为 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;链接默认大小按钮&lt;/button&gt; 2、button-groups.less2.1、button-groups.less源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238//// Button groups(按钮组)// --------------------------------------------------// Make the div behave like a button(按钮组).btn-group,.btn-group-vertical &#123; position: relative; display: inline-block; vertical-align: middle; // match .btn alignment given font-size hack above &gt; .btn &#123; position: relative; float: left; // Bring the &quot;active&quot; button to the front &amp;:hover, &amp;:focus, &amp;:active, &amp;.active &#123; z-index: 2; &#125; &#125;&#125;// Prevent double borders when buttons are next to each other(去除按钮组间的边框).btn-group &#123; .btn + .btn, .btn + .btn-group, .btn-group + .btn, .btn-group + .btn-group &#123; margin-left: -1px; &#125;&#125;// Optional: Group multiple button groups together for a toolbar(工具栏，按钮分组的父容器).btn-toolbar &#123; margin-left: -5px; // Offset the first child&apos;s margin &amp;:extend(.clearfix all); .btn, .btn-group, .input-group &#123; float: left; &#125; &gt; .btn, &gt; .btn-group, &gt; .input-group &#123; margin-left: 5px; &#125;&#125;// 去除圆角，生成按钮组圆角效果.btn-group &gt; .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) &#123; border-radius: 0;&#125;// Set corners individual because sometimes a single button can be in a .btn-group and we need :first-child and :last-child to both match.btn-group &gt; .btn:first-child &#123; margin-left: 0; &amp;:not(:last-child):not(.dropdown-toggle) &#123; .border-right-radius(0); &#125;&#125;// Need .dropdown-toggle since :last-child doesn&apos;t apply, given that a .dropdown-menu is used immediately after it.btn-group &gt; .btn:last-child:not(:first-child),.btn-group &gt; .dropdown-toggle:not(:first-child) &#123; .border-left-radius(0);&#125;// Custom edits for including btn-groups within btn-groups (useful for including dropdown buttons within a btn-group).btn-group &gt; .btn-group &#123; float: left;&#125;.btn-group &gt; .btn-group:not(:first-child):not(:last-child) &gt; .btn &#123; border-radius: 0;&#125;.btn-group &gt; .btn-group:first-child:not(:last-child) &#123; &gt; .btn:last-child, &gt; .dropdown-toggle &#123; .border-right-radius(0); &#125;&#125;.btn-group &gt; .btn-group:last-child:not(:first-child) &gt; .btn:first-child &#123; .border-left-radius(0);&#125;// On active and open, don&apos;t show outline.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle &#123; outline: 0;&#125;// Sizing(按钮组大小设置)//// Remix the default button sizing classes into new ones for easier manipulation..btn-group-xs &gt; .btn &#123; &amp;:extend(.btn-xs); &#125;.btn-group-sm &gt; .btn &#123; &amp;:extend(.btn-sm); &#125;.btn-group-lg &gt; .btn &#123; &amp;:extend(.btn-lg); &#125;// Split button dropdowns(嵌套分组)// ----------------------// Give the line between buttons some depth.btn-group &gt; .btn + .dropdown-toggle &#123; padding-left: 8px; padding-right: 8px;&#125;.btn-group &gt; .btn-lg + .dropdown-toggle &#123; padding-left: 12px; padding-right: 12px;&#125;// The clickable button for toggling the menu// Remove the gradient and set the same inset shadow as the :active state.btn-group.open .dropdown-toggle &#123; .box-shadow(inset 0 3px 5px rgba(0,0,0,.125)); // Show no shadow for `.btn-link` since it has no other button styles. &amp;.btn-link &#123; .box-shadow(none); &#125;&#125;// Reposition the caret.btn .caret &#123; margin-left: 0;&#125;// Carets in other button sizes.btn-lg .caret &#123; border-width: @caret-width-large @caret-width-large 0; border-bottom-width: 0;&#125;// Upside down carets for .dropup.dropup .btn-lg .caret &#123; border-width: 0 @caret-width-large @caret-width-large;&#125;// Vertical button groups(垂直按钮组)// ----------------------.btn-group-vertical &#123; &gt; .btn, &gt; .btn-group, &gt; .btn-group &gt; .btn &#123; display: block; float: none; width: 100%; max-width: 100%; &#125; // Clear floats so dropdown menus can be properly placed &gt; .btn-group &#123; &amp;:extend(.clearfix all); &gt; .btn &#123; float: none; &#125; &#125; &gt; .btn + .btn, &gt; .btn + .btn-group, &gt; .btn-group + .btn, &gt; .btn-group + .btn-group &#123; margin-top: -1px; margin-left: 0; &#125;&#125;.btn-group-vertical &gt; .btn &#123; &amp;:not(:first-child):not(:last-child) &#123; border-radius: 0; &#125; &amp;:first-child:not(:last-child) &#123; .border-top-radius(@btn-border-radius-base); .border-bottom-radius(0); &#125; &amp;:last-child:not(:first-child) &#123; .border-top-radius(0); .border-bottom-radius(@btn-border-radius-base); &#125;&#125;.btn-group-vertical &gt; .btn-group:not(:first-child):not(:last-child) &gt; .btn &#123; border-radius: 0;&#125;.btn-group-vertical &gt; .btn-group:first-child:not(:last-child) &#123; &gt; .btn:last-child, &gt; .dropdown-toggle &#123; .border-bottom-radius(0); &#125;&#125;.btn-group-vertical &gt; .btn-group:last-child:not(:first-child) &gt; .btn:first-child &#123; .border-top-radius(0);&#125;// Justified button groups(等分按钮)// ----------------------.btn-group-justified &#123; display: table; width: 100%; table-layout: fixed; border-collapse: separate; &gt; .btn, &gt; .btn-group &#123; float: none; display: table-cell; width: 1%; &#125; &gt; .btn-group .btn &#123; width: 100%; &#125; &gt; .btn-group .dropdown-menu &#123; left: auto; &#125;&#125;// Checkbox and radio options//// In order to support the browser&apos;s form validation feedback, powered by the// `required` attribute, we have to &quot;hide&quot; the inputs via `clip`. We cannot use// `display: none;` or `visibility: hidden;` as that also hides the popover.// Simply visually hiding the inputs via `opacity` would leave them clickable in// certain cases which is prevented by using `clip` and `pointer-events`.// This way, we ensure a DOM element is visible to position the popover from.//// See https://github.com/twbs/bootstrap/pull/12794 and// https://github.com/twbs/bootstrap/pull/14559 for more information.[data-toggle=&quot;buttons&quot;] &#123; &gt; .btn, &gt; .btn-group &gt; .btn &#123; input[type=&quot;radio&quot;], input[type=&quot;checkbox&quot;] &#123; position: absolute; clip: rect(0,0,0,0); pointer-events: none; &#125; &#125;&#125; 2.2、button-groups.less应用1234567891011121314151617181920212223242526272829303132333435363738&lt;!--btn-toolbar: 按钮工具栏--&gt;&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot;&gt; &lt;!--大按钮组--&gt; &lt;div class=&quot;btn-group btn-group-lg&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 1&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 2&lt;/button&gt; &lt;/div&gt; &lt;!--小按钮组--&gt; &lt;div class=&quot;btn-group btn-group-sm&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 3&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 4&lt;/button&gt; &lt;/div&gt; &lt;!--特小按钮组--&gt; &lt;div class=&quot;btn-group btn-group-xs&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 5&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 6&lt;/button&gt; &lt;/div&gt; &lt;!--垂直按钮组--&gt; &lt;div class=&quot;btn-group-vertical&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 7&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 8&lt;/button&gt; &lt;/div&gt; &lt;!--嵌套按钮组--&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 9&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;按钮 10&lt;/button&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; 下列 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;下拉链接 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;下拉链接 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"bootstrap 之 transition","slug":"bootstrap/transition","date":"2017-10-28T15:37:32.000Z","updated":"2018-04-15T13:59:44.000Z","comments":true,"path":"bootstrap/transition/","link":"","permalink":"http://blog.master-ss.cn/bootstrap/transition/","excerpt":"最近一段时间研究了下 bootstrap 源码，现在开始总结，先从 transition(动画)开始。","text":"最近一段时间研究了下 bootstrap 源码，现在开始总结，先从 transition(动画)开始。 一、源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* ======================================================================== * Bootstrap: transition.js v3.3.7(动画过渡) * http://getbootstrap.com/javascript/#transitions * ======================================================================== * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */+function ($) &#123; &apos;use strict&apos;; // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/) // ============================================================ // 判断浏览器是否支持哪种transitionEnd，如果不支持则返回false function transitionEnd() &#123; var el = document.createElement(&apos;bootstrap&apos;) var transEndEventNames = &#123; WebkitTransition : &apos;webkitTransitionEnd&apos;, MozTransition : &apos;transitionend&apos;, OTransition : &apos;oTransitionEnd otransitionend&apos;, transition : &apos;transitionend&apos; &#125; for (var name in transEndEventNames) &#123; if (el.style[name] !== undefined) &#123; return &#123; end: transEndEventNames[name] &#125; &#125; &#125; return false // explicit for ie8 ( ._.) &#125; // http://blog.alexmaccaw.com/css-transitions $.fn.emulateTransitionEnd = function (duration) &#123; var called = false var $el = this $(this).one(&apos;bsTransitionEnd&apos;, function () &#123; called = true &#125;) // 如果没有监听到了bsTransitionEnd，那么采用定时器触发事件 var callback = function () &#123; if (!called) $($el).trigger($.support.transition.end) &#125; setTimeout(callback, duration) return this &#125; // 初始化 $(function () &#123; $.support.transition = transitionEnd() if (!$.support.transition) return // 用于传入事件类型，来自定义事件。这样就能自己添加事件$el.one(&apos;bsTransitionEnd&apos;, function() &#123;&#125;)，而不用$el.one($.support.transition.end, function() &#123;&#125;) $.event.special.bsTransitionEnd = &#123; bindType: $.support.transition.end, delegateType: $.support.transition.end, handle: function (e) &#123; if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments) &#125; &#125; &#125;)&#125;(jQuery); 二、源码分析1、transitionEnd遍历各浏览器兼容的transitionEnd，判断哪个是当前浏览器兼容，并返回。 2、emulateTransitionEnd当监听到bsTransitionEnd设置called标志量为true，并设置定时器，如果bsTransitionEnd没有被触发，那么采用定时器来触发transitionEnd事件。 3、event.special.bsTransitionEnd采用jQuery处理特殊的事件，将兼容的transitionEnd委托为bsTransitionEnd。","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://blog.master-ss.cn/categories/bootstrap/"}],"tags":[]},{"title":"css 之 Sass 入门二","slug":"css/sass2","date":"2017-08-21T03:52:23.000Z","updated":"2018-04-19T08:32:06.000Z","comments":true,"path":"css/sass2/","link":"","permalink":"http://blog.master-ss.cn/css/sass2/","excerpt":"继续研究 sass 的运算、控制命令、函数、@ 规范等。","text":"继续研究 sass 的运算、控制命令、函数、@ 规范等。 一、运算1、加法、减法123.box &#123; width: 20px + 8px;&#125; 携带不同类型的单位时，在 Sass 中计算会报错 2、乘法123.box &#123; width: 10px * 2;&#125; 当一个单位同时声明两个值时会有问题；携带不同类型的单位时，在 Sass 中计算会报错 3、除法123.box &#123; width: (100px / 2); &#125; 如果数值或它的任意部分是存储在一个变量中或是函数的返回值、数值被圆括号包围、数值是另一个数学表达式的一部分才会生效。 4、颜色运算所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：color: #010203 + #040506; ==&gt; color: #050709; 5、字符运算可通过加法符号 “+” 来对字符串进行连接。如：p:before {content: &quot;Foo &quot; + Bar;} ==&gt; p:before {content: &quot;Foo Bar&quot;;} 二、控制命令1、@if@if 可一个条件单独使用，也可以和 @else 结合多条件使用 2、@for@for $i from through (包括 end)@for $i from to (不包括 end)其中 $i 表示变量，start 表示起始值，end 表示结束值 3、@while和 @for 指令很相似，只要 @while 后面的条件为 true 就会执行 4、@each@each 循环就是去遍历一个列表，然后从列表中取出对应的值 (@each $var in ) 5、三目判断if($condition, $if_true, $if_false)。三个参数分别表示：条件，条件为真的值，条件为假的值。 三、字符串函数1、unquote、quoteunquote：删除一个字符串中的引号；quote：给字符串添加引号 2、to-upper-case、to-lower-caseto-upper-case：将字符串小写字母转换成大写字母；to-lower-case：将字符串转换成小写字母 四、数字函数1、percentage($value)：将一个不带单位的数转换成百分比值；2、round($value)：将数值四舍五入，转换成一个最接近的整数；3、ceil($value)：将大于自己的小数转换成下一位整数；4、floor($value)：将一个数去除他的小数部分；5、abs($value)：返回一个数的绝对值；6、min($numbers…)：找出几个数值之间的最小值；7、max($numbers…)：找出几个数值之间的最大值；8、random(): 获取随机数 五、列表函数1、length($list)：返回一个列表的长度值；2、nth($list, $n)：返回一个列表中指定的某个标签值3、join($list1, $list2, [$separator])：将两个列给连接在一起，变成一个列表；4、append($list1, $val, [$separator])：将某个值放在列表的最后；5、zip($lists…)：将几个列表结合成一个多维的列表；6、index($list, $value)：返回一个值在列表中的位置值。 六、Introspection 函数1、type-of($value)：返回一个值的类型2、unit($number)：返回一个值的单位3、unitless($number)：判断一个值是否带有单位4、comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并 七、Sass Maps 函数1、map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。2、map-merge($map1,$map2)：将两个 map 合并成一个新的 map。3、map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。4、map-keys($map)：返回 map 中所有的 key。5、map-values($map)：返回 map 中所有的 value。6、map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。7、keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。 八、RGB 颜色函数1、rgb($red,$green,$blue)：根据红、绿、蓝三个值创建一个颜色；2、rgba($red,$green,$blue,$alpha)：根据红、绿、蓝和透明度值创建一个颜色；3、red($color)：从一个颜色中获取其中红色值；4、green($color)：从一个颜色中获取其中绿色值；5、blue($color)：从一个颜色中获取其中蓝色值；6、mix($color-1,$color-2,[$weight])：把两种颜色混合在一起。 九、Opacity 函数1、alpha($color) /opacity($color)：获取颜色透明度值；2、rgba($color, $alpha)：改变颜色的透明度值；3、opacify($color, $amount) / fade-in($color, $amount)：使颜色更不透明；4、transparentize($color, $amount) / fade-out($color, $amount)：使颜色更加透明。 十、@ 规则1、@importsass中如导入其他sass文件，最后编译为一个css文件，优于纯 css 的 @import 2、@extend用来扩展选择器或占位符 3、@at-root@at-root 从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用 @at-root 4、@debug@debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug 5、@warn@warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass 6、@error@error 和 @warn、@debug 功能是如出一辙","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"css 之 Sass 入门一","slug":"css/sass","date":"2017-08-21T02:38:42.000Z","updated":"2018-04-19T08:32:48.000Z","comments":true,"path":"css/sass/","link":"","permalink":"http://blog.master-ss.cn/css/sass/","excerpt":"Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。采用 Ruby 语言编写的一款 CSS 预处理语言，诞生于 2007 年，是最大的成熟的 CSS 预处理语言。Sass 有两种：一种是早期版本，文件后缀名为 sass，不使用大括号和分号，以严格的缩进式语法规则来书写；另外一种与我们的 CSS 语法非常类似。","text":"Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。采用 Ruby 语言编写的一款 CSS 预处理语言，诞生于 2007 年，是最大的成熟的 CSS 预处理语言。Sass 有两种：一种是早期版本，文件后缀名为 sass，不使用大括号和分号，以严格的缩进式语法规则来书写；另外一种与我们的 CSS 语法非常类似。 一、安装及运行12345678//安装 sasssudo gem install sass//查看 sass版本号(检查 sass 是否安装成功)sass -v//运行(进入到相应目录文件下再跑命令，--watch 起到监听作用，一旦 style.scss 发生改变自动编译到 style.css 中)sass --watch style.scss:style.css 二、变量sass 的变量必须是 $ 开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像 CSS 属性设置一样），如果值后面加上 !default 则表示默认值。 1、普通变量定义之后可以在全局范围内使用12345678910//sass style$fontSize: 12px;body&#123; font-size:$fontSize;&#125;//css stylebody&#123; font-size:12px;&#125; 2、默认变量sass 的默认变量仅需要在值后面加上!default即可，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可1234567891011//sass style$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123; line-height: $baseLineHeight; &#125;//css stylebody&#123; line-height:2;&#125; 3、特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以 #{$variables} 形式使用123456789101112131415161718192021//sass style$borderDirection: top !default; $baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;//应用于复杂的属性值body&#123; font:#&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style.border-top&#123; border-top:1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 4、多值变量多值变量分为 list 类型和 map 类型，简单来说 list 类型有点像 js 中的数组，而 map 类型有点像 js 中的对象list 数据可通过空格，逗号或小括号分隔多个值，可用 nth($var,$index) 取值1234567891011121314151617181920212223$px: 5px 10px 20px 30px;//二维数据，相当于js中的二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px);//使用 sass style$linkColor: #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;//css stylea&#123; color:#08c;&#125;a:hover&#123; color:#333;&#125; map 数据以 key 和 value 成对出现，其中 value 又可以是 list，可通过 map-get($map,$key) 取值123456789101112131415161718//sass style$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css styleh1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; 5、全局变量在变量值后面加上 !global 即为全局变量，sass3.4 后的版本中正式应用1234567891011121314151617//sass style$fontSize: 12px;body&#123; $fontSize: 14px !global; font-size:$fontSize;&#125;p&#123; font-size:$fontSize;&#125;//css stylebody&#123; font-size: 14px;&#125;p&#123; font-size: 14px;&#125; 三、嵌套1、选择器嵌套所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了 sass 文件的结构性和可读性。在选择器嵌套中，可以使用 &amp; 表示父元素选择器123456789101112131415161718//sass stylenav &#123; a &#123; color: red; header &amp; &#123; color:green; &#125; &#125;&#125;//css stylenav a &#123; color: red;&#125;header nav a &#123; color: green;&#125; 2、属性嵌套所谓属性嵌套指的是有些属性拥有同一个开始单词，如 border-width，border-color 都是以 border 开头12345678910111213//sass style.box &#123; border: &#123; top: 1px solid red; bottom: 1px solid green; &#125;&#125;//css style.box &#123; border-top: 1px solid red; border-bottom: 1px solid green;&#125; 3、伪元素嵌套其实伪元素嵌套和属性嵌套非常类似，只不过他需要借助&amp;符号一起配合使用12345678910111213141516171819202122//sass style.clearfix &#123; &amp;:before, &amp;:after &#123; content: &quot;&quot;; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125;&#125;//css style.clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both; overflow: hidden;&#125; 四、混合宏 &amp; 继承 &amp; 占位符1、混合宏使用 @mixin 声明混合，可以传递参数，参数名以 $ 符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin 通过 @include 来调用无参宏1234567891011121314//sass style(无参宏)@mixin center-block &#123; margin-left:auto; margin-right:auto;&#125;.demo&#123; @include center-block;&#125;//css style.demo&#123; margin-left:auto; margin-right:auto;&#125; 2、有参宏123456789101112//sass style@mixin opacity($opacity:50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125;.opacity&#123; @include opacity; //参数使用默认值&#125;.opacity-80&#123; @include opacity(80); //传递参数&#125; 3、多个参宏1234567891011@mixin horizontal-line($border:1px dashed #ccc, $padding:10px)&#123; border-bottom:$border; padding-top:$padding; padding-bottom:$padding; &#125;.imgtext-h li&#123; @include horizontal-line(1px solid #ccc);&#125;.imgtext-h--product li&#123; @include horizontal-line($padding:15px);&#125; 4、多组参宏(如果一个参数可以有多组值，如 box-shadow、transition 等，那么参数则需要在变量后加三个点表示，如 $variables…)123456789//box-shadow可以有多组值，所以在变量参数后面添加...@mixin box-shadow($shadow...) &#123; -webkit-box-shadow:$shadow; box-shadow:$shadow;&#125;.box&#123; border:1px solid #ccc; @include box-shadow(0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125; 5、继承sass 中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。12345678910111213141516//sass styleh1&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; @extend h1; border-width: 2px;&#125;//css styleh1,.speaker&#123; border: 4px solid #ff9aa9;&#125;.speaker&#123; border-width: 2px;&#125; 6、占位符从 sass 3.2.0 以后就可以定义占位选择器 %。这种选择器的优势在于：如果不调用则不会有任何多余的 css 文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。1234567891011121314151617//sass style%mt5 &#123; margin-top: 5px;&#125;.btn &#123; @extend %mt5;&#125;.block &#123; @extend %mt5;&#125;//css style.btn, .block &#123; margin-top: 5px;&#125; 7、比较 五、其他1、注释类似 CSS 的注释方式，使用 /* 开头，结束使用 */，会在编译出来的 CSS 显示类似 JavaScript 的注释方式，使用 //，在编译出来的 CSS 中不会显示 2、数据类型数字: 如，1、 2、 13、 10px；字符串：有引号字符串或无引号字符串，如，”foo”、 ‘bar’、 baz；颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)；布尔型：如，true、 false；空值：如，null；值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif。 3、插值 #{}123456789101112131415161718//设置属性值$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123; #&#123;$prop&#125;-#&#123;$side&#125;: $value; &#125;&#125;.login-box &#123; @include set-value(top, 14px);&#125;//构建选择器@mixin generate-sizes($class, $small, $medium, $big) &#123; .#&#123;$class&#125;-small &#123; font-size: $small; &#125; .#&#123;$class&#125;-medium &#123; font-size: $medium; &#125; .#&#123;$class&#125;-big &#123; font-size: $big; &#125;&#125;@include generate-sizes(&quot;header-text&quot;, 12px, 20px, 40px); 当你想设置属性或属性值的时候你可以使用字符串插入进来。另一个有用的用法是构建一个选择器，如上。123456789101112131415161718192021$btn-success: #5cb85c;$btn-info: #5bc0de;$btn-warning: #f0ad4e;$btn-danger: #d9534f;@mixin set-bg($name) &#123; background-color: $btn-#&#123;$name&#125;;//btn有多种状态,都存在变量里;&#125;.btn &#123; @include set-bg(success);&#125;//编译会报错：(Undefined variable: &quot;$btn-&quot;.)@mixin btn-status &#123; margin-top: 20px; background: #F00;&#125;$flag: &quot;status&quot;;.box &#123; @include btn-#&#123;$flag&#125;;&#125;//也会报错：(Invalid CSS after &quot;...nclude updated -&quot;: expected &quot;&#125;&quot;, was &quot;#&#123;$flag&#125;;&quot;) 限制 (mixin 中) 如上。","categories":[{"name":"css","slug":"css","permalink":"http://blog.master-ss.cn/categories/css/"}],"tags":[]},{"title":"zpeto 之核心代码二","slug":"zepto/core2Js","date":"2017-08-07T03:42:45.000Z","updated":"2018-04-18T05:58:06.000Z","comments":true,"path":"zepto/core2Js/","link":"","permalink":"http://blog.master-ss.cn/zepto/core2Js/","excerpt":"这篇研究 zepto 核心代码的实例方法。","text":"这篇研究 zepto 核心代码的实例方法。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686//定义zepto对象实例能够调用的方法$.fn = &#123; constructor: zepto.Z, length: 0, //由于zepto对象是类数组对象，所以拷贝一些有用的数组方法可直接使用 forEach: emptyArray.forEach, reduce: emptyArray.reduce, push: emptyArray.push, sort: emptyArray.sort, splice: emptyArray.splice, indexOf: emptyArray.indexOf, //如果参数是zepto对象则转成数组，再将this转成数组合并 concat: function () &#123; var i, value, args = []; for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i]; args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) &#125;, //调用内部工具函数$.map，并将返回结果包装成zepto对象 map: function (fn) &#123; return $($.map(this, function (el, i) &#123; return fn.call(el, i, el) &#125;)) &#125;, //返回的数组再次包装成zepto对象 slice: function () &#123; return $(slice.apply(this, arguments)) &#125;, //判断上下文是否已经存在，如果存在则立即执行，否则监听DOMContentLoaded事件 ready: function (callback) &#123; //需要检查document.body是否存在，因为IE浏览器会在它还没创建body元素时就触发document的ready事件 if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($); else document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; callback($) &#125;, false); return this &#125;, //不传参返回集合中所有元素并转成数组格式，传参大于0返回相应索引元素，小于0返回倒序返回 get: function (idx) &#123; return idx === undefined ? slice.call(this) : this[idx &gt;= 0 ? idx : idx + this.length] &#125;, //将zepto类数组对象转成数组 toArray: function () &#123; return this.get() &#125;, //返回当前zepto对象的length属性，也即集合中元素的个数 size: function () &#123; return this.length &#125;, //从其父节点中删除当前集合中的元素，有效的从dom中移除(这里的重点是parentNode.removeChild(this); 如果是没有父节点的这里不会执行) remove: function () &#123; return this.each(function () &#123; if (this.parentNode != null) this.parentNode.removeChild(this) &#125;) &#125;, //返回原先的zepto对象，如果返回false可终止遍历，返回this使得可链式调用 each: function (callback) &#123; emptyArray.every.call(this, function (el, idx) &#123; return callback.call(el, idx, el) !== false &#125;); return this &#125;, //过滤，如果参数是函数，返回执行为true的子元素；如果是字符串，那么调用zepto.matches来判断当前元素是否匹配相应选择器 filter: function (selector) &#123; if (isFunction(selector)) return this.not(this.not(selector)); return $(filter.call(this, function (element) &#123; return zepto.matches(element, selector) &#125;)) &#125;, //调用$(selector, context)来获取符合条件的集合元素，然后合并成数组去重并包装成zepto对象 add: function (selector, context) &#123; return $(uniq(this.concat($(selector, context)))) &#125;, //判断当前元素集合中的第一个元素是否符css选择器 is: function (selector) &#123; return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector) &#125;, //排除集合里满足条件的记录，接收参数为: css选择器, function, dom, nodeList not: function (selector) &#123; var nodes = []; //判断selector是否为函数，遍历执行函数返回false，则push到数组中(safari下的typeof nodeList也是function，所以需要判断selector.call !== undefined) if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function (idx) &#123; if (!selector.call(this, idx)) nodes.push(this) &#125;); else &#123; //当selector为字符串的时候，对集合进行筛选，也就是筛选出集合中满足selector的记录 var excludes = typeof selector == &apos;string&apos; ? this.filter(selector) : //如果为元素集合，那么调用slice.call得到数组，否则调用zepto构造函数 (likeArray(selector) &amp;&amp; isFunction(selector.item)) ? slice.call(selector) : $(selector); this.forEach(function (el) &#123; if (excludes.indexOf(el) &lt; 0) nodes.push(el) &#125;) &#125; return $(nodes) &#125;, //判断当前对象集合的子元素是否有符合选择器的元素，或者是否包含指定的DOM节点，如果有，则返回新的对象集合 has: function (selector) &#123; return this.filter(function () &#123; return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size() &#125;) &#125;, //从当前对象集合中获取给定索引值(以0为基数)，只取一个值(slice(-1)取倒数第一个) eq: function (idx) &#123; return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1) &#125;, //获取当前对象集合中的第一个元素 first: function () &#123; var el = this[0]; return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, //获取对象集合中最后一个元素 last: function () &#123; var el = this[this.length - 1]; return el &amp;&amp; !isObject(el) ? el : $(el) &#125;, //在当前上下文中查找符合selector的对象 find: function (selector) &#123; var result, $this = this; //如果没有选择器，那么返回空zepto对象 if (!selector) result = $(); //如果selector为dom元素或者zepto对象时，那么返回在上下文dom元素中selector的dom元素数组 else if (typeof selector == &apos;object&apos;) result = $(selector).filter(function () &#123; var node = this; return emptyArray.some.call($this, function (parent) &#123; return $.contains(parent, node) &#125;) &#125;); //如果是长度为1的zepto对象，那么直接调用zepto.qsa查询相应dom元素下符合selector条件的dom元素，再转成zepto对象 else if (this.length == 1) result = $(zepto.qsa(this[0], selector)); //如果是长度大于1的zepto对象，那么分别查询不同dom元素下符合selector条件的dom元素 else result = this.map(function () &#123; return zepto.qsa(this, selector) &#125;); return result; &#125;, //从元素本身开始，逐级向上级元素匹配，并返回最先匹配selector的元素。如果给定context节点参数，那么只匹配该节点的后代元素 closest: function (selector, context) &#123; var nodes = [], collection = typeof selector == &apos;object&apos; &amp;&amp; $(selector); this.each(function (_, node) &#123; //如果selector是对象，那么封装成zepto对象并判断node及其祖先节点是否存在内部；否则调用zepto.matches判断node及其祖先节点是否匹配选择器 while (node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector))) node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode; //如果该节点和其所有祖先节点都不匹配，那么node==false，不会被push进去(nodes.indexOf(node)&lt;0用来移除重复节点) if (node &amp;&amp; nodes.indexOf(node) &lt; 0) nodes.push(node) &#125;); return $(nodes) &#125;, //获取对象集合每个元素所有的祖先元素。如果css选择器参数给出，过滤出符合条件的元素 parents: function (selector) &#123; var ancestors = [], nodes = this; //现将所有祖先节点放到ancestors数组中 while (nodes.length &gt; 0) nodes = $.map(nodes, function (node) &#123; if ((node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0) &#123; ancestors.push(node); return node &#125; &#125;); //然后再过滤掉不符合选择器的节点 return filtered(ancestors, selector) &#125;, //获取对象集合中每个元素的直接父元素。如果css选择器参数给出。过滤出符合条件的元素 parent: function (selector) &#123; //获取对象的所有dom元素父节点，然后去重，再过滤掉不匹配选择器的元素 return filtered(uniq(this.pluck(&apos;parentNode&apos;)), selector) &#125;, //获得每个匹配元素集合元素的直接子元素，如果给定selector，那么返回的结果中只包含符合css选择器的元素 children: function (selector) &#123; return filtered(this.map(function () &#123; return children(this) &#125;), selector) &#125;, //获得每个匹配元素集合元素的子元素，包括文字和注释节点 contents: function () &#123; return this.map(function () &#123; //contentDocument: 取得子窗口的 document 对象 return this.contentDocument || slice.call(this.childNodes) &#125;) &#125;, //获取对象集合中所有元素的兄弟节点。如果给定CSS选择器参数，过滤出符合选择器的元素 siblings: function (selector) &#123; //先获取dom节点父元素，那么获取该父元素所有的子元素，过滤掉当前元素，再进行选择器匹配 return filtered(this.map(function (i, el) &#123; return filter.call(children(el.parentNode), function (child) &#123; return child !== el &#125;) &#125;), selector) &#125;, //清空对象集合中每个元素的DOM内容 empty: function () &#123; return this.each(function () &#123; this.innerHTML = &apos;&apos; &#125;) &#125;, //获取对象集合中每一个元素的属性值 pluck: function (property) &#123; return $.map(this, function (el) &#123; return el[property] &#125;) &#125;, //恢复对象集合中每个元素默认的“display”值。如果你用hide将元素隐藏，用该属性可以将其显示。相当于去掉了display：none show: function () &#123; return this.each(function () &#123; //清除内联样式display=&quot;none&quot; this.style.display == &quot;none&quot; &amp;&amp; (this.style.display = &apos;&apos;); //Window.getComputedStyle()获取最终样式，可查找伪元素样式；如果最终样式display为none，那么设置将display设置为默认 if (getComputedStyle(this, &apos;&apos;).getPropertyValue(&quot;display&quot;) == &quot;none&quot;) this.style.display = defaultDisplay(this.nodeName) &#125;) &#125;, //用给定的内容替换所有匹配的元素 replaceWith: function (newContent) &#123; //现在元素之前插入新的匹配元素，然后移除this下的dom元素 return this.before(newContent).remove(); &#125;, //在每个匹配的元素外层包上一个html元素(structure参数可以是一个单独的元素或者一些嵌套的元素。也可以是一个html字符串片段或者dom节点。还可以是一个生成用来包元素的回调函数，这个函数返回前两种类型的包裹片段) wrap: function (structure) &#123; var func = isFunction(structure); if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length &gt; 1; return this.each(function (index) &#123; $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ) &#125;) &#125;, //在所有匹配元素外面包一个单独的结构，结构可以是单个元素或几个嵌套的元素 wrapAll: function (structure) &#123; if (this[0]) &#123; //包裹内容插入到第一个元素前 $(this[0]).before(structure = $(structure)); var children; //取包裹内容里的第一个子元素的最里层 while ((children = structure.children()).length) structure = children.first(); //将当期zepto对象对应的dom元素全部插入到最里层元素 $(structure).append(this) &#125; return this &#125;, //将每个元素中的内容包裹在一个单独的结构中 wrapInner: function (structure) &#123; var func = isFunction(structure); return this.each(function (index) &#123; var self = $(this), contents = self.contents(), dom = func ? structure.call(this, index) : structure; //如果没有内容文本，那么直接将dom元素放到zepto对应dom元素中；如果有，则将内容文本节点放到dom中，并将dom插入到文本节点前面(wrapAll实现) contents.length ? contents.wrapAll(dom) : self.append(dom) &#125;) &#125;, //移除集合中每个元素的直接父节点，并把他们的子元素保留在原来的位置 unwrap: function () &#123; //获取直接父节点并遍历，用父节点的直接子元素替换掉父节点达到移除每个元素的直接父节点目的 this.parent().each(function () &#123; $(this).replaceWith($(this).children()) &#125;); return this &#125;, //通过深度克隆来复制集合中的所有元素 clone: function () &#123; return this.map(function () &#123; //cloneNode(true):如果为true，那么这个节点的子节点同时被拷贝；否则只能拷贝当前特定节点 return this.cloneNode(true) &#125;) &#125;, //通过设置css的属性display为none来将对象集合中的元素隐藏 hide: function () &#123; return this.css(&quot;display&quot;, &quot;none&quot;) &#125;, //显示或隐藏匹配元素 toggle: function (setting) &#123; return this.each(function () &#123; var el = $(this); //如果没有给定setting，那么获取display属性作为setting，根据setting判断显示还是隐藏 (setting === undefined ? el.css(&quot;display&quot;) == &quot;none&quot; : setting) ? el.show() : el.hide() &#125;) &#125;, //获取对象集合中每一个元素的前一个兄弟节点，通过选择器来进行过滤 prev: function (selector) &#123; //根据元素的previousElementSibling属性来获取前一个兄弟节点 return $(this.pluck(&apos;previousElementSibling&apos;)).filter(selector || &apos;*&apos;) &#125;, //获取对象集合中每一个元素的下一个兄弟节点(可以选择性的带上过滤选择器) next: function (selector) &#123; //根据元素的nextElementSibling属性来获取下一个兄弟节点；如果为null，会在zepto.matches被排除 return $(this.pluck(&apos;nextElementSibling&apos;)).filter(selector || &apos;*&apos;) &#125;, //获取或设置对象集合中元素的HTML内容(通过innerHTML读内容,append()写内容) html: function (html) &#123; return 0 in arguments ? //当给定content参数时，用其替换对象集合中每个元素的内容 this.each(function (idx) &#123; var originHtml = this.innerHTML; $(this).empty().append(funcArg(this, html, idx, originHtml)) &#125;) : //当没有给定content参数时，返回对象集合中第一个元素的innerHtml (0 in this ? this[0].innerHTML : null) &#125;, //获取或者设置所有对象集合中元素的文本内容 text: function (text) &#123; return 0 in arguments ? this.each(function (idx) &#123; var newText = funcArg(this, text, idx, this.textContent); this.textContent = newText == null ? &apos;&apos; : &apos;&apos; + newText &#125;) : (0 in this ? this.pluck(&apos;textContent&apos;).join(&quot;&quot;) : null) &#125;, //读取第一个dom元素属性或设置所有dom元素属性(attr(name)、attr(name, value)、attr(name, function(index, oldValue)&#123; ... &#125;)、attr(&#123; name: value, name2: value2, ... &#125;)) attr: function (name, value) &#123; var result; return (typeof name == &apos;string&apos; &amp;&amp; !(1 in arguments)) ? (0 in this &amp;&amp; this[0].nodeType == 1 &amp;&amp; (result = this[0].getAttribute(name)) != null ? result : undefined) : this.each(function (idx) &#123; if (this.nodeType !== 1) return; if (isObject(name)) for (key in name) setAttribute(this, key, name[key]) else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))) &#125;) &#125;, //移除当前对象集合中所有元素的指定属性 removeAttr: function (name) &#123; return this.each(function () &#123; this.nodeType === 1 &amp;&amp; name.split(&apos; &apos;).forEach(function (attribute) &#123; //这里的this是dom节点，因为forEach绑定了this值(这里没有指定attribute的值，会将这个属性移除掉) setAttribute(this, attribute) &#125;, this) &#125;) &#125;, //读取或设置dom元素的属性值(中文api: 它在读取属性值的情况下优先于attr，因为这些属性值会因为用户的交互发生改变，如checked和selected) prop: function (name, value) &#123; //优先读取修正属性，DOM的两字母属性都是驼峰格式 name = propMap[name] || name; return (1 in arguments) ? this.each(function (idx) &#123; this[name] = funcArg(this, value, idx, this[name]) &#125;) : //这里是直接获得dom上的属性，而不是调用getAttribute方法 (this[0] &amp;&amp; this[0][name]) &#125;, //从集合的每个DOM节点中删除一个属性(值得注意的是如果尝试删除DOM的一些内置属性，如className或maxLength，将不会有任何效果，因为浏览器禁止删除这些属性) removeProp: function (name) &#123; name = propMap[name] || name; //这是用JavaScript的delete操作符，删除dom元素的属性 return this.each(function () &#123; delete this[name] &#125;) &#125;, //读取或写入dom的 data-* 自定义属性 data: function (name, value) &#123; //改成连字符格式(aTcF-&gt;a-tc-f) var attrName = &apos;data-&apos; + name.replace(capitalRE, &apos;-$1&apos;).toLowerCase(); var data = (1 in arguments) ? this.attr(attrName, value) : this.attr(attrName); //如果是设置自定义属性，那么返回this，即当前zepto对象，deserializeValue(data)返回的还是this return data !== null ? deserializeValue(data) : undefined &#125;, //获取或设置匹配元素的值 val: function (value) &#123; //当给定value参数，那么将设置所有元素的value if (0 in arguments) &#123; if (value == null) value = &quot;&quot;; return this.each(function (idx) &#123; this.value = funcArg(this, value, idx, this.value) &#125;) &#125; else &#123; //当没有给定value参数，返回第一个元素的值。如果是&lt;select multiple&gt;标签，则返回一个包含被选中的option值的数组(this[0].multiple:多选select) return this[0] &amp;&amp; (this[0].multiple ? $(this[0]).find(&apos;option&apos;).filter(function () &#123; return this.selected &#125;).pluck(&apos;value&apos;) : this[0].value) &#125; &#125;, //读/写坐标 距离文档document的偏移值 offset: function (coordinates) &#123; //写入坐标 if (coordinates) return this.each(function (index) &#123; var $this = $(this), //如果coordinates是函数，执行函数 coords = funcArg(this, coordinates, index, $this.offset()), //取父元素坐标 parentOffset = $this.offsetParent().offset(), //计算出合理的坐标(相对于父元素的偏移量-父元素的偏移量=相对于document的偏移量) props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125;; //修正postin static-&gt;relative if ($this.css(&apos;position&apos;) == &apos;static&apos;) props[&apos;position&apos;] = &apos;relative&apos;; //写入样式 $this.css(props) &#125;); //读取坐标 if (!this.length) return null; /** * document.documentElement !== this[0]：解决$(&apos;html&apos;).offset()返回width为undefined的bug； * 调用getBoundingClientRect方法之前判断this[0]是否在元素上，存在该方法 * */ if (document.documentElement !== this[0] &amp;&amp; !$.contains(document.documentElement, this[0])) return &#123;top: 0, left: 0&#125;; //读取到元素相对于页面视窗的位置 var obj = this[0].getBoundingClientRect(); //window.pageYOffset就是类似Math.max(document.documentElement.scrollTop||document.body.scrollTop) return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125; &#125;, //读取或设置DOM元素的css属性(当value参数不存在的时候，返回对象集合中第一个元素的css属性。当value参数存在时，设置对象集合中每一个元素的对应css属性) css: function (property, value) &#123; //只有一个传参，读 if (arguments.length &lt; 2) &#123; var element = this[0]; if (typeof property == &apos;string&apos;) &#123; if (!element) return; //如果设置了行内样式，直接读取，否则读取计算样式(没有考虑计算样式!important情况) return element.style[camelize(property)] || getComputedStyle(element, &apos;&apos;).getPropertyValue(property) &#125; else if (isArray(property)) &#123; //如果property是数组，则返回一个属性对象 if (!element) return; var props = &#123;&#125;; var computedStyle = getComputedStyle(element, &apos;&apos;); $.each(property, function (_, prop) &#123; props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop)) &#125;); return props &#125; &#125; //有多个传参，写 var css = &apos;&apos;; if (type(property) == &apos;string&apos;) &#123; //null、undefined、false时，删掉样式 if (!value &amp;&amp; value !== 0) this.each(function () &#123; this.style.removeProperty(dasherize(property)) &#125;); else //dasherize是将字符串转换成css属性(background-color格式)，并根据value类型可能加上&apos;px&apos; css = dasherize(property) + &quot;:&quot; + maybeAddPx(property, value) &#125; else &#123; //如果property是对象的话，遍历处理 for (key in property) if (!property[key] &amp;&amp; property[key] !== 0) this.each(function () &#123; this.style.removeProperty(dasherize(key)) &#125;); else css += dasherize(key) + &apos;:&apos; + maybeAddPx(key, property[key]) + &apos;;&apos; &#125; return this.each(function () &#123; //这里并没有去重，但是并没有影响 this.style.cssText += &apos;;&apos; + css; &#125;) &#125;, //获取一个元素的索引值 index: function (element) &#123; //如果没有给出element参数，那么获取this的父元素，然后获取所有子元素，并判断第一个元素出现的位置；如果给出了element，返回它在当前对象集合中的位置 return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]) &#125;, //检查对象集合中是否有元素含有指定的class hasClass: function (name) &#123; //如果没有传参数，则直接返回false if (!name) return false; return emptyArray.some.call(this, function (el) &#123; //这里this为classRE(name)，name被转成正则表达式，这里使用正则因为className(el)可能是空格隔开的多个class组成 return this.test(className(el)) &#125;, classRE(name)) &#125;, //为每个匹配的元素添加指定的class类名。多个class类名使用空格分隔 addClass: function (name) &#123; if (!name) return this; return this.each(function (idx) &#123; //处理非dom元素，继续下一个元素(没有return false) if (!(&apos;className&apos; in this)) return; classList = []; //className(this)：获取当前dom元素的className；处理name为函数情况 var cls = className(this), newName = funcArg(this, name, idx, cls); //根据newName的空格分成数组，分别判断当前元素是否存在；如果不存在则添加到数组中 newName.split(/\\s+/g).forEach(function (klass) &#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this); //设置dom元素的className classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;) &#125;, //移除当前对象集合中所有元素的指定class。如果没有指定name参数，将移出所有的class。多个class参数名称可以利用空格分隔 removeClass: function (name) &#123; return this.each(function (idx) &#123; if (!(&apos;className&apos; in this)) return; if (name === undefined) return className(this, &apos;&apos;); classList = className(this); //使用正则表达式移除相应klass funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function (klass) &#123; classList = classList.replace(classRE(klass), &quot; &quot;) &#125;); className(this, classList.trim()) &#125;) &#125;, //在匹配的元素集合中的每个元素上添加或删除一个或多个样式类。如果class的名称存在则删除它，如果不存在，就添加它 toggleClass: function (name, when) &#123; if (!name) return this; return this.each(function (idx) &#123; var $this = $(this), names = funcArg(this, name, idx, className(this)); names.split(/\\s+/g).forEach(function (klass) &#123; (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass) &#125;) &#125;) &#125;, //读写元素 滚动条的垂直偏移 scrollTop: function (value) &#123; if (!this.length) return; var hasScrollTop = &apos;scrollTop&apos; in this[0]; if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset; return this.each(hasScrollTop ? function () &#123; this.scrollTop = value &#125; : function () &#123; this.scrollTo(this.scrollX, value) &#125;) &#125;, //读写元素 滚动条的水平偏移 scrollLeft: function (value) &#123; if (!this.length) return; var hasScrollLeft = &apos;scrollLeft&apos; in this[0]; if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset; return this.each(hasScrollLeft ? function () &#123; this.scrollLeft = value &#125; : function () &#123; this.scrollTo(value, this.scrollY) &#125;) &#125;, //获取对象集合中第一个元素的位置(获取相对父元素的坐标) position: function () &#123; if (!this.length) return; //获取第一个元素 var elem = this[0], //获取第一个定位过的祖先元素 offsetParent = this.offsetParent(), //对象集合中第一个元素的offset offset = this.offset(), parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123;top: 0, left: 0&#125; : offsetParent.offset(); // Subtract element margins(offset减去margin影响的值，再减去父元素的偏移量和边框宽度就等于相对于父元素的坐标) // note: when an element has margin: auto the offsetLeft and marginLeft are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat($(elem).css(&apos;margin-top&apos;)) || 0; offset.left -= parseFloat($(elem).css(&apos;margin-left&apos;)) || 0; //加上父元素的边框 parentOffset.top += parseFloat($(offsetParent[0]).css(&apos;border-top-width&apos;)) || 0; parentOffset.left += parseFloat($(offsetParent[0]).css(&apos;border-left-width&apos;)) || 0; // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125; &#125;, //找到第一个定位过的祖先元素(读取父元素中第一个其position设为relative或absolute的可见元素) offsetParent: function () &#123; return this.map(function () &#123; var parent = this.offsetParent || document.body; while (parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(&quot;position&quot;) == &quot;static&quot;) parent = parent.offsetParent; return parent &#125;) &#125;&#125;;// for now$.fn.detach = $.fn.remove;//width:获取对象集合中第一个元素的宽或者设置对象集合中所有元素的宽；height:获取对象集合中第一个元素的高度或者设置对象集合中所有元素的高度[&apos;width&apos;, &apos;height&apos;].forEach(function (dimension) &#123; //width、height=&gt;Width、Height var dimensionProperty = dimension.replace(/./, function (m) &#123; return m[0].toUpperCase() &#125;); //$.fn.width、$.fn.height $.fn[dimension] = function (value) &#123; //获取对象集合中第一个元素 var offset, el = this[0]; //window用innerWidth、innerHeight获取 if (value === undefined) return isWindow(el) ? el[&apos;inner&apos; + dimensionProperty] : //document，用scrollWidth、scrollHeight获取 isDocument(el) ? el.documentElement[&apos;scroll&apos; + dimensionProperty] : //否则用offsetWidth、offsetHeight (offset = this.offset()) &amp;&amp; offset[dimension]; else return this.each(function (idx) &#123; el = $(this); //如果value是函数，那么执行&apos;arg.call(context, idx, payload)&apos;，el[dimension]()为原先值；否则直接返回value el.css(dimension, funcArg(this, value, idx, el[dimension]())) &#125;) &#125;&#125;);//递归遍历 node 的子节点，将节点交由回调函数 fun 处理function traverseNode(node, fun) &#123; fun(node); for (var i = 0, len = node.childNodes.length; i &lt; len; i++) traverseNode(node.childNodes[i], fun)&#125;//生成after、prepend、before、append、insertAfter、insertBefore、appendTo、prependTo方法adjacencyOperators.forEach(function (operator, operatorIndex) &#123; var inside = operatorIndex % 2; //=&gt; prepend, append /** * after:在每个匹配的元素后插入内容(外部插入) * prepend:将参数内容插入到每个匹配元素的前面(内部插入) * before:在匹配每个元素的前面插入内容(外部插入) * append:在每个匹配的元素末尾插入内容(内部插入) * */ $.fn[operator] = function () &#123; //参数可以是节点数组、zepto对象或者html片段 var argType, nodes = $.map(arguments, function (arg) &#123; var arr = []; argType = type(arg); //如果是dom节点数组、zepto对象数组、html片段数组或者其混合状态 if (argType == &quot;array&quot;) &#123; arg.forEach(function (el) &#123; if (el.nodeType !== undefined) return arr.push(el); else if ($.zepto.isZ(el)) return arr = arr.concat(el.get()); arr = arr.concat(zepto.fragment(el)) &#125;); return arr &#125; //如果是对象或者null直接返回；否则生成dom元素并返回 return argType == &quot;object&quot; || arg == null ? arg : zepto.fragment(arg) &#125;), //如果zepto对象内dom元素大于1,需要克隆里面的元素，拿克隆的元素来进行操作，否则会出现多次操作同一元素，前面的操作会被覆盖无效 parent, copyByClone = this.length &gt; 1; //为0，不需要操作，直接返回 if (nodes.length &lt; 1) return this; //遍历zepto对象下的dom元素 return this.each(function (_, target) &#123; //inside 1(内部插入)：prepend, append取自身；inside 0(外部插入)：after, before取父元素 parent = inside ? target : target.parentNode; //0:after、1:prepend、2:before、3:append target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null; //父元素是否在document中 var parentInDocument = $.contains(document.documentElement, parent); //遍历待插入的元素(一个疑问：nodes可能会二维数组，没有对这种情况进行判断处理) nodes.forEach(function (node) &#123; //拷贝需要添加的节点，避免多次操作同一元素，前面的操作会被覆盖无效 if (copyByClone) node = node.cloneNode(true); //定位元素不存在，没法执行插入操作，直接删除，返回 else if (!parent) return $(node).remove(); //insertBefore(newnode,existingnode):newnode 需要插入的节点对象；existingnode 在其之前插入新节点的子节点，如果未规定会在结尾插入 parent.insertBefore(node, target); //如果父元素在document里，则调用traverseNode来处理node节点及node节点的所有子节点 if (parentInDocument) traverseNode(node, function (el) &#123; //脚本通过insertBefore的方法插入到dom中时，是不会执行脚本的，所以需要使用eval来进行处理。 if (el.nodeName != null &amp;&amp; el.nodeName.toUpperCase() === &apos;SCRIPT&apos; &amp;&amp; (!el.type || el.type === &apos;text/javascript&apos;) &amp;&amp; !el.src) &#123; /** * ownerDocument:返回的是元素的根节点，也即document对象；defaultView返回的是document对象所关联的window对象； * 这里主要是处理iframe里的script，因为在iframe中有独立的window对象；如果不存在该属性，则默认使用当前的window对象 * */ var target = el.ownerDocument ? el.ownerDocument.defaultView : window; //最后调用window的eval方法，执行script中的脚本，脚本用el.innerHTML取得 target[&apos;eval&apos;].call(target, el.innerHTML) &#125; &#125;) &#125;) &#125;) &#125;; //生成after=&gt;insertAfter、prepend=&gt;prependTo、before=&gt;insertBefore、append=&gt;appendTo方法(简单地反向调用对应的方法) $.fn[inside ? operator + &apos;To&apos; : &apos;insert&apos; + (operatorIndex ? &apos;Before&apos; : &apos;After&apos;)] = function (html) &#123; $(html)[operator](this); return this &#125;&#125;); 二、源码分析1、prop &amp; attrprop 是直接读取获取设置 dom 元素上的属性值，删除使用 delete；attr 是调用 setAttribute、getAttribute 和 removeAttribute 方法。 2、css读取 dom.style 上的属性值(行内样式)或者调用 getComputedStyle(element, ‘’).getPropertyValue(property) 方法(计算样式)；设置 css 值时设置的是 dom.style.cssText，不用去重，就算重复了也没关系，后面的属性值会覆盖前面的。 3、after、prepend、before、append、insertAfter、insertBefore、appendTo、prependToafter、prepend、before、append 巧妙的用了 parent.insertBefore(node, target) 方法来统一处理；insertAfter、insertBefore、appendTo、prependTo 巧妙的反向调用对应的方法 4、cloneNode(true)拷贝节点副本，为了避免同时添加一个元素多次，后面的操作会覆盖前面的(设置 true 为深拷贝，同时拷贝其子节点) 5、wrap、wrapAll、wrapInner1234567891011121314151617181920212223242526272829303132原文&lt;ul&gt; &lt;li title=&apos;苹果&apos;&gt;苹果&lt;/li&gt; &lt;li title=&apos;橘子&apos;&gt;橘子&lt;/li&gt; &lt;li title=&apos;菠萝&apos;&gt;菠萝&lt;/li&gt;&lt;/ul&gt; 1、$(&quot;li&quot;).wrap(&quot;&lt;div&gt;&lt;/div&gt;&quot;);每一个选择器都添加&lt;ul&gt; &lt;div&gt;&lt;li title=&quot;苹果&quot;&gt;苹果&lt;/li&gt;&lt;/div&gt; &lt;div&gt;&lt;li title=&quot;橘子&quot;&gt;橘子&lt;/li&gt;&lt;/div&gt; &lt;div&gt;&lt;li title=&quot;菠萝&quot;&gt;菠萝&lt;/li&gt;&lt;/div&gt;&lt;/ul&gt; 2、$(&quot;li&quot;).wrapAll(&quot;&lt;div&gt;&lt;/div&gt;&quot;);在所有选中的选择器最外面添加&lt;ul&gt; &lt;div&gt; &lt;li title=&quot;苹果&quot;&gt;苹果&lt;/li&gt; &lt;li title=&quot;橘子&quot;&gt;橘子&lt;/li&gt; &lt;li title=&quot;菠萝&quot;&gt;菠萝&lt;/li&gt; &lt;/div&gt;&lt;/ul&gt; 3、$(&quot;li&quot;).wrapInner(&quot;&lt;div&gt;&lt;/div&gt;&quot;);为选择器的内容添加&lt;ul&gt; &lt;li title=&apos;苹果&apos;&gt;&lt;div&gt;苹果&lt;/div&gt;&lt;/li&gt; &lt;li title=&apos;橘子&apos;&gt;&lt;div&gt;橘子&lt;/div&gt;&lt;/li&gt; &lt;li title=&apos;菠萝&apos;&gt;&lt;div&gt;菠萝&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt; 这几个方法有点绕，看上面的实例就知道了。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zpeto 之核心代码一","slug":"zepto/core1Js","date":"2017-08-07T03:25:41.000Z","updated":"2018-04-18T05:50:47.000Z","comments":true,"path":"zepto/core1Js/","link":"","permalink":"http://blog.master-ss.cn/zepto/core1Js/","excerpt":"这篇主要研究 zepto 核心模块的结构和一些工具方法。","text":"这篇主要研究 zepto 核心模块的结构和一些工具方法。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502(function (global, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) define(function () &#123; return factory(global) &#125;); else factory(global)&#125;(this, function (window) &#123; var Zepto = (function () &#123; //定义要使用的变量 var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice, document = window.document, elementDisplay = &#123;&#125;, classCache = &#123;&#125;, //不需要添加&apos;px&apos;后缀的css属性 cssNumber = &#123; &apos;column-count&apos;: 1, &apos;columns&apos;: 1, &apos;font-weight&apos;: 1, &apos;line-height&apos;: 1, &apos;opacity&apos;: 1, &apos;z-index&apos;: 1, &apos;zoom&apos;: 1 &#125;, //匹配HTML代码 fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, //匹配单个HTML标签 singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, //匹配自闭合标签 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, //匹配根节点 rootNodeRE = /^(?:body|html)$/i, //匹配A-Z capitalRE = /([A-Z])/g, //这些属性已经存在相应方法($.fn.x) methodAttributes = [&apos;val&apos;, &apos;css&apos;, &apos;html&apos;, &apos;text&apos;, &apos;data&apos;, &apos;width&apos;, &apos;height&apos;, &apos;offset&apos;], //操作方法集合，方便高效生成方法 adjacencyOperators = [&apos;after&apos;, &apos;prepend&apos;, &apos;before&apos;, &apos;append&apos;], //容器对象，用于生成fragment虚拟的节点元素 table = document.createElement(&apos;table&apos;), tableRow = document.createElement(&apos;tr&apos;), containers = &#123; &apos;tr&apos;: document.createElement(&apos;tbody&apos;), &apos;tbody&apos;: table, &apos;thead&apos;: table, &apos;tfoot&apos;: table, &apos;td&apos;: tableRow, &apos;th&apos;: tableRow, &apos;*&apos;: document.createElement(&apos;div&apos;) &#125;, //document.readyState的状态 readyRE = /complete|loaded|interactive/, //匹配 a-z、A-Z、0-9、下划线、连词符组合起来的单词，这其实就是单个id和class的命名规则 simpleSelectorRE = /^[\\w-]*$/, //存储对象的类型 class2type = &#123;&#125;, //存储对象的toString字符串方法 toString = class2type.toString, zepto = &#123;&#125;, camelize, uniq, tempParent = document.createElement(&apos;div&apos;), //修正dom元素属性 propMap = &#123; &apos;tabindex&apos;: &apos;tabIndex&apos;, &apos;readonly&apos;: &apos;readOnly&apos;, &apos;for&apos;: &apos;htmlFor&apos;, &apos;class&apos;: &apos;className&apos;, &apos;maxlength&apos;: &apos;maxLength&apos;, &apos;cellspacing&apos;: &apos;cellSpacing&apos;, &apos;cellpadding&apos;: &apos;cellPadding&apos;, &apos;rowspan&apos;: &apos;rowSpan&apos;, &apos;colspan&apos;: &apos;colSpan&apos;, &apos;usemap&apos;: &apos;useMap&apos;, &apos;frameborder&apos;: &apos;frameBorder&apos;, &apos;contenteditable&apos;: &apos;contentEditable&apos; &#125;, /** * 判断是否为数组类型(如果不支持isArray，那么调用instanceof来判断是否是数组) * 这里存在一个问题，如果存在iframe，那么iframe中的数组对象 instanceof 页面的Array为false * 有个更好的解决方案：Object.prototype.toString.call(object) === &apos;[object Array]&apos;，即$.type为array * */ isArray = Array.isArray || function (object) &#123; return object instanceof Array &#125;; //元素是否匹配选择器 zepto.matches = function (element, selector) &#123; //没参数，非元素，直接返回 if (!selector || !element || element.nodeType !== 1) return false; //如果浏览器支持MatchesSelector直接调用 var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector; if (matchesSelector) return matchesSelector.call(element, selector); //浏览器不支持MatchesSelector的话 var match, parent = element.parentNode, temp = !parent; //如果元素没有父元素，存入到临时的div中 if (temp) (parent = tempParent).appendChild(element); //在父元素中查找匹配选择器的子元素，如果子元素中出现了当前元素，那么说明该子元素匹配选择器(注意~取反位运算符，作用是将值取负数再减1，如-1变成0、0变成-1) match = ~zepto.qsa(parent, selector).indexOf(element); //移除临时div子元素 temp &amp;&amp; tempParent.removeChild(element); return match &#125;; //判断类型模块(基础类型会被转成引用类型，通过&#123;&#125;.toString.call(obj)) function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || &quot;object&quot; &#125; //判断是否是函数 function isFunction(value) &#123; return type(value) == &quot;function&quot; &#125; //判断是否为window对象(通过判断对象的obj的window属性指向自身) function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125; //判断是否为document对象(通过判断对象的节点属性nodeType等于属性DOCUMENT_NODE) function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125; //判断是否为对象 function isObject(obj) &#123; return type(obj) == &quot;object&quot; &#125; //测试对象是否是“纯粹”的对象，这个对象是通过对象常量(&quot;&#123;&#125;&quot;)或者new Object创建的，如果是，则返回true(通过判断obj._proto_==Object.prototype) function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype &#125; //类数组(不是function或window对象，存在length，且length==0或者length为number而且length-1属性也存在的引用类型或者真正的数组) //比如：likeArrayData = &#123;&apos;0&apos;: 0,&apos;1&apos;: 1,&quot;2&quot;: 2,length: 3&#125; function likeArray(obj) &#123; var length = !!obj &amp;&amp; &apos;length&apos; in obj &amp;&amp; obj.length, type = $.type(obj); return &apos;function&apos; != type &amp;&amp; !isWindow(obj) &amp;&amp; ( &apos;array&apos; == type || length === 0 || (typeof length == &apos;number&apos; &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) ) &#125; //删除数组的null和undefined(undefined类型转换和null相同) function compact(array) &#123; return filter.call(array, function (item) &#123; return item != null &#125;) &#125; //数组扁平化，最多只能展开一层嵌套(巧用apply方法) function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array &#125; //字符串驼峰化(将word-word的形式的字符串转换成wordWord的形式，&apos;-&apos;可以为一个或多个) camelize = function (str) &#123; return str.replace(/-+(.)?/g, function (match, chr) &#123; return chr ? chr.toUpperCase() : &apos;&apos; &#125;) &#125;; //将驼峰式的写法转换成连字符&apos;-&apos;的写法 function dasherize(str) &#123; return str.replace(/::/g, &apos;/&apos;) .replace(/([A-Z]+)([A-Z][a-z])/g, &apos;$1_$2&apos;) .replace(/([a-z\\d])([A-Z])/g, &apos;$1_$2&apos;) .replace(/_/g, &apos;-&apos;) .toLowerCase() &#125; //数组去重(使用原生数组过滤方法filter) uniq = function (array) &#123; return filter.call(array, function (item, idx) &#123; return array.indexOf(item) == idx &#125;) &#125;; //将参数变为正则表达式 function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp(&apos;(^|\\\\s)&apos; + name + &apos;(\\\\s|$)&apos;)) &#125; //将一些css样式，为number类型 function maybeAddPx(name, value) &#123; return (typeof value == &quot;number&quot; &amp;&amp; !cssNumber[dasherize(name)]) ? value + &quot;px&quot; : value &#125; //获取节点名对应dom元素默认display属性 function defaultDisplay(nodeName) &#123; var element, display; if (!elementDisplay[nodeName]) &#123; //根据节点名新建dom元素，再添加到document中 element = document.createElement(nodeName); document.body.appendChild(element); //获取最终样式display作为默认样式，并移除创建的元素 display = getComputedStyle(element, &apos;&apos;).getPropertyValue(&quot;display&quot;); element.parentNode.removeChild(element); //如果默认的最终样式display为none，强制设置为block，并缓存到对象中，下次可直接使用，避免dom操作 display == &quot;none&quot; &amp;&amp; (display = &quot;block&quot;); elementDisplay[nodeName] = display &#125; return elementDisplay[nodeName] &#125; //返回元素的直接子元素 function children(element) &#123; //如果存在children属性，那么将element.children改成数组 return &apos;children&apos; in element ? slice.call(element.children) : //否则调用element.childNodes，并返回元素节点 $.map(element.childNodes, function (node) &#123; if (node.nodeType == 1) return node &#125;) &#125; //实际构造函数(将dom数组转化为类数组对象&#123;0:dom0,1:dom1,length:2,selector:xxx&#125;，并设置对应的length属性和selector属性) function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0; for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len; this.selector = selector || &apos;&apos; &#125; //从给定的html片段生成dom数组 zepto.fragment = function (html, name, properties) &#123; var dom, nodes, container; //如果是单个标签，则用该标签名创建dom对象(如&apos;&lt;div&gt;&lt;/div&gt;&apos;，不能含有) if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)); if (!dom) &#123; //对html进行修复，如&lt;p class=&quot;test&quot; /&gt;修复成&lt;p class=&quot;test&quot; /&gt;&lt;/p&gt; if (html.replace) html = html.replace(tagExpanderRE, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;); //如果没有指定标签名，则获取标签名。如传入&lt;div&gt;test&lt;/div&gt;，获取到的name为div if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1; //如果传进来的标签名或者查找到的标签名不在containers中，那么设置标签名为*，即div if (!(name in containers)) name = &apos;*&apos;; //将containers标签名对应dom对象赋值给container container = containers[name]; //用容器将html字符串片段包起来 container.innerHTML = &apos;&apos; + html; //获取子节点(这里使用slice.call是很有必要的) dom = $.each(slice.call(container.childNodes), function () &#123; container.removeChild(this) &#125;) &#125; //如果属性值(即$函数的context参数)为纯对象，则给dom元素设置属性 if (isPlainObject(properties)) &#123; nodes = $(dom); $.each(properties, function (key, value) &#123; //zepto已经定义了相应的方法，则调用zepto对应的方法($.fn.x) if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value); //否则统一调用zepto的attr方法设置属性($.fn.attr) else nodes.attr(key, value) &#125;) &#125; return dom &#125;; //返回Z函数的实例 zepto.Z = function (dom, selector) &#123; return new Z(dom, selector) &#125;; //判断是否是zepto对象，因为做了&apos;zepto.Z.prototype = Z.prototype = $.fn&apos;操作，同时所有的zepto的实例都继承了$.fn对象的方法 zepto.isZ = function (object) &#123; return object instanceof zepto.Z &#125;; //初始化zepto对象 zepto.init = function (selector, context) &#123; var dom; //如果没有给出选择器，那么返回空的zepto对象&#123;&quot;length&quot;:0,&quot;selector&quot;:&quot;&quot;&#125; if (!selector) return zepto.Z(); //处理字符串选择器，用法$(selector, [context])、$(htmlString)、$(htmlString, attributes) else if (typeof selector == &apos;string&apos;) &#123; selector = selector.trim(); //selector的第一个字符为&lt;，并且为html片段，根据html片段创建节点(Chrome 21和Firefox 15会报DOM error 12错误，如果标签不是以&lt;开始的话) if (selector[0] == &apos;&lt;&apos; &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null; //如果存在context，那么在指定上下文选择节点 else if (context !== undefined) return $(context).find(selector); //如果没有指定上下文，那么用CSS选择器来选择节点 else dom = zepto.qsa(document, selector) &#125; //如果选择器是函数，那么在dom加载完成后执行，参数为$(如果dom已经加载则直接执行；否则设置监听等待dom加载完成再执行，用法Zepto(function($)&#123; ... &#125;)) else if (isFunction(selector)) return $(document).ready(selector); //如果选择器就是zepto对象，那么直接返回这个对象，用法$(&lt;Zepto collection&gt;) else if (zepto.isZ(selector)) return selector; else &#123; //如果选择器为数组，那么删除数组中的null和undefined，用法$(&lt;DOM nodes&gt;) if (isArray(selector)) dom = compact(selector); //如果选择器是对象，则将对象包装成数组，用法$(&lt;DOM nodes&gt;) else if (isObject(selector)) dom = [selector], selector = null; //如果是html片段，那么根据html片段创建相应节点 else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null; //如果存在context，那么在指定上下文选择节点 else if (context !== undefined) return $(context).find(selector); //如果没有指定上下文，那么用CSS选择器来选择节点 else dom = zepto.qsa(document, selector) &#125; //根据节点dom来创建一个新的zepto对象 return zepto.Z(dom, selector) &#125;; //当调用方法$时即调用zepto.init(该方法实现选择节点的细节和创造可调用插件方法的zepto对象) $ = function (selector, context) &#123; return zepto.init(selector, context) &#125;; //扩展目标对象的属性 function extend(target, source, deep) &#123; for (key in source) //如果为深度复制，并且源对象的属性值为纯粹对象或者数组 if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; //如果源对象的属性值为纯粹对象，并且目标对象对应的属性值不为纯粹对象，则将目标对象对应的属性值置为空对象 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125;; //如果源对象的属性值为数组，并且目标对象对应的属性值不为数组，则将目标对象对应的属性值置为空数组 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = []; //递归调用extend函数 extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key] &#125; /** * $.extend 方法可以用来扩展目标对象的属性。目标对象的同名属性会被源对象的非空属性(undefined)覆盖。 * 调用方法：$.extend(target, [source, [source2, ...]]) | $.extend(true, target, [source, ...]) * */ $.extend = function (target) &#123; //args用来接收第一个参数外的所有参数 var deep, args = slice.call(arguments, 1); //如果第一个参数target为boolean类型，那么是$.extend(true, target, [source, ...])调用，并将target重新赋值 if (typeof target == &apos;boolean&apos;) &#123; deep = target; target = args.shift() &#125; args.forEach(function (arg) &#123; extend(target, arg, deep) &#125;); return target &#125;; //zepto的选择器实现方法，不直接调用querySelectorAll方法是因为这个方法相较于getElementById、getElementsByClassName、getElementsByTagName而言更耗性能 zepto.qsa = function (element, selector) &#123; var found, //找到的元素 maybeID = selector[0] == &apos;#&apos;, maybeClass = !maybeID &amp;&amp; selector[0] == &apos;.&apos;, //确保一个字符的标签也能够被检测到(去掉id和class选择器第一个字符) nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, //单个id、class、标签的命名规则 isSimple = simpleSelectorRE.test(nameOnly); return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? //Safari的DocumentFragment元素没有getElementById方法 ((found = element.getElementById(nameOnly)) ? [found] : []) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : //排除不合法的element(合法节点:1 Element、9 Document、11 DocumentFragment) //slice.call 处理所获取到的集合，这样获取到的DOM集合就成为了数组，可以直接使用数组的方法了 slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? //DocumentFragment元素没有getElementsByClassName/TagName方法 maybeClass ? element.getElementsByClassName(nameOnly) : //简单的单个选择器，是类选择器，则使用getElementsByClassName查询类名符合的元素 element.getElementsByTagName(selector) : //如果也不是类选择器，那么调用getElementsByTagName查询标签名符合的元素 element.querySelectorAll(selector) //如果不是简单的单个选择器，或者没有getElementsByClassName方法，那么调用querySelectorAll查询所有 ) &#125;; //过滤掉nodes参数中不符合selector的节点；如果selector为null/undefined那么直接返回节点对象 function filtered(nodes, selector) &#123; return selector == null ? $(nodes) : $(nodes).filter(selector) &#125; //检查给定的父节点中是否包含有给定的子节点(document.documentElement.contains检测浏览器是否支持contains方法) $.contains = document.documentElement.contains ? function (parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node) &#125; : function (parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true; return false &#125;; //判断arg是否是函数，如果是则执行并返回执行结果；否则直接返回args function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg &#125; //设置属性 function setAttribute(node, name, value) &#123; //value为null/undefined,处理成删除，否则设值 value == null ? node.removeAttribute(name) : node.setAttribute(name, value) &#125; //设置或返回节点的className function className(node, value) &#123; var klass = node.className || &apos;&apos;, //为了兼容SVGAnimatedString svg = klass &amp;&amp; klass.baseVal !== undefined; if (value === undefined) return svg ? klass.baseVal : klass; svg ? (klass.baseVal = value) : (node.className = value) &#125; /** * 反系列化值(&quot;true&quot;=&gt;true, &quot;false&quot;=&gt;false, &quot;null&quot;=&gt;null, &quot;42&quot;=&gt;42, &quot;42.5&quot;=&gt;42.5, &quot;08&quot;=&gt;&quot;08&quot;, JSON=&gt;parse if valid, String=&gt;self) * +value将字符串转成number类型，注意&apos;08&apos;会被转成数字8，最后当成字符串处理；如果是非数字格式字符串的话，被转化为NaN，继续后面的判断操作 * */ function deserializeValue(value) &#123; try &#123; return value ? value == &quot;true&quot; || ( value == &quot;false&quot; ? false : value == &quot;null&quot; ? null : +value + &quot;&quot; == value ? +value : /^[\\[\\&#123;]/.test(value) ? $.parseJSON(value) : value ) : value &#125; catch (e) &#123; return value &#125; &#125; $.type = type; $.isFunction = isFunction; $.isWindow = isWindow; $.isArray = isArray; $.isPlainObject = isPlainObject; //判断是否为空对象 $.isEmptyObject = function (obj) &#123; var name; for (name in obj) return false return true &#125;; //是否为数值(不为null或undefined、不为布尔值、不为NaN、为有限数值、不为字符串或者字符串但是字符串长度大于0且转换成数字后不为NaN) $.isNumeric = function (val) &#123; var num = Number(val), type = typeof val; return val != null &amp;&amp; type != &apos;boolean&apos; &amp;&amp; (type != &apos;string&apos; || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125;; //返回指定元素在数组中的索引值(第三个参数fromIndex为可选参数，表示从哪个索引值开始向后查找) $.inArray = function (elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i) &#125;; //字符串转换成驼峰式的字符串 $.camelCase = camelize; //删除字符串头尾的空格(如果参数为null或undefined，则直接返回空字符串；否则调用字符串原生的trim方法去除头尾的空格) $.trim = function (str) &#123; return str == null ? &quot;&quot; : String.prototype.trim.call(str) &#125;; //为了拓展插件 $.uuid = 0; $.support = &#123;&#125;; $.expr = &#123;&#125;; $.noop = function () &#123; &#125;; //遍历类数组或对象中的元素，将回调函数返回值组成一个新的数组，并将该数组扁平化后返回，会将null及undefined排除 $.map = function (elements, callback) &#123; var value, values = [], i, key; if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; value = callback(elements[i], i); if (value != null) values.push(value) &#125; else for (key in elements) &#123; value = callback(elements[key], key); if (value != null) values.push(value) &#125; return flatten(values) &#125;; //用来遍历数组或者类数组对象(回调函数this指向的是item，回调函数参数是(index, item)) $.each = function (elements, callback) &#123; var i, key; if (likeArray(elements)) &#123; //类数组 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; //对象 for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125;; //其实就是数组的filter函数 $.grep = function (elements, callback) &#123; return filter.call(elements, callback) &#125;; //将原生JSON解析方法赋值给$.parseJSON if (window.JSON) $.parseJSON = JSON.parse; //生成class2type映射 $.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function (i, name) &#123; class2type[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase() &#125;); //将$.fn分别赋值给Z和zepto.Z的prototype zepto.Z.prototype = Z.prototype = $.fn; //将内部的操作函数放到$.zepto命名空间下，以便外部能够使用 zepto.uniq = uniq; zepto.deserializeValue = deserializeValue; $.zepto = zepto; return $ &#125;)(); //赋值给全局对象使Zepto成为全局函数 window.Zepto = Zepto; //如果$已经被占用了，那么使用Zepto；否则使用$代替Zepto window.$ === undefined &amp;&amp; (window.$ = Zepto); return Zepto&#125;)); 二、源码分析1、amdzepto 方法支持 amd 模块加载，整体是个匿名闭包自运行函数。 2、结构function Z 是真正的构造函数，这里 zepto 实例结构为类数组是因为方法调用好用的数组方法，不直接用数组格式是因为继承$.fn，使得所有实例可直接调用$.fn中的方法。这里把构造函数、初始化、选择器查找、生成 fragment 等方法统一封装到 zepto 对象中去了。这里有个地方需要注意，为了使 zepto 实例可调 $.fn 方法，把$.fn给了 Z.prototype，同时为了使得 zepto.isZ 里面 object instanceof zepto.Z 可以正常运行，让 zepto.Z.prototype = Z.prototype(instanceof 判断object._proto_是否在 zepto.Z.prototype 的原型链上)；将 zepto 对象赋值给 $ 的 zepto 属性，以便外部能够调用；而$是一个函数，内调用 zepto.init 完成初始化。直接在$下的属性方法是工具方法，在$.fn对象中的是zepto 实例的方法。将$返回给 Zepto 并赋值给全局对象，判断$是否被占用了，如果占用了那么使用 Zepto；否则可使用$代替 Zepto。 3、$.type这里很巧妙的先将特定的 js 类型数据遍历赋值到 class2type 对象属性上，后面直接从 class2type 对象获取相应的数据类型。 4、$.isArray判断是否为数组类型(如果不支持 isArray，那么调用 instanceof 来判断是否是数组)。这里存在一个问题，如果存在 iframe，那么 iframe 中的数组对象 instanceof 页面的 Array 为false。有个更好的解决方案：Object.prototype.toString.call(object) === ‘[object Array]’，即 $.type 为 array。 5、function flatten这里巧妙的用了 apply 方法，使得 concat.apply 能够展开一层嵌套。 6、uniq这是除了新建一个结果数组、利用对象属性外，另一个很不错的数组去重方法。调用 filter 方法过滤掉当前索引不等于首次出现在数组位置的元素。 7、HTMLCollection.item获取相应位置出现的 dom 元素，等同于 HTMLCollection[item] 8、children &amp; childNodeschildNodes: 返回指定元素的子元素集合，包括属性节点，元素节点和文本节点；children: 返回所有元素节点的子元素集合。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 touch.js","slug":"zepto/touchJs","date":"2017-08-03T01:42:49.000Z","updated":"2018-04-18T06:34:06.000Z","comments":true,"path":"zepto/touchJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/touchJs/","excerpt":"touch.js 主要提供滑动(swipe)与点击(tap：模拟 click)的事件封装，针对手机常用浏览器(touchstart,touchmove,touchend)和 IE10(msPointDown) 的触摸事件兼容处理以及手势的事件处理。","text":"touch.js 主要提供滑动(swipe)与点击(tap：模拟 click)的事件封装，针对手机常用浏览器(touchstart,touchmove,touchend)和 IE10(msPointDown) 的触摸事件兼容处理以及手势的事件处理。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181//touch事件 在触摸设备上触发tap–和swipe–相关事件。这适用于所有的`touch`(iOS, Android)和`pointer`事件(Windows Phone)。(function ($) &#123; var touch = &#123;&#125;, //延迟触发(ms): 250, 0, 0, 750 touchTimeout, tapTimeout, swipeTimeout, longTapTimeout, longTapDelay = 750, gesture; //判断滑动方向，返回Left, Right, Up, Down function swipeDirection(x1, x2, y1, y2) &#123; return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;) &#125; //长按 function longTap() &#123; //定时器执行了没有清空的必要 longTapTimeout = null; if (touch.last) &#123; touch.el.trigger(&apos;longTap&apos;); touch = &#123;&#125; &#125; &#125; //取消长按 function cancelLongTap() &#123; if (longTapTimeout) clearTimeout(longTapTimeout); longTapTimeout = null &#125; //取消所有 function cancelAll() &#123; if (touchTimeout) clearTimeout(touchTimeout); if (tapTimeout) clearTimeout(tapTimeout); if (swipeTimeout) clearTimeout(swipeTimeout); if (longTapTimeout) clearTimeout(longTapTimeout); touchTimeout = tapTimeout = swipeTimeout = longTapTimeout = null; touch = &#123;&#125; &#125; //判断是否是点击指针是否为主指针(http://www.ayqy.net/blog/html5%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/) function isPrimaryTouch(event) &#123; return (event.pointerType == &apos;touch&apos; || event.pointerType == event.MSPOINTER_TYPE_TOUCH) &amp;&amp; event.isPrimary &#125; //判断是否为鼠标事件或者ie的点击事件 function isPointerEventType(e, type) &#123; return (e.type == &apos;pointer&apos; + type || e.type.toLowerCase() == &apos;mspointer&apos; + type) &#125; //加载完全时执行，将事件绑定到全局的document $(document).ready(function () &#123; var now, delta, deltaX = 0, deltaY = 0, firstTouch, _isPointerType; //IE的手势 if (&apos;MSGesture&apos; in window) &#123; gesture = new MSGesture(); gesture.target = document.body &#125; $(document) .bind(&apos;MSGestureEnd&apos;, function (e) &#123; //处理IE手势结束 var swipeDirectionFromVelocity = e.velocityX &gt; 1 ? &apos;Right&apos; : e.velocityX &lt; -1 ? &apos;Left&apos; : e.velocityY &gt; 1 ? &apos;Down&apos; : e.velocityY &lt; -1 ? &apos;Up&apos; : null; if (swipeDirectionFromVelocity) &#123; touch.el.trigger(&apos;swipe&apos;); touch.el.trigger(&apos;swipe&apos; + swipeDirectionFromVelocity) &#125; &#125;) .on(&apos;touchstart MSPointerDown pointerdown&apos;, function (e) &#123; //处理手指接触事件 //屏蔽掉非触摸设备(非触屏设备鼠标事件isPrimary属性为true) if ((_isPointerType = isPointerEventType(e, &apos;down&apos;)) &amp;&amp; !isPrimaryTouch(e)) return; //记录起点坐标(_isPointerType用于ie) firstTouch = _isPointerType ? e : e.touches[0]; //重置终点坐标(正常情况下touch会在touchend或cancelAll中清空，除了因为preventDefault等导致touchcancel不被触发) if (e.touches &amp;&amp; e.touches.length === 1 &amp;&amp; touch.x2) &#123; touch.x2 = undefined; touch.y2 = undefined &#125; //当前时间毫秒数 now = Date.now(); //距离上次触碰的时间差 delta = now - (touch.last || now); //点击元素 如果是正常的dom元素，则赋值于touch.el；若是非正常元素，比如伪元素，则touch源是其父元素 touch.el = $(&apos;tagName&apos; in firstTouch.target ? firstTouch.target : firstTouch.target.parentNode); //重置touch延迟事件处理器 touchTimeout &amp;&amp; clearTimeout(touchTimeout); //记录点击起点坐标 touch.x1 = firstTouch.pageX; touch.y1 = firstTouch.pageY; //判断是否双击 if (delta &gt; 0 &amp;&amp; delta &lt;= 250) touch.isDoubleTap = true; //将当期时间毫秒数存储到touch的last属性上 touch.last = now; //注册长按延迟事件处理器 longTapTimeout = setTimeout(longTap, longTapDelay); //支持IE手势识别 if (gesture &amp;&amp; _isPointerType) gesture.addPointer(e.pointerId); &#125;) .on(&apos;touchmove MSPointerMove pointermove&apos;, function (e) &#123; //处理手指滑动 if ((_isPointerType = isPointerEventType(e, &apos;move&apos;)) &amp;&amp; !isPrimaryTouch(e)) return; firstTouch = _isPointerType ? e : e.touches[0]; //取消长按事件处理器(touchstart设置的) cancelLongTap(); //设置touch对象的位置 touch.x2 = firstTouch.pageX; touch.y2 = firstTouch.pageY; deltaX += Math.abs(touch.x1 - touch.x2); deltaY += Math.abs(touch.y1 - touch.y2); &#125;) .on(&apos;touchend MSPointerUp pointerup&apos;, function (e) &#123; //处理手指离开 if ((_isPointerType = isPointerEventType(e, &apos;up&apos;)) &amp;&amp; !isPrimaryTouch(e)) return; //取消长按事件处理器(touchstart设置的) cancelLongTap(); //swipe 判定滑动动作（起点 - 终点的横向或者纵向距离超过30px） if ((touch.x2 &amp;&amp; Math.abs(touch.x1 - touch.x2) &gt; 30) || (touch.y2 &amp;&amp; Math.abs(touch.y1 - touch.y2) &gt; 30)) //延迟执行所以可以在scroll事件触发时取消执行swipe事件 swipeTimeout = setTimeout(function () &#123; //根据方向触发滑动事件，并清空touch对象(所有touchend的回调触发自定义事件都作了判断是否touch对象有el属性，屏蔽比如滚动时同时触发了滑动事件等奇怪的现象) if (touch.el) &#123; touch.el.trigger(&apos;swipe&apos;); touch.el.trigger(&apos;swipe&apos; + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2))) &#125; touch = &#123;&#125; &#125;, 0); //一般情况下，touch是会存在last属性的；如果长按，那么touch会被赋空值，就不存在last属性了 else if (&apos;last&apos; in touch) //当位置发生改变超过30px，不会被触发(比如移动到一个位置然后返回原先的位置) if (deltaX &lt; 30 &amp;&amp; deltaY &lt; 30) &#123; //立即准备执行轻触，不立即执行是为了scroll时能取消执行轻触(tap触发在scroll之前) tapTimeout = setTimeout(function () &#123; // 触发全局tap，cancelTouch可以取消singleTap，doubleTap事件，以求更快响应轻触 var event = $.Event(&apos;tap&apos;); event.cancelTouch = cancelAll; // [by paper] fix -&gt; &quot;TypeError: &apos;undefined&apos; is not an object (evaluating &apos;touch.el.trigger&apos;), when double tap if (touch.el) touch.el.trigger(event); //立即触发doubleTap if (touch.isDoubleTap) &#123; if (touch.el) touch.el.trigger(&apos;doubleTap&apos;); touch = &#123;&#125; &#125; // 250ms后触发singleTap，因为需要判断tap后250内是否还有tap，如果有则触发doubleTap；否则触发singleTap else &#123; touchTimeout = setTimeout(function () &#123; //定时器已经执行了，没有必要clear touchTimeout = null; if (touch.el) touch.el.trigger(&apos;singleTap&apos;); touch = &#123;&#125; &#125;, 250) &#125; &#125;, 0) &#125; else &#123; /** * 当位置距离总和deltaX或deltaY大于30，并且起点到终点距离小于30 * 即存在这样一种情况，移动到一个位置，然后返回原先的位置 * 则直接清空touch对象，并不执行任何操作 * */ touch = &#123;&#125; &#125; //重置横向，纵向滑动距离 deltaX = deltaY = 0; &#125;) //当浏览器窗口失去焦点(如模态框弹窗显示)，取消所有将要发生的事件 .on(&apos;touchcancel MSPointerCancel pointercancel&apos;, cancelAll); //浏览器窗口滚动时，取消所有将要发生的事件，因为滚动window意味着用户的意图是滚动而不是tap或者swipe $(window).on(&apos;scroll&apos;, cancelAll) &#125;); //绑定自定义回调函数到自定义事件上 [&apos;swipe&apos;, &apos;swipeLeft&apos;, &apos;swipeRight&apos;, &apos;swipeUp&apos;, &apos;swipeDown&apos;, &apos;doubleTap&apos;, &apos;tap&apos;, &apos;singleTap&apos;, &apos;longTap&apos;].forEach(function (eventName) &#123; $.fn[eventName] = function (callback) &#123; return this.on(eventName, callback) &#125; &#125;)&#125;)(Zepto); 二、源码分析1、MSPointerDown/pointerdown由于 IE 浏览器的触碰事件使用的是 MSPointerDown/pointerdown 等这样的鼠标事件来标识的，所以为了兼容IE浏览器也需要监听此类事件。在 webkit 内核的移动端浏览器上 touch.js 可以正常运行，但是在 chrome 浏览器模拟移动端时会被触发两次，一次是监听到鼠标事件(pointerdown)，一次是监听到 touch 事件 2、longTap原生 JS 并没有提供 longTap 之类事件，所以 zepto 自己封装实现了此类事件。首先在 touchstart 时设置一个定时器 750ms，如果在此区间没有触发 touchmove、touchend、touchcancel 以及 scroll 事件，那么说明是长按事件，触发相应回调。 3、doubleTapzepto 同时也封装实现了 doubleTap。在 touchstart 时设置延迟变量为这次与上次点击时间差，如果大于 0(第一次点击为 0)并且小于 250，那么设置touch 对象双击标志量 isDoubleTap 为 true，并在 touchend 触发 doubleTap 事件。 4、tap vs swipe在 touchend 中判断起点坐标与终点坐标距离如果超过了 30px，那么触发 swipe 事件，并触发 swipe 相应方向事件。tap 需判断累计距离不超过 30px，如果超过 30px 可能存在移动到某个点再返回回来这种情况。 5、singleTap在 touchend 中设置定时器 250ms，如果在此区间再次点击则清掉定时器，否则触发 singleTap 事件。 6、scroll窗口滚动时，可以监听到 scroll 事件。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 fx_methods.js","slug":"zepto/fx_methodsJs","date":"2017-07-31T14:01:56.000Z","updated":"2018-04-18T06:21:43.000Z","comments":true,"path":"zepto/fx_methodsJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/fx_methodsJs/","excerpt":"依赖 fx.js，主要是针对 show，hide，fadeIn，fadeOut 等方法的封装。","text":"依赖 fx.js，主要是针对 show，hide，fadeIn，fadeOut 等方法的封装。 一、源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//fx_methods 以动画形式的show,hide,toggle和fade等方法.(function ($, undefined) &#123; var document = window.document, docElem = document.documentElement, origShow = $.fn.show, origHide = $.fn.hide, origToggle = $.fn.toggle; //底层方法，调用$.fn.animate方法 function anim(el, speed, opacity, scale, callback) &#123; if (typeof speed == &apos;function&apos; &amp;&amp; !callback) callback = speed, speed = undefined; var props = &#123;opacity: opacity&#125;; if (scale) &#123; props.scale = scale; //设置元素变换的基点，默认为(50% 50% 0)，第三个参数为可选，当为3D变化时，可传第三个参数 el.css($.fx.cssPrefix + &apos;transform-origin&apos;, &apos;0 0&apos;) &#125; return el.animate(props, speed, null, callback) &#125; //底层方法：隐藏显示的元素 function hide(el, speed, scale, callback) &#123; return anim(el, speed, 0, scale, function () &#123; //调用原先的方法，即设置元素的display属性为none($.fn.hide) origHide.call($(this)); callback &amp;&amp; callback.call(this) &#125;) &#125; //首先调用原先的$.fn.show方法将元素display属性设置为block，然后设置opacity属性为0，再进行过渡opacity为1，宽高设置为原先的 $.fn.show = function (speed, callback) &#123; origShow.call(this); if (speed === undefined) speed = 0; else this.css(&apos;opacity&apos;, 0); return anim(this, speed, 1, &apos;1,1&apos;, callback) &#125;; //隐藏元素效果(通过设置opacity为0隐藏元素，同时设置scale有切换效果，设置切换原点为0、0，宽高为0) $.fn.hide = function (speed, callback) &#123; //如果speed参数为undefined，即过渡时间为undefined，那么直接调用核心方法里面的隐藏元素方法 if (speed === undefined) return origHide.call(this); else return hide(this, speed, &apos;0,0&apos;, callback) &#125;; //如果speed不符合要求，那么直接调用原先的$.fn.toggle方法，否则进行进行判断当前显示状态并切换 $.fn.toggle = function (speed, callback) &#123; if (speed === undefined || typeof speed == &apos;boolean&apos;) return origToggle.call(this, speed); else return this.each(function () &#123; var el = $(this); el[el.css(&apos;display&apos;) == &apos;none&apos; ? &apos;show&apos; : &apos;hide&apos;](speed, callback) &#125;) &#125;; //淡入淡出总函数，相比而言去掉了scale变化 $.fn.fadeTo = function (speed, opacity, callback) &#123; return anim(this, speed, opacity, null, callback) &#125;; //淡入(如果之前的opacity大于0，那么记录下来，然后设置opacity为0，然后过渡到记录值；如果opacity&lt;=0，那么直接过渡到1) $.fn.fadeIn = function (speed, callback) &#123; var target = this.css(&apos;opacity&apos;); if (target &gt; 0) this.css(&apos;opacity&apos;, 0); else target = 1; return origShow.call(this).fadeTo(speed, target, callback) &#125;; //淡出 $.fn.fadeOut = function (speed, callback) &#123; return hide(this, speed, null, callback) &#125;; //淡入淡出切换 $.fn.fadeToggle = function (speed, callback) &#123; return this.each(function () &#123; var el = $(this); el[ (el.css(&apos;opacity&apos;) == 0 || el.css(&apos;display&apos;) == &apos;none&apos;) ? &apos;fadeIn&apos; : &apos;fadeOut&apos; ](speed, callback) &#125;) &#125;&#125;)(Zepto); 二、源码分析1、transform-origin设置变形原点，默认值(50% 50% 0)，第三个参数为可选，当为 3D 变化时，可传第三个参数。 2、fadeIn如果之前的 opacity 大于 0，那么记录下来，然后设置 opacity 为 0，然后过渡到记录值；如果 opacity&lt;=0，那么直接过渡到 1 3、奇怪的现象1234567var div1 = $(&apos;#foo1&apos;);div1.show(1000, function () &#123; console.log(&apos;fx_methods show&apos;); div1.toggle(1000, function () &#123; console.log(&apos;fx_methods hide&apos;); &#125;);&#125;); 在过渡成功回调函数中再次设置过渡效果无效，会被立即执行，不会有过渡效果。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 fx.js","slug":"zepto/fxJs","date":"2017-07-31T01:33:19.000Z","updated":"2018-04-18T06:27:15.000Z","comments":true,"path":"zepto/fxJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/fxJs/","excerpt":"zepto 的 fx 模块，封装了 CSS 的过渡和动画。","text":"zepto 的 fx 模块，封装了 CSS 的过渡和动画。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//fx The animate()方法(function ($, undefined) &#123; //prefix:样式前缀(-webkit-、-moz-、-o-)；eventPrefix事件前缀(webkit、&apos;&apos;、o) var prefix = &apos;&apos;, eventPrefix, //内核厂商 vendors = &#123;Webkit: &apos;webkit&apos;, Moz: &apos;&apos;, O: &apos;o&apos;&#125;, testEl = document.createElement(&apos;div&apos;), //支持的过渡、动画效果 supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i, transform, //过渡 transitionProperty, transitionDuration, transitionTiming, transitionDelay, //动画 animationName, animationDuration, animationTiming, animationDelay, cssReset = &#123;&#125;; //将字符串转成css属性，如aB--&gt;a-b function dasherize(str) &#123; return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase() &#125; //修正事件名(如果不支持css3标准语法，则为事件添加前缀) function normalizeEvent(name) &#123; return eventPrefix ? eventPrefix + name : name.toLowerCase() &#125; //如果不支持css3标准，那么为样式加上内核厂商前缀 if (testEl.style.transform === undefined) $.each(vendors, function (vendor, event) &#123; if (testEl.style[vendor + &apos;TransitionProperty&apos;] !== undefined) &#123; prefix = &apos;-&apos; + vendor.toLowerCase() + &apos;-&apos;; eventPrefix = event; return false &#125; &#125;); //将transform设置为兼容性写法 transform = prefix + &apos;transform&apos;; cssReset[transitionProperty = prefix + &apos;transition-property&apos;] = cssReset[transitionDuration = prefix + &apos;transition-duration&apos;] = cssReset[transitionDelay = prefix + &apos;transition-delay&apos;] = cssReset[transitionTiming = prefix + &apos;transition-timing-function&apos;] = cssReset[animationName = prefix + &apos;animation-name&apos;] = cssReset[animationDuration = prefix + &apos;animation-duration&apos;] = cssReset[animationDelay = prefix + &apos;animation-delay&apos;] = cssReset[animationTiming = prefix + &apos;animation-timing-function&apos;] = &apos;&apos;; $.fx = &#123; //判断是否支持css3的过渡及动画，如果即不支持css3的标准语法同时不支持带前缀的兼容形式，那么判断为不支持 off: (eventPrefix === undefined &amp;&amp; testEl.style.transitionProperty === undefined), speeds: &#123;_default: 400, fast: 200, slow: 600&#125;, cssPrefix: prefix, transitionEnd: normalizeEvent(&apos;TransitionEnd&apos;), animationEnd: normalizeEvent(&apos;AnimationEnd&apos;) &#125;; /** * 自定义动画 * properties:属性对象 * duration:过渡的时间，_default/fast/slow/数字 * ease:变化的速率曲线，ease、linear、ease-in / ease-out、ease-in-out * callback:回调函数 * delay:延迟时间 * 并不是完全意义上的校验函数参数 * 只有&apos;function(properties,callback)&apos;、&apos;function(properties,duration,callback))&apos;、&apos;function(properties,duration,easing,callback,delay))&apos; * &apos;function(properties,&#123;duration: msec, easing: type, complete: fn &#125;&apos;、&apos;function(animationName, &#123;&#125;&apos;几种格式 * * */ $.fn.animate = function (properties, duration, ease, callback, delay) &#123; // 传参为function(properties,callback) if ($.isFunction(duration)) callback = duration, ease = undefined, duration = undefined; // 传参为function(properties,duration，callback) if ($.isFunction(ease)) callback = ease, ease = undefined; //传参为function(properties, &#123;&#125;) if ($.isPlainObject(duration)) ease = duration.easing, callback = duration.complete, delay = duration.delay, duration = duration.duration; if (duration) duration = (typeof duration == &apos;number&apos; ? duration : ($.fx.speeds[duration] || $.fx.speeds._default)) / 1000; if (delay) delay = parseFloat(delay) / 1000; return this.anim(properties, duration, ease, callback, delay) &#125;; $.fn.anim = function (properties, duration, ease, callback, delay) &#123; var key, cssValues = &#123;&#125;, cssProperties, transforms = &apos;&apos;, that = this, wrappedCallback, endEvent = $.fx.transitionEnd, fired = false; //修正好时间 if (duration === undefined) duration = $.fx.speeds._default / 1000; //修正好延迟 if (delay === undefined) delay = 0; //如果浏览器不支持动画，持续时间设为0，直接跳动画结束 if ($.fx.off) duration = 0; //css3动画:keyframe animation if (typeof properties == &apos;string&apos;) &#123; cssValues[animationName] = properties; cssValues[animationDuration] = duration + &apos;s&apos;; cssValues[animationDelay] = delay + &apos;s&apos;; cssValues[animationTiming] = (ease || &apos;linear&apos;); endEvent = $.fx.animationEnd; &#125; else &#123; cssProperties = []; // CSS3的过渡 for (key in properties) //用于传参时&#123;&quot;rotateX&quot;: &quot;120deg&quot;&#125;这种形式的properties，正常情况下是&quot;transform&quot;: &quot;rotateX(120deg)&quot; if (supportedTransforms.test(key)) transforms += key + &apos;(&apos; + properties[key] + &apos;) &apos;; else cssValues[key] = properties[key], cssProperties.push(dasherize(key)); if (transforms) cssValues[transform] = transforms, cssProperties.push(transform); if (duration &gt; 0 &amp;&amp; typeof properties === &apos;object&apos;) &#123; cssValues[transitionProperty] = cssProperties.join(&apos;, &apos;); cssValues[transitionDuration] = duration + &apos;s&apos;; cssValues[transitionDelay] = delay + &apos;s&apos;; cssValues[transitionTiming] = (ease || &apos;linear&apos;) &#125; &#125; //动画完成后的响应函数 wrappedCallback = function (event) &#123; event = undefined; //动画完成后移除监听函数 if (typeof event !== &apos;undefined&apos;) &#123; //如果监听函数不是设置在事件发生元素上，而是元素的祖先元素，通过向上冒泡触发的，那么不能移除 if (event.target !== event.currentTarget) return; // makes sure the event didn&apos;t bubble from &quot;below&quot; $(event.target).unbind(endEvent, wrappedCallback) &#125; else $(this).unbind(endEvent, wrappedCallback); // triggered by setTimeout fired = true; //动画完成后，将过渡和动画样式重置为空 $(this).css(cssReset); callback &amp;&amp; callback.call(this); &#125;; //处理动画结束事件 if (duration &gt; 0) &#123; this.bind(endEvent, wrappedCallback); // transitionEnd is not always firing on older Android phones // so make sure it gets fired //延时ms后执行动画，注意这里加了25ms，保持endEvent，动画先执行完。 //旧的android手机不一定总是会调用transitionEnd回调函数，所以在动画执行完后进行判断，如果没有执行则自己手动调用 setTimeout(function () &#123; if (fired) return; wrappedCallback.call(that) &#125;, ((duration + delay) * 1000) + 25) &#125; /** * 主动触发页面回流，刷新DOM，让接下来设置的动画可以正确播放 * 更改 offsetTop、offsetLeft、offsetWidth、offsetHeight； * scrollTop、scrollLeft、scrollWidth、scrollHeight； * clientTop、clientLeft、clientWidth、clientHeight； * getComputedStyle()、currentStyle()，这些都会触发回流。 * 回流导致DOM重新渲染，平时要尽可能避免。 * 但这里，为了动画即时生效播放，则主动触发回流，刷新DOM * */ this.size() &amp;&amp; this.get(0).clientLeft //设置样式，启动动画 this.css(cssValues); //duration为0，即浏览器不支持动画的情况，直接执行动画结束，执行回调。 if (duration &lt;= 0) setTimeout(function () &#123; that.each(function () &#123; wrappedCallback.call(this) &#125;) &#125;, 0); return this &#125;; testEl = null;&#125;)(Zepto); 二、源码分析1、添加前缀首先判断是否支持标准语法testEl.style.transform === undefined，如果不支持则遍历 Webkit、Moz、O 前缀判断是否有相应前缀语法testEl.style[vendor + &#39;TransitionProperty&#39;] !== undefined，为属性添加相应内核前缀。如果既不支持标准语法，也不支持兼容的加前缀语法，那么设置过渡时间为 0，直接跳转到结束。 2、transitionEnd &amp; animationEnd通过监听 transitionEnd/animationEnd 来执行过渡/动画结束回调函数。有个奇怪的现象：测试对象是google浏览器，支持标准语法，设置的是标准浏览器 css 语法，那么可以同时监听多个 animationend 事件，如果既有 animationend 也有 webkitAnimationEnd，webkitAnimationEnd 无效，单独监听 webkitAnimationEnd 是有效果的。如果浏览器设置的是兼容浏览器版本 css 语法，那么 webkitAnimationEnd 和 animationend事件均有效。案例如下:123456789101112131415var div1 = $(&apos;#foo1&apos;);div1.animate(&#123; &quot;width&quot;: &quot;300px&quot;, &quot;height&quot;: &quot;300px&quot; &#125;, &apos;slow&apos;, &apos;ease-in-out&apos;, function () &#123; console.log(&apos;div1 animate callback&apos;); &#125;, &apos;2000&apos;);div1[0].addEventListener(&apos;transitionend&apos;, function () &#123; console.log(&apos;transitionend&apos;);&#125;);div1[0].addEventListener(&apos;webkitTransitionEnd&apos;, function () &#123; console.log(&apos;webkitTransitionEnd&apos;);&#125;); 有的老 android 手机不一定总是会触发 transitionEnd/animationEnd，可以用定时器来触发，如果触发了设置标志量 fired 为 true，然后定时器设置过渡和动画都执行完再调用，执行时判断 fired，如果为 true 则不操作，否则手动调用完成回调函数。在设置的监听回调函数中，效果执行完成后会重置过渡/动画样式为空，同时移除监听。有个情况需要特别注意，如果是子元素触发冒泡上来的，那么不能移除监听和重置样式。 3、页面回流在设置了新的样式后，主动触发页面回流，刷新 DOM，让接下来设置的过渡/动画可以正常执行。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 deferred.js","slug":"zepto/deferredJs","date":"2017-07-29T02:05:17.000Z","updated":"2018-04-18T06:21:24.000Z","comments":true,"path":"zepto/deferredJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/deferredJs/","excerpt":"zepto 的 deferred 模块，实现了 promise，可使 ajax 请求摆脱回调地狱，使用链式调用。","text":"zepto 的 deferred 模块，实现了 promise，可使 ajax 请求摆脱回调地狱，使用链式调用。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//提供 $.Deferred promises API. 依赖&quot;callbacks&quot; 模块.(function ($) &#123; var slice = Array.prototype.slice; function Deferred(func) &#123; var tuples = [ // 状态切换方法名、对应状态执行方法名、函数回调列表、最终状态 [&quot;resolve&quot;, &quot;done&quot;, $.Callbacks(&#123;once: 1, memory: 1&#125;), &quot;resolved&quot;], [&quot;reject&quot;, &quot;fail&quot;, $.Callbacks(&#123;once: 1, memory: 1&#125;), &quot;rejected&quot;], [&quot;notify&quot;, &quot;progress&quot;, $.Callbacks(&#123;memory: 1&#125;)] ], //Promise的初始状态 state = &quot;pending&quot;, /** * promise只包含执行阶段的方法always(),then(),done(),fail(),progress()及辅助方法state()、promise()等。 * deferred则在继承promise的基础上，增加切换状态的方法，resolve()/resolveWith(),reject()/rejectWith(),notify()/notifyWith() * 所以称promise是deferred的只读副本 * */ promise = &#123; // 返回promise状态 state: function () &#123; return state &#125;, //成功/失败均回调调用 always: function () &#123; deferred.done(arguments).fail(arguments); return this &#125;, then: function (/* fnDone [, fnFailed [, fnProgress]] */) &#123; var fns = arguments; //生成新的deferred，即defer；并为旧deferred添加新的回调函数；返回新的promise对象，then方法后的回调会被添加到新的回调函数列表中 return Deferred(function (defer) &#123; $.each(tuples, function (i, tuple) &#123; //i==0:fnDone；i==1:fnFailed；i==2:fnProgress var fn = $.isFunction(fns[i]) &amp;&amp; fns[i]; //为旧deferred的done/fail/progress方法添加回调函数，回调函数不会立即执行 deferred[tuple[1]](function () &#123; //旧deferred状态切换方法名触发时，调用相应的then函数参数 var returned = fn &amp;&amp; fn.apply(this, arguments); /** * 如果then的函数参数调用返回了值，而且值存在promise方法，那么执行promise方法， * 并将defer的resolve/reject/notify添加到promise的done/fail/progress中， * 如果返回的继承promise的对象状态被切换，那么defer的相应状态切换方法同时被调用 * */ if (returned &amp;&amp; $.isFunction(returned.promise)) &#123; returned.promise() .done(defer.resolve) .fail(defer.reject) .progress(defer.notify) &#125; else &#123; /** * 如果then方法有返回值，则新defer的所有回调函数都使用该值作为参数，否则使用旧deferred回调参数 * 在非严格模式下，this为null或undefined时为被自动替换成全局对象window * */ var context = this === promise ? defer.promise() : this, values = fn ? [returned] : arguments; defer[tuple[0] + &quot;With&quot;](context, values) &#125; &#125;) &#125;); fns = null &#125;).promise() &#125;, //如果存在obj，则将promise对象的方法赋值给obj；否则返回promise对象 promise: function (obj) &#123; return obj != null ? $.extend(obj, promise) : promise &#125; &#125;, deferred = &#123;&#125;; //给deferred添加切换状态方法 $.each(tuples, function (i, tuple) &#123; var list = tuple[2], //回调函数列表 stateString = tuple[3]; //promise最终状态 //扩展promise的done、fail、progress为Callback的add方法，使其成为回调列表，使用的时候.done(func) func就添加到了回调函数中 promise[tuple[1]] = list.add; /** * 切换的状态是resolve成功/reject失败；添加首组方法做预处理，修改state的值，使成功或失败互斥； * disable后就算上次触发了add时还是不会立即执行，memory被设置为undefined * 锁定progress回调列表，锁定后progress回调列表不能再被触发 * */ if (stateString) &#123; list.add(function () &#123; state = stateString; //i^1 ^异或运算符 0^1=1 1^1=0，成功或失败回调互斥，调用一方，禁用另一方 &#125;, tuples[i ^ 1][2].disable, tuples[2][2].lock) &#125; //添加切换状态方法 resolve()/resolveWith(),reject()/rejectWith(),notify()/notifyWith() deferred[tuple[0]] = function () &#123; deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments); return this &#125;; deferred[tuple[0] + &quot;With&quot;] = list.fireWith &#125;); //deferred包装成promise 继承promise对象的方法 promise.promise(deferred); //传递了参数func，执行 if (func) func.call(deferred, deferred); //返回deferred对象 return deferred &#125; //主要用于多异步队列处理：多异步队列都成功，执行成功方法，一个失败，执行失败方法。也可以传非异步队列对象 $.when = function (sub) &#123; var resolveValues = slice.call(arguments), //队列个数 len = resolveValues.length, i = 0, //子deferred计数 remain = len !== 1 || (sub &amp;&amp; $.isFunction(sub.promise)) ? len : 0, //主def，如果是1个fn，直接以它为主def，否则建立新的Def deferred = remain === 1 ? sub : Deferred(), progressValues, progressContexts, resolveContexts, updateFn = function (i, ctx, val) &#123; return function (value) &#123; ctx[i] = this; val[i] = arguments.length &gt; 1 ? slice.call(arguments) : value; if (val === progressValues) &#123; //如果是通知，调用主函数的通知，通知可以调用多次 deferred.notifyWith(ctx, val) &#125; else if (!(--remain)) &#123; //如果是成功，则需等成功计数为0，即所有子def都成功执行了，remain变为0，再调用主函数的成功 deferred.resolveWith(ctx, val) &#125; &#125; &#125;; //如果参数列表长度大于一，那么校验是否为promise对象，如果不是则将remain减一 if (len &gt; 1) &#123; progressValues = new Array(len); progressContexts = new Array(len); resolveContexts = new Array(len); for (; i &lt; len; ++i) &#123; if (resolveValues[i] &amp;&amp; $.isFunction(resolveValues[i].promise)) &#123; resolveValues[i].promise() .done(updateFn(i, resolveContexts, resolveValues)) .fail(deferred.reject) //直接挂入主def的失败通知函数,当某个子def失败时，调用主def的切换失败状态方法，执行主def的失败函数列表 .progress(updateFn(i, progressContexts, progressValues)) &#125; else &#123; //非def，直接标记成功，减1 --remain &#125; &#125; &#125; //比如无参数，或者所有子队列全为非def，直接切换到成功状态，后面就算返回了promise对象，添加的回调函数也不会被触发 if (!remain) deferred.resolveWith(resolveContexts, resolveValues); return deferred.promise() &#125;; $.Deferred = Deferred&#125;)(Zepto); 二、源码分析1、关于 this在 apply 方法中，如果 this 的为 null，那么在非严格模式下，this 会被自动替换为全局对象 window(call 方法同)。 2、关于回调函数所有的 done、fail、always 只是往回调列表数组中添加函数而已，回调列表数组由 callbacks 模块提供。 3、deferred &amp; promisepromise 只包含执行阶段的方法 always(),then(),done(),fail(),progress() 及辅助方法 state()、promise() 等。deferred 继承了 promise 所有方法，同时增加切换状态的方法，resolve()/resolveWith(),reject()/rejectWith(),notify()/notifyWith()，所以说 promise 是 deferred 的只读副本。而且 deferred 切换状态时，会把其他状态的回调函数列表进行禁用或者上锁(callbacks 模块)，成功/失败回调切换都只能调用一次，通知回调可以调用多次，实现了 promise 规范的只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换限制。 4、then 方法如果 then 方法返回一个新的 promise 对象，那么将新 deferred 的状态切换函数添加到返回的 promise 对象的回调函数列表中，这样当返回的 promise 的回调函数被调用时，新的 deferred 对象状态切换函数也会被调用，而且 then 方法后的回调函数同时被执行。如果返回的不是 promise 对象，那么直接调用回调函数。 5、when 方法用来处理同时多个 promise。新建一个新的 deferred 对象，如果一个 promise 的失败回调函数被执行，那么 deferred 对象直接执行失败回调函数，由于 callbacks 模块的处理，所以失败回调函数只会被调用一次；如果 promise 的成功回调函数被执行，那么将 remain 计数器减一，直到计数器减到 0(即所有的 promise 都被处理了)，deferred 对象才执行成功回调函数。 三、promise 规范它的规范内容大致如下 一个 promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） 一个 promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 promise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类 then”的对象或方法，即 thenable 对象 四、案例1234567891011121314151617181920212223242526272829$.ajax(&#123; type: &apos;GET&apos;, // type: &apos;POST&apos;, url: &apos;/projects.json&apos;, dataType: &apos;json&apos;, timeout: 300, success: function(data) &#123; console.log(data); &#125;, error: function(xhr, type) &#123; alert(&apos;Ajax error!&apos;); &#125;&#125;).done(function() &#123; console.info(&quot;done&quot;);&#125;).fail(function() &#123; console.info(&quot;fail&quot;);&#125;).always(function() &#123; console.info(&quot;always&quot;);&#125;) //then 三个参数 第一个是成功后回掉，第二个是失败，第三个是运行中.then(function() &#123; console.info(&quot;then1&quot;);&#125;, function() &#123; console.info(&quot;then2&quot;);&#125;, function() &#123; console.info(&quot;then3&quot;);&#125;);//成功回调：done always then1//失败回调：alert(&apos;Ajax error!&apos;) fail always then2 案例一12345678910111213141516171819var wait = function (dtd) &#123; var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function () &#123; console.log(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks, 1000); return dtd.promise(); // 返回promise对象 // 返回dtd.promise 因其没有resolve和reject方法，所以在外面不能该调用这两个方法改变状态&#125;;$.when(wait()).done(function () &#123; console.log(&quot;哈哈，成功了！&quot;);&#125;).fail(function () &#123; console.log(&quot;出错啦！&quot;);&#125;);//执行完毕！//哈哈，成功了！ 案例二","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 callbacks.js","slug":"zepto/callbacksJs","date":"2017-07-27T09:40:41.000Z","updated":"2018-04-18T02:45:04.000Z","comments":true,"path":"zepto/callbacksJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/callbacksJs/","excerpt":"callbacks 用来管理回调函数，也作为 deferred 延迟对象的基础部分。","text":"callbacks 用来管理回调函数，也作为 deferred 延迟对象的基础部分。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//为&quot;deferred&quot;模块提供 $.Callbacks。(function ($) &#123; // Create a collection of callbacks to be fired in a sequence, with configurable behaviour // Option flags: // - once: 回调只能触发一次 // - memory: 记住最近的上下文和参数，如果memory为true则添加的时候会执行一次 // - stopOnFalse: 当某个回调函数返回false时中断执行 // - unique: 一个回调函数只能被添加一次 $.Callbacks = function (options) &#123; options = $.extend(&#123;&#125;, options); var memory, // 记录上一次触发回调函数列表时的参数，之后添加的函数都用这参数立即执行 fired, // 是否回调过标志量 firing, // 回调函数列表是否正在执行中 firingStart, // 开始回调函数的下标 firingLength, // 回调函数列表长度 firingIndex, // 回调列表索引值 list = [], // 回调数据源:回调列表 stack = !options.once &amp;&amp; [], //回调只能触发一次的时候，stack永远为false；多次触发永远为数组 //触发回调底层函数 fire = function (data) &#123; memory = options.memory &amp;&amp; data; fired = true; firingIndex = firingStart || 0; firingStart = 0; firingLength = list.length; firing = true; //遍历回调列表，全部回调函数都执行，参数是传递过来的data for (; list &amp;&amp; firingIndex &lt; firingLength; ++firingIndex) &#123; //如果 list[ firingIndex ] 为false，且stopOnFalse（中断）模式，则中断回掉执行，设置memory为false if (list[firingIndex].apply(data[0], data[1]) === false &amp;&amp; options.stopOnFalse) &#123; memory = false; break &#125; &#125; //回调执行完毕 firing = false; if (list) &#123; //stack里还缓存有未执行的回调，则执行stack里的回调 if (stack) stack.length &amp;&amp; fire(stack.shift()); //如果只执行一次而且memory为true(类型转换),那么清空回调函数(不禁用是因为设置了memory，add执行时会调用) else if (memory) list.length = 0; //如果只执行一次而且memory为false(类型转换),那么禁用回调函数 else Callbacks.disable(); &#125; &#125;, Callbacks = &#123; //添加回调函数 add: function () &#123; if (list) &#123; var start = list.length, add = function (args) &#123; $.each(args, function (_, arg) &#123; if (typeof arg === &quot;function&quot;) &#123; //非unique，或者是unique，但回调列表未添加过 if (!options.unique || !Callbacks.has(arg)) list.push(arg) &#125; //是数组/伪数组，添加，重新遍历 else if (arg &amp;&amp; arg.length &amp;&amp; typeof arg !== &apos;string&apos;) add(arg) &#125;) &#125;; //添加进列表 add(arguments); //如果列表正在执行中，修正长度，使得新添加的回调也可以执行 if (firing) firingLength = list.length; else if (memory) &#123; //memory 模式下，修正开始下标 firingStart = start; //立即执行所有回调 fire(memory) &#125; &#125; return this &#125;, //从回调列表里删除一个或一组回调函数 remove: function () &#123; if (list) &#123; $.each(arguments, function (_, arg) &#123; var index; while ((index = $.inArray(arg, list, index)) &gt; -1) &#123; list.splice(index, 1); // Handle firing indexes if (firing) &#123; //避免回调列表溢出 if (index &lt;= firingLength) --firingLength; //如果移除的函数已经执行过了，则将迭代下标减一，否则会漏掉回调函数没执行 if (index &lt;= firingIndex) --firingIndex &#125; &#125; &#125;) &#125; return this &#125;, //检查指定的回调函数是否在回调列表中；如果参数为空，则方法用来表明是否存在回调函数 has: function (fn) &#123; return !!(list &amp;&amp; (fn ? $.inArray(fn, list) &gt; -1 : list.length)) &#125;, //清空回调函数 empty: function () &#123; firingLength = list.length = 0; return this &#125;, //禁用回调函数 disable: function () &#123; list = stack = memory = undefined; return this &#125;, //是否禁用了回调函数 disabled: function () &#123; return !list &#125;, //锁定回调函数 lock: function () &#123; stack = undefined; //非memory模式下，禁用列表 if (!memory) Callbacks.disable(); return this &#125;, //是否是锁定的(一次性调用的时，为true) locked: function () &#123; return !stack &#125;, //用上下文、参数执行列表中的所有回调函数 fireWith: function (context, args) &#123; //如果调用过一次了fired被设置为true，如果设置once为true的话(可类型转换)，则不执行回调函数 if (list &amp;&amp; (!fired || stack)) &#123; args = args || []; args = [context, args.slice ? args.slice() : args]; //正在回调中,存入stack if (firing) stack.push(args); //否则立即回调,外层fire函数 else fire(args); &#125; return this &#125;, //执行回调 fire: function () &#123; return Callbacks.fireWith(this, arguments) &#125;, //回调列表是否被回调过 fired: function () &#123; return !!fired &#125; &#125;; return Callbacks &#125;&#125;)(Zepto); 二、源码解析1、Option once设置一个标志量为 fired，第一次调用 fire 方法时设置为 true，下次再次调用时判断 stack(由 once 值决定)决定是否执行回调列表函数； 2、Option memory记住上次 fire 的回调参数，下次 add 时判断 memory 值，如果为 true(类型转换)则将 add 方法参数里面的回调函数执行一次，参数为 memory； 3、数组移除使用 $.inArray(arg, list, index)) 判断是否存在数组中，并且记录索引值；如果出现了，则移除并从当前记住索引值开始继续判断。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 ajax.js","slug":"zepto/ajaxJs","date":"2017-07-26T01:33:44.000Z","updated":"2018-04-18T02:43:05.000Z","comments":true,"path":"zepto/ajaxJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/ajaxJs/","excerpt":"$.ajax是 zepto 发送请求的核心方法，$.get,$.post,$.jsonp都是封装了$.ajax方法。$.ajax将 jsonp 与异步请求的代码格式统一起来，内部主要是先处理url、数据和请求头部，然后新建 XMLHttpRequest 对象发送请求。","text":"$.ajax是 zepto 发送请求的核心方法，$.get,$.post,$.jsonp都是封装了$.ajax方法。$.ajax将 jsonp 与异步请求的代码格式统一起来，内部主要是先处理url、数据和请求头部，然后新建 XMLHttpRequest 对象发送请求。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463(function ($) &#123; var jsonpID = +new Date(), document = window.document, key, name, rscript = /&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi, scriptTypeRE = /^(?:text|application)\\/javascript/i, xmlTypeRE = /^(?:text|application)\\/xml/i, jsonType = &apos;application/json&apos;, htmlType = &apos;text/html&apos;, blankRE = /^\\s*$/, originAnchor = document.createElement(&apos;a&apos;); originAnchor.href = window.location.href; //触发自定义事件并且如果阻止默认事件触发返回false function triggerAndReturn(context, eventName, data) &#123; var event = $.Event(eventName); $(context).trigger(event, data); return !event.isDefaultPrevented() &#125; //触发ajax的全局事件 function triggerGlobal(settings, context, eventName, data) &#123; if (settings.global) return triggerAndReturn(context || document, eventName, data) &#125; //正在ajax请求数量 $.active = 0; //第一次ajax触发时触发,绑定在document上 function ajaxStart(settings) &#123; if (settings.global &amp;&amp; $.active++ === 0) triggerGlobal(settings, null, &apos;ajaxStart&apos;) &#125; //所有ajax都已经停止触发,绑定在document上 function ajaxStop(settings) &#123; if (settings.global &amp;&amp; !(--$.active)) triggerGlobal(settings, null, &apos;ajaxStop&apos;) &#125; //触发beforeSend事件或全局ajaxBeforeSend事件，如果有一个返回false,则取消此次请求；否则触发ajaxSend全局事件 function ajaxBeforeSend(xhr, settings) &#123; var context = settings.context; if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, &apos;ajaxBeforeSend&apos;, [xhr, settings]) === false) return false; triggerGlobal(settings, context, &apos;ajaxSend&apos;, [xhr, settings]) &#125; //请求成功调用函数 function ajaxSuccess(data, xhr, settings, deferred) &#123; var context = settings.context, status = &apos;success&apos;; settings.success.call(context, data, status, xhr); if (deferred) deferred.resolveWith(context, [data, status, xhr]); triggerGlobal(settings, context, &apos;ajaxSuccess&apos;, [xhr, settings, data]); ajaxComplete(status, xhr, settings) &#125; //请求失败调用函数 type: &quot;timeout&quot;, &quot;error&quot;, &quot;abort&quot;, &quot;parsererror&quot; function ajaxError(error, type, xhr, settings, deferred) &#123; var context = settings.context; settings.error.call(context, xhr, type, error); if (deferred) deferred.rejectWith(context, [xhr, type, error]); triggerGlobal(settings, context, &apos;ajaxError&apos;, [xhr, settings, error || type]); ajaxComplete(type, xhr, settings) &#125; //请求完成调用函数 status: &quot;success&quot;, &quot;notmodified&quot;, &quot;error&quot;, &quot;timeout&quot;, &quot;abort&quot;, &quot;parsererror&quot; function ajaxComplete(status, xhr, settings) &#123; var context = settings.context; settings.complete.call(context, xhr, status); triggerGlobal(settings, context, &apos;ajaxComplete&apos;, [xhr, settings]); ajaxStop(settings) &#125; //执行自定义过滤函数 function ajaxDataFilter(data, type, settings) &#123; if (settings.dataFilter == empty) return data; var context = settings.context; return settings.dataFilter.call(context, data, type) &#125; // Empty function, used as default callback function empty() &#123; &#125; $.ajaxJSONP = function (options, deferred) &#123; if (!(&apos;type&apos; in options)) return $.ajax(options) var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || (&apos;Zepto&apos; + (jsonpID++)), script = document.createElement(&apos;script&apos;), originalCallback = window[callbackName], responseData, abort = function (errorType) &#123; $(script).triggerHandler(&apos;error&apos;, errorType || &apos;abort&apos;) &#125;, xhr = &#123;abort: abort&#125;, abortTimeout if (deferred) deferred.promise(xhr) $(script).on(&apos;load error&apos;, function (e, errorType) &#123; clearTimeout(abortTimeout) $(script).off().remove() if (e.type == &apos;error&apos; || !responseData) &#123; ajaxError(null, errorType || &apos;error&apos;, xhr, options, deferred) &#125; else &#123; ajaxSuccess(responseData[0], xhr, options, deferred) &#125; window[callbackName] = originalCallback if (responseData &amp;&amp; $.isFunction(originalCallback)) originalCallback(responseData[0]) originalCallback = responseData = undefined &#125;) if (ajaxBeforeSend(xhr, options) === false) &#123; abort(&apos;abort&apos;) return xhr &#125; window[callbackName] = function () &#123; responseData = arguments &#125; script.src = options.url.replace(/\\?(.+)=\\?/, &apos;?$1=&apos; + callbackName) document.head.appendChild(script) if (options.timeout &gt; 0) abortTimeout = setTimeout(function () &#123; abort(&apos;timeout&apos;) &#125;, options.timeout) return xhr &#125;; //包含Ajax请求的默认设置的全局对象 $.ajaxSettings = &#123; // Default type of request type: &apos;GET&apos;, // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // The context for the callbacks context: null, // Whether to trigger &quot;global&quot; Ajax events global: true, // Transport xhr: function () &#123; return new window.XMLHttpRequest() &#125;, // MIME types mapping // IIS returns Javascript as &quot;application/x-javascript&quot; accepts: &#123; script: &apos;text/javascript, application/javascript, application/x-javascript&apos;, json: jsonType, xml: &apos;application/xml, text/xml&apos;, html: htmlType, text: &apos;text/plain&apos; &#125;, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty &#125;; //根据媒体类型获取dataType:html,json,scirpt,xml,text等 function mimeToDataType(mime) &#123; if (mime) mime = mime.split(&apos;;&apos;, 2)[0]; return mime &amp;&amp; ( mime == htmlType ? &apos;html&apos; : mime == jsonType ? &apos;json&apos; : scriptTypeRE.test(mime) ? &apos;script&apos; : xmlTypeRE.test(mime) &amp;&amp; &apos;xml&apos; ) || &apos;text&apos; &#125; //将查询参数追加到URL后面 function appendQuery(url, query) &#123; if (query == &apos;&apos;) return url; return (url + &apos;&amp;&apos; + query).replace(/[&amp;?]&#123;1,2&#125;/, &apos;?&apos;) &#125; // serialize payload and append it to the URL for GET requests function serializeData(options) &#123; //对于非Get请求。是否自动将data转换为字符串 if (options.processData &amp;&amp; options.data &amp;&amp; $.type(options.data) != &quot;string&quot;) options.data = $.param(options.data, options.traditional); //get请求，将序列化的数据追加到url后面 if (options.data &amp;&amp; (!options.type || options.type.toUpperCase() == &apos;GET&apos; || &apos;jsonp&apos; == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined &#125; $.ajax = function (options) &#123; var settings = $.extend(&#123;&#125;, options || &#123;&#125;), deferred = $.Deferred &amp;&amp; $.Deferred(), urlAnchor, hashIndex; //复制默认配置值到选项中(如果选项中没设置) for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]; //触发ajaxStart时间，可在document进行监听 ajaxStart(settings); //判断是否跨域(通过页面url和接口url进行比较,判断ip协议和端口号是否相等) if (!settings.crossDomain) &#123; urlAnchor = document.createElement(&apos;a&apos;); urlAnchor.href = settings.url; //解决ie的hack urlAnchor.href = urlAnchor.href; settings.crossDomain = (originAnchor.protocol + &apos;//&apos; + originAnchor.host) !== (urlAnchor.protocol + &apos;//&apos; + urlAnchor.host) &#125; //未设置url，取当前地址栏(如果有hash，截掉hash) if (!settings.url) settings.url = window.location.toString(); if ((hashIndex = settings.url.indexOf(&apos;#&apos;)) &gt; -1) settings.url = settings.url.slice(0, hashIndex); serializeData(settings); ///\\?.+=\\?/.test(settings.url):有xxx.html?a=1?=cccc类似形式，为jsonp var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url); if (hasPlaceholder) dataType = &apos;jsonp&apos;; //不设置缓存，加时间戳 &apos;_=&apos; + Date.now() if (settings.cache === false || ( (!options || options.cache !== true) &amp;&amp; (&apos;script&apos; == dataType || &apos;jsonp&apos; == dataType) )) settings.url = appendQuery(settings.url, &apos;_=&apos; + Date.now()); //如果是jsonp,调用$.ajaxJSONP,不走XHR，走script if (&apos;jsonp&apos; == dataType) &#123; if (!hasPlaceholder) //判断url是否有类似jsonp的参数 settings.url = appendQuery(settings.url, settings.jsonp ? (settings.jsonp + &apos;=?&apos;) : settings.jsonp === false ? &apos;&apos; : &apos;callback=?&apos;); return $.ajaxJSONP(settings, deferred) &#125; //媒体类型 var mime = settings.accepts[dataType], headers = &#123;&#125;, //设置请求头的方法 setHeader = function (name, value) &#123; headers[name.toLowerCase()] = [name, value] &#125;, //如果URL没协议，读取本地URL的协议 protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = settings.xhr(), nativeSetHeader = xhr.setRequestHeader, abortTimeout; //将xhr设为只读Deferred对象，不能更改状态 if (deferred) deferred.promise(xhr); //如果没有跨域(x-requested-with XMLHttpRequest 表明是AJax异步;x-requested-with null 表明同步,浏览器工具栏未显示,在后台request可以获取到) if (!settings.crossDomain) setHeader(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;); setHeader(&apos;Accept&apos;, mime || &apos;*/*&apos;); if (mime = settings.mimeType || mime) &#123; //媒体数据源里对应多个，如 script: &apos;text/javascript, application/javascript, application/x-javascript&apos;,设置最新的写法 if (mime.indexOf(&apos;,&apos;) &gt; -1) mime = mime.split(&apos;,&apos;, 2)[0]; //对Mozilla的修正 xhr.overrideMimeType &amp;&amp; xhr.overrideMimeType(mime) &#125; /** * Content-Type: 内容类型指定响应的HTTP内容类型。决定浏览器将以什么形式、什么编码读取这个文件. 如果未指定ContentType，默认为TEXT/HTML。 * 当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2...），然后把这个字串append到 * url后面，用?分割，加载这个新的url；当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 * 如果method==get，则请求头部不用设置Content-Type，若method==post，则请求头部的Content-Type默认设置&apos;application/x-www-form-urlencoded&apos; * */ if (settings.contentType || (settings.contentType !== false &amp;&amp; settings.data &amp;&amp; settings.type.toUpperCase() != &apos;GET&apos;)) setHeader(&apos;Content-Type&apos;, settings.contentType || &apos;application/x-www-form-urlencoded&apos;); //设置请求头 if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]) xhr.setRequestHeader = setHeader; xhr.onreadystatechange = function () &#123; /** 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 */ if (xhr.readyState == 4) &#123; xhr.onreadystatechange = empty; //使用了闭包 clearTimeout(abortTimeout); var result, error = false; /** * 根据状态来判断请求是否成功 * &gt;=200 &amp;&amp; &lt; 300 表示成功 * 304 文件未修改 成功 * xhr.status == 0 &amp;&amp; protocol == &apos;file:&apos; 未请求，打开的本地文件，非localhost ip形式 * */ if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 || (xhr.status == 0 &amp;&amp; protocol == &apos;file:&apos;)) &#123; //getResponseHeader:从响应信息中获取指定的http头 dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader(&apos;content-type&apos;)); //响应值 if (xhr.responseType == &apos;arraybuffer&apos; || xhr.responseType == &apos;blob&apos;) result = xhr.response; else &#123; result = xhr.responseText; try &#123; /** * http://perfectionkills.com/global-eval-what-are-the-options/ * sanitize response accordingly if data filter callback provided * (1,eval)(result) (1,eval)这是一个典型的逗号操作符，返回最右边的值 * (1,eval) eval 的区别是:前者是一个值，不可以再覆盖。后者是变量,如var a = 1; (1,a) = 1;会报错； * (1,eval)(result) eval(result) 的区别是:前者变成值后，只能读取window域下的变量。而后者，遵循作用域链，从局部变量上溯到window域 * 显然(1,eval)(result) 避免了作用域链的上溯操作，性能更好 * */ result = ajaxDataFilter(result, dataType, settings); if (dataType == &apos;script&apos;) (1, eval)(result); else if (dataType == &apos;xml&apos;) result = xhr.responseXML; else if (dataType == &apos;json&apos;) result = blankRE.test(result) ? null : $.parseJSON(result) &#125; catch (e) &#123; error = e &#125; //解析出错，抛出 &apos;parsererror&apos;事件 if (error) return ajaxError(error, &apos;parsererror&apos;, xhr, settings, deferred) &#125; //执行success ajaxSuccess(result, xhr, settings, deferred) &#125; else &#123; //如果请求出错,xhr.status = 0 / null 执行abort,其他执行error ajaxError(xhr.statusText || null, xhr.status ? &apos;error&apos; : &apos;abort&apos;, xhr, settings, deferred) &#125; &#125; &#125;; //执行请求前置器,若返回false则中断请求 if (ajaxBeforeSend(xhr, settings) === false) &#123; xhr.abort(); ajaxError(null, &apos;abort&apos;, xhr, settings, deferred); return xhr &#125; // 这是一个小技巧，默认async为true，若settings里面设置了，则为设置的值 var async = &apos;async&apos; in settings ? settings.async : true; //准备xhr请求 xhr.open(settings.type, settings.url, async, settings.username, settings.password); //对象包含的属性被逐字复制到XMLHttpRequest的实例(如设置跨域凭证withCredentials) if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name] //设置请求头 for (name in headers) nativeSetHeader.apply(xhr, headers[name]) //超时处理：设置了settings.timeout，超时后调用xhr.abort()中断请求 if (settings.timeout &gt; 0) abortTimeout = setTimeout(function () &#123; xhr.onreadystatechange = empty; xhr.abort(); ajaxError(null, &apos;timeout&apos;, xhr, settings, deferred) &#125;, settings.timeout); // avoid sending empty string (#319) xhr.send(settings.data ? settings.data : null); return xhr &#125;; //进行可选参数(data/success)校验 function parseArguments(url, data, success, dataType) &#123; if ($.isFunction(data)) dataType = success, success = data, data = undefined; if (!$.isFunction(success)) dataType = success, success = undefined; return &#123; url: url , data: data , success: success , dataType: dataType &#125; &#125; //$.ajax的简写方式 get请求 $.get = function (/* url, data, success, dataType */) &#123; return $.ajax(parseArguments.apply(null, arguments)) &#125;; //$.ajax的简写方式 post请求 $.post = function (/* url, data, success, dataType */) &#123; var options = parseArguments.apply(null, arguments); options.type = &apos;POST&apos;; return $.ajax(options) &#125;; //$.ajax的简写方式 获取JSON数据 $.getJSON = function (/* url, data, success */) &#123; var options = parseArguments.apply(null, arguments); options.dataType = &apos;json&apos;; return $.ajax(options) &#125;; /** * 通过GET Ajax载入远程HTML内容代码并插入至当前的dom元素中 * 可以使用匹配selector选择器的HTML内容来更新集合,如$(&apos;#some_element&apos;).load(&apos;/foo.html #bar&apos;) * 如果没有给定CSS选择器，将使用完整的返回文本 * 在没有选择器的情况下，任何javascript块都会添加。如果带上选择器，匹配选择器内的script将会被删除 * */ $.fn.load = function (url, data, success) &#123; if (!this.length) return this; var self = this, parts = url.split(/\\s/), selector, options = parseArguments(url, data, success), callback = options.success; if (parts.length &gt; 1) options.url = parts[0], selector = parts[1]; // response.replace(rscript, &quot;&quot;) 过滤出script标签 //$(&apos;&lt;div&gt;&apos;).html(response.replace(rscript, &quot;&quot;)) innerHTML方式转换成DOM options.success = function (response) &#123; self.html(selector ? $(&apos;&lt;div&gt;&apos;).html(response.replace(rscript, &quot;&quot;)).find(selector) : response); //dom操作后执行成功回调函数(注:callback存储的是自定义成功回调函数,options.success后面被重新赋值为ajax回调函数,不会死循环) callback &amp;&amp; callback.apply(self, arguments) &#125;; $.ajax(options); return this &#125;; var escape = encodeURIComponent; //序列化 function serialize(params, obj, traditional, scope) &#123; var type, array = $.isArray(obj), hash = $.isPlainObject(obj); $.each(obj, function (key, value) &#123; type = $.type(value); //如果是第二次递归调用的话，需要处理一下key的值 if (scope) key = traditional ? scope : scope + &apos;[&apos; + (hash || type == &apos;object&apos; || type == &apos;array&apos; ? key : &apos;&apos;) + &apos;]&apos;; // 处理[&#123;name:&apos;&apos;,value:&apos;&apos;&#125;,&#123;name:&apos;&apos;,value:&apos;&apos;&#125;]这种类型 if (!scope &amp;&amp; array) params.add(value.name, value.value); // 处理嵌套对象如&#123;&apos;key&apos;:[]&#125;或者&#123;&apos;key&apos;:&#123;&#125;&#125; else if (type == &quot;array&quot; || (!traditional &amp;&amp; type == &quot;object&quot;)) serialize(params, value, traditional, key); else params.add(key, value) &#125;) &#125; /** * 序列化一个对象，在Ajax请求中提交的数据使用URL编码的查询字符串表示形式。 * 如果shallow设置为true。嵌套对象不会被序列化，嵌套数组的值不会使用放括号在他们的key上。 * */ $.param = function (obj, traditional) &#123; var params = []; params.add = function (key, value) &#123; if ($.isFunction(value)) value = value(); if (value == null) value = &quot;&quot;; this.push(escape(key) + &apos;=&apos; + escape(value)) &#125;; serialize(params, obj, traditional); return params.join(&apos;&amp;&apos;).replace(/%20/g, &apos;+&apos;) &#125;&#125;)(Zepto); 二、源码分析1、事件处理ajaxStart/ajaxStop: 绑定在 document 上，通过全局变量 $.active 变量判断是否触发自定义相应事件；ajaxBeforeSend: ajax 请求前执行自定义拦截函数，同时执行全局 ajaxBeforeSend 函数；如果同时满足触发 ajaxSend 自定义事件，否则触发自定义 abort 事件，执行 ajaxError 函数；ajaxSuccess/ajaxError: ajax 成功/失败回调函数，触发相应自定义函数后调用 ajaxComplete 函数；ajaxComplete: ajax 请求完成回调函数，触发自定义事件，同时触发 ajaxStop 事件。 2、判断是否跨域,确定 settings.crossDomain 的值调用两次 document.createElement(‘a’) 创建两个 a 标签，一个设置为当前 url 地址，一个设置为接口地址，比较两个 a 标签的端口号和 ip 协议判断是否跨域。 3、清除 ajax 缓存(settings.catch === false)在 url 后面添加时间戳参数，防止 ajax 请求缓存。 4、ajax 超时处理ajax 执行时设置一个定时器，时间为超时时间，如果超过则执行 xhr.abort，并且触发 timeout 自定义事件；如果在超时时间内请求成功，则清除定时器，onreadystatechange 函数内部使用了闭包。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 data.js","slug":"zepto/dataJs","date":"2017-07-25T02:54:34.000Z","updated":"2018-04-18T05:59:44.000Z","comments":true,"path":"zepto/dataJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/dataJs/","excerpt":"一个全面的 data() 方法，能够在内存中存储任意对象。","text":"一个全面的 data() 方法，能够在内存中存储任意对象。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293(function($)&#123; //+new Date() 转化为Number类型，会调用Date.prototype上的valueOf方法，等同于Date.prototype.getTime() var data = &#123;&#125;, dataAttr = $.fn.data, camelize = $.camelCase, exp = $.expando = &apos;Zepto&apos; + (+new Date()), emptyArray = []; // Get value from node: // 1. first try key as given, // 2. then try camelized key, // 3. fall back to reading &quot;data-*&quot; attribute. function getData(node, name) &#123; var id = node[exp], store = id &amp;&amp; data[id]; //如果没有指定属性值，则返回整个属性存储对象 if (name === undefined) return store || setData(node); else &#123; if (store) &#123; if (name in store) return store[name]; var camelName = camelize(name); if (camelName in store) return store[camelName] &#125; //调用之前核心库里面的$.fn.data方法获取元素的属性值 return dataAttr.call($(node), name) &#125; &#125; // Store value under camelized key on node function setData(node, name, value) &#123; //第一次为设置值，并将所有dom元素上的自定义属性放到缓存中；后面则从缓存中提取数据 var id = node[exp] || (node[exp] = ++$.uuid), store = data[id] || (data[id] = attributeData(node)); if (name !== undefined) store[camelize(name)] = value; return store &#125; // Read all &quot;data-*&quot; attributes from a node //将node中所有自定义属性组成对象返回 function attributeData(node) &#123; var store = &#123;&#125;; $.each(node.attributes || emptyArray, function(i, attr)&#123; if (attr.name.indexOf(&apos;data-&apos;) == 0) store[camelize(attr.name.replace(&apos;data-&apos;, &apos;&apos;))] = $.zepto.deserializeValue(attr.value) &#125;); return store &#125; //根据参数设置或提取数据 $.fn.data = function(name, value) &#123; return value === undefined ? // set multiple values via object $.isPlainObject(name) ? this.each(function(i, node)&#123; $.each(name, function(key, value)&#123; setData(node, key, value) &#125;) &#125;) : // get value from first element (0 in this ? getData(this[0], name) : undefined) : // set value on all elements this.each(function()&#123; setData(this, name, value) &#125;) &#125;; //调用$.fn.data方法 $.data = function(elem, name, value) &#123; return $(elem).data(name, value) &#125;; //判断dom元素是否存储了缓存对象 $.hasData = function(elem) &#123; var id = elem[exp], store = id &amp;&amp; data[id]; return store ? !$.isEmptyObject(store) : false &#125;; //移除dom元素上的缓存对象 $.fn.removeData = function(names) &#123; if (typeof names == &apos;string&apos;) names = names.split(/\\s+/); return this.each(function()&#123; var id = this[exp], store = id &amp;&amp; data[id]; if (store) $.each(names || store, function(key)&#123; delete store[names ? camelize(this) : key] &#125;) &#125;) &#125; // Generate extended `remove` and `empty` functions //调用remove和empty进行dom操作的同时移除dom元素上的缓存对象 ;[&apos;remove&apos;, &apos;empty&apos;].forEach(function(methodName)&#123; var origFn = $.fn[methodName]; $.fn[methodName] = function() &#123; var elements = this.find(&apos;*&apos;); if (methodName === &apos;remove&apos;) elements = elements.add(this); elements.removeData(); return origFn.call(this) &#125; &#125;)&#125;)(Zepto); 二、源码分析1、0 in this 判断是否为数组2、当 data.js 文件加载完后会生成一个 exp 变量，这个 exp 变量就是节点存储标识的自定义属性名，这个属性名对应的是一个个 id，通过这个 id 可以到 data 对象中找到该节点对应的数据缓存对象。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 event.js","slug":"zepto/eventJs","date":"2017-07-09T15:35:57.000Z","updated":"2018-04-18T06:21:28.000Z","comments":true,"path":"zepto/eventJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/eventJs/","excerpt":"event.js 主要用于提供注册自定义事件和手动触发事件等功能。","text":"event.js 主要用于提供注册自定义事件和手动触发事件等功能。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358//event事件(事件处理)(function ($) &#123; var _zid = 1, undefined, slice = Array.prototype.slice, isFunction = $.isFunction, isString = function (obj) &#123; return typeof obj == &apos;string&apos; &#125;, handlers = &#123;&#125;,//_zid: events 事件缓存池 specialEvents = &#123;&#125;, //是否支持即将获取焦点时触发函数 onfocusin 事件类似于 onfocus 事件。 主要的区别是 onfocus 事件不支持冒泡。 focusinSupported = &apos;onfocusin&apos; in window, focus = &#123;focus: &apos;focusin&apos;, blur: &apos;focusout&apos;&#125;, //mouseenter、mouseleave不冒泡 hover = &#123;mouseenter: &apos;mouseover&apos;, mouseleave: &apos;mouseout&apos;&#125;; //此处标准浏览器，click、mousedown、mouseup、mousemove抛出的就是MouseEvents，应该也是对低版本IE等某些浏览器的修正 specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = &apos;MouseEvents&apos;; //取元素标识符，没有设置一个返回 function zid(element) &#123; return element._zid || (element._zid = _zid++) &#125; //根据形参条件 查找元素上事件响应函数集合 function findHandlers(element, event, fn, selector) &#123; event = parse(event); if (event.ns) var matcher = matcherFor(event.ns); /** * 若有event.e ,则判断事件类型是否相同，否则直接走下一步 * 若有event.e,则判断事件命名空间是否相同 RegExp.prototype.test = function(String) &#123;&#125;; * zid(handler.fn)返回handler.fn的标识，没有加一个，判断fn标识符是否相同 * 若有selector 则判断selector是否相同 * */ return (handlers[zid(element)] || []).filter(function (handler) &#123; return handler &amp;&amp; (!event.e || handler.e == event.e) &amp;&amp; (!event.ns || matcher.test(handler.ns)) &amp;&amp; (!fn || zid(handler.fn) === zid(fn)) &amp;&amp; (!selector || handler.sel == selector) &#125;) &#125; /** * 解析事件类型 parse(&quot;click.zhutao.xiaoyu&quot;); =&gt; Object &#123;e: &quot;click&quot;, ns: &quot;xiaoyu zhutao&quot;&#125; * slice取从索引为1之后的所有项，sort对数组进行排序，join(&quot; &quot;)将数组变为字符串，中间插入空格 * */ function parse(event) &#123; var parts = (&apos;&apos; + event).split(&apos;.&apos;); return &#123;e: parts[0], ns: parts.slice(1).sort().join(&apos; &apos;)&#125; &#125; //生成命名空间的正则对象 matcherFor(&quot;xiaoyu zhutao&quot;); =&gt; /(?:^| )xiaoyu.* ?zhutao(?: |$)/ function matcherFor(ns) &#123; return new RegExp(&apos;(?:^| )&apos; + ns.replace(&apos; &apos;, &apos; .* ?&apos;) + &apos;(?: |$)&apos;) &#125; //addEventListener 的第三个参数，true - 事件句柄在捕获阶段执行，false - 默认,事件句柄在冒泡阶段执行 function eventCapture(handler, captureSetting) &#123; return handler.del &amp;&amp; (!focusinSupported &amp;&amp; (handler.e in focus)) || !!captureSetting &#125; //修正事件类型 focus-&gt;focusIn blur-&gt;focusOut mouseenter-&gt;mouseover mouseleave-&gt;mouseout function realEvent(type) &#123; return hover[type] || (focusinSupported &amp;&amp; focus[type]) || type &#125; //增加事件底层方法; add(element, event, callback, data, selector, delegator || autoRemove) function add(element, events, fn, data, selector, delegator, capture) &#123; var id = zid(element), set = (handlers[id] || (handlers[id] = [])); events.split(/\\s/).forEach(function (event) &#123; if (event == &apos;ready&apos;) return $(document).ready(fn); var handler = parse(event); handler.fn = fn; handler.sel = selector; //如果事件是mouseenter, mouseleave，模拟mouseover mouseout事件处理 if (handler.e in hover) fn = function (e) &#123; /** * relatedTarget 事件属性返回与事件的目标节点相关的节点。 * 对于 mouseover 事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。 * 对于 mouseout 事件来说，该属性是离开目标时，鼠标指针进入的节点。 * 对于其他类型的事件来说，这个属性没有用。 * */ var related = e.relatedTarget; //当related不在事件对象event内 表示事件已触发完成，不是在move过程中，需要执行响应函数 if (!related || (related !== this &amp;&amp; !$.contains(this, related))) return handler.fn.apply(this, arguments) &#125;; handler.del = delegator; var callback = delegator || fn; handler.proxy = function (e) &#123; e = compatible(e); //如果某个监听函数执行了event.stopImmediatePropagation()方法,则除了该事件的冒泡行为被阻止之外(event.stopPropagation方法的作用),该元素绑定的后序事件的监听函数的执行也将被阻止. if (e.isImmediatePropagationStopped()) return; e.data = data; //执行回调函数，context：element，arguments：event,e._args(默认是undefind，trigger()时传递的参数） var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args)); //当事件响应函数返回false时，阻止浏览器默认操作和冒泡 if (result === false) e.preventDefault(), e.stopPropagation(); return result &#125;; //设置事件响应函数的索引,删除事件时，根据它来删除 delete handlers[id][handler.i] handler.i = set.length; set.push(handler); if (&apos;addEventListener&apos; in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125; //删除事件,对应add function remove(element, events, fn, selector, capture) &#123; var id = zid(element); (events || &apos;&apos;).split(/\\s/).forEach(function (event) &#123; findHandlers(element, event, fn, selector).forEach(function (handler) &#123; // delete删除掉数组中的元素后，会把该下标出的值置为undefined,数组的长度不会变 delete handlers[id][handler.i] if (&apos;removeEventListener&apos; in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)) &#125;) &#125;) &#125; //此处不清楚要干嘛，将事件两个核心底层方法封装到event对象里，方便做Zepto插件事件扩展吧 $.event = &#123;add: add, remove: remove&#125;; //接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context)语境，新函数中this指向context参数 $.proxy = function (fn, context) &#123; //如果传了第3个参数，取到第3个参数以后（包含第3个参数）所有的参数数组 var args = (2 in arguments) &amp;&amp; slice.call(arguments, 2); if (isFunction(fn)) &#123; //args.concat(slice.call(arguments))将代理函数的参数与$.proxy的第三个及后面可选参数合并 var proxyFn = function () &#123; return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) &#125;; //标记函数 proxyFn._zid = zid(fn); return proxyFn &#125; else if (isString(context)) &#123; //另外一种形式，原始的function是从上下文(context)对象的特定属性读取 if (args) &#123; args.unshift(fn[context], fn); return $.proxy.apply(null, args) &#125; else &#123; return $.proxy(fn[context], fn) &#125; &#125; else &#123; throw new TypeError(&quot;expected function&quot;) &#125; &#125;; $.fn.bind = function (event, data, callback) &#123; return this.on(event, data, callback) &#125;; $.fn.unbind = function (event, callback) &#123; return this.off(event, callback) &#125;; //添加一个处理事件到元素，当第一次执行事件以后，该事件将自动解除绑定，保证处理函数在每个元素上最多执行一次。 $.fn.one = function (event, selector, data, callback) &#123; return this.on(event, selector, data, callback, 1) &#125;; var returnTrue = function () &#123; return true &#125;, returnFalse = function () &#123; return false &#125;, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/, eventMethods = &#123; preventDefault: &apos;isDefaultPrevented&apos;, stopImmediatePropagation: &apos;isImmediatePropagationStopped&apos;, stopPropagation: &apos;isPropagationStopped&apos; &#125;; /** * 修正event对象 * @param event 代理的event对象|原生event对象 * @param source 原生event对象 * @returns &#123;*&#125; */ function compatible(event, source) &#123; if (source || !event.isDefaultPrevented) &#123; source || (source = event); /** * 遍历，给事件添加isDefaultPrevented、isImmediatePropagationStopped、isPropagationStopped方法 * isDefaultPrevented:如果preventDefault()被该事件的实例调用，那么返回true。这可作为跨平台的替代原生的defaultPrevented属性，如果defaultPrevented缺失或在某些浏览器下不可靠的时候。 * isImmediatePropagationStopped:如果stopImmediatePropagation()被该事件的实例调用，那么返回true。Zepto在不支持该原生方法的浏览器中实现它，（例如老版本的Android）。 * isPropagationStopped:如果stopPropagation()被该事件的实例调用，那么返回true。 **/ $.each(eventMethods, function (name, predicate) &#123; var sourceMethod = source[name]; event[name] = function () &#123; this[predicate] = returnTrue; return sourceMethod &amp;&amp; sourceMethod.apply(source, arguments) &#125;; event[predicate] = returnFalse &#125;); event.timeStamp || (event.timeStamp = Date.now()); //如果浏览器支持defaultPrevented DOM3 EVENT提出的能否取消默认行为 //source.defaultPrevented:判断默认事件是否已被阻止,与preventDefault()相对应,这是对各种情况的兼容 if (source.defaultPrevented !== undefined ? source.defaultPrevented : &apos;returnValue&apos; in source ? source.returnValue === false : source.getPreventDefault &amp;&amp; source.getPreventDefault()) event.isDefaultPrevented = returnTrue &#125; //返回修正对象 return event &#125; //新建一个对象 封装event，创建代理对象 function createProxy(event) &#123; var key, proxy = &#123;originalEvent: event&#125;; //复制event属性至proxy，ignoreProperties里包含的属性除外 for (key in event) if (!ignoreProperties.test(key) &amp;&amp; event[key] !== undefined) proxy[key] = event[key]; return compatible(proxy, event) &#125; $.fn.delegate = function (selector, event, callback) &#123; return this.on(event, selector, callback) &#125;; $.fn.undelegate = function (selector, event, callback) &#123; return this.off(event, selector, callback) &#125;; //冒泡到document.body绑定事件 $.fn.live = function (event, callback) &#123; $(document.body).delegate(this.selector, event, callback); return this &#125;; //在doument.body解绑事件 $.fn.die = function (event, callback) &#123; $(document.body).undelegate(this.selector, event, callback); return this &#125;; /** * 多个事件可以通过空格的字符串方式添加，或者以事件类型为键、以函数为值的对象方式。 * 如果给定css选择器，当事件在匹配该选择器的元素上发起时，事件才会被触发 * 如果给定data参数，这个值将在事件处理程序执行期间被作为有用的 event.data 属性 * */ $.fn.on = function (event, selector, data, callback, one) &#123; var autoRemove, delegator, $this = this; //event是对象&#123; type: handler, type2: handler2, ... &#125; if (event &amp;&amp; !isString(event)) &#123; $.each(event, function (type, fn) &#123; $this.on(type, selector, data, fn, one) &#125;); return $this &#125; //校验调整函数参数 if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = data, data = selector, selector = undefined; if (callback === undefined || data === false) callback = data, data = undefined; //如果false在回调函数的位置上作为参数传递给这个方法，它相当于传递一个函数，这个函数直接返回false。 if (callback === false) callback = returnFalse; return $this.each(function (_, element) &#123; if (one) autoRemove = function (e) &#123; remove(element, e.type, callback); return callback.apply(this, arguments) &#125;; if (selector) delegator = function (e) &#123; //closest 从元素本身开始，逐级向上级元素匹配，并返回最先匹配selector的元素。如果给定context节点参数，那么只匹配该节点的后代元素。 var evt, match = $(e.target).closest(selector, element).get(0) //其实还是在父元素上进行监听，只不过如果事件触发的元素不是匹配的话，不调用函数回调 if (match &amp;&amp; match !== element) &#123; evt = $.extend(createProxy(e), &#123;currentTarget: match, liveFired: element&#125;) return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1))) &#125; &#125;; add(element, event, callback, data, selector, delegator || autoRemove) &#125;) &#125;; $.fn.off = function (event, selector, callback) &#123; var $this = this; if (event &amp;&amp; !isString(event)) &#123; $.each(event, function (type, fn) &#123; $this.off(type, selector, fn) &#125;); return $this &#125; if (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== false) callback = selector, selector = undefined; if (callback === false) callback = returnFalse; return $this.each(function () &#123; remove(this, event, callback, selector) &#125;) &#125;; //在对象集合的元素上触发指定的事件。事件可以是一个字符串类型，也可以是一个 通过$.Event 定义的事件对象。如果给定args参数，它会作为参数传递给事件函数。 $.fn.trigger = function (event, args) &#123; event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event); event._args = args; return this.each(function () &#123; // handle focus(), blur() by calling them directly if (event.type in focus &amp;&amp; typeof this[event.type] == &quot;function&quot;) this[event.type](); // items in the collection might not be DOM elements else if (&apos;dispatchEvent&apos; in this) this.dispatchEvent(event); //可能不是dom元素上触发指定事件 else $(this).triggerHandler(event, args) &#125;) &#125;; // triggers event handlers on current element just as if an event occurred, // doesn&apos;t trigger an actual event, doesn&apos;t bubble $.fn.triggerHandler = function (event, args) &#123; var e, result; this.each(function (i, element) &#123; e = createProxy(isString(event) ? $.Event(event) : event); e._args = args; e.target = element; //找到此元素上此事件类型上的事件响应函数集，遍历，触发 $.each(findHandlers(element, event.type || event), function (i, handler) &#123; //调用 handler.proxy执行事件 result = handler.proxy(e); //如果event调用了immediatePropagationStopped()，终止后续事件的响应 if (e.isImmediatePropagationStopped()) return false &#125;) &#125;); return result &#125;; //给常用事件生成便捷方法 (&apos;focusin focusout focus blur load resize scroll unload click dblclick &apos; + &apos;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &apos; + &apos;change select keydown keypress keyup error&apos;).split(&apos; &apos;).forEach(function (event) &#123; //有callback回调，是绑定事件，否则，触发事件 $.fn[event] = function (callback) &#123; return (0 in arguments) ? this.bind(event, callback) : this.trigger(event) &#125; &#125;); //创建Event对象 $.Event = function (type, props) &#123; //当type是个对象时 保证type为对象的属性字符串，props为对象 if (!isString(type)) props = type, type = props.type; //创建自定义事件，如果是click,mousedown,mouseup mousemove创建为MouseEvent对象,bubbles设为冒泡 var event = document.createEvent(specialEvents[type] || &apos;Events&apos;), bubbles = true; //bubbles = !!props[name]冒泡判断；event[name] = props[name] props属性扩展到event对象上 if (props) for (var name in props) (name == &apos;bubbles&apos;) ? (bubbles = !!props[name]) : (event[name] = props[name]) //初始化event对象，type为事件名称，如click，bubbles为是否冒泡，第三个参数表示是否可以用preventDefault方法来取消默认操作 event.initEvent(type, bubbles, true); return compatible(event) &#125;;&#125;)(Zepto); 二、源码分析$.Event注册自定义事件核心流程:1、document.createEvent(type) 创建一个新的自定义事件2、event.initEvent(type, bubbles, cancelable) 初始化自定义事件3、compatible(event) 给事件添加 isDefaultPrevented、isImmediatePropagationStopped、isPropagationStopped 方法 $.fn.onon 方法主要调用原生的 target.addEventListener(type, listener[, useCapture]); 方法。1、$.fn.one 方法是在 on 方法的回调函数中调用 remove 方法移除事件监听2、如果 on 方法中有选择器，虽然是必须在子元素上点击才有效果，但是事件监听其实还是在父元素上，只不过在回调函数中设置了如果不是匹配的子元素触发不进行操作 $.fn.offoff 方法主要调用原生 target.removeEventListener(type, listener[, useCapture]); 方法，与 $.fn.on 相对 $.fn.triggertrigger 方法判断元素如果是 dom 元素触发的，则调用原生 target.dispatchEvent(event) 方法；如果不是 dom 元素上触发的，那么直接手动调用回调函数。 handlers事件缓存池，用于移除或者触发监听函数找到相应的回调函数，然后进行相应操作。","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"zepto 之 form.js","slug":"zepto/formJs","date":"2017-07-05T01:46:40.000Z","updated":"2018-04-18T06:21:37.000Z","comments":true,"path":"zepto/formJs/","link":"","permalink":"http://blog.master-ss.cn/zepto/formJs/","excerpt":"研究总结下之前用过的 zepto 类库，先从表单模块源码开始。","text":"研究总结下之前用过的 zepto 类库，先从表单模块源码开始。 一、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445//部分代码改动，为了消除警告和格式排版//form表单(序列化form表单里面字段和注册submit事件以及触发表单提交事件)(function ($) &#123; //序列表单内容为JSON数组 $.fn.serializeArray = function () &#123; var name, type, result = [], add = function (value) &#123; if (value.forEach) return value.forEach(add); result.push(&#123;name: name, value: value&#125;) &#125;; if (this[0]) $.each(this[0].elements, function (_, field) &#123; type = field.type; name = field.name; //排除fieldset，禁用元素，submit,reset,button，file和未被选中的radio,checkbox,原因是这些元素不需要传递给服务器 if (name &amp;&amp; field.nodeName.toLowerCase() != &apos;fieldset&apos; &amp;&amp; !field.disabled &amp;&amp; type != &apos;submit&apos; &amp;&amp; type != &apos;reset&apos; &amp;&amp; type != &apos;button&apos; &amp;&amp; type != &apos;file&apos; &amp;&amp; ((type != &apos;radio&apos; &amp;&amp; type != &apos;checkbox&apos;) || field.checked)) //&#123;name:value&#125;形式加入到结果数组中 add($(field).val()) &#125;); return result &#125;; //序列表表单内容为查询字符串 $.fn.serialize = function () &#123; var result = []; this.serializeArray().forEach(function (elm) &#123; //每个key-value，都保守URI编码 result.push(encodeURIComponent(elm.name) + &apos;=&apos; + encodeURIComponent(elm.value)) &#125;); return result.join(&apos;&amp;&apos;) &#125;; //提交表单 $.fn.submit = function (callback) &#123; //0 in arguments 判断是否传了回调函数，传了回调，就当成绑定submit事件 if (0 in arguments) this.bind(&apos;submit&apos;, callback); else if (this.length) &#123; //没有传回调，当成直接提交，this.length表示有表单元素 var event = $.Event(&apos;submit&apos;); //get和eq方法不同，get方法返回的dom节点，eq返回的还是Zepto对象集合 this.eq(0).trigger(event); if (!event.isDefaultPrevented()) this.get(0).submit() &#125; return this &#125;&#125;)(Zepto); 二、源码分析整个表单模块被一个自运行匿名函数包含，防止作用域污染。 serializeArray1、循环递归函数 add 解决 value 为数组的情况;2、formObject.elements 为包含表单里面所有字段节点的数组;提示: 如果 elements 数组具有名称(input 标签的 id 或 name 属性)，那么该元素的名称就是 formObject 的一个属性，因此可以使用名称而不是数字来引用 input 对象；比如，假设 x 是一个 form 对象，其中的一个 input 对象的名称是 fname，则可以使用 x.fname 来引用该对象 submit1、$.Event 是创建事件,trigger(event) 触发自定义事件,并不会提交表单;2、document.forms[0].submit() 执行默认提交表单处理","categories":[{"name":"zepto","slug":"zepto","permalink":"http://blog.master-ss.cn/categories/zepto/"}],"tags":[]},{"title":"cordova 之 hooks","slug":"essay/hooks","date":"2017-03-17T07:33:41.000Z","updated":"2018-12-21T05:45:10.733Z","comments":true,"path":"essay/hooks/","link":"","permalink":"http://blog.master-ss.cn/essay/hooks/","excerpt":"hooks 是一些在 Cordova 执行命令时运行的特殊脚本，能够允许你拓展 Cordova 命令来适应你自己的需求。官方推荐三个地方定义 hooks，分别在工程的 config.xml、插件的 plugin.xml 和 hooks 文件夹，这里介绍的是第三个地方。任何一门编程语言都能够写 hooks，但是考虑到跨平台运行（即需要不同语言的运行环境），推荐使用 Node.js。","text":"hooks 是一些在 Cordova 执行命令时运行的特殊脚本，能够允许你拓展 Cordova 命令来适应你自己的需求。官方推荐三个地方定义 hooks，分别在工程的 config.xml、插件的 plugin.xml 和 hooks 文件夹，这里介绍的是第三个地方。任何一门编程语言都能够写 hooks，但是考虑到跨平台运行（即需要不同语言的运行环境），推荐使用 Node.js。 一、hooks 应用场景hooks 应用场景一：修改应用配置信息，我们在应用开发中，引入的插件可能有冲突之类的问题，这个时候原生开发人员会让我们在添加平台加一些配置信息。也就是说我们每次添加平台后都需要手动去改平台中代码，不太方便，程序员就要尽可能的懒起来，这个时候就可以用上 hooks 了；hooks 应用场景二：环境切换，我们的 Cordova 工程经常有开发、uat、生产等不同环境。对应不同的环境，我们有不同的接口地址、不同的插件 API keys，甚至不同的应用图标和 Splash。对于不同接口地址、不同的应用图标和 Splash等，我们可以使用自定义 gulp 任务实现，但是对于插件中的接口地址、API keys 不太好做处理。 二、Cordova 支持的 hooks 类型 三、hooks 执行顺序根据以上表格可以推导出不同类型 hooks 执行顺序，以 cordova platform add 和 cordova build 为例：123456789101112131415cordova platform add： before_platform_add before_prepare after_prepare before_plugin_install after_plugin_install after_platform_add cordova build： before_build before_prepare after_prepare before_compile after_compile after_build 四、应用实例4.1、以我现在正在开发的 xxx 项目为例，添加平台后修改平台内配置信息（cordova platform add）1、在应用根目录下新建 hooks 文件夹（如果先前有可删除），在 hooks 文件夹内新建 after_platform_add 文件夹，内新建一个 js 文件，命名随意；2、读写平台中的 AndroidManifest.xml 文件，修改配置信息；12345678910111213141516一、解决方法数越界 1. build.gradle 配置defaultConfig&#123; multiDexEnabled true&#125; 2. dependencies&#123; compile &quot;com.android.support:multidex:1.0.0&quot;&#125;3. AndroidManifest.xml 中 Application 添加属性android:name=&quot;android.support.multidex.MultiDexApplication&quot; 二、解决条码扫描插件最低版本冲突 1. AndroidManifest.xml 中 Manifest 添加属性 xmlns:tools=&quot;http://schemas.android.com/tools&quot; 2. Manifest 中添加节点&lt;uses-sdk android:minSdkVersion=&quot;16&quot; tools:overrideLibrary=&quot;org.xwalk.core&quot; /&gt; 3、Android 打包配置需求如上；12345678910111213141516171819202122232425262728293031323334353637383940414243var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var rootdir = process.argv[2];//正则表达式替换文本function replace_string_in_file(filename, to_replace, replace_with) &#123; var data = fs.readFileSync(filename, &apos;utf8&apos;); var result = data.replace(to_replace, replace_with); fs.writeFileSync(filename, result, &apos;utf8&apos;);&#125;if (rootdir) &#123; //获取平台信息数组 var platforms = (process.env.CORDOVA_PLATFORMS ? process.env.CORDOVA_PLATFORMS.split(&apos;,&apos;) : []); for (var x = 0; x &lt; platforms.length; x += 1) &#123; try &#123; var platform = platforms[x].trim().toLowerCase(); //如果是android平台 if (platform === &apos;android&apos;) &#123; //替换平台内AndroidManifest.xml文件内容 var fullfilename = path.join(rootdir, ‘platforms/android/AndroidManifest.xml&apos;); //判断AndroidManifest.xml文件是否存在 if (fs.existsSync(fullfilename)) &#123; replace_string_in_file(fullfilename, &quot;&lt;manifest&quot;, &apos;&lt;manifest xmlns:tools=&quot;http://schemas.android.com/tools&quot;&apos;); replace_string_in_file(fullfilename, &quot;&lt;supports-screens&quot;, &apos;&lt;uses-sdk android:minSdkVersion=&quot;16&quot; tools:overrideLibrary=&quot;org.xwalk.core&quot; /&gt;&lt;supports-screens&apos;); replace_string_in_file(fullfilename, &quot;&lt;application&quot;, &apos;&lt;application android:name=&quot;android.support.multidex.MultiDexApplication&quot;&apos;); &#125; else &#123; console.log(&quot;missing: &quot; + fullfilename); &#125; //替换build.gradle文件内容 var fullfilename2 = path.join(rootdir, &apos;platforms/android/build.gradle&apos;); if (fs.existsSync(fullfilename2)) &#123; replace_string_in_file(fullfilename2, /defaultConfig\\s*\\&#123;/gi, &apos;defaultConfig &#123;\\n multiDexEnabled true&apos;); replace_string_in_file(fullfilename2, /&#125;\\s*dependencies\\s*\\&#123;/gi, &apos;&#125;\\n dependencies &#123;\\n compile &quot;com.android.support:multidex:1.0.0&quot;&apos;); &#125; else &#123; console.log(&quot;missing: &quot; + fullfilename2); &#125; &#125; &#125; catch (e) &#123; process.stdout.write(e); &#125; &#125;&#125; 4、附上 hooks 源代码(xxx/after_platform_add/xxx.js)。 4.2、修改插件配置信息（这里修改 xxx 插件 API_KEY 为例）1、在应用根目录下新建 hooks 文件夹（如果先前有可删除），在 hooks 文件夹内新建 before_build 和 before_compile 文件夹，内分别新建一个 js 文件，命令随意；121、修改 android 平台内 AndroidManifest.xml，配置 RONG_CLOUD_APP_KEY（&lt;meta-data android:name=“RONG_CLOUD_APP_KEY&quot; android:value=&quot;&quot; /&gt;）2、修改 ios 平台的 plist文件，配置参数（&lt;config-file target=&quot;*LBXIMConfig.plist&quot; parent=&quot;RongCloudKey&quot;&gt;&lt;string&gt;$RONGCLOUD_KEY&lt;/string&gt;&lt;/config-file&gt;） 2、需求如上（需在原生开发人员配合下修改，由原生开发人员提出修改需求）1234567891011121314151617181920212223242526var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var rootdir = process.argv[2];function replace_string_in_file(filename, to_replace, replace_with) &#123; var data = fs.readFileSync(filename, &apos;utf8&apos;); var result = data.replace(data.match(to_replace)[0], replace_with); fs.writeFileSync(filename, result, &apos;utf8&apos;);&#125;if (rootdir) &#123; // go through each of the platform directories that have been prepared var platforms = (process.env.CORDOVA_PLATFORMS ? process.env.CORDOVA_PLATFORMS.split(&apos;,&apos;) : []); for (var x = 0; x &lt; platforms.length; x += 1) &#123; try &#123; var platform = platforms[x].trim().toLowerCase(); if (platform === &apos;android&apos;) &#123; //替换AndroidManifest.xml文件内容，删除RONG_CLOUD_APP_KEY var fullfilename = path.join(rootdir, &apos;platforms/android/AndroidManifest.xml&apos;); replace_string_in_file(fullfilename, &apos;&lt;meta-data\\.\\*android:name=&quot;RONG_CLOUD_APP_KEY&quot;\\.\\*\\/&gt;&apos;, &apos;&apos;); &#125; &#125; catch (e) &#123; process.stdout.write(e); &#125; &#125;&#125; 3、考虑到 android 在 prepare中 会添加 到AndroidManifest.xml 中，所以在 before_build 文件夹中写如下代码，删除相应配置信息，代码如上(xxx/before_build/xxx.js)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var rootdir = process.argv[2];function replace_string_in_file(filename, to_replace, replace_with) &#123; var data = fs.readFileSync(filename, &apos;utf8&apos;); var result = data.replace(data.match(to_replace)[0], replace_with); fs.writeFileSync(filename, result, &apos;utf8&apos;);&#125;//获取应用名（因为在ios平台中plist配置文件在应用名文件夹目录下）function get_data_in_configxmlfile(filename, to_replace) &#123; var data = fs.readFileSync(filename, &apos;utf8&apos;); return data.match(to_replace)[1];&#125;//替代plist文件内的配置信息function replace_data_in_plistfile(filename, to_replace, replace_with) &#123; var configPlist = fs.readFileSync(filename, &apos;utf8&apos;); var result = configPlist.replace(to_replace, replace_with); fs.writeFileSync(filename, result, &apos;utf8&apos;);&#125;if (rootdir) &#123; // go through each of the platform directories that have been prepared var platforms = (process.env.CORDOVA_PLATFORMS ? process.env.CORDOVA_PLATFORMS.split(&apos;,&apos;) : []); var ourConfigFile = path.join(rootdir, &quot;app/config/config.json&quot;); if (fs.existsSync(ourConfigFile)) &#123; var configObj = JSON.parse(fs.readFileSync(ourConfigFile, &apos;utf8&apos;)); &#125; else &#123; console.log(&quot;app/config/config.json not exist!!!&quot;); return; &#125; for (var x = 0; x &lt; platforms.length; x += 1) &#123; try &#123; var platform = platforms[x].trim().toLowerCase(); if (platform === &apos;android&apos;) &#123; //替换AndroidManifest.xml文件内容，配置RONG_CLOUD_APP_KEY var fullfilename = path.join(rootdir, &apos;platforms/android/AndroidManifest.xml&apos;); replace_string_in_file(fullfilename, &apos;android:name=&quot;RONG_CLOUD_APP_KEY&quot;\\.\\*\\/&gt;&apos;, &apos;android:name=&quot;RONG_CLOUD_APP_KEY&quot; android:value=&quot;&apos; + configObj[&quot;baseConfig&quot;][&quot;RONG_CLOUD_APP_KEY&quot;] + &apos;&quot; /&gt;&apos;); &#125; else &#123; //添加config.xml，读取文件内的应用名 var ourIosConfigFile = path.join(rootdir, &quot;config.xml&quot;); //获取应用名 var appName = get_data_in_configxmlfile(ourIosConfigFile, &quot;&lt;name&gt;(\\.\\*)&lt;\\/name&gt;&quot;); //修改im配置plist文件 var imConfigFile = &apos;platforms/ios/&apos; + appName + &apos;/Resources/LBXIMConfig.plist&apos;; if (fs.existsSync(imConfigFile)&#123; replace_data_in_plistfile(imConfigFile, /&lt;key&gt;RongCloudKey&lt;\\/key&gt;\\s*&lt;string&gt;\\s*\\S*&lt;\\/string&gt;/gi, &apos;&lt;key&gt;RongCloudKey&lt;/key&gt;\\n\\t&lt;string&gt;&apos; + configObj[&quot;baseConfig&quot;][&quot;RONG_CLOUD_APP_KEY&quot;] + &apos;&lt;\\/string&gt;&apos;); &#125; &#125; &#125; catch (e) &#123; process.stdout.write(e); &#125; &#125;&#125; 4、在平台编译之前加上参数。读取配置文件（自定义）内的 RONG_CLOUD_APP_KEY，把参数信息写入平台内部的配置文件中（xxx/before_compile/xxx.js）。","categories":[{"name":"essay","slug":"essay","permalink":"http://blog.master-ss.cn/categories/essay/"}],"tags":[]},{"title":"tools 之 bower","slug":"tools/bower","date":"2017-02-26T01:54:21.000Z","updated":"2018-04-19T07:05:21.000Z","comments":true,"path":"tools/bower/","link":"","permalink":"http://blog.master-ss.cn/tools/bower/","excerpt":"Bower 是 twitter 推出的包管理工具，支持包的下载、更新、卸载等操作。","text":"Bower 是 twitter 推出的包管理工具，支持包的下载、更新、卸载等操作。 一、为什么使用 Bower以往，我们要使用 jQuery、Bootstrap 等模块，会到网上进行搜索，找到下载地址，然后通过浏览器或其它工具下载下来使用。Bower 提供了更简单的获取模块方式。只要一条命令，需要的资源就下载下来了。Bower 是命令行工具，通过 npm 安装。1npm install -g bower 这行命令是 Bower 的全局安装，-g 操作表示全局。Bower 依赖 node, npm 和 git。 二、开始使用包的安装通过命令 bower install 安装软件包，默认会安装到 bower_components/目录.1bower install &lt;package&gt; 想要下载的包可以是 GitHub 上的短链接（如 jquery/jquery）、 .git 、 一个 URL 或者其它.123456789101112# 通过 bower.json 文件安装bower install# 通过在 github 上注册的包名安装bower install jquery# GitHub 短链接（github 别名自动解析 git 库）bower install desandro/masonry# Github上的 .gitbower install git://github.com/user/package.git# URLbower install http://example.com/script.js# 下载本地库bower install ./repos/jquery 三、新建 bower.json可以通过 bower init 命令新建一个 bower.json 文件。会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个 bower.json 文件，用来保存该项目的配置，如下：1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;name&quot;: &quot;blue-leaf&quot;, //包名，必选。 &quot;version&quot;: &quot;1.0.0&quot;, //有意义的版本号。 &quot;description&quot;: &quot;Physics-like animations for pretty particles&quot;, //描述 &quot;main&quot;: [ //字符串或者数组，指定主要会用到包里面哪些文件(不会直接用到) &quot;js/motion.js&quot;, &quot;sass/motion.scss&quot; ], &quot;dependencies&quot;: &#123; //哈希结构，依赖的包，可以指定版本号 &quot;get-size&quot;: &quot;~1.2.2&quot;, &quot;eventEmitter&quot;: &quot;~4.2.11&quot; &#125;, &quot;devDependencies&quot;: &#123; //哈希结构，生产环境下依赖的包 &quot;qunit&quot;: &quot;~1.16.0&quot; &#125;, &quot;moduleType&quot;: [ //模块类型 &quot;amd&quot;, &quot;globals&quot;, &quot;node&quot; ], &quot;keywords&quot;: [ //关键字(便于bower搜索查找) &quot;motion&quot;, &quot;physics&quot;, &quot;particles&quot; ], &quot;authors&quot;: [ //作者 &quot;Betty Beta &lt;bbeta@example.com&gt;&quot; ], &quot;license&quot;: &quot;MIT&quot;, //证书 &quot;ignore&quot;: [ //忽略包的文件夹 &quot;**/.*&quot;, &quot;node_modules&quot;, &quot;bower_components&quot;, &quot;test&quot;, &quot;tests&quot; ], &quot;private&quot;: true //布尔值，设置为true代表你想保持私有，并且将来不会发布它&#125; 如果想保存依赖信息(dependencies)到你的 bower.json 文件，可以使用：bower install PACKAGE –save,或者使用 bower install –save-dev 保存依赖信息(devDependencies). 四、使用下载的包对于已经下载下来的包，默认在当前目录的 bower_components 文件夹。你可以直接在项目里引用。例如：1&lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; 推荐将 Bower 与其它工具一起使用。 五、常用命令123456789bower help //命令查看帮助bower install jquery --save //添加依赖并更新 bower.json 文件bower cache clean //安装失败清除缓存bower install storejs //安装 storejsbower uninstall storejs //卸载 storejsbower info jquery //包的信息bower update //包的更新(根据 bower.json 文件中的版本号更新)bower search bootstrap //包的查找bower uninstall jquery //包的卸载 六、注册添加配置文件(即新建 bower.json)注册自己的包可以注册自己的包，这样其他人也可以使用了，这个操作只是在服务器上保存了一个映射，服务器本身不托管代码。1bower register storejs git://github.com/jaywcjlove/store.js.git 七、配置123456789101112131415161718192021222324252627282930313233&#123; &quot;cwd&quot;: &quot;~/my-project&quot;, //当前工作目录，运行bower的目录 &quot;directory&quot;: &quot;bower_components&quot;, //自定义bower下载的代码包的目录 &quot;registry&quot;: &quot;https://bower.herokuapp.com&quot;, //注册表配置,默认为bower注册表URL &quot;shorthand-resolver&quot;: &quot;git://github.com/&#123;&#123;owner&#125;&#125;/&#123;&#123;package&#125;&#125;.git&quot;, //为速记包名称定义自定义模板,定义Bower在为给定速记构造URL时使用的自定义模板的支持 &quot;proxy&quot;: &quot;http://proxy.local&quot;, //设置http代理 &quot;https-proxy&quot;: &quot;https://proxy.local&quot;, //设置https代理 &quot;ca&quot;: &quot;/var/certificate.pem&quot;, //要使用的CA证书，默认为null &quot;color&quot;: true, //启用或禁用在CLI输出中使用颜色 &quot;timeout&quot;: 60000, //发出请求时使用的超时值 &quot;strict-ssl&quot;: true, //是否在通过https发出请求时执行SSL密钥验证 &quot;storage&quot;: &#123; //在哪里存储持久数据，如缓存，bower需要 &quot;packages&quot; : &quot;~/.bower/packages&quot;, &quot;registry&quot; : &quot;~/.bower/registry&quot;, &quot;links&quot; : &quot;~/.bower/links&quot; &#125;, &quot;tmp&quot;: &quot;〜/.bower/tmp&quot; //在哪里存储临时文件和文件夹。默认为系统临时目录后缀/bower &quot;interactive&quot;: true, //使bower交互，在必要时提示 &quot;resolvers&quot;: [ //用于定位和提取包的Pluggable Resolver列表 &quot;mercurial-bower-resolver&quot; ], &quot;shallowCloneHosts&quot;: [ //允许将已知支持浅克隆的主机列入白名单 &quot;myGitHost.example.com&quot; ], &quot;scripts&quot;: &#123; //脚本,可用于在Bower使用期间触发其他自动化工具,这些钩子旨在允许外部工具帮助将新安装的组件连接到父项目和其他类似的任务中 &quot;preinstall&quot;: &quot;&quot;, &quot;postinstall&quot;: &quot;&quot;, &quot;preuninstall&quot;: &quot;&quot; &#125;, &quot;ignoredDependencies&quot;: [ //当解析包时，Bower将忽略这些依赖关系 &quot;jquery&quot; ]&#125; Bower 的配置文件是 .bowerrc，使用 JSON 格式进行描述，如上。","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.master-ss.cn/categories/tools/"}],"tags":[]}]}