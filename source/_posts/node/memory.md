---
title: node 之内存控制
categories:
- node
---
随着 Node 的发展，JavaScript 已经实现了 CommonJS 的生态圈大一统的梦想，JavaScript 的应用场景早已不再局限在浏览器中。在那些短时间执行的场景，比如网页应用、命令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务器端的广泛应用，其他语言里存在着的问题在 JavaScript 中也暴露出来了。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用，本文将介绍在 Node 中如何合理高效地使用内存。
<!--more-->
### 一、V8 的垃圾回收机制与内存限制
Node 极大地拓宽了 JavaScript 的应用场景，当主流应用场景从客户端延伸到服务器端之后，对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。而在 Node 中，这一切都与 Node 的 JavaScript 执行引擎 V8 息息相关。
#### 1.1、Node 与 V8
Node 在发展历程中离不开 V8，所以在官方的主页介绍中就提到 Node 是一个构建在 Chrome 的 JavaScript 运行时上的平台。
关于 V8，它的来历与背景亦是大有来头。作为虚拟机，V8 的性能表现优异，这与它的领导者有莫大的渊源，Chrome 的成功也离不开它背后的天才——Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JavaScript 虚拟机。
#### 1.2、V8 的内存限制
在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如无法将一个 2 GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32 GB。这样在单个 Node 进程的情况下，计算机的内存资源无法得到充足的使用。
造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。
至于 V8 为何要限制堆的大小，表层原因为 V8 最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8 的限制值已经绰绰有余。深层原因是 V8 的垃圾回收机制的限制。按官方的说法，以 1.5 GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。
当然，这个限制也不是不能打开，V8 依然提供了选项让我们使用更多的内存。Node 在启动时可以传递 --max-old-space-size 或--max-new-space-size 来调整内存限制的大小，示例如下：
```
node --max-old-space-size=1700 test.js // 单位为MB 
// 或者
node --max-new-space-size=1024 test.js // 单位为KB 
```
上述参数在 V8 初始化时生效，一旦生效就不能再动态改变。如果遇到 Node 无法分配足够内存给 JavaScript 对象的情况，可以用这个办法来放宽 V8 默认的内存限制，避免在执行过程中稍微多用了一些内存就轻易崩溃。
#### 1.3、V8 的内存分代
在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。
V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 --max-old-space-size 命令行参数可以用于设置老生代内存空间的最大值，--max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着 V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。
### 二、内存指标
#### 2.1、高效使用内存
在 V8 面前，开发者所要具备的责任是如何让垃圾回收机制更高效地工作。
在正常的 JavaScript 执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于 V8 的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。
#### 2.2、查看内存使用情况
process.memoryUsage() 可以查看内存使用情况。
```
$ node
> process.memoryUsage()
{ rss: 21708800,
  heapTotal: 7684096,
  heapUsed: 4975704,
  external: 8676 }
```
rss 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中。
除了 rss 外，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息。heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。这 3 个值的单位都是字节。为了更好地查看效果，我们格式化一下输出结果：
```
var showMem = function () {
    var mem = process.memoryUsage();
    var format = function (bytes) {
        return (bytes / 1024 / 1024).toFixed(2) + ' MB';
    };
    console.log('Process: heapTotal ' + format(mem.heapTotal) + ' heapUsed ' + format(mem.heapUsed) + ' rss ' + format(mem.rss));
    console.log('-----------------------------------------------------------');
};
```
同时，写一个方法用于不停地分配内存但不释放内存，相关代码如下：
```
var useMem = function () {
    var size = 20 * 1024 * 1024;
    var arr = new Array(size);
    for(var i = 0; i < size; i++){
        arr[i] = 0;
    }
    return arr
};
var total = [];
for(var j = 0; j < 15; j++){ 
    showMem();
    total.push(useMem());
}
showMem();
```
将以上代码存为 outofmemory.js 并执行它，得到的输出结果如下：
```
Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 20.14 MB
-----------------------------------------------------------
Process: heapTotal 166.84 MB heapUsed 164.25 MB rss 181.61 MB
-----------------------------------------------------------
Process: heapTotal 326.85 MB heapUsed 324.25 MB rss 341.66 MB
-----------------------------------------------------------
Process: heapTotal 486.86 MB heapUsed 484.26 MB rss 501.73 MB
-----------------------------------------------------------
Process: heapTotal 646.88 MB heapUsed 644.26 MB rss 661.78 MB
-----------------------------------------------------------
Process: heapTotal 806.89 MB heapUsed 804.26 MB rss 821.81 MB
-----------------------------------------------------------
Process: heapTotal 966.90 MB heapUsed 964.26 MB rss 981.82 MB
-----------------------------------------------------------
Process: heapTotal 1126.91 MB heapUsed 1124.27 MB rss 1141.84 MB
-----------------------------------------------------------
Process: heapTotal 1286.92 MB heapUsed 1284.27 MB rss 1301.86 MB
-----------------------------------------------------------

<--- Last few GCs --->

[8918:0x102802400]     1415 ms: Mark-sweep 1284.0 (1290.9) -> 1283.9 (1290.9) MB, 130.2 / 0.0 ms  allocation failure GC in old space requested
[8918:0x102802400]     1547 ms: Mark-sweep 1283.9 (1290.9) -> 1283.9 (1287.9) MB, 131.9 / 0.0 ms  last resort GC in old space requested
[8918:0x102802400]     1681 ms: Mark-sweep 1283.9 (1287.9) -> 1283.9 (1287.9) MB, 133.5 / 0.0 ms  last resort GC in old space requested
```
可以看到，每次调用 useMem 都导致了 3 个值的增长。在接近 1500 MB 的时候，无法继续分配内存，然后进程内存溢出了，连循环体都无法执行完成。
#### 2.3、查看系统的内存占用
与 process.memoryUsage() 不同的是，os 模块中的 totalmem() 和 freemem() 这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。示例代码如下：
```
$ node
> os.totalmem()
17179869184
> os.freemem()
4527833088
>
```
从输出信息可以看到我的电脑的总内存为 16 GB，当前闲置内存大致为 4.2 GB。
#### 2.4、堆外内存
通过 process.memoryUsage() 的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。我们将那些不是通过 V8 分配的内存称为堆外内存。
这里我们将前面的 useMem() 方法稍微改造一下，将 Array 变为 Buffer，将 size 变大，每一次构造 200 MB 的对象，相关代码如下：
```
var useMem = function () {
    var size = 200 * 1024 * 1024;
    var buffer = new Buffer(size);
    for (var i = 0; i < size; i++) {
        buffer[i] = 0;
    }
    return buffer;
};
```
重新执行该代码，得到的输出结果如下所示：
```
Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 19.86 MB
-----------------------------------------------------------
Process: heapTotal 6.83 MB heapUsed 4.25 MB rss 221.35 MB
-----------------------------------------------------------
Process: heapTotal 6.83 MB heapUsed 4.26 MB rss 421.52 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 621.91 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 821.91 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 1021.92 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1222.19 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1422.21 MB
-----------------------------------------------------------
Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1622.21 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 1822.21 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 2021.24 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.96 MB rss 2221.24 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 2421.28 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2620.31 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2820.31 MB
-----------------------------------------------------------
Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 3020.34 MB
-----------------------------------------------------------
```
我们看到 15 次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heapTotal 与 heapUsed 的变化极小，唯一变化的是 rss 的值，并且该值已经远远超过 V8 的限制值。这其中的原因是 Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以也不会有堆内存的大小限制。
为何 Buffer 对象并非通过 V8 分配？这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流，操作字符串远远不能满足传输的性能需求。
所以从上面的介绍可以得知，Node 的内存构成主要由通过 V8 进行分配的部分和 Node 自行分配的部分。受 V8 的垃圾回收限制的主要是 V8 的堆内存。
### 三、内存泄漏
Node 对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。
在 V8 的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。
通常，造成内存泄漏的原因有几个：缓存、队列消费不及时与作用域未释放。
#### 3.1、慎将内存当做缓存
缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间。
但是在 Node 中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。
另一个问题在于，JavaScript 开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。
直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。
如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。它的好处多多，在 Node 中主要可以解决两个问题：将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效；进程之间可以共享缓存。
目前，市面上较好的缓存有 Redis 和 Memcached。Node 模块的生态系统十分完善，这两个产品的客户端都有。
#### 3.2、关注队列状态
有的应用会收集日志，如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而 JavaScript 中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。
遇到这种场景，表层的解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。
### 四、大内存应用
在 Node 中，不可避免地还是会存在操作大文件的场景。由于 Node 的内存限制，操作大文件也需要小心，好在 Node 提供了 stream 模块用于处理大文件。
stream 模块是 Node 的原生模块，直接引用即可。stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node 中的大多数模块都有 stream 的应用，比如 fs 的 createReadStream() 和 createWriteStream() 方法可以分别用于创建文件的可读流和可写流，process 模块中的 stdin 和 stdout 则分别是可读流和可写流的示例。
由于 V8 的内存限制，我们无法通过 fs.readFile() 和 fs.writeFile() 直接进行大文件的操作，而改用 fs.createReadStream() 和 fs.createWriteStream() 方法通过流的方式实现对大文件的操作。下面的代码展示了如何读取一个文件，然后将数据写入到另一个文件的过程：
```
var reader = fs.createReadStream('in.txt');
var writer = fs.createWriteStream('out.txt');
reader.on('data', function (chunk) {
    writer.write(chunk);
});
reader.on('end', function () {
    writer.end();
});
```
由于读写模型固定，上述方法有更简洁的方式，具体如下所示：
```
var reader = fs.createReadStream('in.txt');
var writer = fs.createWriteStream('out.txt');
reader.pipe(writer);
```
可读流提供了管道方法 pipe()，封装了 data 事件和写入操作。通过流的方式，上述代码不会受到 V8 内存限制的影响，有效地提高了程序的健壮性。
如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试进行纯粹的 Buffer 操作，这不会受到 V8 堆内存的限制。但是这种大片使用内存的情况依然要小心，即使 V8 不限制堆内存的大小，物理内存依然有限制。