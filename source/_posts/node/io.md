---
title: node 之异步 I/O
categories:
- node
---
在绝大多数高级编程语言中，异步并不多见，造成这个现象的主要原因是：程序员不太适合通过异步编程来进行程序设计。在众多语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。伴随着异步 I/O 的还有事件驱动和单线程，他们构成了 Node 的基调。与 Node 的事件驱动、异步 I/O 设计理念比较相近的一个知名产品为 Nginx。Nginx 采用纯 C 编写，性能表现非常优异。
<!--more--> 
### 一、为什么要异步 I/O
#### 1.1、用户体验
异步的概念之所以首先在 Web 2.0 中火起来，是因为浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。在 B/S 模型中，网络速度的限制给网页的实时体验造成很大的麻烦，而采用异步请求，在下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。
同理，前端通过异步可以消除掉 UI 阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源需要 M 毫秒的耗时，第二个资源需要 N 毫秒的耗时。如果采用同步的方式，代码大致如下：
```
// 时间为 M
getData('from_db');
// 时间为 N
getData('from_remote_api');
```
但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源，如此我们可以享受到并发的优势，代码大致如下：
```
getData('from_db', function (result) {
    // 时间为 M
});
getData('from_remote_api', function (result) {
    // 时间为 N
});
```
对比两者的时间总消耗，前者为 M+N，后者为 max(M, N)。随着应用复杂性的增加，情景将会变成 M+N+... 和 max(M, N, ...)，同步和异步的优劣势将会凸显出来。这就是异步 I/O 在 Node 中如此盛行，甚至将其作为主要理念进行设计的原因。
#### 1.2、资源分配
假设业务场景有一组互不相干的任务需要完成，现行主流方法有两种：单线程串行依次执行、多线程并行完成。如果创建多线程的开销小于并行执行，那么多线程的方式是首先的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。在复杂的业务中，多线程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。
单线程顺序执行比较符合编程人员按顺序思考的思维方式，而且目前依然是最主流的编程方式，因为它易于表达，但是缺点在于性能。
所以单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。Node 在两者之间给出了它的方案：利用单线程，远离死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好的使用 CPU。
异步 I/O 可以算 Node 的特色，因为它是首个大规模的将异步 I/O 应用在应用层的平台，力求在单线程上将资源分配的更高效。为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览中 Web Workers 的子进程，该子进程可以通过工作进程高效地利用 CPU 和 I/O。
### 二、实现现状
#### 2.1、异步 I/O 与非阻塞 I/O
操作系统内核对于 I/O 只有阻塞和非阻塞两种。阻塞 I/O 的特点是调用之后要等待系统内核层面完成所有操作后调用才结束。非阻塞 I/O 在于获取数据的过程中不带数据直接返回，要获取数据，还需要通过文件描述符再次读取，这对性能的提升是明显的。
任何技术都并非完美，阻塞 I/O 造成 CPU 等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让 CPU 处理状态判断，是对 CPU 资源的浪费。现存的轮询技术主要有：read、select、poll、epoll、kqueue，其中 epoll 是 Linux 下效率最高的 I/O 事件通知机制。
#### 2.2、非阻塞异步 I/O
可以使用多线程的方式，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O。
<img src="/assets/node/async-io.png">
Node 在`*nix`平台下自行实现了线程池来完成异步 I/O，而在 Windows 平台下采用了 IOCP。由于 Windows 平台和`*nix`平台的差异，Node 提供了 libuv 作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。
<img src="/assets/node/lib-uv.png">

### 三、异步 I/O
#### 3.1、事件循环
Node 自身的执行模型：事件循环，正是它使得回调函数十分普遍。
在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。
#### 3.2、观察者
每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。
浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。
事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。
#### 3.3、非 I/O 的异步 API
- 定时器

setTimeout() 和 setInterval() 与浏览器中的 API 是一致的，分别用于单次和多次定时执行任务。它们的实现原理与异步 I/O 比较类似，只是不需要 I/O 线程池的参与。

- process.nextTick()

也许为了立即异步执行一个任务，会这样调用 setTimeout() 来达到所需的效果：
```
setTimeout(function () {
    // TODO
}, 0);
```
由于事件循环自身的特点，定时器的精确度不够，而且创建定时器对象和迭代等操作较为浪费性能。实际上，process.nextTick() 方法的操作相对较为轻量。每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。
- setImmediate()

setImmediate() 方法与 process.nextTick() 方法十分类似，详情见 [node 之 event-loop](/node/event-loop)。
### 四、浏览器与 Node 事件循环细微区别
通过一个例子来说明两者区别：
```
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```
浏览器端运行结果：timer1 => promise1 => timer2 => promise2
Node端运行结果分两种情况：
- 如果是 node11 版本一旦执行一个阶段里的一个宏任务 (setTimeout, setInterval 和 setImmediate) 就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为 timer1 => promise1 => timer2 => promise2
- 如果是 node10 及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中：
  - 如果是第二个定时器还未在完成队列中，最后的结果为 timer1 => promise1 => timer2 => promise2
  - 如果是第二个定时器已经在完成队列中，则最后的结果为 timer1 => timer2 => promise1 => promise2

浏览器和 Node 环境下，microtask 任务队列的执行时机不同：Node 端，microtask 在事件循环的各个阶段之间执行；浏览器端，microtask 在事件循环的 macrotask 执行完之后执行。