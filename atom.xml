<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青松的博客</title>
  
  <subtitle>天行健，君子以自强不息；地势坤，君子以厚德载物。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.master-ss.cn/"/>
  <updated>2019-10-27T02:20:59.443Z</updated>
  <id>http://blog.master-ss.cn/</id>
  
  <author>
    <name>张松松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建npm私有库</title>
    <link href="http://blog.master-ss.cn/project/verdaccio/"/>
    <id>http://blog.master-ss.cn/project/verdaccio/</id>
    <published>2019-10-27T01:29:03.040Z</published>
    <updated>2019-10-27T02:20:59.443Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用 verdaccio 搭建了一个 npm 私有库，verdaccio 特点如下：</p><ul><li>私有包托管在内部服务器中</li><li>项目中即可使用公用仓库上的公共包，也可使用内部服务器上的私有包</li><li>下载的时候公共包走公共仓库，私有包走内部服务器的私有仓库</li><li>只缓存下载过的包，而不是全部同步</li></ul><p>具体搭建过程如下。<br><a id="more"></a> </p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>verdaccio 官网地址 <a href="https://verdaccio.org/zh-CN" target="_blank" rel="noopener">https://verdaccio.org/zh-CN</a><br>安装依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g verdaccio --unsafe-perm=true --allow-root</span><br></pre></td></tr></table></figure></p><p>安装依赖包添加权限是因为直接安装会导致某些权限上的问题，哪怕是用 root 权限去执行</p><h3 id="二、修改配置"><a href="#二、修改配置" class="headerlink" title="二、修改配置"></a>二、修改配置</h3><h4 id="2-1、修改配置文件"><a href="#2-1、修改配置文件" class="headerlink" title="2.1、修改配置文件"></a>2.1、修改配置文件</h4><p>配置文件路径：/root/.config/verdaccio/config.yaml（PS：使用系统为 CentOS 7.5）<br>将 <code>auth: htpasswd:</code> 下的 max_users 改为 -1，让用户不能通过 npm adduser 注册账户</p><h4 id="2-2、手动添加账号"><a href="#2-2、手动添加账号" class="headerlink" title="2.2、手动添加账号"></a>2.2、手动添加账号</h4><p>生成 md5 的 htpasswd 密码，有<a href="http://www.htaccesstools.com/htpasswd-generator/" target="_blank" rel="noopener">密码生成的网站</a><br>会生成以下格式的用户名和密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username:$apr1$809o3o2I$.pN83j6srvreYZA4NL8GF0</span><br></pre></td></tr></table></figure></p><p>在<code>/root/.config/verdaccio</code>下创建或编辑文件 htpasswd<br>写入上面字符串，每个用户占一行，现在就可以通过上面的用户名和密码访问了</p><h3 id="三、启动服务"><a href="#三、启动服务" class="headerlink" title="三、启动服务"></a>三、启动服务</h3><p>使用 pm2 管理 verdaccio，如果没有安装 pm2，需安装一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装 pm2 全局包 --&gt;</span><br><span class="line">npm install pm2 -g</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 pm2 启动 verdaccio 服务 --&gt;</span><br><span class="line">pm2 start/stop verdaccio</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看进程启动情况 --&gt;</span><br><span class="line">pm2 ls</span><br></pre></td></tr></table></figure></p><h3 id="四、配置-nginx-反向代理"><a href="#四、配置-nginx-反向代理" class="headerlink" title="四、配置 nginx 反向代理"></a>四、配置 nginx 反向代理</h3><p>由于 verdaccio 默认是启动在 4873 端口，方便起见，配置 nginx 反向代理到该端口<br>如果需要查看 verdaccio 的端口号，可以用 <code>pm2 ls</code> 查看到 verdaccio 的 pid，然后使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nap | grep &lt;pid&gt;</span><br></pre></td></tr></table></figure></p><p>查看占用的端口号。<br>然后我们去配置域名解析，然后配置 nginx，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name npm.master-ss.cn;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass              http://127.0.0.1:4873/;</span><br><span class="line">    proxy_set_header        Host $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用 <code>nginx -s reload</code> 重启 nginx 服务器，等域名解析生效后就能直接访问了。</p><h3 id="五、使用"><a href="#五、使用" class="headerlink" title="五、使用"></a>五、使用</h3><h4 id="5-1、nrm-切换镜像源"><a href="#5-1、nrm-切换镜像源" class="headerlink" title="5.1、nrm 切换镜像源"></a>5.1、nrm 切换镜像源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 全局安装 nrm --&gt;</span><br><span class="line">npm install -g nrm</span><br><span class="line"></span><br><span class="line">&lt;!-- 增加源 --&gt;</span><br><span class="line">nrm add masterss http://npm.master-ss.cn/</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看可选的源 --&gt;</span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换源 --&gt;</span><br><span class="line">nrm use masterss</span><br></pre></td></tr></table></figure><h4 id="5-2、发布包"><a href="#5-2、发布包" class="headerlink" title="5.2、发布包"></a>5.2、发布包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 登录 --&gt;</span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line">&lt;!-- 发布 --&gt;</span><br><span class="line">npm publish</span><br><span class="line"></span><br><span class="line">&lt;!-- 卸载发布 --&gt;</span><br><span class="line">npm unpublish</span><br></pre></td></tr></table></figure><h4 id="5-3、安装包"><a href="#5-3、安装包" class="headerlink" title="5.3、安装包"></a>5.3、安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方法一：使用 --registry 添加 --&gt;</span><br><span class="line">npm install --save xxx --registry=http://npm.master-ss.cn/</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二：使用 nrm 切换源 --&gt;</span><br><span class="line">nrm use masterss</span><br><span class="line">npm install --save xxx</span><br></pre></td></tr></table></figure><p>推荐在项目初始化的时候使用方法一，因为使用方法二切换到私有源安装的时候会比较慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用 verdaccio 搭建了一个 npm 私有库，verdaccio 特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有包托管在内部服务器中&lt;/li&gt;
&lt;li&gt;项目中即可使用公用仓库上的公共包，也可使用内部服务器上的私有包&lt;/li&gt;
&lt;li&gt;下载的时候公共包走公共仓库，私有包走内部服务器的私有仓库&lt;/li&gt;
&lt;li&gt;只缓存下载过的包，而不是全部同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体搭建过程如下。&lt;br&gt;
    
    </summary>
    
      <category term="project" scheme="http://blog.master-ss.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 聚合查询综合实例</title>
    <link href="http://blog.master-ss.cn/database/mongo7/"/>
    <id>http://blog.master-ss.cn/database/mongo7/</id>
    <published>2019-10-22T08:44:24.256Z</published>
    <updated>2019-10-22T09:47:43.214Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb aggregation 综合实例<br><a id="more"></a> </p><h3 id="一、性能优化"><a href="#一、性能优化" class="headerlink" title="一、性能优化"></a>一、性能优化</h3><ul><li>查询结果需少于 16M<ul><li>使用 $limit &amp; $project</li></ul></li><li>每个管道阶段内存占用少于 100M<ul><li>使用索引</li><li>使用 allowDiskUse，减慢查询速度，可规避 100M 限制，不过不适用于 $graphLookup，因为 $graphLookup 不支持</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      title: /^[aeiou]/i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      title_size: &#123; $size: &#123; $split: [&quot;$title&quot;, &quot; &quot;] &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$title_size&quot;,</span><br><span class="line">      count: &#123; $sum: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sort: &#123; count: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">&lt;!-- 可优化为 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      title: /^[aeiou]/i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sortByCount: &#123;</span><br><span class="line">      $size: &#123; $split: [&quot;$title&quot;, &quot; &quot;] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.stocks.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $unwind: &quot;$trades&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &#123;</span><br><span class="line">        time: &quot;$id&quot;,</span><br><span class="line">        action: &quot;$trades.action&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      trades: &#123; $sum: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$_id.time&quot;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        $push: &#123;</span><br><span class="line">          type: &quot;$_id.action&quot;,</span><br><span class="line">          count: &quot;$trades&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      total_trades: &#123; $sum: &quot;$trades&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sort: &#123; total_trades: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">&lt;!-- 可优化为 --&gt;</span><br><span class="line">db.stocks.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      buy_actions: &#123;</span><br><span class="line">        $size: &#123;</span><br><span class="line">          $filter: &#123;</span><br><span class="line">            input: &quot;$trades&quot;,</span><br><span class="line">            cond: &#123; $eq: [&quot;$$this.action&quot;, &quot;buy&quot;] &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      sell_actions: &#123;</span><br><span class="line">        $size: &#123;</span><br><span class="line">          $filter: &#123;</span><br><span class="line">            input: &quot;$trades&quot;,</span><br><span class="line">            cond: &#123; $eq: [&quot;$$this.action&quot;, &quot;sell&quot;] &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      total_trades: &#123; $size: &quot;$trades&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sort: &#123; total_trades: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="二、综合实例"><a href="#二、综合实例" class="headerlink" title="二、综合实例"></a>二、综合实例</h3><p>使用 air_alliances 和 air_routes 集合，找出哪个 alliance 在 JFK 和 LHR 机场之间双向运作有最多的航空公司<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">db.air_routes.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      src_airport: &#123; $in: [&quot;LHR&quot;, &quot;JFK&quot;] &#125;,</span><br><span class="line">      dst_airport: &#123; $in: [&quot;LHR&quot;, &quot;JFK&quot;] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $lookup: &#123;</span><br><span class="line">      from: &quot;air_alliances&quot;,</span><br><span class="line">      foreignField: &quot;airlines&quot;,</span><br><span class="line">      localField: &quot;airline.name&quot;,</span><br><span class="line">      as: &quot;alliance&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123; alliance: &#123; $ne: [] &#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $addFields: &#123;</span><br><span class="line">      alliance: &#123; $arrayElemAt: [&quot;$alliance.name&quot;, 0] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$airline.id&quot;,</span><br><span class="line">      alliance: &#123; $first: &quot;$alliance&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sortByCount: &quot;$alliance&quot;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb aggregation 综合实例&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 聚合查询之多维分组</title>
    <link href="http://blog.master-ss.cn/database/mongo6/"/>
    <id>http://blog.master-ss.cn/database/mongo6/</id>
    <published>2019-10-22T07:40:21.960Z</published>
    <updated>2019-10-22T08:39:04.992Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb aggregation 分组操作符<br><a id="more"></a> </p><h3 id="一、-sortByCount"><a href="#一、-sortByCount" class="headerlink" title="一、$sortByCount"></a>一、$sortByCount</h3><p>$sortByCount 等效于 $group + $sort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &quot;$imdb.rating&quot;,</span><br><span class="line">      &quot;count&quot;: &#123; &quot;$sum&quot;: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sort&quot;: &#123; &quot;count&quot;: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sortByCount&quot;: &quot;$imdb.rating&quot;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="二、-bucket"><a href="#二、-bucket" class="headerlink" title="二、$bucket"></a>二、$bucket</h3><p>根据边界分段分组，boundaries 表示分段边界数组，default 表示不在边界内显示字段，默认显示 count，使用 output 可以自定义输出字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.companies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;&quot;founded_year&quot;: &#123;&quot;$gt&quot;: 1980&#125;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$bucket&quot;: &#123;</span><br><span class="line">      &quot;groupBy&quot;: &quot;$number_of_employees&quot;,</span><br><span class="line">      &quot;boundaries&quot;: [ 0, 20, 50, 100, 500, 1000, Infinity  ],</span><br><span class="line">      &quot;default&quot;: &quot;Other&quot;,</span><br><span class="line">      &quot;output&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;&quot;$sum&quot;:1&#125;,</span><br><span class="line">        &quot;average&quot;: &#123;&quot;$avg&quot;: &quot;$number_of_employees&quot; &#125;,</span><br><span class="line">        &quot;categories&quot;: &#123;&quot;$addToSet&quot;: &quot;$category_code&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="三、-bucketAuto"><a href="#三、-bucketAuto" class="headerlink" title="三、$bucketAuto"></a>三、$bucketAuto</h3><p>自动分段分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123; &quot;imdb.rating&quot;: &#123; &quot;$gte&quot;: 0 &#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$bucketAuto&quot;: &#123;</span><br><span class="line">      &quot;groupBy&quot;: &quot;$imdb.rating&quot;,</span><br><span class="line">      &quot;buckets&quot;: 4,</span><br><span class="line">      &quot;output&quot;: &#123;</span><br><span class="line">        &quot;average_per_bucket&quot;: &#123; &quot;$avg&quot;: &quot;$imdb.rating&quot; &#125;,</span><br><span class="line">        &quot;count&quot;: &#123; &quot;$sum&quot;: 1 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="四、-facet"><a href="#四、-facet" class="headerlink" title="四、$facet"></a>四、$facet</h3><p>将 $bucket、$bucketAuto、$sortByCount 等聚合到同一阶段，每个键都是输出字段，不能包含 $facet、$out、$geoNear、$indexStats 和 $collStats。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">db.companies.aggregate( [</span><br><span class="line">  &#123; &quot;$match&quot;: &#123; &quot;$text&quot;: &#123;&quot;$search&quot;: &quot;Databases&quot;&#125; &#125; &#125;,</span><br><span class="line">  &#123; &quot;$facet&quot;: &#123;</span><br><span class="line">    &quot;Categories&quot;: [&#123;&quot;$sortByCount&quot;: &quot;$category_code&quot;&#125;],</span><br><span class="line">    &quot;Employees&quot;: [</span><br><span class="line">      &#123; &quot;$match&quot;: &#123;&quot;founded_year&quot;: &#123;&quot;$gt&quot;: 1980&#125;&#125;&#125;,</span><br><span class="line">      &#123;&quot;$bucket&quot;: &#123;</span><br><span class="line">        &quot;groupBy&quot;: &quot;$number_of_employees&quot;,</span><br><span class="line">        &quot;boundaries&quot;: [ 0, 20, 50, 100, 500, 1000, Infinity  ],</span><br><span class="line">        &quot;default&quot;: &quot;Other&quot;</span><br><span class="line">      &#125;&#125;],</span><br><span class="line">    &quot;Founded&quot;: [</span><br><span class="line">      &#123; &quot;$match&quot;: &#123;&quot;offices.city&quot;: &quot;New York&quot; &#125;&#125;,</span><br><span class="line">      &#123;&quot;$bucketAuto&quot;: &#123;</span><br><span class="line">        &quot;groupBy&quot;: &quot;$founded_year&quot;,</span><br><span class="line">        &quot;buckets&quot;: 5   &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;&#125;]).pretty()</span><br><span class="line"></span><br><span class="line">&lt;!-- 应用实例 --&gt;</span><br><span class="line">同时在 imdb.rating 和 metacritic 字段上排前十的有多少部电影？</span><br><span class="line">&lt;!-- 聚合查询 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      metacritic: &#123; $gte: 0 &#125;,</span><br><span class="line">      &quot;imdb.rating&quot;: &#123; $gte: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      metacritic: 1,</span><br><span class="line">      imdb: 1,</span><br><span class="line">      title: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $facet: &#123;</span><br><span class="line">      top_metacritic: [</span><br><span class="line">        &#123;</span><br><span class="line">          $sort: &#123;</span><br><span class="line">            metacritic: -1,</span><br><span class="line">            title: 1</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          $limit: 10</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          $project: &#123;</span><br><span class="line">            title: 1</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      top_imdb: [</span><br><span class="line">        &#123;</span><br><span class="line">          $sort: &#123;</span><br><span class="line">            &quot;imdb.rating&quot;: -1,</span><br><span class="line">            title: 1</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          $limit: 10</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          $project: &#123;</span><br><span class="line">            title: 1</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      movies_in_both: &#123;</span><br><span class="line">        $setIntersection: [&quot;$top_metacritic&quot;, &quot;$top_imdb&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb aggregation 分组操作符&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 聚合查询组合信息</title>
    <link href="http://blog.master-ss.cn/database/mongo5/"/>
    <id>http://blog.master-ss.cn/database/mongo5/</id>
    <published>2019-10-22T01:22:06.259Z</published>
    <updated>2019-10-22T08:40:36.583Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb aggregation 组合信息操作符<br><a id="more"></a> </p><h3 id="一、-group"><a href="#一、-group" class="headerlink" title="一、$group"></a>一、$group</h3><p>通过指定的 _id 字段对输入文档进行分组（_id 是用来标识分组），并针对每个不同的分组输出文档。每个输出文档的 _id 字段均包含唯一的按值分组，输出文档还可以包含某些 accumulator 表达式值的计算字段，如：$sum、$avg、$min、$max    等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 先分组统计，再根据 count 倒序排列 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &quot;$year&quot;,</span><br><span class="line">      &quot;count&quot;: &#123; &quot;$sum&quot;: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sort&quot;: &#123; &quot;count&quot;: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;!-- $group 的字段可以使用表达式 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &#123;</span><br><span class="line">        &quot;numDirectors&quot;: &#123;</span><br><span class="line">          &quot;$cond&quot;: [&#123; &quot;$isArray&quot;: &quot;$directors&quot; &#125;, &#123; &quot;$size&quot;: &quot;$directors&quot; &#125;, 0]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;numFilms&quot;: &#123; &quot;$sum&quot;: 1 &#125;,</span><br><span class="line">      &quot;averageMetacritic&quot;: &#123; &quot;$avg&quot;: &quot;$metacritic&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sort&quot;: &#123; &quot;_id.numDirectors&quot;: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;!-- 先过滤，再对所有数据进行分组，计算平均值 --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123; &quot;metacritic&quot;: &#123; &quot;$gte&quot;: 0 &#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: null,</span><br><span class="line">      &quot;averageMetacritic&quot;: &#123; &quot;$avg&quot;: &quot;$metacritic&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="二、accumulator"><a href="#二、accumulator" class="headerlink" title="二、accumulator"></a>二、accumulator</h3><p>使用 $sum、$avg、$min、$max    等，$map、$reduce 可用于更复杂的计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 $reduce 计算 avg_high_tmp 最大值 --&gt;</span><br><span class="line">db.icecream_data.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: 0,</span><br><span class="line">      &quot;max_high&quot;: &#123;</span><br><span class="line">        &quot;$reduce&quot;: &#123;</span><br><span class="line">          &quot;input&quot;: &quot;$trends&quot;,</span><br><span class="line">          &quot;initialValue&quot;: -Infinity,</span><br><span class="line">          &quot;in&quot;: &#123;</span><br><span class="line">            &quot;$cond&quot;: [</span><br><span class="line">              &#123; &quot;$gt&quot;: [&quot;$$this.avg_high_tmp&quot;, &quot;$$value&quot;] &#125;,</span><br><span class="line">              &quot;$$this.avg_high_tmp&quot;,</span><br><span class="line">              &quot;$$value&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;!-- 可使用 $max 简化操作 --&gt;</span><br><span class="line">db.icecream_data.aggregate([&#123;</span><br><span class="line">  &quot;$project&quot;: &#123;</span><br><span class="line">    &quot;_id&quot;: 0,</span><br><span class="line">    &quot;max_high&quot;: &#123;</span><br><span class="line">      &quot;$max&quot;: &quot;$trends.avg_high_tmp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line">&lt;!-- 分组计算总和 --&gt;</span><br><span class="line">db.icecream_data.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: 0,</span><br><span class="line">      &quot;yearly_sales (millions)&quot;: &#123; &quot;$sum&quot;: &quot;$trends.icecream_sales_in_millions&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;!-- 应用实例 --&gt;</span><br><span class="line">对所有获得至少 1 项奥斯卡奖的影片，请计算 imdb.rating 的标准偏差，最高，最低和平均值。</span><br><span class="line">提示-该系列中所有获得奥斯卡奖的电影都以类似于以下奖项之一的字符串开头：</span><br><span class="line">比如：</span><br><span class="line">Won 13 Oscars</span><br><span class="line">Won 1 Oscar</span><br><span class="line">数字精确到小数点后 4 位</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      awards: /Won \d&#123;1,2&#125; Oscars?/</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: null,</span><br><span class="line">      highest_rating: &#123; $max: &quot;$imdb.rating&quot; &#125;,</span><br><span class="line">      lowest_rating: &#123; $min: &quot;$imdb.rating&quot; &#125;,</span><br><span class="line">      average_rating: &#123; $avg: &quot;$imdb.rating&quot; &#125;,</span><br><span class="line">      deviation: &#123; $stdDevSamp: &quot;$imdb.rating&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="二、-unwind"><a href="#二、-unwind" class="headerlink" title="二、$unwind"></a>二、$unwind</h3><p>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。只在数组中使用，在大集合中使用 $unwind 会有性能问题，可能导致内存超出，所以尽早使用 $match 过滤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 找出 2010 到 2015 电影 imdb.rating 最高的 genres --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;imdb.rating&quot;: &#123; &quot;$gt&quot;: 0 &#125;,</span><br><span class="line">      &quot;year&quot;: &#123; &quot;$gte&quot;: 2010, &quot;$lte&quot;: 2015 &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$unwind&quot;: &quot;$genres&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &#123;</span><br><span class="line">        &quot;year&quot;: &quot;$year&quot;,</span><br><span class="line">        &quot;genre&quot;: &quot;$genres&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;average_rating&quot;: &#123; &quot;$avg&quot;: &quot;$imdb.rating&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sort&quot;: &#123; &quot;_id.year&quot;: -1, &quot;average_rating&quot;: -1 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$group&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &quot;$_id.year&quot;,</span><br><span class="line">      &quot;genre&quot;: &#123; &quot;$first&quot;: &quot;$_id.genre&quot; &#125;,</span><br><span class="line">      &quot;average_rating&quot;: &#123; &quot;$first&quot;: &quot;$average_rating&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$sort&quot;: &#123; &quot;_id&quot;: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;!-- 应用实例 --&gt;</span><br><span class="line">计算每个 cast 的参加电影数量，并获取每个 cast 的平均 imdb.rating。</span><br><span class="line">出现在英语作为可用语言的电影次数最多的 cast，电影数量和平均 imdb.rating（精确到小数点后一位）是多少？</span><br><span class="line">按照以下顺序和格式提供输入：</span><br><span class="line">&#123; &quot;_id&quot;: &quot;First Last&quot;, &quot;numFilms&quot;: 1, &quot;average&quot;: 1.1 &#125;</span><br><span class="line">$trunc 将数字截断为整数或指定的小数位：&#123; $trunc : [ &lt;number&gt;, &lt;place&gt; ] &#125;，place 默认为 0</span><br><span class="line">$trunc: [1234.5678, 0] =&gt; 1234</span><br><span class="line">$trunc: [1234.5678, -2] =&gt; 1200</span><br><span class="line">$trunc: [1234.5678, 2] =&gt; 1234.56</span><br><span class="line">&lt;!-- 聚合查询如下： --&gt;</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      languages: &quot;English&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123; _id: 0, cast: 1, &quot;imdb.rating&quot;: 1 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $unwind: &quot;$cast&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$cast&quot;,</span><br><span class="line">      numFilms: &#123; $sum: 1 &#125;,</span><br><span class="line">      average: &#123; $avg: &quot;$imdb.rating&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      numFilms: 1,</span><br><span class="line">      average: &#123;</span><br><span class="line">        $divide: [&#123; $trunc: &#123; $multiply: [&quot;$average&quot;, 10] &#125; &#125;, 10]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sort: &#123; numFilms: -1 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $limit: 1</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="三、-lookup"><a href="#三、-lookup" class="headerlink" title="三、$lookup"></a>三、$lookup</h3><p>对同一数据库中的未分片集合执行左外部联接。在每个输入文档中，$lookup 阶段都会添加一个新的数组字段，其元素是 “joined” 集合中的匹配文档，$lookup 阶段将这些经过重整的文档传递到下一个阶段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">db.air_alliances.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$lookup&quot;: &#123;</span><br><span class="line">      &quot;from&quot;: &quot;air_airlines&quot;,</span><br><span class="line">      &quot;localField&quot;: &quot;airlines&quot;,</span><br><span class="line">      &quot;foreignField&quot;: &quot;name&quot;,</span><br><span class="line">      &quot;as&quot;: &quot;airlines&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]).pretty()</span><br><span class="line"></span><br><span class="line">&lt;!-- 应用实例 --&gt;</span><br><span class="line">在 air_alliances 中使用 Boeing 747 或 Airbus A380（在 air_routes 中分别为 747 和 380）最多的是哪个 alliance？</span><br><span class="line">&lt;!-- 聚合查询实例 --&gt;</span><br><span class="line">db.air_routes.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      airplane: /747|380/</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $lookup: &#123;</span><br><span class="line">      from: &quot;air_alliances&quot;,</span><br><span class="line">      foreignField: &quot;airlines&quot;,</span><br><span class="line">      localField: &quot;airline.name&quot;,</span><br><span class="line">      as: &quot;alliance&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $unwind: &quot;$alliance&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$alliance.name&quot;,</span><br><span class="line">      count: &#123; $sum: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $sort: &#123; count: -1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="四、-graphLookup"><a href="#四、-graphLookup" class="headerlink" title="四、$graphLookup"></a>四、$graphLookup</h3><p>对集合执行递归搜索，其中包含用于通过递归深度和查询限制搜索的选项，from 为递归匹配 connectFromField 和 connectToField 字段的集合。<br>注意事项：<br>可能返回过多数据，导致内存溢出，使用 $allowDiskUse 选项；<br>或者给 connectToField 添加索引；<br>不能在分片集合中使用；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自递归查询出所有下属 --&gt;</span><br><span class="line">db.parent_reference.aggregate([&#123;</span><br><span class="line">  $match: &#123;</span><br><span class="line">    name: &apos;Eliot&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $graphLookup: &#123;</span><br><span class="line">    from: &apos;parent_reference&apos;,</span><br><span class="line">    startWith: &apos;$_id&apos;,</span><br><span class="line">    connectFromField: &apos;_id&apos;,</span><br><span class="line">    connectToField: &apos;reports_to&apos;,</span><br><span class="line">    as: &apos;all_reports&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]).pretty()</span><br><span class="line"></span><br><span class="line">&lt;!-- 自递归查询出所有下属，maxDepth 如果为 0 则是直接下属，没有递归查询；depthField  --&gt;</span><br><span class="line">db.child_reference.aggregate([&#123;</span><br><span class="line">  $match: &#123;</span><br><span class="line">    name: &apos;Dev&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $graphLookup: &#123;</span><br><span class="line">    from: &apos;child_reference&apos;,</span><br><span class="line">    startWith: &apos;$direct_reports&apos;,</span><br><span class="line">    connectFromField: &apos;direct_reports&apos;,</span><br><span class="line">    connectToField: &apos;name&apos;,</span><br><span class="line">    as: &apos;till_2_level_reports&apos;,</span><br><span class="line">    maxDepth: 1,</span><br><span class="line">    depthField: &apos;level&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]).pretty()</span><br><span class="line"></span><br><span class="line">&lt;!-- 跨表递归查询，restrictSearchWithMatch 用于递归查询过滤 --&gt;</span><br><span class="line">db.air_airlines.aggregate([&#123;</span><br><span class="line">  $match: &#123;</span><br><span class="line">    name: &apos;TAP Portugal&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $graphLookup: &#123;</span><br><span class="line">    from: &apos;air_routes&apos;,</span><br><span class="line">    startWith: &apos;$base&apos;,</span><br><span class="line">    connectFromField: &apos;dst_airport&apos;,</span><br><span class="line">    connectToField: &apos;src_airport&apos;,</span><br><span class="line">    as: &apos;chain&apos;,</span><br><span class="line">    maxDepth: 1,</span><br><span class="line">    depthField: &apos;level&apos;,</span><br><span class="line">    restrictSearchWithMatch: &#123;</span><br><span class="line">      &apos;airline.name&apos;: &apos;TAP Portugal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;], &#123;</span><br><span class="line">  allowDiskUse: true</span><br><span class="line">&#125;).pretty()</span><br><span class="line"></span><br><span class="line">&lt;!-- 应用实例 --&gt;</span><br><span class="line">查找最多有一个中转的，属于 &quot;OneWorld&quot; 联盟的航空公司的 base 机场的所有可能目的地的列表。航空公司应是德国，西班牙或加拿大的国家航空公司。包括目的地以及该位置的航空公司。小提示，应该找到158个目的地。</span><br><span class="line">db.air_alliances.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123; name: &quot;OneWorld&quot; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $graphLookup: &#123;</span><br><span class="line">      startWith: &quot;$airlines&quot;,</span><br><span class="line">      from: &quot;air_airlines&quot;,</span><br><span class="line">      connectFromField: &quot;name&quot;,</span><br><span class="line">      connectToField: &quot;name&quot;,</span><br><span class="line">      as: &quot;airlines&quot;,</span><br><span class="line">      maxDepth: 0,</span><br><span class="line">      restrictSearchWithMatch: &#123;</span><br><span class="line">        country: &#123; $in: [&quot;Germany&quot;, &quot;Spain&quot;, &quot;Canada&quot;] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $graphLookup: &#123;</span><br><span class="line">      startWith: &quot;$airlines.base&quot;,</span><br><span class="line">      from: &quot;air_routes&quot;,</span><br><span class="line">      connectFromField: &quot;dst_airport&quot;,</span><br><span class="line">      connectToField: &quot;src_airport&quot;,</span><br><span class="line">      as: &quot;connections&quot;,</span><br><span class="line">      maxDepth: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      validAirlines: &quot;$airlines.name&quot;,</span><br><span class="line">      &quot;connections.dst_airport&quot;: 1,</span><br><span class="line">      &quot;connections.airline.name&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; $unwind: &quot;$connections&quot; &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      isValid: &#123;</span><br><span class="line">        $in: [&quot;$connections.airline.name&quot;, &quot;$validAirlines&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;connections.dst_airport&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; $match: &#123; isValid: true &#125; &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &quot;$connections.dst_airport&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb aggregation 组合信息操作符&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 聚合查询基础</title>
    <link href="http://blog.master-ss.cn/database/mongo4/"/>
    <id>http://blog.master-ss.cn/database/mongo4/</id>
    <published>2019-10-21T09:53:04.749Z</published>
    <updated>2019-10-21T14:24:32.844Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb aggregation 基础。<br><a id="more"></a> </p><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><ul><li><p>远程连接<br>mongo “mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017/test?replicaSet=Cluster0-shard-0” -authenticationDatabase admin -ssl -username m001-student -password m001-mongodb-basics</p></li><li><p>导出<br>mongodump -u m121 -p aggregations -h “Cluster0-shard-0/cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017” –db aggregations –authenticationDatabase admin –ssl -o /Users/songsong.zhang/Desktop/mongo</p></li><li><p>导入<br>mongorestore –db aggregations /Users/songsong.zhang/Desktop/mongo/aggregations</p></li><li><p>管道通信<br>$match &gt; $project &gt; $group<br>$match: 用来过滤文档查询<br>$project: 用来格式化输出<br>$group: 用来数组分组</p></li></ul><h3 id="二、基础命令"><a href="#二、基础命令" class="headerlink" title="二、基础命令"></a>二、基础命令</h3><ul><li><p>$match<br>$match 使用 Mongodb 查询语句，应尽可能在前面被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">db.solarSystem.aggregate([&#123;</span><br><span class="line">  &quot;$match&quot;: &#123; &quot;type&quot;: &#123; &quot;$ne&quot;: &quot;Star&quot;&#125; &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$count&quot;: &quot;planets&quot;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">应用实例：</span><br><span class="line">在下一个电影之夜帮助 MongoDB 挑选电影，可能的电影必须满足以下条件：</span><br><span class="line">imdb.rating 至少为 7；</span><br><span class="line">genres 不包含 &quot;Crime&quot; 或 &quot;Horror&quot;；</span><br><span class="line">rated 为 &quot;PG&quot; 或 &quot;G&quot;；</span><br><span class="line">languages 包含 &quot;English&quot; 和 &quot;Japanese&quot;；</span><br><span class="line">具体管道通信代码如下：</span><br><span class="line">var pipeline = [</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      &quot;imdb.rating&quot;: &#123; $gte: 7 &#125;,</span><br><span class="line">      genres: &#123; $nin: [ &quot;Crime&quot;, &quot;Horror&quot; ] &#125; ,</span><br><span class="line">      rated: &#123; $in: [&quot;PG&quot;, &quot;G&quot; ] &#125;,</span><br><span class="line">      languages: &#123; $all: [ &quot;English&quot;, &quot;Japanese&quot; ] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>$project<br>一旦表明某个字段显式返回，则所有返回的字段均需要显式表明，_id 除外；<br>不仅仅可以移除和返回字段，而且可以添加新字段；<br>在聚合管道中可多次使用；<br>可使用已存在字段重新分配新值或创建新字段；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">db.solarSystem.aggregate([&#123;</span><br><span class="line">&quot;$project&quot;: &#123;</span><br><span class="line">&quot;_id&quot;: 0,</span><br><span class="line">&quot;name&quot;: 1,</span><br><span class="line">&quot;myWeight&quot;: &#123;</span><br><span class="line">&quot;$multiply&quot;: [&#123;</span><br><span class="line">&quot;$divide&quot;: [&quot;$gravity.value&quot;, 9.8]</span><br><span class="line">&#125;, 86]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">应用实例：</span><br><span class="line">我们的电影数据集包含许多不同的文档，其中一些具有比其他更复杂的标题。如果我们想分析集合以查找仅由一个单词组成的电影标题，则可以获取数据集中的所有电影并在客户端应用程序中进行一些处理，但是 aggregation 允许我们在数据库中处理！</span><br><span class="line">查找标题由一个单词组成的电影数量，比如，&quot;Cinderella&quot; 和 &quot;3-25&quot; 应该算在内，而 &quot;Cast Away&quot; 则不算。</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        $type: &quot;string&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      title: &#123; $split: [&quot;$title&quot;, &quot; &quot;] &#125;,</span><br><span class="line">      _id: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      title: &#123; $size: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]).itcount()</span><br></pre></td></tr></table></figure></li><li><p>$addFields<br>为查询结果添加字段，如果已存在则覆盖原字段。$project 有同样的效果，但是通常用于显示或移除字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.solarSystem.aggregate([</span><br><span class="line">&#123;&quot;$project&quot;: &#123;</span><br><span class="line">    &quot;_id&quot;: 0,</span><br><span class="line">    &quot;name&quot;: 1,</span><br><span class="line">    &quot;gravity&quot;: 1,</span><br><span class="line">    &quot;mass&quot;: 1,</span><br><span class="line">    &quot;radius&quot;: 1,</span><br><span class="line">    &quot;sma&quot;: 1&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;&quot;$addFields&quot;: &#123;</span><br><span class="line">    &quot;gravity&quot;: &quot;$gravity.value&quot;,</span><br><span class="line">    &quot;mass&quot;: &quot;$mass.value&quot;,</span><br><span class="line">    &quot;radius&quot;: &quot;$radius.value&quot;,</span><br><span class="line">    &quot;sma&quot;: &quot;$sma.value&quot;</span><br><span class="line">&#125;&#125;]);</span><br></pre></td></tr></table></figure></li><li><p>指针类<br>$limit、$skip、$count、$sort</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">db.solarSystem.aggregate([&#123;</span><br><span class="line">  &quot;$match&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Terrestrial planet&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$count&quot;: &quot;terrestrial planets&quot;</span><br><span class="line">&#125;]).pretty();</span><br><span class="line"></span><br><span class="line">使用实例：</span><br><span class="line">MongoDB安排了另一个电影之夜。这次，我们对员工进行了投票，以找出他们最喜欢的女演员或演员，并获得了这些结果：</span><br><span class="line">favorites = [</span><br><span class="line">  &quot;Sandra Bullock&quot;,</span><br><span class="line">  &quot;Tom Hanks&quot;,</span><br><span class="line">  &quot;Julia Roberts&quot;,</span><br><span class="line">  &quot;Kevin Spacey&quot;,</span><br><span class="line">  &quot;George Clooney&quot;</span><br><span class="line">]</span><br><span class="line">对于在 USA 发行的 Tomatos.viewer.rating 大于或等于 3 的电影，请计算一个名为 num_favs 的新字段，该字段表示在该电影的 cast 字段中出现多少个 favorites。对 num_favs，tomatos.viewer.rating 和 title 进行降序排序，结果中第 25 部电影的标题是什么？</span><br><span class="line">聚合查询如下：</span><br><span class="line">db.movies.aggregate([&#123;</span><br><span class="line">  &quot;$match&quot;: &#123;</span><br><span class="line">    &quot;tomatoes.viewer.rating&quot;: &#123; &quot;$gte&quot;: 3 &#125;,</span><br><span class="line">    &quot;countries&quot;: &quot;USA&quot;,</span><br><span class="line">    &quot;cast&quot;: &#123;</span><br><span class="line">      &quot;$in&quot;: favorites</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$project&quot;: &#123;</span><br><span class="line">    &quot;_id&quot;: -1,</span><br><span class="line">    &quot;title&quot;: 1,</span><br><span class="line">    &quot;tomatoes.viewer.rating&quot;: 1,</span><br><span class="line">    &quot;num_favs&quot;: &#123;</span><br><span class="line">      &quot;$size&quot;: &#123;</span><br><span class="line">        &quot;$setIntersection&quot;: [</span><br><span class="line">          &quot;$cast&quot;,</span><br><span class="line">          favorites</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$sort&quot;: &#123;</span><br><span class="line">    &quot;num_favs&quot;: -1,</span><br><span class="line">    &quot;tomatoes.viewer.rating&quot;: -1,</span><br><span class="line">    &quot;title&quot;: -1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$skip&quot;: 24</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;$limit&quot;: 1</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></li><li><p>综合实例<br>计算每部可选语言是英语的电影的平均评分，而且 imdb.rating 至少为 1，imdb.votes 至少为 1，并且该电影于 1990 年或之后发行。需要重新规范化 imdb.votes，公式如下：<br>scaled_votes = 1 + 9 * ((x - x_min) / (x_max - x_min))<br>x_max = 1521105<br>x_min = 5<br>x = imdb.votes<br>normalized_rating = average(scaled_votes, imdb.rating)<br>哪部电影的 normalized_rating 最低？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">聚合查询如下：</span><br><span class="line">db.movies.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">      year: &#123; $gte: 1990 &#125;,</span><br><span class="line">      languages: &#123; $in: [&quot;English&quot;] &#125;,</span><br><span class="line">      &quot;imdb.votes&quot;: &#123; $gte: 1 &#125;,</span><br><span class="line">      &quot;imdb.rating&quot;: &#123; $gte: 1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      _id: 0,</span><br><span class="line">      title: 1,</span><br><span class="line">      &quot;imdb.rating&quot;: 1,</span><br><span class="line">      &quot;imdb.votes&quot;: 1,</span><br><span class="line">      normalized_rating: &#123;</span><br><span class="line">        $avg: [</span><br><span class="line">          &quot;$imdb.rating&quot;,</span><br><span class="line">          &#123;</span><br><span class="line">            $add: [</span><br><span class="line">              1,</span><br><span class="line">              &#123;</span><br><span class="line">                $multiply: [</span><br><span class="line">                  9,</span><br><span class="line">                  &#123;</span><br><span class="line">                    $divide: [</span><br><span class="line">                      &#123; $subtract: [&quot;$imdb.votes&quot;, 5] &#125;,</span><br><span class="line">                      &#123; $subtract: [1521105, 5] &#125;</span><br><span class="line">                    ]</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; $sort: &#123; normalized_rating: 1 &#125; &#125;,</span><br><span class="line">  &#123; $limit: 1 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb aggregation 基础。&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>chrome 调试小技巧</title>
    <link href="http://blog.master-ss.cn/tools/chrome/"/>
    <id>http://blog.master-ss.cn/tools/chrome/</id>
    <published>2019-10-13T13:02:17.187Z</published>
    <updated>2019-10-13T13:36:03.330Z</updated>
    
    <content type="html"><![CDATA[<p>最近又学到了一些 chrome 调试的小技巧，赶紧记录下来。<br><a id="more"></a> </p><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><ul><li>快速切换文件</li><li>在源代码中搜索</li><li>强制改变元素状态（方便查看不同状态下元素的样式）</li></ul><h3 id="二、快速切换文件"><a href="#二、快速切换文件" class="headerlink" title="二、快速切换文件"></a>二、快速切换文件</h3><p>如果查找每个文件，一般都是打开控制台，在 source 控制面板里面一个一个去找，看下面的图就应该知道，这么多文件，你都不知道在哪个目录下面，然后就只能一个一个点开看</p><p><img src="/assets/tools/chrome/source.png"></p><p>后来才发现原来按 Ctrl+P（cmd+p on mac）,就能快速搜寻和打开你项目的文件。</p><p><img src="/assets/tools/chrome/search-file.gif"></p><h3 id="三、在源代码中搜索"><a href="#三、在源代码中搜索" class="headerlink" title="三、在源代码中搜索"></a>三、在源代码中搜索</h3><p>大家都知道如果在要在 Elements 查看源码，只要定位到 Elements 面板，然后按 ctrl+f 就可以了</p><p><img src="/assets/tools/chrome/search-code.png"></p><p>可是如果你希望在源代码中搜索要怎么办呢？在页面已经加载的文件中搜寻一个特定的字符串，快捷键是 Ctrl+Shift+F (Cmd+Opt+F)，这种搜寻方式还支持正则表达式哦</p><p><img src="/assets/tools/chrome/search-sourcecode.png"></p><h3 id="四、强制改变元素状态"><a href="#四、强制改变元素状态" class="headerlink" title="四、强制改变元素状态"></a>四、强制改变元素状态</h3><p>chrome 控制台有一个可以模拟 CSS 状态的功能，例如元素的 hover 和 focus，可以很容易的改变元素样式。在 CSS 编辑器中可以利用这个功能查看不同状态下元素的样式，相信这个功能对于模仿别人界面的前端爱好者来说是非常实用的。</p><p><img src="/assets/tools/chrome/dom-status.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又学到了一些 chrome 调试的小技巧，赶紧记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.master-ss.cn/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>本机字体检测</title>
    <link href="http://blog.master-ss.cn/project/font/"/>
    <id>http://blog.master-ss.cn/project/font/</id>
    <published>2019-09-29T09:26:51.200Z</published>
    <updated>2019-09-29T09:44:21.625Z</updated>
    
    <content type="html"><![CDATA[<p>前端时间做过一个关于字体检测项目，现在做下总结，主要用于在本机检测某字体是否安装。<br><a id="more"></a> </p><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function isSupportFontFamily(f) &#123;</span><br><span class="line">  if (typeof f !== &apos;string&apos;) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  var h = &apos;Arial&apos;</span><br><span class="line">  if (f.toLowerCase() == h.toLowerCase()) &#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  var e = &apos;a&apos;</span><br><span class="line">  var d = 100</span><br><span class="line">  var a = 100; var i = 100</span><br><span class="line">  var c = document.createElement(&apos;canvas&apos;)</span><br><span class="line">  var b = c.getContext(&apos;2d&apos;)</span><br><span class="line">  c.width = a</span><br><span class="line">  c.height = i</span><br><span class="line">  b.textAlign = &apos;center&apos;</span><br><span class="line">  b.fillStyle = &apos;black&apos;</span><br><span class="line">  b.textBaseline = &apos;middle&apos;</span><br><span class="line">  var g = function (j) &#123;</span><br><span class="line">    b.clearRect(0, 0, a, i)</span><br><span class="line">    b.font = d + &apos;px &apos; + j + &apos;, &apos; + h</span><br><span class="line">    b.fillText(e, a / 2, i / 2)</span><br><span class="line">    var k = b.getImageData(0, 0, a, i).data</span><br><span class="line">    return [].slice.call(k).filter(function (l) &#123; return l != 0 &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return g(h).join(&apos;&apos;) !== g(f).join(&apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上代码，很简单一个方法，传入字体名称，判断本机是否已经安装该字体。</p><h3 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h3><h4 id="2-1、语法"><a href="#2-1、语法" class="headerlink" title="2.1、语法"></a>2.1、语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSupportFontFamily(fontFamily)</span><br></pre></td></tr></table></figure><p>其中 fontFamily 参数是必须的，为 CSS 中 font-family 设置的 web 可识别的字体名称，例如宋体 ‘simsun’，微软雅黑 ‘Microsoft Yahei’ 等。<br>例如，我们要判断用户的操作系统是否安装了微软雅黑字体，可以这么处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// isSupportMicrosoftYahei 为 true 或者 false</span><br><span class="line">var isSupportMicrosoftYahei = isSupportFontFamily(&apos;Microsoft Yahei&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="2-2、原理"><a href="#2-2、原理" class="headerlink" title="2.2、原理"></a>2.2、原理</h4><p>根据用户设置的字体将某一个字符 ‘a’ 绘制在 canvas 上，并提取像素信息，然后和默认字体 ‘Arial’ 进行比对。如果像素不一致，说明字体生效，反之说明字体不生效。<br>兼容 IE9+，以及其他所有现代浏览器。</p><h4 id="2-3、部分字体中英文名称"><a href="#2-3、部分字体中英文名称" class="headerlink" title="2.3、部分字体中英文名称"></a>2.3、部分字体中英文名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Times New Roman&apos;, &apos;en_name&apos;: &apos;Times New Roman&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Zhiyong Elegant&apos;, &apos;en_name&apos;: &apos;Zhiyong Elegant&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;ZhiyongWrite&apos;, &apos;en_name&apos;: &apos;ZhiyongWrite&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;仿宋&apos;, &apos;en_name&apos;: &apos;FangSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪贤二体&apos;, &apos;en_name&apos;: &apos;XianErTi&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;黑体&apos;, &apos;en_name&apos;: &apos;SimHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;楷体&apos;, &apos;en_name&apos;: &apos;KaiTi&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;濑户字体&apos;, &apos;en_name&apos;: &apos;SetoFont&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;隶书&apos;, &apos;en_name&apos;: &apos;LiSu&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;沐瑶软笔手写体&apos;, &apos;en_name&apos;: &apos;Muyao-Softbrush&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;庞门正道标题体&apos;, &apos;en_name&apos;: &apos;PangMenZhengDao&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;锐字真言体&apos;, &apos;en_name&apos;: &apos;ZhenyanGB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;手书体&apos;, &apos;en_name&apos;: &apos;ShouShuti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;思源黑体&apos;, &apos;en_name&apos;: &apos;Source Han Sans CN&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;思源柔黑体&apos;, &apos;en_name&apos;: &apos;Gen Jyuu Gothic&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;思源宋体&apos;, &apos;en_name&apos;: &apos;Source Han Serif CN&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;思源真黑体&apos;, &apos;en_name&apos;: &apos;Gen Shin Gothic&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;宋体&apos;, &apos;en_name&apos;: &apos;SimSun&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;新宋体&apos;, &apos;en_name&apos;: &apos;NSimSun&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;杨任东竹石体&apos;, &apos;en_name&apos;: &apos;YRDZST&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;幼圆&apos;, &apos;en_name&apos;: &apos;YouYuan&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;源流明体&apos;, &apos;en_name&apos;: &apos;GenRynMin TW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;源漾明体&apos;, &apos;en_name&apos;: &apos;GenYoMin TW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;源云明体&apos;, &apos;en_name&apos;: &apos;GenWanMin TW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷高端黑&apos;, &apos;en_name&apos;: &apos;huxiaobo-gdh&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷酷黑&apos;, &apos;en_name&apos;: &apos;HuXiaoBo-KuHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷快乐体&apos;, &apos;en_name&apos;: &apos;HappyZcool&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷快乐体新版&apos;, &apos;en_name&apos;: &apos;HappyZco6&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷庆科黄油体&apos;, &apos;en_name&apos;: &apos;zcoolqingkehuangyouti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷文艺体&apos;, &apos;en_name&apos;: &apos;zcoolwenyiti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;站酷小薇logo体&apos;, &apos;en_name&apos;: &apos;xiaowei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;装甲明朝体&apos;, &apos;en_name&apos;: &apos;SoukouMincho&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Abril&apos;, &apos;en_name&apos;: &apos;Abril&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Abril Titling&apos;, &apos;en_name&apos;: &apos;Abril Titling&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Adelle&apos;, &apos;en_name&apos;: &apos;Adelle&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Adelle Sans&apos;, &apos;en_name&apos;: &apos;Adelle Sans&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Adelle Sans DEV&apos;, &apos;en_name&apos;: &apos;Adelle Sans&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Adobe Gothic Std B&apos;, &apos;en_name&apos;: &apos;Adobe Gothic Std B&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Adobe Myungjo Std M&apos;, &apos;en_name&apos;: &apos;Adobe Myungjo Std M&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Alize&apos;, &apos;en_name&apos;: &apos;Alize&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Arial Unicode MS&apos;, &apos;en_name&apos;: &apos;Arial&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Athelas&apos;, &apos;en_name&apos;: &apos;Athelas&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;AwanZaman&apos;, &apos;en_name&apos;: &apos;AwanZaman&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Bely&apos;, &apos;en_name&apos;: &apos;BELY&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Bree&apos;, &apos;en_name&apos;: &apos;Bree&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Bree Serif&apos;, &apos;en_name&apos;: &apos;Bree Serif&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Capitolium2&apos;, &apos;en_name&apos;: &apos;Capitolium2&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Century Gothic&apos;, &apos;en_name&apos;: &apos;Century Gothic&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Cora&apos;, &apos;en_name&apos;: &apos;Cora&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Coranto 2&apos;, &apos;en_name&apos;: &apos;Coranto 2&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Crete&apos;, &apos;en_name&apos;: &apos;Crete&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Ebony&apos;, &apos;en_name&apos;: &apos;Ebony&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Edita&apos;, &apos;en_name&apos;: &apos;Edita&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Eskapade&apos;, &apos;en_name&apos;: &apos;Eskapade&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Essay&apos;, &apos;en_name&apos;: &apos;Essay Text&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Fino&apos;, &apos;en_name&apos;: &apos;FINO&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Fino Stencil&apos;, &apos;en_name&apos;: &apos;FINO STENCIL&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Garalda&apos;, &apos;en_name&apos;: &apos;Garalda&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Givry&apos;, &apos;en_name&apos;: &apos;Givry&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Helvetica&apos;, &apos;en_name&apos;: &apos;Helvetica&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Iro Sans&apos;, &apos;en_name&apos;: &apos;IRO SANS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Iskra&apos;, &apos;en_name&apos;: &apos;Iskra&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Karmina&apos;, &apos;en_name&apos;: &apos;Karmina&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Karmina Sans&apos;, &apos;en_name&apos;: &apos;Karmina Sans&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;LFT Etica&apos;, &apos;en_name&apos;: &apos;LFT Etica&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Lipa Agate&apos;, &apos;en_name&apos;: &apos;Lipa Agate&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Lisbeth&apos;, &apos;en_name&apos;: &apos;Lisbeth&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Maiola&apos;, &apos;en_name&apos;: &apos;Maiola&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Marco&apos;, &apos;en_name&apos;: &apos;Marco&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Noam&apos;, &apos;en_name&apos;: &apos;NOAM&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Noort&apos;, &apos;en_name&apos;: &apos;NOORT&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Pollen&apos;, &apos;en_name&apos;: &apos;Pollen&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Protipo&apos;, &apos;en_name&apos;: &apos;PROTIPO&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Ronnia&apos;, &apos;en_name&apos;: &apos;Ronnia&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Sanserata&apos;, &apos;en_name&apos;: &apos;Sanserata&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Serifa®&apos;, &apos;en_name&apos;: &apos;Serifa&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Serpentine™&apos;, &apos;en_name&apos;: &apos;Serpentine&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Sirba&apos;, &apos;en_name&apos;: &apos;Sirba&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Soleil&apos;, &apos;en_name&apos;: &apos;Soleil&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Tablet Gothic&apos;, &apos;en_name&apos;: &apos;Tablet Gothic&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;冬青黑体简&apos;, &apos;en_name&apos;: &apos;Hiragino Sans GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正报宋简体&apos;, &apos;en_name&apos;: &apos;FZBaoSong4S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正本墨绪圆体&apos;, &apos;en_name&apos;: &apos;FZBMXY JW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兵马俑体&apos;, &apos;en_name&apos;: &apos;FZBingMaYongTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正博雅宋简体&apos;, &apos;en_name&apos;: &apos;FZBoYaSongS-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正彩云简体&apos;, &apos;en_name&apos;: &apos;FZCaiYun9S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正藏意汉体简体&apos;, &apos;en_name&apos;: &apos;FZZangYiHanTiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正超粗黑简体&apos;, &apos;en_name&apos;: &apos;FZChaoCuHei-S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正超重要体&apos;, &apos;en_name&apos;: &apos;FzCHAOZYTJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗活意简体&apos;, &apos;en_name&apos;: &apos;FZCuHuoYi-M25S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗倩简体&apos;, &apos;en_name&apos;: &apos;FZCuQian7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗宋简体&apos;, &apos;en_name&apos;: &apos;FZCuSong9S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗谭黑简体&apos;, &apos;en_name&apos;: &apos;FZTanHeiS-B-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗雅宋简体&apos;, &apos;en_name&apos;: &apos;FZYaSongS-B-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正粗圆简体&apos;, &apos;en_name&apos;: &apos;FZCuYuan3S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正大标宋简体&apos;, &apos;en_name&apos;: &apos;FZDaBiaoSong6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正大黑简体&apos;, &apos;en_name&apos;: &apos;FZDaHei2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正大魏体简体&apos;, &apos;en_name&apos;: &apos;FZDaWeiTiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正邓黑隶&apos;, &apos;en_name&apos;: &apos;FZDengHLJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正方俊黑&apos;, &apos;en_name&apos;: &apos;FZFangJunHeiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正仿宋简体&apos;, &apos;en_name&apos;: &apos;FZFangSong2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正飞跃体&apos;, &apos;en_name&apos;: &apos;FZFeiYueTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正复古粗宋&apos;, &apos;en_name&apos;: &apos;FOUNDERTYPE&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正古隶简体&apos;, &apos;en_name&apos;: &apos;FZGuLi2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正管峻楷书&apos;, &apos;en_name&apos;: &apos;FZGUANJUNKAISHUS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正汉真广标简体&apos;, &apos;en_name&apos;: &apos;FZHanZhenGuangBiaoS-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正行楷简体&apos;, &apos;en_name&apos;: &apos;FZXingKai4S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正黑体简体&apos;, &apos;en_name&apos;: &apos;FZHS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正琥珀简体&apos;, &apos;en_name&apos;: &apos;FZHuPo4S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正华隶简体&apos;, &apos;en_name&apos;: &apos;FZHuaLi4S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正黄草简体&apos;, &apos;en_name&apos;: &apos;FZHuangCao9S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正活龙体&apos;, &apos;en_name&apos;: &apos;FZHuoLTJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正记忆的碎片体&apos;, &apos;en_name&apos;: &apos;FZJiYiDeSuiPianTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正剪纸简体&apos;, &apos;en_name&apos;: &apos;FZJianZhi-M23S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正静蕾简体&apos;, &apos;en_name&apos;: &apos;FZJingLeiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正卡通简体&apos;, &apos;en_name&apos;: &apos;FZKaTong9S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正楷体简体&apos;, &apos;en_name&apos;: &apos;FZKai3S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正康体简体&apos;, &apos;en_name&apos;: &apos;FZKangTi7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正克书皇榜体&apos;, &apos;en_name&apos;: &apos;FZKeShuHuangBang&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭超细黑简体&apos;, &apos;en_name&apos;: &apos;FZLanTingHeiS-UL-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭粗黑简体&apos;, &apos;en_name&apos;: &apos;FZLTCHJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭黑简体&apos;, &apos;en_name&apos;: &apos;FZLanTingHeiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭特黑简体&apos;, &apos;en_name&apos;: &apos;FZLanTingHeiS-H-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭细黑_GBK&apos;, &apos;en_name&apos;: &apos;FZLanTingHei-L-GBK&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭细黑_GBK-M&apos;, &apos;en_name&apos;: &apos;FZLanTingHei-L-GBK-M&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭纤黑繁体&apos;, &apos;en_name&apos;: &apos;FZLanTingHeiT-EL-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭纤黑简体&apos;, &apos;en_name&apos;: &apos;FZLanTingHeiS-EL-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭圆简体&apos;, &apos;en_name&apos;: &apos;FZLanTingYuanS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正兰亭圆简体_纤&apos;, &apos;en_name&apos;: &apos;FZLanTingYuanS-EL-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正隶变简体&apos;, &apos;en_name&apos;: &apos;FZLiBian2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正隶二简体&apos;, &apos;en_name&apos;: &apos;FZLiShu II6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正隶书简体&apos;, &apos;en_name&apos;: &apos;FZLiSS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正流行体简体&apos;, &apos;en_name&apos;: &apos;FZLiuXingTi-M26S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正美黑简体&apos;, &apos;en_name&apos;: &apos;FZMeiHei7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正萌软体&apos;, &apos;en_name&apos;: &apos;FZMengRuanTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正萌艺体&apos;, &apos;en_name&apos;: &apos;FZMengYiTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正喵呜简体&apos;, &apos;en_name&apos;: &apos;FZMiaoWuS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正喵呜体&apos;, &apos;en_name&apos;: &apos;FZMiaoWuS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正胖头鱼简体&apos;, &apos;en_name&apos;: &apos;FZPangTouYu-M24S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正胖娃简体&apos;, &apos;en_name&apos;: &apos;FZPangWa8S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正品尚粗黑简体&apos;, &apos;en_name&apos;: &apos;FZPinShangHeiS-B-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正品尚黑简体&apos;, &apos;en_name&apos;: &apos;FZPinShangHeiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正平和简体&apos;, &apos;en_name&apos;: &apos;FZPingHeS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正奇妙体&apos;, &apos;en_name&apos;: &apos;FZQiMTJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正启笛简体&apos;, &apos;en_name&apos;: &apos;FZQiDiS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正启体简体&apos;, &apos;en_name&apos;: &apos;FZQiTi4S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正清仿宋系列&apos;, &apos;en_name&apos;: &apos;FZQingFangSongS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正晴朗体&apos;, &apos;en_name&apos;: &apos;FZQINGLANGTIS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正趣黑&apos;, &apos;en_name&apos;: &apos;FZQuHJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正锐正圆&apos;, &apos;en_name&apos;: &apos;FZRuiZhengYuanS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正尚酷简体&apos;, &apos;en_name&apos;: &apos;FZShangKuS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正尚艺体&apos;, &apos;en_name&apos;: &apos;FZShangYiTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正少儿简体&apos;, &apos;en_name&apos;: &apos;FZShaoErS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正瘦金书简体&apos;, &apos;en_name&apos;: &apos;FZShouJinShu-S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正书宋&apos;, &apos;en_name&apos;: &apos;FZSS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正书宋简体&apos;, &apos;en_name&apos;: &apos;FZShuSoS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正舒体&apos;, &apos;en_name&apos;: &apos;FZShuTi&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正舒体简体&apos;, &apos;en_name&apos;: &apos;FZShuTi5S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正水黑简体&apos;, &apos;en_name&apos;: &apos;FZShuiHei-S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正水云简体&apos;, &apos;en_name&apos;: &apos;FZShuiYunS-EB-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正水柱简体&apos;, &apos;en_name&apos;: &apos;FZShuiZhu8S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正宋黑简体&apos;, &apos;en_name&apos;: &apos;FZSongHei7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正宋三简体&apos;, &apos;en_name&apos;: &apos;FZSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正宋一简体&apos;, &apos;en_name&apos;: &apos;FZSongYi3S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正苏新诗小爨&apos;, &apos;en_name&apos;: &apos;FZSuXinShiXiaoCuanS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正孙拥声简体&apos;, &apos;en_name&apos;: &apos;FZSunYongShengS-R-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正淘乐简体&apos;, &apos;en_name&apos;: &apos;FZTLJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正玩伴体系列&apos;, &apos;en_name&apos;: &apos;FZWanBTJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正魏碑简体&apos;, &apos;en_name&apos;: &apos;FZWeiBei3S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正细等线简体&apos;, &apos;en_name&apos;: &apos;FZXiDengXian6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正细黑一简体&apos;, &apos;en_name&apos;: &apos;FZXiHei I8S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正细倩简体&apos;, &apos;en_name&apos;: &apos;FZXiQian5S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正细珊瑚简体&apos;, &apos;en_name&apos;: &apos;FZXiShanHu3S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正细圆简体&apos;, &apos;en_name&apos;: &apos;FZXiYuS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正仙阵体&apos;, &apos;en_name&apos;: &apos;FZXianZhenTiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正祥隶简体&apos;, &apos;en_name&apos;: &apos;FZXiangLi7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正小标宋简体&apos;, &apos;en_name&apos;: &apos;FZXiaoBiaoSong5S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正小篆体&apos;, &apos;en_name&apos;: &apos;FZXiaoZhuanTi3T&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正新报宋简体&apos;, &apos;en_name&apos;: &apos;FZNew BaoSong2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正新舒体简体&apos;, &apos;en_name&apos;: &apos;FZNew ShuTi8S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正秀麗&apos;, &apos;en_name&apos;: &apos;FZXiuLiB3&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正雅士黑&apos;, &apos;en_name&apos;: &apos;FZYaShiHeiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正颜宋简体_粗&apos;, &apos;en_name&apos;: &apos;FZYanSongS-B-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正姚体&apos;, &apos;en_name&apos;: &apos;FZYaoti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正姚体简体&apos;, &apos;en_name&apos;: &apos;FZYaoTi6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正艺黑简体&apos;, &apos;en_name&apos;: &apos;FZYiHei-S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正硬笔行书简体&apos;, &apos;en_name&apos;: &apos;FZYingBiXingShu6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正硬笔楷书简体&apos;, &apos;en_name&apos;: &apos;FZYingBiKaiShu5S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正悠宋简可变&apos;, &apos;en_name&apos;: &apos;FZYouSJ VF WT&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正幼线简体&apos;, &apos;en_name&apos;: &apos;FZYouXian9S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正韵动特黑简体&apos;, &apos;en_name&apos;: &apos;FZYunDongHeiS-H-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正赞美体&apos;, &apos;en_name&apos;: &apos;FZZANMTJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正毡笔黑简体&apos;, &apos;en_name&apos;: &apos;FZZhanBiHei-M22S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正正粗黑简体&apos;, &apos;en_name&apos;: &apos;FZZhengHeiS-B-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正正大黑简体&apos;, &apos;en_name&apos;: &apos;FZZhengHeiS-EB-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正正纤黑简体&apos;, &apos;en_name&apos;: &apos;FZZhengHeiS-EL-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正正准黑简体&apos;, &apos;en_name&apos;: &apos;FZZhengHeiS-M-GB&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正稚艺简体&apos;, &apos;en_name&apos;: &apos;FZZhiYi2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正中等线简体&apos;, &apos;en_name&apos;: &apos;FZZhongDengXian7S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正中倩简体&apos;, &apos;en_name&apos;: &apos;FZZhongQian6S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正准圆简体&apos;, &apos;en_name&apos;: &apos;FZZhunYuan2S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-曾柏求排笔&apos;, &apos;en_name&apos;: &apos;FZZJ-ZBQPBJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-陈光池楷书&apos;, &apos;en_name&apos;: &apos;FZZJ-CGCKSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-顾建平楷书&apos;, &apos;en_name&apos;: &apos;FZZJ-GJPKSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-顾建平隶书&apos;, &apos;en_name&apos;: &apos;FZZJ-GJPLSJF&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-顧建平篆書&apos;, &apos;en_name&apos;: &apos;FZZJ-GJPZSFU&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-豪放行书简体&apos;, &apos;en_name&apos;: &apos;FZZJ-HFXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-李凤武行书&apos;, &apos;en_name&apos;: &apos;FZZJ-LFWXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-刘宏楷书&apos;, &apos;en_name&apos;: &apos;FZZJ-LHKSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-刘毅硬笔行书&apos;, &apos;en_name&apos;: &apos;FZZJ-LYYBXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-刘毅硬笔楷书&apos;, &apos;en_name&apos;: &apos;FZZJ-LYYBKSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-柳正枢行楷&apos;, &apos;en_name&apos;: &apos;FZZJ-LZSXKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-清代碑体&apos;, &apos;en_name&apos;: &apos;FZZJ-QDBTJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-陶建华魏碑&apos;, &apos;en_name&apos;: &apos;FZZJ-TJHWBJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-童体硬笔字体&apos;, &apos;en_name&apos;: &apos;FZZJ-TTYBFONT&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-吴进行书&apos;, &apos;en_name&apos;: &apos;FZZJ-WJXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-严祖喜行楷&apos;, &apos;en_name&apos;: &apos;FZZJ-YZXXKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-颜振东楷&apos;, &apos;en_name&apos;: &apos;FZZJ-YZDKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-叶根友特楷&apos;, &apos;en_name&apos;: &apos;YEGENYOUTEKAI&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-张二魁硬楷&apos;, &apos;en_name&apos;: &apos;FZZJ-ZEKYKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-张亮硬笔行书&apos;, &apos;en_name&apos;: &apos;FZZJ-ZLYBXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-长江行书&apos;, &apos;en_name&apos;: &apos;FZZJ-CJXSJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-周密行楷&apos;, &apos;en_name&apos;: &apos;FZZJ-ZMXKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-禚效锋行草&apos;, &apos;en_name&apos;: &apos;FZZJ-ZXFXCJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正字迹-自强魏楷体&apos;, &apos;en_name&apos;: &apos;FZZJ-ZQWKJW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;方正综艺简体&apos;, &apos;en_name&apos;: &apos;FZZongYi5S&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪PP体简&apos;, &apos;en_name&apos;: &apos;HYPPTiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪程行简&apos;, &apos;en_name&apos;: &apos;HYChengXingJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪大黑简&apos;, &apos;en_name&apos;: &apos;HYDaHeiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪大宋简&apos;, &apos;en_name&apos;: &apos;HYDaSongJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪蝶语简体&apos;, &apos;en_name&apos;: &apos;HYDieYuJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪方叠体检&apos;, &apos;en_name&apos;: &apos;HYFangDieJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪仿宋简&apos;, &apos;en_name&apos;: &apos;HYFangSongJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪刚艺体&apos;, &apos;en_name&apos;: &apos;HYGangYiTi&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪行楷简&apos;, &apos;en_name&apos;: &apos;HYXingKaiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪黑荔枝&apos;, &apos;en_name&apos;: &apos;HYHeiLiZhiTiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪家书简&apos;, &apos;en_name&apos;: &apos;HYJiaShuJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪楷体&apos;, &apos;en_name&apos;: &apos;HYKaiti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪楷体简&apos;, &apos;en_name&apos;: &apos;HYKaiTiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪乐喵体简&apos;, &apos;en_name&apos;: &apos;HYLeMiaoTi&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪立黑简&apos;, &apos;en_name&apos;: &apos;HYLiHeiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪菱心体简&apos;, &apos;en_name&apos;: &apos;HYLingXinJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪漫步体间&apos;, &apos;en_name&apos;: &apos;HYManBuJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪旗黑&apos;, &apos;en_name&apos;: &apos;HYQiheiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪旗黑&apos;, &apos;en_name&apos;: &apos;HYQiheiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪旗黑&apos;, &apos;en_name&apos;: &apos;HYQiheiS&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪尚巍手书W&apos;, &apos;en_name&apos;: &apos;HYShangWeiShouShuW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪书魂体检&apos;, &apos;en_name&apos;: &apos;HYShuHunJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪娃娃纂简&apos;, &apos;en_name&apos;: &apos;HYWaWaZhuanJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪小麦体&apos;, &apos;en_name&apos;: &apos;HYXiaoMaiTiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪醒示体简&apos;, &apos;en_name&apos;: &apos;HYXingShiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪秀英体简&apos;, &apos;en_name&apos;: &apos;HYXiuYingJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪雪峰体简&apos;, &apos;en_name&apos;: &apos;HYXueFengJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪雪君体简&apos;, &apos;en_name&apos;: &apos;HYXueJunJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪丫丫体简&apos;, &apos;en_name&apos;: &apos;HYYaYaJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪雅酷黑W&apos;, &apos;en_name&apos;: &apos;HYYaKuHeiW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪长美黑简&apos;, &apos;en_name&apos;: &apos;HYChangMeiHeiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪中等线简&apos;, &apos;en_name&apos;: &apos;HYZhongDengXianJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪中黑简&apos;, &apos;en_name&apos;: &apos;HYZhongHeiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪中隶书简&apos;, &apos;en_name&apos;: &apos;HYZhongLiShuJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪中宋简&apos;, &apos;en_name&apos;: &apos;HYZhongSongJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;汉仪综艺体简&apos;, &apos;en_name&apos;: &apos;HYZongYiJ&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华康翩翩体&apos;, &apos;en_name&apos;: &apos;Hanzipen SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华康手札体&apos;, &apos;en_name&apos;: &apos;Hannotate SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文彩云&apos;, &apos;en_name&apos;: &apos;STCaiyun&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文仿宋&apos;, &apos;en_name&apos;: &apos;STFangsong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文行楷&apos;, &apos;en_name&apos;: &apos;STXingkai&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文黑体&apos;, &apos;en_name&apos;: &apos;STHeiti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文琥珀&apos;, &apos;en_name&apos;: &apos;STHupo&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文楷体&apos;, &apos;en_name&apos;: &apos;STKaiti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文隶书&apos;, &apos;en_name&apos;: &apos;STLiti&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文宋体&apos;, &apos;en_name&apos;: &apos;STSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文细黑&apos;, &apos;en_name&apos;: &apos;STXihei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文新魏&apos;, &apos;en_name&apos;: &apos;STXinwei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;华文中宋&apos;, &apos;en_name&apos;: &apos;STZhongsong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;兰亭黑-简&apos;, &apos;en_name&apos;: &apos;Lantinghei SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;苹方&apos;, &apos;en_name&apos;: &apos;PingFang SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;微软雅黑&apos;, &apos;en_name&apos;: &apos;Microsoft Yahei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;微软正黑体&apos;, &apos;en_name&apos;: &apos;Microsoft JhengHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;小美体&apos;, &apos;en_name&apos;: &apos;XIAOMEI JW&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房版&apos;, &apos;en_name&apos;: &apos;RTWS BanHe&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房博黑&apos;, &apos;en_name&apos;: &apos;MF BoHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房典黑&apos;, &apos;en_name&apos;: &apos;MF DianHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房鼎黑体&apos;, &apos;en_name&apos;: &apos;MF DingHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房黄金时代&apos;, &apos;en_name&apos;: &apos;MF TheGoldenEra&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房佳黑&apos;, &apos;en_name&apos;: &apos;MF JiaHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房坚黑&apos;, &apos;en_name&apos;: &apos;MF JianHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房锦宋体&apos;, &apos;en_name&apos;: &apos;MF JinSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房劲&apos;, &apos;en_name&apos;: &apos;RTWS JinHe&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房郎&apos;, &apos;en_name&apos;: &apos;RTWS LangSon&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房力黑&apos;, &apos;en_name&apos;: &apos;MF LiHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房力黑体&apos;, &apos;en_name&apos;: &apos;MF LiHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房凌黑&apos;, &apos;en_name&apos;: &apos;MF LingHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房明黑&apos;, &apos;en_name&apos;: &apos;MF MingHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房品宋&apos;, &apos;en_name&apos;: &apos;MF PinSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房启黑体&apos;, &apos;en_name&apos;: &apos;MF QiHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房形黑&apos;, &apos;en_name&apos;: &apos;MF XingHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房形黑体&apos;, &apos;en_name&apos;: &apos;MF XingHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房雅&apos;, &apos;en_name&apos;: &apos;RTWS YaYua&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房元黑体&apos;, &apos;en_name&apos;: &apos;MF YuanHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房云宋体&apos;, &apos;en_name&apos;: &apos;MF YunSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房哲黑&apos;, &apos;en_name&apos;: &apos;MF ZheHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房臻宋体&apos;, &apos;en_name&apos;: &apos;MF ZhenSong&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;造字工房卓黑体&apos;, &apos;en_name&apos;: &apos;MF ZhuoHei&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;Tahoma&apos;, &apos;en_name&apos;: &apos;tahoma&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;行楷-简&apos;, &apos;en_name&apos;: &apos;Xingkai SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;宋体-简&apos;, &apos;en_name&apos;: &apos;Songti SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;娃娃体-简&apos;, &apos;en_name&apos;: &apos;Wawati SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;魏碑-简&apos;, &apos;en_name&apos;: &apos;Weibei SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;雅痞-简&apos;, &apos;en_name&apos;: &apos;Yapi SC&apos; &#125;,</span><br><span class="line">  &#123; &apos;cn_name&apos;: &apos;圆体-简&apos;, &apos;en_name&apos;: &apos;Yuanti SC&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端时间做过一个关于字体检测项目，现在做下总结，主要用于在本机检测某字体是否安装。&lt;br&gt;
    
    </summary>
    
      <category term="project" scheme="http://blog.master-ss.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 之查询操作符</title>
    <link href="http://blog.master-ss.cn/database/mongo3/"/>
    <id>http://blog.master-ss.cn/database/mongo3/</id>
    <published>2019-08-12T10:03:01.520Z</published>
    <updated>2019-08-15T07:34:41.577Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 mongodb 查询时常用的操作符。<br><a id="more"></a> </p><h3 id="一、比较操作符"><a href="#一、比较操作符" class="headerlink" title="一、比较操作符"></a>一、比较操作符</h3><ul><li><p>$in<br>包含在数组中<br>db.movieDetails.find({rated: {$in: [“G”, “PG”, “PG-13”]}}, {_id: 0, title: 1, rated: 1}).pretty()</p></li><li><p>$gte &amp; $lt<br>$gte 大于等于（greater than or equal to）；$lt 小于（less than）<br>db.movieDetails.find({runtime: {$gte: 90, $lt: 120}}, {_id: 0, title: 1, runtime: 1})</p></li><li><p>$ne<br>不等于，包括完全不包含这个字段的情况<br>db.movieDetails.find({rated: {$ne: “UNRATED”}}, {_id: 0, title: 1, rated: 1})</p></li></ul><h3 id="二、元素操作符"><a href="#二、元素操作符" class="headerlink" title="二、元素操作符"></a>二、元素操作符</h3><ul><li><p>$exists<br>查找某个字段是否存在<br>db.moviesDetails.find({mpaaRating: {$exists: true}})<br>null 会查找值为 null 或不存在该字段的文档<br>db.movieDetails.find({mpaaRating: null})</p></li><li><p>$type<br>查看符合类型的文档<br>db.movies.find({viewerRating: {$type: “int”}}).pretty()</p></li></ul><h3 id="三、逻辑操作符"><a href="#三、逻辑操作符" class="headerlink" title="三、逻辑操作符"></a>三、逻辑操作符</h3><ul><li><p>$or<br>查看满足单个条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.movieDetails.find(&#123;$or: [&#123;&quot;tomato.meter&quot;: &#123;$gt: 95&#125;&#125;,                               </span><br><span class="line">                            &#123;&quot;metacritic&quot;: &#123;$gt: 88&#125;&#125;]&#125;,</span><br><span class="line">                     &#123;_id: 0, title: 1, &quot;tomato.meter&quot;: 1, &quot;metacritic&quot;: 1&#125;)</span><br></pre></td></tr></table></figure></li><li><p>$and<br>查看同时满足多个条件，一般情况不需要，跟默认查询情况效果相同。但是可应用于多个条件限制在同一个字段上时，默认查询情况不能用重复的 key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.movieDetails.find(&#123;$and: [&#123;&quot;metacritic&quot;: &#123;$ne: null&#125;&#125;,</span><br><span class="line">                             &#123;&quot;metacritic&quot;: &#123;$exists: true&#125;&#125;]&#125;,</span><br><span class="line">                          &#123;_id: 0, title: 1, &quot;metacritic&quot;: 1&#125;)</span><br><span class="line"></span><br><span class="line">// 能很好的查询值为 null 的情况，因为查询 null 包括值为 null 和键值对不存在的情况</span><br><span class="line">db.movieDetails.find(&#123;$and: [&#123;&quot;metacritic&quot;: null&#125;,</span><br><span class="line">                             &#123;&quot;metacritic&quot;: &#123;$exists: true&#125;&#125;]&#125;,</span><br><span class="line">                     &#123;_id: 0, title: 1, &quot;metacritic&quot;: 1&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、数组操作符"><a href="#四、数组操作符" class="headerlink" title="四、数组操作符"></a>四、数组操作符</h3><ul><li><p>$all<br>数组中的所有元素均出现文档值中，被包含关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.movieDetails.find(&#123;genres: &#123;$all: [&quot;Comedy&quot;, &quot;Crime&quot;, &quot;Drama&quot;]&#125;&#125;, </span><br><span class="line">                     &#123;_id: 0, title: 1, genres: 1&#125;).pretty()</span><br></pre></td></tr></table></figure></li><li><p>$size<br>查询符合指定长度数组的文档<br>db.movieDetails.find({countries: {$size: 1}}).pretty()</p></li><li><p>$elemMatch<br>遍历对象数组或二维数组中至少有一个对象或数组符合的文档；如果不使用 $elemMatch，则完全遍历，不考虑对象或数组为整体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 二维数组 --&gt;</span><br><span class="line">&#123; _id: 1, results: [ 82, 85, 88 ] &#125;</span><br><span class="line">&#123; _id: 2, results: [ 75, 88, 89 ] &#125;</span><br><span class="line">&lt;!-- 数据查询 --&gt;</span><br><span class="line">db.scores.find(</span><br><span class="line">   &#123; results: &#123; $elemMatch: &#123; $gte: 80, $lt: 85 &#125; &#125; &#125;</span><br><span class="line">)</span><br><span class="line">&lt;!-- 返回结果：因为 82 既大于等于 80 又小于 85 --&gt;</span><br><span class="line">&#123; &quot;_id&quot; : 1, &quot;results&quot; : [ 82, 85, 88 ] &#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对象数组 --&gt;</span><br><span class="line">boxOffice: [ &#123; &quot;country&quot;: &quot;USA&quot;, &quot;revenue&quot;: 228.4 &#125;,</span><br><span class="line">             &#123; &quot;country&quot;: &quot;Australia&quot;, &quot;revenue&quot;: 19.6 &#125;,</span><br><span class="line">             &#123; &quot;country&quot;: &quot;UK&quot;, &quot;revenue&quot;: 33.9 &#125;,</span><br><span class="line">             &#123; &quot;country&quot;: &quot;Germany&quot;, &quot;revenue&quot;: 16.2 &#125;,</span><br><span class="line">             &#123; &quot;country&quot;: &quot;France&quot;, &quot;revenue&quot;: 19.8 &#125; ]</span><br><span class="line">db.movieDetails.find(&#123;boxOffice: &#123;$elemMatch: &#123;&quot;country&quot;: &quot;Germany&quot;, &quot;revenue&quot;: &#123;$gt: 16&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、评估操作符"><a href="#五、评估操作符" class="headerlink" title="五、评估操作符"></a>五、评估操作符</h3><ul><li><p>$regex<br>正则表达式匹配文档<br>db.movieDetails.find({“awards.text”: {$regex: /^Won.* /}}, {_id: 0, title: 1, “awards.text”: 1}).pretty()</p></li><li><p>$text<br>文本搜索匹配文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $text:</span><br><span class="line">    &#123;</span><br><span class="line">      $search: &lt;string&gt;,</span><br><span class="line">      $language: &lt;string&gt;,</span><br><span class="line">      $caseSensitive: &lt;boolean&gt;,</span><br><span class="line">      $diacriticSensitive: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.articles.find( &#123; $text: &#123; $search: &quot;coffee&quot; &#125; &#125; )</span><br><span class="line">&lt;!-- 查询包含 bake、coffee、cake 的语句，甚至这些词的动词格式 --&gt;</span><br><span class="line">db.articles.find( &#123; $text: &#123; $search: &quot;bake coffee cake&quot; &#125; &#125; )</span><br><span class="line">&lt;!-- 查询确切 coffee shop 字符串 --&gt;</span><br><span class="line">db.articles.find( &#123; $text: &#123; $search: &quot;\&quot;coffee shop\&quot;&quot; &#125; &#125; )</span><br><span class="line">&lt;!-- 查询包含 bake，不包含 shop 的语句，甚至这些词的动词格式 --&gt;</span><br><span class="line">db.articles.find( &#123; $text: &#123; $search: &quot;coffee -shop&quot; &#125; &#125; )</span><br><span class="line">&lt;!-- $language 用来表达特定语言下的动词格式，标识为 none 为不识别动词 --&gt;</span><br><span class="line">&lt;!-- $caseSensitive 是否大小写敏感 --&gt;</span><br><span class="line">db.articles.find( &#123; $text: &#123; $search: &quot;Coffee&quot;, $caseSensitive: true &#125; &#125; )</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 mongodb 查询时常用的操作符。&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 基础</title>
    <link href="http://blog.master-ss.cn/database/mongo2/"/>
    <id>http://blog.master-ss.cn/database/mongo2/</id>
    <published>2019-08-12T07:06:43.723Z</published>
    <updated>2019-10-21T09:43:00.608Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb shell 安装和基础操作。<br><a id="more"></a> </p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><ul><li><p>安装 homebrew<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p></li><li><p>安装 mongodb<br>brew install mongodb</p></li><li><p>开机自启动<br>brew services start mongodb</p></li></ul><h3 id="二、更新"><a href="#二、更新" class="headerlink" title="二、更新"></a>二、更新</h3><ul><li><p>更新 homebrew<br>brew update</p></li><li><p>更新 mongodb<br>brew upgrade mongodb</p></li><li><p>查询 mongodb 相关软件<br>brew search mongodb</p></li><li><p>查询 mongodb 相关信息<br>brew info mongodb</p></li><li><p>卸载 mongodb<br>brew uninstall mongodb</p></li></ul><h3 id="三、基础命令"><a href="#三、基础命令" class="headerlink" title="三、基础命令"></a>三、基础命令</h3><ul><li><p>进入命令行<br>mongo</p></li><li><p>连接远程数据库<br>mongo “mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017/test?replicaSet=Cluster0-shard-0” –authenticationDatabase admin –ssl –username m001-student –password m001-mongodb-basics</p></li><li><p>退出命令行<br>quit()</p></li><li><p>查看数据库列表<br>show databases</p></li><li><p>使用数据库、创建数据库<br>use databases</p></li><li><p>查看当前数据库<br>db</p></li><li><p>删除当前数据库<br>db.dropDatabase()</p></li><li><p>不切换当前数据库访问其他的数据库<br>db.getSiblingDB(‘name’)</p></li><li><p>删除集合<br>db.collection.drop()</p></li><li><p>查看集合数据数量<br>db.collection.count()</p></li><li><p>插入单条数据<br>db.collection.insertOne(doc)</p></li><li><p>批量插入<br>db.collection.insertMany([doc…], { “ordered”: false })<br>ordered 为 false 即遇到出错继续执行插入操作，默认为 true，遇错停止</p></li><li><p>数据查询<br>db.collection.find({a: b, “c.d”: e, “f.0”: g, h: [i, j]}).pretty()<br>查询同时满足多个条件的数据；<br>pretty() 格式化输出；<br>如果 “a” 对应的值是数组类型，则查找文档中 “a” 数组含有 b 元素；<br>“c.d” 是嵌套文档；<br>查找文档中 “f” 数组第一个是 g 元素；<br>查找文档中 “h” 数组含 [i, j] 且数组元素顺序固定；</p></li><li><p>查询下一页<br>it<br>命令行查找默认显示20条数据，如果查看更多输入 it（iterate）遍历下个20条数据</p></li><li><p>分页查询<br>sort: 1 升序；-1 降序<br>skip: 查询 5 条之后的数据<br>limit: 总计返回 10 条件数据<br>db.userInfo.find().sort({age: -1}).skip(5).limit(10)</p></li><li><p>格式化输出字段<br>db.collection.find({a: b}, {c: 1})<br>查找默认显示全部字段，如果 project 特别指定返回某些字段，如 c: 1，则显示 c 和 _id，其他字段隐藏，_id 需明确指定（_id : 0）不返回才不会显示；如果设定一些字段为 0，则隐藏这些字段，其他字段显示</p></li><li><p>查找集合中某个字段所有不同的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 数据对象 --&gt;</span><br><span class="line">&#123; &quot;_id&quot;: 1, &quot;dept&quot;: &quot;A&quot;, &quot;item&quot;: &#123; &quot;sku&quot;: &quot;111&quot;, &quot;color&quot;: &quot;red&quot; &#125;, &quot;sizes&quot;: [ &quot;S&quot;, &quot;M&quot; ] &#125;</span><br><span class="line">&#123; &quot;_id&quot;: 2, &quot;dept&quot;: &quot;A&quot;, &quot;item&quot;: &#123; &quot;sku&quot;: &quot;111&quot;, &quot;color&quot;: &quot;blue&quot; &#125;, &quot;sizes&quot;: [ &quot;M&quot;, &quot;L&quot; ] &#125;</span><br><span class="line">&#123; &quot;_id&quot;: 3, &quot;dept&quot;: &quot;B&quot;, &quot;item&quot;: &#123; &quot;sku&quot;: &quot;222&quot;, &quot;color&quot;: &quot;blue&quot; &#125;, &quot;sizes&quot;: &quot;S&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot;: 4, &quot;dept&quot;: &quot;A&quot;, &quot;item&quot;: &#123; &quot;sku&quot;: &quot;333&quot;, &quot;color&quot;: &quot;black&quot; &#125;, &quot;sizes&quot;: [ &quot;S&quot; ] &#125;</span><br><span class="line">&lt;!-- 字段返回 --&gt;</span><br><span class="line">db.inventory.distinct( &quot;dept&quot; )</span><br><span class="line">[ &quot;A&quot;, &quot;B&quot; ]</span><br><span class="line">&lt;!-- 嵌套字段返回 --&gt;</span><br><span class="line">db.inventory.distinct( &quot;item.sku&quot; )</span><br><span class="line">[ &quot;111&quot;, &quot;222&quot;, &quot;333&quot; ]</span><br><span class="line">&lt;!-- 数组返回 --&gt;</span><br><span class="line">db.inventory.distinct( &quot;sizes&quot; )</span><br><span class="line">[ &quot;M&quot;, &quot;S&quot;, &quot;L&quot; ]</span><br><span class="line">&lt;!-- 加查询条件 --&gt;</span><br><span class="line">db.inventory.distinct( &quot;item.sku&quot;, &#123; dept: &quot;A&quot; &#125; )</span><br><span class="line">[ &quot;111&quot;, &quot;333&quot; ]</span><br></pre></td></tr></table></figure></li><li><p>替换某条数据<br>updateOne 是更新文档中某个字段，replaceOne 则是替换整个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let filter = &#123;title: &quot;House, M.D., Season Four: New Beginnings&quot;&#125;</span><br><span class="line">let doc = db.movieDetails.findOne(filter);</span><br><span class="line">doc.poster;</span><br><span class="line">doc.poster = &quot;https://www.imdb.com/title/tt1329164/mediaviewer/rm2619416576&quot;;</span><br><span class="line">doc.genres;</span><br><span class="line">doc.genres.push(&quot;TV Series&quot;);</span><br><span class="line">db.movieDetails.replaceOne(filter, doc);</span><br></pre></td></tr></table></figure></li><li><p>删除某条数据<br>db.orders.deleteOne( { “_id” : ObjectId(“563237a41a4d68582c2509da”) } )<br>deleteOne 删除单文档，deleteMany 删除多文档</p></li><li><p>执行 js 文件<br>load(‘filePath.js’)</p></li></ul><h3 id="四、更新操作符"><a href="#四、更新操作符" class="headerlink" title="四、更新操作符"></a>四、更新操作符</h3><ul><li><p>$set<br>db.collection.updateOne({a: b}, {$set: {c: d}})<br>更新单条数据，c 的值将被更新为 d，updateMany 更新所有匹配到的数据</p></li><li><p>$push &amp; $each<br>$push 将元素添加到数组中；$each 遍历数组，添加到 reviews 数组中；upsert 选项为若没有查询到匹配的文档，则插入该文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">  title: &quot;The Martian&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $push: &#123;</span><br><span class="line">    reviews: &#123;</span><br><span class="line">      $each: [&#123;</span><br><span class="line">         rating: 0.5,</span><br><span class="line">         reviewer: &quot;Yabo A.&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">         rating: 5,</span><br><span class="line">         reviewer: &quot;Kristina Z.&quot;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  upsert: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>$unset<br>删除相应字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.movieDetails.updateMany(&#123;</span><br><span class="line">  rated: null</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $unset: &#123;</span><br><span class="line">    rated: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>$rename<br>db.students.updateMany( {}, { $rename: { “nmae”: “name” } } )<br>更新字段名</p></li><li><p>$inc<br>$inc 字段增加值，接受正负数，如果字段不存在则为设置值，如果值为 null 则报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.products.update(</span><br><span class="line">   &#123; sku: &quot;abc123&quot; &#125;,</span><br><span class="line">   &#123; $inc: &#123; quantity: -2, &quot;metrics.orders&quot;: 1 &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>$addToSet<br>添加值到数组中，含去重，即相同元素不添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.update(</span><br><span class="line">   &#123; _id: 2 &#125;,</span><br><span class="line">   &#123; $addToSet: &#123; tags: &#123; $each: [ &quot;camera&quot;, &quot;electronics&quot;, &quot;accessories&quot; ] &#125; &#125; &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></li><li><p>$pop<br>从数组中移除第一个或最后一个元素，其中 -1 为第一个，1 为最后一个<br>db.students.update( { _id: 1 }, { $pop: { scores: -1 } } )</p></li><li><p>$pull<br>从数组中移除满足条件的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.stores.update(</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">    &#123; $pull: &#123; fruits: &#123; $in: [ &quot;apples&quot;, &quot;oranges&quot; ] &#125;, vegetables: &quot;carrots&quot; &#125; &#125;,</span><br><span class="line">    &#123; multi: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>$pullAll<br>从数组中移除匹配到的值<br>db.survey.update( { _id: 1 }, { $pullAll: { scores: [ 0, 5 ] } } )</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb shell 安装和基础操作。&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb 之 Compass</title>
    <link href="http://blog.master-ss.cn/database/mongo1/"/>
    <id>http://blog.master-ss.cn/database/mongo1/</id>
    <published>2019-08-12T02:55:49.838Z</published>
    <updated>2019-10-21T09:45:18.765Z</updated>
    
    <content type="html"><![CDATA[<p>对 mongodb 做一个系统性的研究和总结，先从可视化工具 MongoDB Compass 开始。<br><a id="more"></a> </p><h3 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h3><h4 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h4><p>MongoDB Compass 是官方数据库可视化工具，下载地址是 <a href="https://www.mongodb.com/download-center/compass" target="_blank" rel="noopener">https://www.mongodb.com/download-center/compass</a> 。</p><h4 id="1-2、连接"><a href="#1-2、连接" class="headerlink" title="1.2、连接"></a>1.2、连接</h4><p>输入数据库和用户信息，连接数据库。<br><img src="/assets/database/mongo/compass-login.png"></p><p>连接成功后即可显示数据库信息。<br><img src="/assets/database/mongo/database.png"></p><h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><h4 id="2-1、查看集合"><a href="#2-1、查看集合" class="headerlink" title="2.1、查看集合"></a>2.1、查看集合</h4><p>选择查看的集合，点击即可查看<br><img src="/assets/database/mongo/collection.png"></p><h4 id="2-2、分析结构"><a href="#2-2、分析结构" class="headerlink" title="2.2、分析结构"></a>2.2、分析结构</h4><p>可点击切换到 Schema，查看分析其结构，或者查看索引等。<br><img src="/assets/database/mongo/schema.png"></p><h4 id="2-3-条件查询"><a href="#2-3-条件查询" class="headerlink" title="2.3 条件查询"></a>2.3 条件查询</h4><p>用户可自主输入搜索条件或者在 Schema 中点击，即可获取搜索条件。<br><img src="/assets/database/mongo/search.png"></p><p>用户甚至可以使用 shift + 拖拽 的方式进行地理位置区域查询。<br><img src="/assets/database/mongo/search-geo.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 mongodb 做一个系统性的研究和总结，先从可视化工具 MongoDB Compass 开始。&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://blog.master-ss.cn/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>ps 之替换文字</title>
    <link href="http://blog.master-ss.cn/tools/ps2/"/>
    <id>http://blog.master-ss.cn/tools/ps2/</id>
    <published>2019-08-12T02:28:09.606Z</published>
    <updated>2019-08-12T02:38:04.964Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍如何替换图片上的文字。<br><a id="more"></a></p><h3 id="一、清除原图文字"><a href="#一、清除原图文字" class="headerlink" title="一、清除原图文字"></a>一、清除原图文字</h3><p>选中需清除区域。<br><img src="/assets/tools/ps/select.png"></p><p>清除选中区域。<br><img src="/assets/tools/ps/clear.png"></p><h3 id="二、填写文字"><a href="#二、填写文字" class="headerlink" title="二、填写文字"></a>二、填写文字</h3><p>选择文字工具。<br><img src="/assets/tools/ps/text.png"></p><p>编写需填写的内容。<br><img src="/assets/tools/ps/edit.png"></p><p>调整字体、大小和位置等。<br><img src="/assets/tools/ps/adjust.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍如何替换图片上的文字。&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.master-ss.cn/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>ps 之去背景&amp;文字变色</title>
    <link href="http://blog.master-ss.cn/tools/ps1/"/>
    <id>http://blog.master-ss.cn/tools/ps1/</id>
    <published>2019-08-06T07:41:59.827Z</published>
    <updated>2019-08-06T08:48:46.191Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个前端，不可避免的需要处理一些图片，而 ps 作为专业处理图片的软件能非常方便的帮我们处理很多事情，现在记录一些用过的小技巧，这里使用的版本是 ps CC 2017。<br><a id="more"></a></p><h3 id="一、去背景"><a href="#一、去背景" class="headerlink" title="一、去背景"></a>一、去背景</h3><p>选择“魔术橡皮檫工具”，选中需要去除的背景，即能让背景透明。<br><img src="/assets/tools/ps/rubber.png"></p><p>如果需要去除的背景和其他区域连在一起，可使用套索工具将需要去除的区域圈起来，然后再使用“魔术橡皮檫工具”去除背景。<br><img src="/assets/tools/ps/lasso.png"></p><h3 id="二、文字变色"><a href="#二、文字变色" class="headerlink" title="二、文字变色"></a>二、文字变色</h3><p>选择“魔棒工具”，勾选“消除锯齿”，不勾选“连续”，然后选中文本。<br><img src="/assets/tools/ps/wand.png"></p><p>如果部分文本不需要变色，可选中“矩形选框工具”，然后选择“从选区减去”，然后圈中不变色的文本。<br><img src="/assets/tools/ps/remove.png"></p><p>选择“编辑”，然后给选中文本进行颜色填充或者进行描边。<br><img src="/assets/tools/ps/fill.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个前端，不可避免的需要处理一些图片，而 ps 作为专业处理图片的软件能非常方便的帮我们处理很多事情，现在记录一些用过的小技巧，这里使用的版本是 ps CC 2017。&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.master-ss.cn/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>paypal 之网站集成</title>
    <link href="http://blog.master-ss.cn/project/paypal/"/>
    <id>http://blog.master-ss.cn/project/paypal/</id>
    <published>2019-07-16T01:36:54.277Z</published>
    <updated>2019-07-16T02:13:24.809Z</updated>
    
    <content type="html"><![CDATA[<p>项目要求，Web 网站需要实现 paypal 收款，废话不说，直接切入正题。<br><a id="more"></a> </p><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><h4 id="1-1、注册账号"><a href="#1-1、注册账号" class="headerlink" title="1.1、注册账号"></a>1.1、注册账号</h4><p>在 paypal <a href="https://www.paypal.com" target="_blank" rel="noopener">官网</a>注册一个账号，注意要账户类型要选择企业账户，其他信息如实填写好。注意 paypal 是支持接入个体工商户的，亲测有效。</p><h4 id="1-2、调解中心"><a href="#1-2、调解中心" class="headerlink" title="1.2、调解中心"></a>1.2、调解中心</h4><p>注册成功并完善资料后，账号登录要前往<code>调解中心</code>点击<code>前往账户限制</code>按钮，（完善账号信息，否则正式对接接口的时候，表单提交直接报错！！这是一个坑！！），需要提交以下文件：中国大陆居民身份证（正反面）和营业执照照片；这个审核过程一般 1 天左右的时间就可以完成。当然还需要邮箱验证等，这些都比较简单立刻能够操作完成。</p><h4 id="1-3、沙箱测试"><a href="#1-3、沙箱测试" class="headerlink" title="1.3、沙箱测试"></a>1.3、沙箱测试</h4><p>当账户注册成功以后，paypal 会分配给开发者账号两个沙箱测试账号（一个买家账号和一个商家账号）。去 paypal <a href="https://developer.paypal.com/developer/accounts" target="_blank" rel="noopener">开发者账号管理端</a>查看，用上面刚刚注册的账号密码即可。<br>系统自动分配两个 Country 值为 C2（代表中国区）的账号，但是千万不要同时拿着这两个账号来进行沙箱收付款测试，因为国内政策原因， paypal 规定中国地区和中国地区的账户之间无法实现付款，所以新建一个沙箱测试账号，买家的余额随便填，但是买家和商家的地区一定要选择不一样。</p><h3 id="二、代码开发"><a href="#二、代码开发" class="headerlink" title="二、代码开发"></a>二、代码开发</h3><h4 id="2-1、form-表单"><a href="#2-1、form-表单" class="headerlink" title="2.1、form 表单"></a>2.1、form 表单</h4><p>其实代码很简单，就一段 Html Form 表单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://www.paypal.com/cgi-bin/webscr 生产地址 --&gt;</span><br><span class="line">&lt;!-- https://www.sandbox.paypal.com/cgi-bin/webscr  沙箱测试地址 --&gt;</span><br><span class="line">&lt;form action=&quot;https://www.paypal.com/cgi-bin/webscr&quot; method=&quot;post&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt;  &lt;!-- name=&quot;cmd&quot;这个参数比较重要，_xclick表示立即支付，还有_s_xclick加密按钮等 --&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;business&quot; value=&quot;商家账号&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;item_name&quot; value=&quot;产品名称&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;item_number&quot; value=&quot;产品编号&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;金额&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;currency_code&quot; value=&quot;USD&quot;&gt;  &lt;!-- 币种 --&gt;</span><br><span class="line">  &lt;input type=&apos;hidden&apos; name=&apos;return&apos; value=&quot;支付成功后网页跳转地址&quot;&gt;</span><br><span class="line">  &lt;input type=&apos;hidden&apos; name=&apos;notify_url&apos; value=&quot;异步通知交易信息地址&quot;&gt;</span><br><span class="line">  &lt;input type=&apos;hidden&apos; name=&apos;invoice&apos; value=&quot;发票编码&quot;&gt;  &lt;!-- 注意：不能提交两次一样的发票编码 --&gt;</span><br><span class="line">  &lt;input type=&apos;hidden&apos; name=&apos;charset&apos; value=&apos;utf-8&apos;&gt;  &lt;!-- 字符集 --&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;no_shipping&quot; value=&quot;1&quot;&gt;  &lt;!-- 不要求客户提供收货地址 --&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;no_note&quot; value=&quot;1&quot;&gt;  &lt;!-- 付款说明 --&gt;</span><br><span class="line">  &lt;input type=&apos;hidden&apos; name=&apos;rm&apos; value=&apos;1&apos;&gt;  &lt;!-- 付款完成后的返回URL的行为 --&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>下面列举些付款变量列表：</p><ul><li>cmd: _xclick 表示立即购买；_xclick_subscription 表示订阅；_cart 表示购物车；s_x-click 表示加密按钮</li><li>return: 指完成付款后客户的浏览器返回到的 URL。如果省略，则您的买家将被带到 paypal 网站</li><li>notify_url: 用于接受 paypal 发送的关于即时付款通知的交易信息的 URL，必须是有效的 URL</li><li>no_shipping: 买家的送货地址，省略或设为 0 则提示客户输入收货地址，1 则不要求客户提供收货地址，2 则客户必须提供收货地址</li><li>no_note: 为付款加入说明，如果省略或设为 0，则会提示您的客户输入说明，如果设为 1，则不会提示您的客户输入说明</li><li>rm: 付款完成后的返回 URL 的行为，只有在 return 变量被设置后才能生效。如果省略或为 0，则 GET 方法用于没有启用即时付款通知的所有购物车交易，而 POST 方法用于所有其他交易；如果为 1 并设置了return，则客户的浏览器由 GET 方法返回至返回 URL，并且不提交任何交易变量；如果为 2 并设置了 return，则客户的浏览器由 POST 方法返回至返回 URL，同时将所有可用交易变量发送至该 URL</li></ul><p>更多详情查看<a href="http://www.fyhqy.com/post-150.html" target="_blank" rel="noopener">paypal付款按钮变量列表</a>或官方文档。</p><h4 id="2-2、提交支付"><a href="#2-2、提交支付" class="headerlink" title="2.2、提交支付"></a>2.2、提交支付</h4><p>表单代码一提交，就链接到了 paypal 的支付界面，然后输入买家账号、密码就能完成支付；等支付成功以后，paypay 会把支付信息回调给notify_url 提供的接口地址（paypal 如果回调失败，最多回调三次）。<br>等沙箱测试通过以后 ，就直接切换成生产地址就好；这里不得不赞美一下paypal的沙箱搞的真不错，几乎和生产可以同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目要求，Web 网站需要实现 paypal 收款，废话不说，直接切入正题。&lt;br&gt;
    
    </summary>
    
      <category term="project" scheme="http://blog.master-ss.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>frp 之内网穿透</title>
    <link href="http://blog.master-ss.cn/tools/frp/"/>
    <id>http://blog.master-ss.cn/tools/frp/</id>
    <published>2019-07-11T09:41:18.264Z</published>
    <updated>2019-08-06T07:41:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>刚搞定内网穿透，成就感爆棚，之前一直都是用<a href="http://www.ngrok.cc/" target="_blank" rel="noopener">别人的服务</a>，现在终于自己搞定了。<br><a id="more"></a> </p><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><h4 id="1-1、优点"><a href="#1-1、优点" class="headerlink" title="1.1、优点"></a>1.1、优点</h4><ul><li>在不部署的情况下就能够演示网站</li><li>在移动设备上查看本地代码运行效果</li><li>使用固定域名地址来映射本地效果</li><li>方便开发对接第三方服务应用，比如微信公众号等</li></ul><h4 id="1-2、准备"><a href="#1-2、准备" class="headerlink" title="1.2、准备"></a>1.2、准备</h4><ul><li>公网服务器 1 台，需备案</li><li>内网电脑</li></ul><h3 id="二、实现流程"><a href="#二、实现流程" class="headerlink" title="二、实现流程"></a>二、实现流程</h3><h4 id="2-1、下载-frp"><a href="#2-1、下载-frp" class="headerlink" title="2.1、下载 frp"></a>2.1、下载 frp</h4><p>下载地址是 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a> ，分别下载<code>frp_xxx_linux_amd64.tar.gz</code>和 <code>frp_xxx_darwin_amd64.tar.gz</code>。xxx 是版本号，推荐最新版本。因为本人使用 mac 电脑，如果是 windows 系统，则需下载<code>frp_xxx_windows_amd64.zip</code>。</p><h4 id="2-2、服务端启动"><a href="#2-2、服务端启动" class="headerlink" title="2.2、服务端启动"></a>2.2、服务端启动</h4><p>新建目录<code>mkdir -p /usr/local/frp</code>，上传<code>frp_xxx_linux_amd64.tar.gz</code>至服务器该目录下，解压<code>tar -zxvf  frp_xxx_linux_amd64.tar.gz</code>，进入解压目录<code>cd frp_xxx_linux_amd64</code>，移除<code>frpc</code>文件夹、frpc.ini、frpc_full.ini。<br>然后进行配置，<code>vi ./frps.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 3000</span><br></pre></td></tr></table></figure></p><p>其中<code>bind_port</code>端口用来和客户端进行通信，<code>vhost_http_port</code>为服务端<code>http</code>服务端口。<br>保存然后启动服务<code>./frps -c ./frps.ini</code>，这是前台启动，后台启动命令为<code>nohup ./frps -c ./frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</code><br>如果需要关闭这个进程，则获取进程<code>ps -ef|grep frps</code>，然后关闭<code>kill -9 pid</code>。</p><h4 id="2-3、客户端启动"><a href="#2-3、客户端启动" class="headerlink" title="2.3、客户端启动"></a>2.3、客户端启动</h4><p>首先解压<code>frp_xxx_darwin_amd64.tar.gz</code>或<code>frp_xxx_windows_amd64.zip</code>，然后删除<code>frps</code>文件夹、frps.ini、frps_full.ini。<br>再进行配置，<code>vi ./frpc.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xx.xx.xx.xx</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 7001</span><br><span class="line">custom_domains = xx.xx.cn</span><br></pre></td></tr></table></figure></p><p>其中 server_addr 为公用服务器 ip 地址，server_port 与服务端 bind_port 一致，local_port 为内网 web 服务的端口号，custom_domains 为所绑定的公网服务器域名，一级、二级域名都可以。<br>保存然后启动服务<code>./frpc -c ./frpc.ini</code>。</p><h4 id="2-4、nginx-请求代理"><a href="#2-4、nginx-请求代理" class="headerlink" title="2.4、nginx 请求代理"></a>2.4、nginx 请求代理</h4><p>目前还需要在域名下带端口号才能够访问，而很多对接的第三方服务不允许域名下带端口号，所以用 nginx 做下代理工作。<br>推荐新增二级域名，然后配置 nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream frps &#123;</span><br><span class="line">  server 127.0.0.1:3000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name frps.xx.xx;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header X-Nginx-Proxy true;</span><br><span class="line">   </span><br><span class="line">    proxy_pass http://127.0.0.1:3000; </span><br><span class="line">    proxy_redirect off;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启 nginx 后便能够使用该二级域名访问本地服务了！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚搞定内网穿透，成就感爆棚，之前一直都是用&lt;a href=&quot;http://www.ngrok.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别人的服务&lt;/a&gt;，现在终于自己搞定了。&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.master-ss.cn/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>alipay 之电脑网站支付</title>
    <link href="http://blog.master-ss.cn/project/alipay/"/>
    <id>http://blog.master-ss.cn/project/alipay/</id>
    <published>2019-07-08T06:44:56.266Z</published>
    <updated>2019-07-08T07:22:57.051Z</updated>
    
    <content type="html"><![CDATA[<p>近期有接入支付宝的电脑网站支付 api，遇到一些需要注意事项，记录下来。<br><a id="more"></a> </p><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><h4 id="1-1、申请接入"><a href="#1-1、申请接入" class="headerlink" title="1.1、申请接入"></a>1.1、申请接入</h4><p>可以查看官方文档 <a href="https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001000" target="_blank" rel="noopener">https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001000</a></p><h4 id="1-2、接入文档"><a href="#1-2、接入文档" class="headerlink" title="1.2、接入文档"></a>1.2、接入文档</h4><p>可以查看官方文档 <a href="https://docs.open.alipay.com/270/105898" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105898</a></p><h3 id="二、开发流程"><a href="#二、开发流程" class="headerlink" title="二、开发流程"></a>二、开发流程</h3><h4 id="2-1、sdk-获取"><a href="#2-1、sdk-获取" class="headerlink" title="2.1、sdk 获取"></a>2.1、sdk 获取</h4><p>这里以 nodejs 的 sdk 为例，官方在 npm 已发布 <a href="https://www.npmjs.com/package/alipay-sdk" target="_blank" rel="noopener">alipay-sdk</a> 包</p><h4 id="2-2、接口调用"><a href="#2-2、接口调用" class="headerlink" title="2.2、接口调用"></a>2.2、接口调用</h4><p>官方文档可查看 <a href="https://www.yuque.com/chenqiu/alipay-node-sdk/page_api" target="_blank" rel="noopener">https://www.yuque.com/chenqiu/alipay-node-sdk/page_api</a> ，特别注意电脑网站支付属于页面类的接口调用，不要弄混了。以 egg 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- app.js --&gt;</span><br><span class="line">const AlipaySdk = require(&apos;alipay-sdk&apos;).default</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  app.beforeStart(async () =&gt; &#123;</span><br><span class="line">    // 将 AlipaySdk 实例挂载到 app 上</span><br><span class="line">    app.alipaySdk = new AlipaySdk(&#123;</span><br><span class="line">      appId: &apos;xxxx&apos;,</span><br><span class="line">      privateKey: fs.readFileSync(&apos;./rsa_private_key.pem&apos;, &apos;ascii&apos;),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- app/controller/xxx.js --&gt;</span><br><span class="line">const AlipayFormData = require(&apos;alipay-sdk/lib/form&apos;).default</span><br><span class="line">async alipay() &#123;</span><br><span class="line">  const &#123; ctx, &#125; = this</span><br><span class="line"></span><br><span class="line">  const &#123; amount, tradeNo, invoice, notifyUrl, &#125; = ctx.request.body</span><br><span class="line"></span><br><span class="line">  const formData = new AlipayFormData()</span><br><span class="line">  // 调用 setMethod 并传入 get，会返回可以跳转到支付页面的 url</span><br><span class="line">  formData.setMethod(&apos;get&apos;)</span><br><span class="line">  formData.addField(&apos;notifyUrl&apos;, notifyUrl)</span><br><span class="line">  formData.addField(&apos;bizContent&apos;, JSON.stringify(&#123;</span><br><span class="line">    outTradeNo: tradeNo,</span><br><span class="line">    passbackParams: invoice,</span><br><span class="line">    totalAmount: amount,</span><br><span class="line">    qrPayMode: &apos;2&apos;,</span><br><span class="line">    productCode: &apos;FAST_INSTANT_TRADE_PAY&apos;,</span><br><span class="line">    subject: &apos;xxx&apos;,</span><br><span class="line">  &#125;))</span><br><span class="line">  const result = await this.app.alipaySdk.exec(&apos;alipay.trade.page.pay&apos;, &#123;&#125;, &#123;</span><br><span class="line">    formData: formData</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: 200,</span><br><span class="line">    status: 200,</span><br><span class="line">    url: result,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3、页面跳转"><a href="#2-3、页面跳转" class="headerlink" title="2.3、页面跳转"></a>2.3、页面跳转</h4><p>这里有个地方需要特别注意，本人开发中在 vscode 的控制台上直接打印了跳转 url，然后点击在浏览器上查看会报错 <code>错误代码 invalid-signature 错误原因: 验签出错，建议检查签名字符串或签名私钥与应用公钥是否匹配，网关生成的验签字符串为</code>，查阅了大量资料才在 <a href="https://github.com/alipay/alipay-sdk-nodejs/issues/25" target="_blank" rel="noopener">issue</a> 上看到答案。正确的做法是拷贝控制台上的链接，然后手动复制到浏览器地址栏，直接点击会被 decodeURIComponent 处理导致验签失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期有接入支付宝的电脑网站支付 api，遇到一些需要注意事项，记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="project" scheme="http://blog.master-ss.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之进程管理</title>
    <link href="http://blog.master-ss.cn/node/process/"/>
    <id>http://blog.master-ss.cn/node/process/</id>
    <published>2019-02-28T02:14:58.904Z</published>
    <updated>2019-02-28T08:13:00.531Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 运行在单个进程的单个线程上，它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高 CPU 的使用率，但是单进程单线程并非完美的结构。如何充分利用多核CPU服务器、如何保证进程的健壮性和稳定性，前者只是利用率不足的问题，后者对于实际产品化带来一定的顾虑，本文关于进程的介绍和讨论将会解决掉这两个问题。<br>Node 自身还有一定的 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 开发者而言是透明的，本文将围绕 JavaScript 部分展开，屏蔽底层细节的讨论。<br><a id="more"></a> </p><h3 id="一、服务模型变迁"><a href="#一、服务模型变迁" class="headerlink" title="一、服务模型变迁"></a>一、服务模型变迁</h3><p>Web 服务器的架构已经历了几次变迁，服务器处理客户端请求的并发量，就是每个里程碑的见证。</p><h4 id="1-1、同步"><a href="#1-1、同步" class="headerlink" title="1.1、同步"></a>1.1、同步</h4><p>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，它的处理能力相当低下，假设每次响应服务耗用的时间稳定为 N 秒，这类服务的 QPS 为 1/N。</p><h4 id="1-2、复制进程"><a href="#1-2、复制进程" class="headerlink" title="1.2、复制进程"></a>1.2、复制进程</h4><p>为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。并把预复制（prefork）被引入服务模型中，即预先复制一定数量的进程，同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽，假设进程数上限为 M，那这类服务的 QPS 为 M/N。</p><h4 id="1-3、多线程"><a href="#1-3、多线程" class="headerlink" title="1.3、多线程"></a>1.3、多线程</h4><p>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性，假设线程所占用的资源为进程的 1/L，受资源上限的影响，它的 QPS 则为 M * L/N。</p><h4 id="1-4、事件驱动"><a href="#1-4、事件驱动" class="headerlink" title="1.4、事件驱动"></a>1.4、事件驱动</h4><p>Apache 就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来。为了解决高并发问题，基于事件驱动的服务模型出现了，像 Node 与 Nginx 均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。<br>基于事件的服务模型存在的问题即是开始时提及的两个问题：CPU 的利用率和进程的健壮性。由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，它的上限决定这类服务模型的性能上限，可伸缩性远比前两者高。</p><h3 id="二、多进程架构"><a href="#二、多进程架构" class="headerlink" title="二、多进程架构"></a>二、多进程架构</h3><p>理想状态下每个进程各自利用一个 CPU，以此实现多核 CPU 的利用。Node 提供了 child_process 模块，并且也提供了 child_process.fork() 函数供我们实现进程的复制。通过 fork() 复制的进程都是一个独立的进程，这个进程中有着独立而全新的 V8 实例。它需要至少 30 毫秒的启动时间和至少 10MB 的内存。尽管 Node 提供了 fork() 供我们复制进程使每个 CPU 内核都使用上，但是依然要切记 fork() 进程是昂贵的。好在 Node 通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将 CPU 资源利用起来。</p><h4 id="2-1、创建子进程"><a href="#2-1、创建子进程" class="headerlink" title="2.1、创建子进程"></a>2.1、创建子进程</h4><p>child_process 模块给予 Node 可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。</p><ul><li>spawn()：启动一个子进程来执行命令；</li><li>exec()：启动一个子进程来执行命令，有回调函数获知子进程的状况；</li><li>execFile()：启动一个子进程来执行可执行文件；</li><li>fork()：与 spawn() 类似，不同点在于它创建 Node 的子进程只需指定要执行的 JavaScript 文件模块即可。</li></ul><p>以一个寻常命令为例，node worker.js 分别用上述 4 种方法实现，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">cp.spawn(&apos;node&apos;, [&apos;worker.js&apos;]);</span><br><span class="line">cp.exec(&apos;node worker.js&apos;, function (err, stdout, stderr) &#123;</span><br><span class="line">// some code</span><br><span class="line">&#125;);</span><br><span class="line">cp.execFile(&apos;worker.js&apos;, function (err, stdout, stderr) &#123;</span><br><span class="line">    // some code</span><br><span class="line">&#125;);</span><br><span class="line">cp.fork(&apos;./worker.js&apos;);</span><br></pre></td></tr></table></figure></p><p>以上4个方法在创建子进程之后均会返回子进程对象。它们的差别可以通过表9-1查看：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">回调/异常</th><th style="text-align:center">进程类型</th><th style="text-align:center">执行类型</th><th style="text-align:center">可设置超时</th></tr></thead><tbody><tr><td style="text-align:center">spawn()</td><td style="text-align:center">N</td><td style="text-align:center">任意</td><td style="text-align:center">命令</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">exec()</td><td style="text-align:center">Y</td><td style="text-align:center">任意</td><td style="text-align:center">命令</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">execFile()</td><td style="text-align:center">Y</td><td style="text-align:center">任意</td><td style="text-align:center">可执行文件</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">fork()</td><td style="text-align:center">N</td><td style="text-align:center">Node</td><td style="text-align:center">JavaScript文件</td><td style="text-align:center">N</td></tr></tbody></table><p>这里的可执行文件是指可以直接执行的文件，如果是 JavaScript 文件通过 execFile() 运行，它的首行内容必须添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br></pre></td></tr></table></figure></p><p>尽管4种创建子进程的方式有些差别，但事实上后面 3 种方法都是 spawn() 的延伸应用。</p><h4 id="2-2、进程间通信"><a href="#2-2、进程间通信" class="headerlink" title="2.2、进程间通信"></a>2.2、进程间通信</h4><p>在前端浏览器中，JavaScript 主线程与 UI 渲染共用同一个线程。执行 JavaScript 的时候 UI 渲染是停滞的，渲染 UI 时，JavaScript 是停滞的，两者互相阻塞。长时间执行 JavaScript 将会造成 UI 停顿不响应。为了解决这个问题，HTML5 提出了 WebWorker API。WebWorker 允许创建工作线程并在后台运行，使得一些阻塞较为严重的计算不影响主线程上的 UI 渲染。<br>而 Node 在 Master-Worker 模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于 child_process 模块，创建好了子进程，然后与父子进程间通信是十分容易的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// parent.js</span><br><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var n = cp.fork(__dirname + &apos;/sub.js&apos;);</span><br><span class="line">n.on(&apos;message&apos;, function (m) &#123;</span><br><span class="line">    console.log(&apos;PARENT got message:&apos;, m);</span><br><span class="line">&#125;);</span><br><span class="line">n.send(&#123; hello: &apos;world&apos; &#125;);</span><br><span class="line">// sub.js</span><br><span class="line">process.on(&apos;message&apos;, function (m) &#123;</span><br><span class="line">    console.log(&apos;CHILD got message:&apos;, m);</span><br><span class="line">&#125;);</span><br><span class="line">process.send(&#123;foo: &apos;bar&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>通过 fork() 或者其他 API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建 IPC 通道。通过 IPC 通道，父子进程之间才能通过 message 和 send() 传递消息。注意，process.send 用来给父进程发送消息，只有子进程才存在。</p><h4 id="2-3、进程间通信原理"><a href="#2-3、进程间通信原理" class="headerlink" title="2.3、进程间通信原理"></a>2.3、进程间通信原理</h4><p>IPC 的全称是 Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket 等。Node 中实现 IPC 通道的是管道（pipe）技术。但此管道非彼管道，在 Node 中管道是个抽象层面的称呼，具体细节实现由 libuv 提供，在 Windows 下由命名管道（named pipe）实现，*nix 系统则采用 Unix Domain Socket 实现。表现在应用层上的进程间通信只有简单的 message 事件和 send() 方法，接口十分简洁和消息化，如下为 IPC 创建和实现的示意图。<br><img src="/assets/node/process.png"><br>父进程在实际创建子进程之前，会创建 IPC 通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道，从而完成父子进程之间的连接，如下为创建 IPC 管道的步骤示意图。<br><img src="/assets/node/process2.png"><br>建立连接之后的父子进程就可以自由地通信了。由于 IPC 通道是用命名管道或 Domain Socket 创建的，它们与网络 socket 的行为比较类似，属于双向通信。不同的是它们在系统内核中就完成了进程间的通信，而不用经过实际的网络层，非常高效。在 Node 中，IPC 通道被抽象为 Stream 对象，在调用 send() 时发送数据（类似于 write()），接收到的消息会通过 message 事件（类似于 data）触发给应用层。<br>注意，只有启动的子进程是 Node 进程时，子进程才会根据环境变量去连接 IPC 通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的 IPC 通道。</p><h4 id="2-4、句柄传递"><a href="#2-4、句柄传递" class="headerlink" title="2.4、句柄传递"></a>2.4、句柄传递</h4><p>建立好进程之间的 IPC 后，将启动的服务器分别监听各自的端口么，如果让服务都监听到相同的端口，将会有什么样的结果？示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// master.js</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;Hello World\n&apos;);</span><br><span class="line">&#125;).listen(8888, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure></p><p>再次启动 master.js 文件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE 127.0.0.1:8888</span><br></pre></td></tr></table></figure></p><p>这时只有一个工作进程能够监听到该端口上，其余的进程在监听的过程中都抛出了 EADDRINUSE 异常，这是端口被占用的情况，新的进程不能继续监听该端口了。这个问题破坏了我们将多个进程监听同一个端口的想法。要解决这个问题，通常的做法是让每个进程监听不同的端口，其中主进程监听主端口（如 80），主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上，如下图所示。<br><img src="/assets/node/process3.png"><br>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。<br>为了解决上述这样的问题，Node 在版本 v0.5.9 引入了进程间发送句柄的功能。send() 方法除了能通过 IPC 发送数据外，还能发送句柄，第二个可选参数就是句柄，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.send(message, [sendHandle])</span><br></pre></td></tr></table></figure></p><p>那什么是句柄？句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端 socket 对象、一个客户端 socket 对象、一个 UDP 套接字、一个管道等。<br>发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到 socket 请求后，将这个 socket 直接发送给工作进程，而不是重新与工作进程之间建立新的 socket 连接来转发数据。文件描述符浪费的问题可以通过这样的方式轻松解决。来看看我们的示例代码。<br>主进程代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var child1 = cp.fork(&apos;child.js&apos;);</span><br><span class="line">var child2 = cp.fork(&apos;child.js&apos;);</span><br><span class="line"></span><br><span class="line">// Open up the server object and send the handle</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line">server.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">    socket.end(&apos;handled by parent\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8001, function () &#123;</span><br><span class="line">    child1.send(&apos;server&apos;, server);</span><br><span class="line">    child2.send(&apos;server&apos;, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>子进程代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;message&apos;, function (m, server) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        server.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            socket.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个示例中直接将一个 TCP 服务器发送给了子进程。这是看起来不可思议的事情，我们先来测试一番，看看效果如何，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 先启动服务器</span><br><span class="line">$ node parent.js</span><br></pre></td></tr></table></figure></p><p>然后新开一个命令行窗口，用上 curl 工具，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27418</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27419</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27419</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by parent</span><br></pre></td></tr></table></figure></p><p>命令行中的响应结果也是很不可思议的，这里子进程和父进程都有可能处理我们客户端发起的请求。这是在 TCP 层面上完成的事情，我们尝试将其转化到 HTTP 层面来试试。对于主进程而言，我们甚至想要它更轻量一点，那么是否将服务器句柄发送给子进程之后，就可以关掉服务器的监听，让子进程来处理请求呢？<br>对主进程进行改动，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// parent.js</span><br><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var child1 = cp.fork(&apos;child.js&apos;);</span><br><span class="line">var child2 = cp.fork(&apos;child.js&apos;);</span><br><span class="line"></span><br><span class="line">// Open up the server object and send the handle</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line"></span><br><span class="line">server.listen(8001, function () &#123;</span><br><span class="line">    child1.send(&apos;server&apos;, server);</span><br><span class="line">    child2.send(&apos;server&apos;, server);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后对子进程进行改动，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&apos;message&apos;, function (m, tcp) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        tcp.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            server.emit(&apos;connection&apos;, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>重新启动 parent.js 后，再次测试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27882</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27883</span><br></pre></td></tr></table></figure></p><p>这样一来，所有的请求都是由子进程处理了。整个过程中，服务的过程发生了一次改变，如下图所示。<br><img src="/assets/node/process4.png"><br>主进程发送完句柄并关闭监听之后，成为了如下图所示的结构。<br><img src="/assets/node/process5.png"><br>我们神奇地发现，多个子进程可以同时监听相同端口，再没有 EADDRINUSE 异常发生了。</p><h4 id="2-5、句柄发送与还原"><a href="#2-5、句柄发送与还原" class="headerlink" title="2.5、句柄发送与还原"></a>2.5、句柄发送与还原</h4><p>上文介绍的虽然是句柄发送，但是仔细看看，句柄发送跟我们直接将服务器对象发送给子进程有没有差别？它是否真的将服务器对象发送给了子进程？为什么它可以发送到多个子进程中？发送给子进程为什么父进程中还存在这个对象？<br>目前子进程对象 send() 方法可以发送的句柄类型包括如下几种。</p><ul><li>net.Socket。TCP 套接字。</li><li>net.Server。TCP 服务器，任意建立在 TCP 服务上的应用层服务都可以享受到它带来的好处。</li><li>net.Native。C++ 层面的 TCP 套接字或 IPC 管道。</li><li>dgram.Socket。UDP 套接字。</li><li>dgram.Native。C++ 层面的 UDP 套接字。</li></ul><p>send() 方法在将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message。message 参数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cmd: &apos;NODE_HANDLE&apos;, type: &apos;net.Server&apos;, msg: message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送到 IPC 管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个 message 对象在写入到 IPC 管道时也会通过 JSON.stringify() 进行序列化。所以最终发送到 IPC 通道中的信息都是字符串，send() 方法能发送消息和句柄并不意味着它能发送任意对象。<br>连接了 IPC 通道的子进程可以读取到父进程发来的消息，将字符串通过 JSON.parse() 解析还原为对象后，才触发 message 事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd 的值如果以 NODE_ 为前缀，它将响应一个内部事件 internalMessage。如果 message.cmd 值为 NODE_HANDLE，它将取出 message.type 值和得到的文件描述符一起还原出一个对应的对象。<br>以发送的 TCP 服务器句柄为例，子进程收到消息后的还原过程如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(message, handle, emit) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var server = new net.Server();</span><br><span class="line">    server.listen(handle, function () &#123;</span><br><span class="line">        emit(server);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，子进程根据 message.type 创建对应 TCP 服务器对象，然后监听到文件描述符上。由于底层细节不被应用层感知，所以在子进程中，开发者会有一种服务器就是从父进程中直接传递过来的错觉。值得注意的是，Node 进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果。<br>目前 Node 只支持上述提到的几种句柄，并非任意类型的句柄都能在进程之间传递，除非它有完整的发送和还原的过程。</p><h4 id="2-4、端口共同监听"><a href="#2-4、端口共同监听" class="headerlink" title="2.4、端口共同监听"></a>2.4、端口共同监听</h4><p>在了解了句柄传递背后的原理后，我们继续探究为何通过发送句柄后，多个进程可以监听到相同的端口而不引起 EADDRINUSE 异常。其答案也很简单，我们独立启动的进程中，TCP 服务器端 socket 套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。<br>Node 底层对每个端口监听都设置了 SO_REUSEADDR 选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(tcp-&gt;io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))</span><br></pre></td></tr></table></figure></p><p>由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于 send() 发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。<br>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的。</p><h3 id="三、集群稳定之路"><a href="#三、集群稳定之路" class="headerlink" title="三、集群稳定之路"></a>三、集群稳定之路</h3><p>搭建好了集群，充分利用了多核 CPU 资源，似乎就可以迎接客户端大量的请求了。但是我们还有一些细节需要考虑，性能问题、多个工作进程的存活状态管理、工作进程的平滑重启、配置或者静态数据的动态重新载入、其他细节。<br>虽然我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，它的稳定性还不能得到完全的保障。我们需要建立起一个健全的机制来保障 Node 应用的健壮性。</p><h4 id="3-1、进程事件"><a href="#3-1、进程事件" class="headerlink" title="3.1、进程事件"></a>3.1、进程事件</h4><p>再次回归到子进程对象上，除了引人关注的 send() 方法和 message 事件外，子进程还有些什么呢？首先除了 message 事件外，Node 还有如下这些事件。</p><ul><li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。</li><li>exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为 null。如果进程是通过 kill() 方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li><li>close：在子进程的标准输入输出流中止时触发该事件，参数与 exit 相同。</li><li>disconnect：在父进程或子进程中调用 disconnect() 方法时触发该事件，在调用该方法时将关闭监听 IPC 通道。</li></ul><p>上述这些事件是父进程能监听到的与子进程相关的事件。除了 send() 外，还能通过 kill() 方法给子进程发送消息。kill() 方法并不能真正地将通过 IPC 相连的子进程杀死，它只是给子进程发送了一个系统信号。默认情况下，父进程将通过 kill() 方法给子进程发送一个 SIGTERM 信号。它与进程默认的 kill() 方法类似，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 子进程</span><br><span class="line">child.kill([signal]);</span><br><span class="line">// 当前进程</span><br><span class="line">process.kill(pid, [signal]);</span><br></pre></td></tr></table></figure></p><p>它们一个发给子进程，一个发给目标进程。在 POSIX 标准中，有一套完备的信号系统，在命令行中执行 kill -l 可以看到详细的信号列表，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL</span><br><span class="line"> 5) SIGTRAP 6) SIGABRT 7) SIGEMT 8) SIGFPE</span><br><span class="line"> 9) SIGKILL10) SIGBUS11) SIGSEGV12) SIGSYS</span><br><span class="line">13) SIGPIPE14) SIGALRM15) SIGTERM16) SIGURG</span><br><span class="line">17) SIGSTOP18) SIGTSTP19) SIGCONT20) SIGCHLD</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGIO24) SIGXCPU</span><br><span class="line">25) SIGXFSZ26) SIGVTALRM27) SIGPROF28) SIGWINCH</span><br><span class="line">29) SIGINFO30) SIGUSR131) SIGUSR2</span><br></pre></td></tr></table></figure></p><p>Node 提供了这些信号对应的信号事件，每个进程都可以监听这些信号事件。这些信号事件是用来通知进程的，每个信号事件有不同的含义，进程在收到响应信号时，应当做出约定的行为，如SIGTERM是软件终止信号，进程收到该信号时应当退出。示例代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;Got a SIGTERM, exiting...&apos;);</span><br><span class="line">    process.exit(1);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;server running with PID:&apos;, process.pid);</span><br><span class="line">process.kill(process.pid, &apos;SIGTERM&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="3-2、自动重启"><a href="#3-2、自动重启" class="headerlink" title="3.2、自动重启"></a>3.2、自动重启</h4><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制了。至少能够通过监听子进程的 exit 事件来获知其退出的信息，在主进程上要加入一些子进程管理的机制，比如重新启动一个工作进程来继续服务。<br>实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// master.js</span><br><span class="line">var fork = require(&apos;child_process&apos;).fork;</span><br><span class="line">var cpus = require(&apos;os&apos;).cpus();</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line">server.listen(1337);</span><br><span class="line">var workers = &#123;&#125;;</span><br><span class="line">var createWorker = function () &#123;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    // 退出时重新启动新的进程</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">        createWorker();</span><br><span class="line">    &#125;);</span><br><span class="line">    // 句柄转发</span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br><span class="line">for (var i = 0; i &lt; cpus.length; i++) &#123;</span><br><span class="line">    createWorker();</span><br><span class="line">&#125;</span><br><span class="line">// 进程自己退出时，让所有工作进程退出 </span><br><span class="line">process.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">    for (var pid in workers) &#123;</span><br><span class="line">        workers[pid].kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>测试一下上面的代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node master.js</span><br><span class="line">Create worker. pid: 28939</span><br><span class="line">Create worker. pid: 28940</span><br><span class="line">Create worker. pid: 28941</span><br><span class="line">Create worker. pid: 28942</span><br><span class="line">Create worker. pid: 28943</span><br><span class="line">Create worker. pid: 28944</span><br><span class="line">Create worker. pid: 28945</span><br><span class="line">Create worker. pid: 28946</span><br></pre></td></tr></table></figure></p><p>通过 kill 命令杀死某个进程试试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill 28939</span><br></pre></td></tr></table></figure></p><p>结果是 28939 进程退出后，自动启动了一个新的工作进程 28959，总体进程数量并没有发生改变，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker 28939 exited.</span><br><span class="line">Create worker. pid: 28959</span><br></pre></td></tr></table></figure></p><p>在这个场景中我们主动杀死了一个进程，在实际业务中，可能有隐藏的 bug 导致工作进程退出，那么我们需要仔细地处理这种异常，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// worker.js </span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var worker;</span><br><span class="line">process.on(&apos;message&apos;, function (m, tcp) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        worker = tcp;</span><br><span class="line">        worker.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            server.emit(&apos;connection&apos;, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&apos;uncaughtException&apos;, function () &#123;</span><br><span class="line">    // 停止接收新的连接  </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程  </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述代码的处理流程是，一旦有未捕获的异常出现，工作进程就会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的 exit 后，将会立即启动新的进程服务，以此保证整个集群中总是有进程在为用户服务的。</p><h4 id="3-3、自杀信号"><a href="#3-3、自杀信号" class="headerlink" title="3.3、自杀信号"></a>3.3、自杀信号</h4><p>当然上述代码存在的问题是要等到已有的所有连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，全处在等待退出的状态。但在等到进程完全退出才重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，这会丢掉大部分请求。<br>为此需要改进这个过程，不能等到工作进程退出后才重启新的工作进程。当然也不能暴力退出进程，因为这样会导致已连接的用户直接断开。于是在退出的流程中增加一个自杀（suicide）信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。代码改动如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// worker.js </span><br><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接   </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程 </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>主进程将重启工作进程的任务，从 exit 事件的处理函数中转移到 message 事件的处理函数中，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var createWorker = function () &#123;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    // 启动新的进程   </span><br><span class="line">    worker.on(&apos;message&apos;, function (message) &#123;</span><br><span class="line">        if (message.act === &apos;suicide&apos;) &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">    &#125;);</span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了模拟未捕获的异常，我们将工作进程的处理代码改为抛出异常，一旦有用户请求，就会有一个可怜的工作进程退出，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">    throw new Error(&apos;throw exception&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后启动所有进程，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node master.js</span><br><span class="line">Create worker. pid: 29428</span><br><span class="line">Create worker. pid: 29429</span><br><span class="line">Create worker. pid: 29430</span><br><span class="line">Create worker. pid: 29431</span><br><span class="line">Create worker. pid: 29432</span><br><span class="line">Create worker. pid: 29433</span><br><span class="line">Create worker. pid: 29434</span><br><span class="line">Create worker. pid: 29435</span><br></pre></td></tr></table></figure></p><p>用curl工具测试效果，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:8001</span><br><span class="line">handled by child, pid is 29433</span><br></pre></td></tr></table></figure></p><p>再回头看重启信息，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Create worker. pid: 29472</span><br><span class="line">Worker 29462 exited.</span><br></pre></td></tr></table></figure></p><p>与前一种方案相比，创建新工作进程在前，退出异常进程在后。在这个可怜的异常进程退出之前，总是有新的工作进程来替上它的岗位。至此我们完成了进程的平滑重启，一旦有异常出现，主进程会创建新的工作进程来为用户服务，旧的进程一旦处理完已有连接就自动断开。整个过程使得我们的应用的稳定性和健壮性大大提高。<br>这里存在问题的是有可能我们的连接是长连接，不是 HTTP 服务的这种短连接，等待长连接断开可能需要较久的时间。为此为已有连接的断开设置一个超时时间是必要的，在限定时间里强制退出的设置如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接</span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程   </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 5秒后退出进程 </span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;, 5000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>进程中如果出现未能捕获的异常，就意味着有那么一段代码在健壮性上是不合格的。为此退出进程前，通过日志记录下问题所在是必须要做的事情，它可以帮我们很好地定位和追踪代码异常出现的位置，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    // 记录日志  </span><br><span class="line">    logger.error(err);</span><br><span class="line">    // 发送自杀信号   </span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接  </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程    </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 5秒后退出进程 </span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;, 5000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="3-4、限量重启"><a href="#3-4、限量重启" class="headerlink" title="3.4、限量重启"></a>3.4、限量重启</h4><p>通过自杀信号告知主进程可以使得新连接总是有进程服务，但是依然还是有极端的情况。工作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误，会导致工作进程被频繁重启，这种频繁重启不属于我们捕捉未知异常的情况，因为这种短时间内频繁重启已经不符合预期的设置，极有可能是程序编写的错误。<br>为了消除这种无意义的重启，在满足一定规则的限制下，不应当反复重启。比如在单位时间内规定只能重启多少次，超过限制就触发 giveup 事件，告知放弃重启工作进程这个重要事件。<br>为了完成限量重启的统计，我们引入一个队列来做标记，在每次重启工作进程之间进行打点并判断重启是否太过频繁，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 重启次数 </span><br><span class="line">var limit = 10;</span><br><span class="line">// 时间单位 </span><br><span class="line">var during = 60000;</span><br><span class="line">var restart = [];</span><br><span class="line">var isTooFrequently = function () &#123;</span><br><span class="line">    // 记录重启时间   </span><br><span class="line">    var time = Date.now();</span><br><span class="line">    var length = restart.push(time);</span><br><span class="line">    if (length &gt; limit) &#123;</span><br><span class="line">        // 取出最后 10 个记录     </span><br><span class="line">        restart = restart.slice(limit * -1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一次重启到前 10 次重启之间的时间间隔  </span><br><span class="line">    return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during;</span><br><span class="line">&#125;;</span><br><span class="line">var workers = &#123;&#125;;</span><br><span class="line">var createWorker = function () &#123;</span><br><span class="line">    // 检查是否太过频繁  </span><br><span class="line">    if (isTooFrequently()) &#123;</span><br><span class="line">        // 触发 giveup 事件后，不再重启  </span><br><span class="line">        process.emit(&apos;giveup&apos;, length, during);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">    &#125;);</span><br><span class="line">    // 重新启动新的进程   </span><br><span class="line">    worker.on(&apos;message&apos;, function (message) &#123;</span><br><span class="line">        if (message.act === &apos;suicide&apos;) &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 句柄转发   </span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>giveup 事件是比 uncaughtException 更严重的异常事件。uncaughtException 只代表集群中某个工作进程退出，在整体性保证下，不会出现用户得不到服务的情况，但是这个 giveup 事件则表示集群中没有任何进程服务了，十分危险。为了健壮性考虑，我们应在 giveup 事件中添加重要日志，并让监控系统监视到这个严重错误，进而报警等。</p><h4 id="3-5、负载均衡"><a href="#3-5、负载均衡" class="headerlink" title="3.5、负载均衡"></a>3.5、负载均衡</h4><p>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将 CPU 资源都调用起来。这犹如饭店将客人的点单分发给多个厨师进行餐点制作，这种保证多个处理单元工作量公平的策略叫负载均衡。<br>Node 默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。<br>一般而言，这种抢占式策略对大家是公平的，各个进程可以根据自己的繁忙度来进行抢占。但是对于 Node 而言，需要分清的是它的繁忙是由 CPU、I/O 两个部分构成的，影响抢占的是 CPU 的繁忙度。对不同的业务，可能存在 I/O 繁忙，而 CPU 较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况。<br>为此 Node 在 v0.11 中提供了一种新的策略使得负载均衡更合理，这种新的策略叫 Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在 N 个工作进程中，每次选择第 i = (i + 1) mod n 个进程来发送连接。在 cluster 模块中启用它的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 启用 Round-Robin  </span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_RR</span><br><span class="line">// 不启用 Round-Robin</span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure></p><p>或者在环境变量中设置 NODE_CLUSTER_SCHED_POLICY 的值，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_CLUSTER_SCHED_POLICY = rr </span><br><span class="line">export NODE_CLUSTER_SCHED_POLICY = none</span><br></pre></td></tr></table></figure></p><p>Round-Robin 非常简单，可以避免 CPU 和 I/O 繁忙差异导致的负载不均衡。Round-Robin 策略也可以通过代理服务器来实现，但是它会导致服务器上消耗的文件描述符是平常方式的两倍。</p><h4 id="3-6、状态共享"><a href="#3-6、状态共享" class="headerlink" title="3.6、状态共享"></a>3.6、状态共享</h4><p>在 Node 进程中不宜存放太多数据，因为它会加重垃圾回收的负担，进而影响性能。同时，Node 也不允许在多个进程之间共享数据。但在实际的业务中，往往需要共享一些数据，譬如配置数据，这在多个进程中应当是一致的。为此，在不允许共享数据的情况下，我们需要一种方案和机制来实现数据在多个进程之间的共享。</p><ul><li>第三方数据存储<br>解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如Redis）中，所有工作进程启动时将其读取进内存中。但这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。<br>实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询。<br>定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟。</li><li>主动通知<br>一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。为了不混合业务逻辑，可以将这个进程设计为只进行轮询和通知，不处理任何业务逻辑。<br>这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用 TCP 或 UDP 的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。由于不涉及太多进程去向同一地方进行状态查询，状态响应处的压力不至于太过巨大，单一的通知服务轮询带来的压力并不大，所以可以将轮询时间调整得较短，一旦发现更新，就能实时地推送到各个子进程中。</li></ul><h3 id="四、Cluster-模块"><a href="#四、Cluster-模块" class="headerlink" title="四、Cluster 模块"></a>四、Cluster 模块</h3><p>Node v0.8 时直接引入了 cluster 模块，用以解决多核 CPU 的利用率问题，同时也提供了较完善的 API，用以处理进程的健壮性问题，cluster 实现创建 Node 进程集群也是很轻松的事情，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// cluster.js</span><br><span class="line">var cluster = require(&apos;cluster&apos;);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">    exec: &quot;./worker.js&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var cpus = require(&apos;os&apos;).cpus(), works = [];</span><br><span class="line">for (var i = 0; i &lt; cpus.length; i++) &#123;</span><br><span class="line">    works[i] = cluster.fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行 node cluster.js 将会得到与前文创建子进程集群的效果相同。就官方的文档而言，它更喜欢如下的形式作为示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var cluster = require(&apos;cluster&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var numCPUs = require(&apos;os&apos;).cpus().length;</span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">    // Fork workers  </span><br><span class="line">    for (var i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.on(&apos;exit&apos;, function (worker, code, signal) &#123;</span><br><span class="line">        console.log(&apos;worker &apos; + worker.process.pid + &apos; died&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Workers can share any TCP connection  </span><br><span class="line">    // In this case its a HTTP server   </span><br><span class="line">    http.createServer(function (req, res) &#123;</span><br><span class="line">        res.writeHead(200);</span><br><span class="line">        res.end(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;).listen(8000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有 NODE_UNIQUE_ID，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster.isWorker = (&apos;NODE_UNIQUE_ID&apos; in process.env);</span><br><span class="line">cluster.isMaster = (cluster.isWorker === false);</span><br></pre></td></tr></table></figure></p><p>但是官方示例中忽而判断 cluster.isMaster、忽而判断 cluster.isWorker，对于代码的可读性十分差。建议用 cluster.setupMaster() 这个 API，将主进程和工作进程从代码上完全剥离，如同 send() 方法看起来直接将服务器从主进程发送到子进程那样神奇，剥离代码之后，甚至都感觉不到主进程中有任何服务器相关的代码。<br>通过 cluster.setupMaster() 创建子进程而不是使用 cluster.fork()，程序结构不再凌乱，逻辑分明，代码的可读性和可维护性较好。</p><h4 id="4-1、Cluster-工作原理"><a href="#4-1、Cluster-工作原理" class="headerlink" title="4.1、Cluster 工作原理"></a>4.1、Cluster 工作原理</h4><p>事实上 cluster 模块就是 child_process 和 net 模块的组合应用。cluster 启动时，会在内部启动 TCP 服务器，在 cluster.fork() 子进程时，将这个 TCP 服务器端 socket 的文件描述符发送给工作进程。如果进程是通过 cluster.fork() 复制出来的，那么它的环境变量里就存在 NODE_UNIQUE_ID，如果工作进程中存在 listen() 侦听网络端口的调用，它将拿到该文件描述符，通过 SO_REUSEADDR 端口重用，从而实现多个子进程共享端口。对于普通方式启动的进程，则不存在文件描述符传递共享等事情。<br>在 cluster 内部隐式创建 TCP 服务器的方式对使用者来说十分透明，但也正是这种方式使得它无法如直接使用 child_process 那样灵活。在 cluster 模块应用中，一个主进程只能管理一组工作进程。<br>对于自行通过 child_process 来操作时，则可以更灵活地控制工作进程，甚至控制多组工作进程。其原因在于自行通过 child_process 操作子进程时，可以隐式地创建多个 TCP 服务器，使得子进程可以共享多个的服务器端 socket。</p><h4 id="4-2、Cluster事件"><a href="#4-2、Cluster事件" class="headerlink" title="4.2、Cluster事件"></a>4.2、Cluster事件</h4><p>对于健壮性处理，cluster 模块也暴露了相当多的事件。</p><ul><li>fork：复制一个工作进程后触发该事件。</li><li>online：复制好一个工作进程后，工作进程主动发送一条 online 消息给主进程，主进程收到消息后，触发该事件。</li><li>listening：工作进程中调用 listen() 后，发送一条 listening 消息给主进程，主进程收到消息后，触发该事件。</li><li>disconnect：主进程和工作进程之间 IPC 通道断开后会触发该事件。</li><li>exit：有工作进程退出时触发该事件。</li><li>setup：cluster.setupMaster() 执行后触发该事件。</li></ul><p>这些事件大多跟 child_process 模块的事件相关，在进程间消息传递的基础上完成的封装。这些事件对于增强应用的健壮性已经足够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 运行在单个进程的单个线程上，它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高 CPU 的使用率，但是单进程单线程并非完美的结构。如何充分利用多核CPU服务器、如何保证进程的健壮性和稳定性，前者只是利用率不足的问题，后者对于实际产品化带来一定的顾虑，本文关于进程的介绍和讨论将会解决掉这两个问题。&lt;br&gt;Node 自身还有一定的 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 开发者而言是透明的，本文将围绕 JavaScript 部分展开，屏蔽底层细节的讨论。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>nvm 简介</title>
    <link href="http://blog.master-ss.cn/node/nvm/"/>
    <id>http://blog.master-ss.cn/node/nvm/</id>
    <published>2019-02-20T09:11:22.098Z</published>
    <updated>2019-02-26T03:04:41.357Z</updated>
    
    <content type="html"><![CDATA[<p>前不久有个旧项目需要低版本的 node 才能跑起来，但是新项目又需要新版本，还好有个工具叫 nvm 能够切换不同版本的 node。<br><a id="more"></a> </p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><h4 id="1-1、mac-或-linux"><a href="#1-1、mac-或-linux" class="headerlink" title="1.1、mac 或 linux"></a>1.1、mac 或 linux</h4><p>安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/cnpm/nvm/master/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功，当出现 “Node Version Manager” 时，说明已安装成功。</p><h4 id="1-2、windows"><a href="#1-2、windows" class="headerlink" title="1.2、windows"></a>1.2、windows</h4><p>nvm-windows 最新下载地址 <code>https://github.com/coreybutler/nvm-windows/releases</code>，这里有四个可下载的文件：</p><ul><li>nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置</li><li>nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便</li><li>Source code(zip)：zip 压缩的源码</li><li>Sourc code(tar.gz)：tar.gz 的源码，一般用于 *nix 系统</li></ul><h3 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h3><ul><li>nvm install <version>：可以是 node.js 版本或最新稳定版本 latest</version></li><li>nvm list：列出已经安装的 node.js 版本</li><li>nvm uninstall <version>：卸载指定版本的 nodejs</version></li><li>nvm use [version]：切换到使用指定的 nodejs 版本</li><li>nvm –version：显示当前运行的 nvm 版本</li></ul><h3 id="三、不同版本的-Nodejs-共享全局的-npm"><a href="#三、不同版本的-Nodejs-共享全局的-npm" class="headerlink" title="三、不同版本的 Nodejs 共享全局的 npm"></a>三、不同版本的 Nodejs 共享全局的 npm</h3><p>用 nvm 管理 node 版本，会碰到这样一个问题：对于各个版本的全局 npm 模块，是各自独立的。因此，当你在 6.16.0 下全局安装了某个模块，然后切换到 8.14.1 之后又得重新安装。所以，解法就是 npm prefix：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前的 prefix</span><br><span class="line">npm config get prefix   // ~/.nvm/versions/node/v8.14.1</span><br><span class="line"></span><br><span class="line">// 将 prefix 设置到一个全局目录下，比如新建一个 /Users/songsong.zhang/npm-global, 这个文件不要放在需要 sudo 的文件夹下</span><br><span class="line">npm config set prefix /Users/songsong.zhang/npm-global</span><br></pre></td></tr></table></figure></p><p>设置之后，再用 npm 安装全局模块时就会放在 npm-global 下，注意 npm/cnpm 的 prefix 是各自独立的，因此每个都需要设置一下。<br>然后呢，全局模块的可执行文件也会放在 npm-global/bin 目录下，想要执行这些命令的话，还需要添加一条 PATH，打开 .bashrc，末尾添加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/Users/songsong.zhang/npm-global/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>如果是 windows 的话，则需要配置环境变量。</p><h3 id="四、使用-nvmrc-文件"><a href="#四、使用-nvmrc-文件" class="headerlink" title="四、使用 .nvmrc 文件"></a>四、使用 .nvmrc 文件</h3><p>如果你的 node 版本与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat .nvmrc</span><br><span class="line">// 6.16.0</span><br><span class="line"></span><br><span class="line">nvm use</span><br><span class="line">// Found &apos;/Users/songsong.zhang/study/es6test/.nvmrc&apos; with version &lt;6.16.0&gt;</span><br><span class="line">// Now using node v6.16.0 (npm v3.10.10)</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">// v6.16.0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久有个旧项目需要低版本的 node 才能跑起来，但是新项目又需要新版本，还好有个工具叫 nvm 能够切换不同版本的 node。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之文件路径</title>
    <link href="http://blog.master-ss.cn/node/path/"/>
    <id>http://blog.master-ss.cn/node/path/</id>
    <published>2019-02-20T07:58:36.239Z</published>
    <updated>2019-02-20T08:42:34.453Z</updated>
    
    <content type="html"><![CDATA[<p>node 有好几种表达文件路径的方式，但是他们之间有细微的区别，很容易搞混，现在梳理一遍。<br><a id="more"></a> </p><h3 id="一、文件路径"><a href="#一、文件路径" class="headerlink" title="一、文件路径"></a>一、文件路径</h3><p>Node 中的文件路径大概有 <code>__dirname</code>, <code>__filename</code>, <code>process.cwd()</code>, <code>./</code> 或者 <code>../</code>，前三个都是绝对路径，为了便于比较，<code>./</code> 和 <code>../</code> 我们通过 <code>path.resolve(&#39;./&#39;)</code>来转换为绝对路径。</p><h4 id="1-1、-dirname"><a href="#1-1、-dirname" class="headerlink" title="1.1、__dirname"></a>1.1、__dirname</h4><p>当前模块的目录名，与 <code>__filename</code> 的 <code>path.dirname()</code> 相同。<br>示例，从 /Users/songsong.zhang/study/es6test/path 运行 node example.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(__dirname);</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">console.log(path.dirname(__filename));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><h4 id="1-2、-filename"><a href="#1-2、-filename" class="headerlink" title="1.2、__filename"></a>1.2、__filename</h4><p>当前模块的文件名，这是当前模块文件的已解析的绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(__filename);</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path/example.js</span><br></pre></td></tr></table></figure></p><h4 id="1-3、process-cwd"><a href="#1-3、process-cwd" class="headerlink" title="1.3、process.cwd()"></a>1.3、process.cwd()</h4><p>process.cwd() 方法返回 Node.js 进程的当前工作目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(`当前工作目录是: $&#123;process.cwd()&#125;`);</span><br><span class="line">// 打印: 当前工作目录是: /Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><h4 id="1-4、-与"><a href="#1-4、-与" class="headerlink" title="1.4、./ 与 ../"></a>1.4、./ 与 ../</h4><p>我们通过 path.resolve() 方法将路径或路径片段的序列解析为绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">console.log(path.resolve(&apos;./&apos;));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br><span class="line">console.log(path.resolve(&apos;../&apos;));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test</span><br></pre></td></tr></table></figure></p><h3 id="二、综合实例"><a href="#二、综合实例" class="headerlink" title="二、综合实例"></a>二、综合实例</h3><p>假如我们有这样的文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path/</span><br><span class="line">    -lib/</span><br><span class="line">        -common.js</span><br><span class="line">    -model</span><br><span class="line">        -task.js</span><br></pre></td></tr></table></figure></p><p>在 task.js 里编写如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">console.log(__dirname);</span><br><span class="line">console.log(__filename);</span><br><span class="line">console.log(process.cwd());</span><br><span class="line">console.log(path.resolve(&apos;./&apos;));</span><br></pre></td></tr></table></figure></p><p>在 <code>model</code> 目录下运行 <code>node task.js</code> 得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model/task.js</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br></pre></td></tr></table></figure></p><p>然后在 <code>path</code> 目录下运行 <code>node model/task.js</code>，得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model/task.js</span><br><span class="line">/Users/songsong.zhang/study/es6test/path</span><br><span class="line">/Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><p>可以得出一些<strong>肤浅的结论</strong>了：</p><ul><li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li><li>__filename: 总是返回被执行的 js 的绝对路径</li><li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li><li>./: 跟 process.cwd() 貌似一样</li></ul><p>但是在 <code>require(&#39;../lib/common&#39;)</code> 里一直都是各种相对路径写，也没见报什么错啊，我们再来个栗子吧，还是上面的结构，<code>model/task.js</code> 里的代码改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var common = require(&apos;../lib/common&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;../lib/common.js&apos;, function (err, data) &#123;</span><br><span class="line">    if (err) return console.log(err);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在 model 目录下运行 <code>node task.js</code>，一切 Ok，没有报错。然后在 path 目录下运行 <code>node model/task.js</code>，然后很果断滴报错了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; Error: ENOENT: no such file or directory, open &apos;../lib/common.js&apos;</span><br><span class="line">  errno: -2,</span><br><span class="line">  code: &apos;ENOENT&apos;,</span><br><span class="line">  syscall: &apos;open&apos;,</span><br><span class="line">  path: &apos;../lib/common.js&apos; &#125;</span><br></pre></td></tr></table></figure></p><p>那么这下问题真的都是来了，按照上面的理论，在 path 下运行时，<code>../lib/common.js</code> 会被转成 <code>/Users/songsong.zhang/study/es6test/lib/common.js</code>，这个路径显然是不存在的，但是从运行结果可以看出 <code>require(&#39;../lib/common&#39;)</code> 是 OK 的，只是 readFile 时报错了。</p><p>那么关于 <code>./</code> 正确的结论是：<br>在 <code>require()</code> 中使用是跟 <code>__dirname</code> 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 <code>process.cwd()</code> 效果相同，是相对于启动脚本所在目录的路径。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>只有在 <code>require()</code> 时才使用相对路径 <code>(./, ../)</code> 的写法，其他地方一律使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前目录下</span><br><span class="line">path.dirname(__filename) + &apos;/test.js&apos;;</span><br><span class="line">// 相邻目录下</span><br><span class="line">path.resolve(__dirname, &apos;../lib/common.js&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node 有好几种表达文件路径的方式，但是他们之间有细微的区别，很容易搞混，现在梳理一遍。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之内存控制</title>
    <link href="http://blog.master-ss.cn/node/memory/"/>
    <id>http://blog.master-ss.cn/node/memory/</id>
    <published>2019-02-14T03:10:17.662Z</published>
    <updated>2019-02-14T06:25:06.375Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Node 的发展，JavaScript 已经实现了 CommonJS 的生态圈大一统的梦想，JavaScript 的应用场景早已不再局限在浏览器中。在那些短时间执行的场景，比如网页应用、命令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务器端的广泛应用，其他语言里存在着的问题在 JavaScript 中也暴露出来了。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用，本文将介绍在 Node 中如何合理高效地使用内存。<br><a id="more"></a></p><h3 id="一、V8-的垃圾回收机制与内存限制"><a href="#一、V8-的垃圾回收机制与内存限制" class="headerlink" title="一、V8 的垃圾回收机制与内存限制"></a>一、V8 的垃圾回收机制与内存限制</h3><p>Node 极大地拓宽了 JavaScript 的应用场景，当主流应用场景从客户端延伸到服务器端之后，对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。而在 Node 中，这一切都与 Node 的 JavaScript 执行引擎 V8 息息相关。</p><h4 id="1-1、Node-与-V8"><a href="#1-1、Node-与-V8" class="headerlink" title="1.1、Node 与 V8"></a>1.1、Node 与 V8</h4><p>Node 在发展历程中离不开 V8，所以在官方的主页介绍中就提到 Node 是一个构建在 Chrome 的 JavaScript 运行时上的平台。<br>关于 V8，它的来历与背景亦是大有来头。作为虚拟机，V8 的性能表现优异，这与它的领导者有莫大的渊源，Chrome 的成功也离不开它背后的天才——Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JavaScript 虚拟机。</p><h4 id="1-2、V8-的内存限制"><a href="#1-2、V8-的内存限制" class="headerlink" title="1.2、V8 的内存限制"></a>1.2、V8 的内存限制</h4><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如无法将一个 2 GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32 GB。这样在单个 Node 进程的情况下，计算机的内存资源无法得到充足的使用。<br>造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。<br>至于 V8 为何要限制堆的大小，表层原因为 V8 最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8 的限制值已经绰绰有余。深层原因是 V8 的垃圾回收机制的限制。按官方的说法，以 1.5 GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。<br>当然，这个限制也不是不能打开，V8 依然提供了选项让我们使用更多的内存。Node 在启动时可以传递 –max-old-space-size 或–max-new-space-size 来调整内存限制的大小，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=1700 test.js // 单位为MB </span><br><span class="line">// 或者</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位为KB</span><br></pre></td></tr></table></figure></p><p>上述参数在 V8 初始化时生效，一旦生效就不能再动态改变。如果遇到 Node 无法分配足够内存给 JavaScript 对象的情况，可以用这个办法来放宽 V8 默认的内存限制，避免在执行过程中稍微多用了一些内存就轻易崩溃。</p><h4 id="1-3、V8-的内存分代"><a href="#1-3、V8-的内存分代" class="headerlink" title="1.3、V8 的内存分代"></a>1.3、V8 的内存分代</h4><p>在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 –max-old-space-size 命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着 V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。</p><h3 id="二、内存指标"><a href="#二、内存指标" class="headerlink" title="二、内存指标"></a>二、内存指标</h3><h4 id="2-1、高效使用内存"><a href="#2-1、高效使用内存" class="headerlink" title="2.1、高效使用内存"></a>2.1、高效使用内存</h4><p>在 V8 面前，开发者所要具备的责任是如何让垃圾回收机制更高效地工作。<br>在正常的 JavaScript 执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于 V8 的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。</p><h4 id="2-2、查看内存使用情况"><a href="#2-2、查看内存使用情况" class="headerlink" title="2.2、查看内存使用情况"></a>2.2、查看内存使用情况</h4><p>process.memoryUsage() 可以查看内存使用情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage()</span><br><span class="line">&#123; rss: 21708800,</span><br><span class="line">  heapTotal: 7684096,</span><br><span class="line">  heapUsed: 4975704,</span><br><span class="line">  external: 8676 &#125;</span><br></pre></td></tr></table></figure></p><p>rss 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中。<br>除了 rss 外，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息。heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。这 3 个值的单位都是字节。为了更好地查看效果，我们格式化一下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var showMem = function () &#123;</span><br><span class="line">    var mem = process.memoryUsage();</span><br><span class="line">    var format = function (bytes) &#123;</span><br><span class="line">        return (bytes / 1024 / 1024).toFixed(2) + &apos; MB&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&apos;Process: heapTotal &apos; + format(mem.heapTotal) + &apos; heapUsed &apos; + format(mem.heapUsed) + &apos; rss &apos; + format(mem.rss));</span><br><span class="line">    console.log(&apos;-----------------------------------------------------------&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同时，写一个方法用于不停地分配内存但不释放内存，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var useMem = function () &#123;</span><br><span class="line">    var size = 20 * 1024 * 1024;</span><br><span class="line">    var arr = new Array(size);</span><br><span class="line">    for(var i = 0; i &lt; size; i++)&#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;;</span><br><span class="line">var total = [];</span><br><span class="line">for(var j = 0; j &lt; 15; j++)&#123; </span><br><span class="line">    showMem();</span><br><span class="line">    total.push(useMem());</span><br><span class="line">&#125;</span><br><span class="line">showMem();</span><br></pre></td></tr></table></figure></p><p>将以上代码存为 outofmemory.js 并执行它，得到的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 20.14 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 166.84 MB heapUsed 164.25 MB rss 181.61 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 326.85 MB heapUsed 324.25 MB rss 341.66 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 486.86 MB heapUsed 484.26 MB rss 501.73 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 646.88 MB heapUsed 644.26 MB rss 661.78 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 806.89 MB heapUsed 804.26 MB rss 821.81 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 966.90 MB heapUsed 964.26 MB rss 981.82 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 1126.91 MB heapUsed 1124.27 MB rss 1141.84 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 1286.92 MB heapUsed 1284.27 MB rss 1301.86 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[8918:0x102802400]     1415 ms: Mark-sweep 1284.0 (1290.9) -&gt; 1283.9 (1290.9) MB, 130.2 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[8918:0x102802400]     1547 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 131.9 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[8918:0x102802400]     1681 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 133.5 / 0.0 ms  last resort GC in old space requested</span><br></pre></td></tr></table></figure></p><p>可以看到，每次调用 useMem 都导致了 3 个值的增长。在接近 1500 MB 的时候，无法继续分配内存，然后进程内存溢出了，连循环体都无法执行完成。</p><h4 id="2-3、查看系统的内存占用"><a href="#2-3、查看系统的内存占用" class="headerlink" title="2.3、查看系统的内存占用"></a>2.3、查看系统的内存占用</h4><p>与 process.memoryUsage() 不同的是，os 模块中的 totalmem() 和 freemem() 这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; os.totalmem()</span><br><span class="line">17179869184</span><br><span class="line">&gt; os.freemem()</span><br><span class="line">4527833088</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>从输出信息可以看到我的电脑的总内存为 16 GB，当前闲置内存大致为 4.2 GB。</p><h4 id="2-4、堆外内存"><a href="#2-4、堆外内存" class="headerlink" title="2.4、堆外内存"></a>2.4、堆外内存</h4><p>通过 process.memoryUsage() 的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。我们将那些不是通过 V8 分配的内存称为堆外内存。<br>这里我们将前面的 useMem() 方法稍微改造一下，将 Array 变为 Buffer，将 size 变大，每一次构造 200 MB 的对象，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var useMem = function () &#123;</span><br><span class="line">    var size = 200 * 1024 * 1024;</span><br><span class="line">    var buffer = new Buffer(size);</span><br><span class="line">    for (var i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        buffer[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>重新执行该代码，得到的输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 19.86 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.83 MB heapUsed 4.25 MB rss 221.35 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.83 MB heapUsed 4.26 MB rss 421.52 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 621.91 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 821.91 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 1021.92 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1222.19 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1422.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1622.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 1822.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 2021.24 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.96 MB rss 2221.24 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 2421.28 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2620.31 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2820.31 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 3020.34 MB</span><br><span class="line">-----------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>我们看到 15 次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heapTotal 与 heapUsed 的变化极小，唯一变化的是 rss 的值，并且该值已经远远超过 V8 的限制值。这其中的原因是 Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以也不会有堆内存的大小限制。<br>为何 Buffer 对象并非通过 V8 分配？这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流，操作字符串远远不能满足传输的性能需求。<br>所以从上面的介绍可以得知，Node 的内存构成主要由通过 V8 进行分配的部分和 Node 自行分配的部分。受 V8 的垃圾回收限制的主要是 V8 的堆内存。</p><h3 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h3><p>Node 对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。<br>在 V8 的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。<br>通常，造成内存泄漏的原因有几个：缓存、队列消费不及时与作用域未释放。</p><h4 id="3-1、慎将内存当做缓存"><a href="#3-1、慎将内存当做缓存" class="headerlink" title="3.1、慎将内存当做缓存"></a>3.1、慎将内存当做缓存</h4><p>缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间。<br>但是在 Node 中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。<br>另一个问题在于，JavaScript 开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。<br>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。<br>如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。它的好处多多，在 Node 中主要可以解决两个问题：将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效；进程之间可以共享缓存。<br>目前，市面上较好的缓存有 Redis 和 Memcached。Node 模块的生态系统十分完善，这两个产品的客户端都有。</p><h4 id="3-2、关注队列状态"><a href="#3-2、关注队列状态" class="headerlink" title="3.2、关注队列状态"></a>3.2、关注队列状态</h4><p>有的应用会收集日志，如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而 JavaScript 中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。<br>遇到这种场景，表层的解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。</p><h3 id="四、大内存应用"><a href="#四、大内存应用" class="headerlink" title="四、大内存应用"></a>四、大内存应用</h3><p>在 Node 中，不可避免地还是会存在操作大文件的场景。由于 Node 的内存限制，操作大文件也需要小心，好在 Node 提供了 stream 模块用于处理大文件。<br>stream 模块是 Node 的原生模块，直接引用即可。stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node 中的大多数模块都有 stream 的应用，比如 fs 的 createReadStream() 和 createWriteStream() 方法可以分别用于创建文件的可读流和可写流，process 模块中的 stdin 和 stdout 则分别是可读流和可写流的示例。<br>由于 V8 的内存限制，我们无法通过 fs.readFile() 和 fs.writeFile() 直接进行大文件的操作，而改用 fs.createReadStream() 和 fs.createWriteStream() 方法通过流的方式实现对大文件的操作。下面的代码展示了如何读取一个文件，然后将数据写入到另一个文件的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reader = fs.createReadStream(&apos;in.txt&apos;);</span><br><span class="line">var writer = fs.createWriteStream(&apos;out.txt&apos;);</span><br><span class="line">reader.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">    writer.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">reader.on(&apos;end&apos;, function () &#123;</span><br><span class="line">    writer.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>由于读写模型固定，上述方法有更简洁的方式，具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reader = fs.createReadStream(&apos;in.txt&apos;);</span><br><span class="line">var writer = fs.createWriteStream(&apos;out.txt&apos;);</span><br><span class="line">reader.pipe(writer);</span><br></pre></td></tr></table></figure></p><p>可读流提供了管道方法 pipe()，封装了 data 事件和写入操作。通过流的方式，上述代码不会受到 V8 内存限制的影响，有效地提高了程序的健壮性。<br>如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试进行纯粹的 Buffer 操作，这不会受到 V8 堆内存的限制。但是这种大片使用内存的情况依然要小心，即使 V8 不限制堆内存的大小，物理内存依然有限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Node 的发展，JavaScript 已经实现了 CommonJS 的生态圈大一统的梦想，JavaScript 的应用场景早已不再局限在浏览器中。在那些短时间执行的场景，比如网页应用、命令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务器端的广泛应用，其他语言里存在着的问题在 JavaScript 中也暴露出来了。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用，本文将介绍在 Node 中如何合理高效地使用内存。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之 module</title>
    <link href="http://blog.master-ss.cn/node/module/"/>
    <id>http://blog.master-ss.cn/node/module/</id>
    <published>2019-01-28T03:28:06.307Z</published>
    <updated>2019-01-28T07:16:23.780Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种网页小脚本而已，在 Web 1.0 时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到 Web 2.0 时代，前端工程师利用它大大提升了网页上的用户体验。<br>长长的后天努力过程中，JavaScript 不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了 JavaScript 先天就缺乏的一项功能：模块。经历十多年的发展后，社区也为 JavaScript 制定了相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。<br><a id="more"></a> </p><h3 id="一、模块实现"><a href="#一、模块实现" class="headerlink" title="一、模块实现"></a>一、模块实现</h3><p><img src="/assets/node/commonjs.png"><br>Node 与浏览器以及 W3C 组织、CommonJS 组织、ECMAScript 之间的关系<br>Node 在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。在 Node 中引入模块，需要经历如下 3 个步骤：路径分析、文件定位、编译执行。在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最 快的。</li><li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</li></ul><h3 id="二、优先从缓存加载"><a href="#二、优先从缓存加载" class="headerlink" title="二、优先从缓存加载"></a>二、优先从缓存加载</h3><p>与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。<br>不论是核心模块还是文件模块，require() 方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。</p><h3 id="三、路径分析和文件定位"><a href="#三、路径分析和文件定位" class="headerlink" title="三、路径分析和文件定位"></a>三、路径分析和文件定位</h3><h4 id="3-1、模块标识符分析"><a href="#3-1、模块标识符分析" class="headerlink" title="3.1、模块标识符分析"></a>3.1、模块标识符分析</h4><p>前面提到过，require()方法接受一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为几类：核心模块，如 http、fs、path 等；. 或 .. 开始的相对路径文件模块；以 / 开始的绝对路径文件模块；非路径形式的文件模块，如自定义的 connect 模块。</p><ul><li>核心模块<br>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个 http 用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。</li><li>路径形式的文件模块<br>以 .、.. 和 / 开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require() 方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给 Node 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。</li><li>自定义模块<br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。<br>在介绍自定义模块的查找方式之前，需要先介绍一下模块路径这个概念。<br>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。<ul><li>创建module_path.js文件，其内容为console.log(module.paths);</li><li>将其放到任意一个目录中然后执行node module_path.js<br>在Linux下，你可能得到的是这样一个数组输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;/home/jackson/research/node_modules&apos;,</span><br><span class="line">&apos;/home/jackson/node_modules&apos;,</span><br><span class="line">&apos;/home/node_modules&apos;,</span><br><span class="line">&apos;/node_modules&apos; ]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>而在 Windows 下，也许是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;c:\\nodejs\\node_modules&apos;, &apos;c:\\node_modules&apos; ]</span><br></pre></td></tr></table></figure></p><p>可以看出，模块路径的生成规则如下所示：</p><ul><li>当前文件目录下的node_modules目录</li><li>父目录下的node_modules目录</li><li>父目录的父目录下的node_modules目录</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录</li></ul><p>它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</p><h4 id="3-2、文件定位"><a href="#3-2、文件定位" class="headerlink" title="3.2、文件定位"></a>3.2、文件定位</h4><p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。<br>但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。</p><ul><li>文件扩展名分析<br>require() 在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS 模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 .js、.json、.node 的次序补足扩展名，依次尝试。<br>在尝试的过程中，需要调用 fs 模块同步阻塞式地判断文件是否存在。因为 Node 是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度。</li><li>目录分析和包<br>在分析标识符的过程中，require() 通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当做一个包来处理。<br>在这个过程中，Node 对 CommonJS 包规范进行了一定程度的支持。首先，Node 在当前目录下查找package.json（CommonJS 包规范定义的包描述文件），通过 JSON.parse() 解析出包描述对象，从中取出 main 属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。<br>而如果 main 属性指定的文件名错误，或者压根没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.node、index.json。<br>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li></ul><h3 id="四、模块编译"><a href="#四、模块编译" class="headerlink" title="四、模块编译"></a>四、模块编译</h3><p>在 Node 中，每个文件模块都是一个对象，编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能。对于不同的文件扩展名，其载入方法也有所不同:</p><h4 id="4-1、JavaScript-模块的编译"><a href="#4-1、JavaScript-模块的编译" class="headerlink" title="4.1、JavaScript 模块的编译"></a>4.1、JavaScript 模块的编译</h4><p>回到 CommonJS 模块规范，我们知道每个模块文件中存在着 require、exports、module 这 3 个变量，但是它们在模块文件中并没有定义，那么从何而来呢？<br>事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。一个正常的JavaScript文件会被包装成如下的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    var math = require(&apos;math&apos;);</span><br><span class="line">    exports.area = function (radius) &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过 vm 原生模块的 runInThisContext() 方法执行（类似 eval，只是具有明确上下文，不污染全局），返回一个具体的 function 对象。最后，将当前模块对象的 exports 属性、require() 方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 function() 执行。<br>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。此外，许多初学者都曾经纠结过为何存在 exports 的情况下，还存在 module.exports。其原因在于，exports 对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。</p><h4 id="4-2、C-C-模块的编译"><a href="#4-2、C-C-模块的编译" class="headerlink" title="4.2、C/C++模块的编译"></a>4.2、C/C++模块的编译</h4><p>Node 调用 process.dlopen() 方法进行加载和执行。在 Node 的架构下，dlopen() 方法在 Windows 和<code>*nix</code>平台下分别有不同的实现，通过 libuv 兼容层进行了封装。<br>实际上，.node 的模块文件并不需要编译，因为它是编写 C/C++ 模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的 exports 对象与 .node 模块产生联系，然后返回给调用者。</p><h4 id="4-3、JSON文件的编译"><a href="#4-3、JSON文件的编译" class="headerlink" title="4.3、JSON文件的编译"></a>4.3、JSON文件的编译</h4><p>.json 文件的编译是 3 种编译方式中最简单的。Node 利用 fs 模块同步读取 JSON 文件的内容之后，调用 JSON.parse() 方法得到对象，然后将它赋给模块对象的 exports，以供外部调用。<br>JSON 文件在用作项目的配置文件时比较有用。如果你定义了一个 JSON 文件作为配置，那就不必调用 fs 模块去异步读取和解析，直接调用 require() 引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p><h3 id="五、核心模块及模块调用栈"><a href="#五、核心模块及模块调用栈" class="headerlink" title="五、核心模块及模块调用栈"></a>五、核心模块及模块调用栈</h3><h4 id="5-1、核心模块"><a href="#5-1、核心模块" class="headerlink" title="5.1、核心模块"></a>5.1、核心模块</h4><p>前面提到，Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为 C/C++ 编写的和 JavaScript 编写的两部分，其中 C/C++ 文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。<br>在核心模块中，有些模块全部由 C/C++ 编写，有些模块则由 C/C++ 完成核心部分，其他部分则由 JavaScript 实现包装或向外导出，以满足性能需求。这种 C++ 模块主内完成核心，JavaScript 主外实现封装的模式是 Node 能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能则弱于静态语言。而 Node 的这种复合模式可以在开发速度和性能之间找到平衡点。</p><h4 id="5-2、模块调用栈"><a href="#5-2、模块调用栈" class="headerlink" title="5.2、模块调用栈"></a>5.2、模块调用栈</h4><p>C/C++ 内建模块属于最底层的模块，它属于核心模块，主要提供 API 给 JavaScript 核心模块和第三方 JavaScript 文件模块调用。如果你不是非常了解要调用的 C/C++ 内建模块，请尽量避免通过 process.binding() 方法直接调用，这是不推荐的。<br>JavaScript 核心模块主要扮演的职责有两类：一类是作为 C/C++ 内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。<br><img src="/assets/node/module.png"><br>模块之间的调用关系<br>文件模块通常由第三方编写，包括普通 JavaScript 模块和 C/C++ 扩展模块，主要调用方向为普通 JavaScript 模块调用扩展模块。</p><h3 id="六、包与NPM"><a href="#六、包与NPM" class="headerlink" title="六、包与NPM"></a>六、包与NPM</h3><p>Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块联系起来的一种机制，详情见 <a href="/node/npm">node 之 npm</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种网页小脚本而已，在 Web 1.0 时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到 Web 2.0 时代，前端工程师利用它大大提升了网页上的用户体验。&lt;br&gt;长长的后天努力过程中，JavaScript 不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了 JavaScript 先天就缺乏的一项功能：模块。经历十多年的发展后，社区也为 JavaScript 制定了相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
</feed>
