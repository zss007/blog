<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青松的博客</title>
  
  <subtitle>天行健，君子以自强不息；地势坤，君子以厚德载物。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.master-ss.cn/"/>
  <updated>2019-02-28T08:13:00.531Z</updated>
  <id>http://blog.master-ss.cn/</id>
  
  <author>
    <name>张松松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node 之进程管理</title>
    <link href="http://blog.master-ss.cn/node/process/"/>
    <id>http://blog.master-ss.cn/node/process/</id>
    <published>2019-02-28T02:14:58.904Z</published>
    <updated>2019-02-28T08:13:00.531Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 运行在单个进程的单个线程上，它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高 CPU 的使用率，但是单进程单线程并非完美的结构。如何充分利用多核CPU服务器、如何保证进程的健壮性和稳定性，前者只是利用率不足的问题，后者对于实际产品化带来一定的顾虑，本文关于进程的介绍和讨论将会解决掉这两个问题。<br>Node 自身还有一定的 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 开发者而言是透明的，本文将围绕 JavaScript 部分展开，屏蔽底层细节的讨论。<br><a id="more"></a> </p><h3 id="一、服务模型变迁"><a href="#一、服务模型变迁" class="headerlink" title="一、服务模型变迁"></a>一、服务模型变迁</h3><p>Web 服务器的架构已经历了几次变迁，服务器处理客户端请求的并发量，就是每个里程碑的见证。</p><h4 id="1-1、同步"><a href="#1-1、同步" class="headerlink" title="1.1、同步"></a>1.1、同步</h4><p>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，它的处理能力相当低下，假设每次响应服务耗用的时间稳定为 N 秒，这类服务的 QPS 为 1/N。</p><h4 id="1-2、复制进程"><a href="#1-2、复制进程" class="headerlink" title="1.2、复制进程"></a>1.2、复制进程</h4><p>为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。并把预复制（prefork）被引入服务模型中，即预先复制一定数量的进程，同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽，假设进程数上限为 M，那这类服务的 QPS 为 M/N。</p><h4 id="1-3、多线程"><a href="#1-3、多线程" class="headerlink" title="1.3、多线程"></a>1.3、多线程</h4><p>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性，假设线程所占用的资源为进程的 1/L，受资源上限的影响，它的 QPS 则为 M * L/N。</p><h4 id="1-4、事件驱动"><a href="#1-4、事件驱动" class="headerlink" title="1.4、事件驱动"></a>1.4、事件驱动</h4><p>Apache 就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来。为了解决高并发问题，基于事件驱动的服务模型出现了，像 Node 与 Nginx 均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。<br>基于事件的服务模型存在的问题即是开始时提及的两个问题：CPU 的利用率和进程的健壮性。由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，它的上限决定这类服务模型的性能上限，可伸缩性远比前两者高。</p><h3 id="二、多进程架构"><a href="#二、多进程架构" class="headerlink" title="二、多进程架构"></a>二、多进程架构</h3><p>理想状态下每个进程各自利用一个 CPU，以此实现多核 CPU 的利用。Node 提供了 child_process 模块，并且也提供了 child_process.fork() 函数供我们实现进程的复制。通过 fork() 复制的进程都是一个独立的进程，这个进程中有着独立而全新的 V8 实例。它需要至少 30 毫秒的启动时间和至少 10MB 的内存。尽管 Node 提供了 fork() 供我们复制进程使每个 CPU 内核都使用上，但是依然要切记 fork() 进程是昂贵的。好在 Node 通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将 CPU 资源利用起来。</p><h4 id="2-1、创建子进程"><a href="#2-1、创建子进程" class="headerlink" title="2.1、创建子进程"></a>2.1、创建子进程</h4><p>child_process 模块给予 Node 可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。</p><ul><li>spawn()：启动一个子进程来执行命令；</li><li>exec()：启动一个子进程来执行命令，有回调函数获知子进程的状况；</li><li>execFile()：启动一个子进程来执行可执行文件；</li><li>fork()：与 spawn() 类似，不同点在于它创建 Node 的子进程只需指定要执行的 JavaScript 文件模块即可。</li></ul><p>以一个寻常命令为例，node worker.js 分别用上述 4 种方法实现，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">cp.spawn(&apos;node&apos;, [&apos;worker.js&apos;]);</span><br><span class="line">cp.exec(&apos;node worker.js&apos;, function (err, stdout, stderr) &#123;</span><br><span class="line">// some code</span><br><span class="line">&#125;);</span><br><span class="line">cp.execFile(&apos;worker.js&apos;, function (err, stdout, stderr) &#123;</span><br><span class="line">    // some code</span><br><span class="line">&#125;);</span><br><span class="line">cp.fork(&apos;./worker.js&apos;);</span><br></pre></td></tr></table></figure></p><p>以上4个方法在创建子进程之后均会返回子进程对象。它们的差别可以通过表9-1查看：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">回调/异常</th><th style="text-align:center">进程类型</th><th style="text-align:center">执行类型</th><th style="text-align:center">可设置超时</th></tr></thead><tbody><tr><td style="text-align:center">spawn()</td><td style="text-align:center">N</td><td style="text-align:center">任意</td><td style="text-align:center">命令</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">exec()</td><td style="text-align:center">Y</td><td style="text-align:center">任意</td><td style="text-align:center">命令</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">execFile()</td><td style="text-align:center">Y</td><td style="text-align:center">任意</td><td style="text-align:center">可执行文件</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">fork()</td><td style="text-align:center">N</td><td style="text-align:center">Node</td><td style="text-align:center">JavaScript文件</td><td style="text-align:center">N</td></tr></tbody></table><p>这里的可执行文件是指可以直接执行的文件，如果是 JavaScript 文件通过 execFile() 运行，它的首行内容必须添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br></pre></td></tr></table></figure></p><p>尽管4种创建子进程的方式有些差别，但事实上后面 3 种方法都是 spawn() 的延伸应用。</p><h4 id="2-2、进程间通信"><a href="#2-2、进程间通信" class="headerlink" title="2.2、进程间通信"></a>2.2、进程间通信</h4><p>在前端浏览器中，JavaScript 主线程与 UI 渲染共用同一个线程。执行 JavaScript 的时候 UI 渲染是停滞的，渲染 UI 时，JavaScript 是停滞的，两者互相阻塞。长时间执行 JavaScript 将会造成 UI 停顿不响应。为了解决这个问题，HTML5 提出了 WebWorker API。WebWorker 允许创建工作线程并在后台运行，使得一些阻塞较为严重的计算不影响主线程上的 UI 渲染。<br>而 Node 在 Master-Worker 模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于 child_process 模块，创建好了子进程，然后与父子进程间通信是十分容易的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// parent.js</span><br><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var n = cp.fork(__dirname + &apos;/sub.js&apos;);</span><br><span class="line">n.on(&apos;message&apos;, function (m) &#123;</span><br><span class="line">    console.log(&apos;PARENT got message:&apos;, m);</span><br><span class="line">&#125;);</span><br><span class="line">n.send(&#123; hello: &apos;world&apos; &#125;);</span><br><span class="line">// sub.js</span><br><span class="line">process.on(&apos;message&apos;, function (m) &#123;</span><br><span class="line">    console.log(&apos;CHILD got message:&apos;, m);</span><br><span class="line">&#125;);</span><br><span class="line">process.send(&#123;foo: &apos;bar&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>通过 fork() 或者其他 API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建 IPC 通道。通过 IPC 通道，父子进程之间才能通过 message 和 send() 传递消息。注意，process.send 用来给父进程发送消息，只有子进程才存在。</p><h4 id="2-3、进程间通信原理"><a href="#2-3、进程间通信原理" class="headerlink" title="2.3、进程间通信原理"></a>2.3、进程间通信原理</h4><p>IPC 的全称是 Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket 等。Node 中实现 IPC 通道的是管道（pipe）技术。但此管道非彼管道，在 Node 中管道是个抽象层面的称呼，具体细节实现由 libuv 提供，在 Windows 下由命名管道（named pipe）实现，*nix 系统则采用 Unix Domain Socket 实现。表现在应用层上的进程间通信只有简单的 message 事件和 send() 方法，接口十分简洁和消息化，如下为 IPC 创建和实现的示意图。<br><img src="/assets/node/process.png"><br>父进程在实际创建子进程之前，会创建 IPC 通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道，从而完成父子进程之间的连接，如下为创建 IPC 管道的步骤示意图。<br><img src="/assets/node/process2.png"><br>建立连接之后的父子进程就可以自由地通信了。由于 IPC 通道是用命名管道或 Domain Socket 创建的，它们与网络 socket 的行为比较类似，属于双向通信。不同的是它们在系统内核中就完成了进程间的通信，而不用经过实际的网络层，非常高效。在 Node 中，IPC 通道被抽象为 Stream 对象，在调用 send() 时发送数据（类似于 write()），接收到的消息会通过 message 事件（类似于 data）触发给应用层。<br>注意，只有启动的子进程是 Node 进程时，子进程才会根据环境变量去连接 IPC 通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的 IPC 通道。</p><h4 id="2-4、句柄传递"><a href="#2-4、句柄传递" class="headerlink" title="2.4、句柄传递"></a>2.4、句柄传递</h4><p>建立好进程之间的 IPC 后，将启动的服务器分别监听各自的端口么，如果让服务都监听到相同的端口，将会有什么样的结果？示例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// master.js</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;Hello World\n&apos;);</span><br><span class="line">&#125;).listen(8888, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure></p><p>再次启动 master.js 文件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE 127.0.0.1:8888</span><br></pre></td></tr></table></figure></p><p>这时只有一个工作进程能够监听到该端口上，其余的进程在监听的过程中都抛出了 EADDRINUSE 异常，这是端口被占用的情况，新的进程不能继续监听该端口了。这个问题破坏了我们将多个进程监听同一个端口的想法。要解决这个问题，通常的做法是让每个进程监听不同的端口，其中主进程监听主端口（如 80），主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上，如下图所示。<br><img src="/assets/node/process3.png"><br>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了系统的扩展能力。<br>为了解决上述这样的问题，Node 在版本 v0.5.9 引入了进程间发送句柄的功能。send() 方法除了能通过 IPC 发送数据外，还能发送句柄，第二个可选参数就是句柄，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.send(message, [sendHandle])</span><br></pre></td></tr></table></figure></p><p>那什么是句柄？句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端 socket 对象、一个客户端 socket 对象、一个 UDP 套接字、一个管道等。<br>发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到 socket 请求后，将这个 socket 直接发送给工作进程，而不是重新与工作进程之间建立新的 socket 连接来转发数据。文件描述符浪费的问题可以通过这样的方式轻松解决。来看看我们的示例代码。<br>主进程代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var child1 = cp.fork(&apos;child.js&apos;);</span><br><span class="line">var child2 = cp.fork(&apos;child.js&apos;);</span><br><span class="line"></span><br><span class="line">// Open up the server object and send the handle</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line">server.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">    socket.end(&apos;handled by parent\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8001, function () &#123;</span><br><span class="line">    child1.send(&apos;server&apos;, server);</span><br><span class="line">    child2.send(&apos;server&apos;, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>子进程代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;message&apos;, function (m, server) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        server.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            socket.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个示例中直接将一个 TCP 服务器发送给了子进程。这是看起来不可思议的事情，我们先来测试一番，看看效果如何，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 先启动服务器</span><br><span class="line">$ node parent.js</span><br></pre></td></tr></table></figure></p><p>然后新开一个命令行窗口，用上 curl 工具，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27418</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27419</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27419</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by parent</span><br></pre></td></tr></table></figure></p><p>命令行中的响应结果也是很不可思议的，这里子进程和父进程都有可能处理我们客户端发起的请求。这是在 TCP 层面上完成的事情，我们尝试将其转化到 HTTP 层面来试试。对于主进程而言，我们甚至想要它更轻量一点，那么是否将服务器句柄发送给子进程之后，就可以关掉服务器的监听，让子进程来处理请求呢？<br>对主进程进行改动，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// parent.js</span><br><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var child1 = cp.fork(&apos;child.js&apos;);</span><br><span class="line">var child2 = cp.fork(&apos;child.js&apos;);</span><br><span class="line"></span><br><span class="line">// Open up the server object and send the handle</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line"></span><br><span class="line">server.listen(8001, function () &#123;</span><br><span class="line">    child1.send(&apos;server&apos;, server);</span><br><span class="line">    child2.send(&apos;server&apos;, server);</span><br><span class="line"></span><br><span class="line">    server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后对子进程进行改动，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&apos;message&apos;, function (m, tcp) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        tcp.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            server.emit(&apos;connection&apos;, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>重新启动 parent.js 后，再次测试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27882</span><br><span class="line">$ curl &quot;http://127.0.0.1:8001&quot;</span><br><span class="line">handled by child, pid is 27883</span><br></pre></td></tr></table></figure></p><p>这样一来，所有的请求都是由子进程处理了。整个过程中，服务的过程发生了一次改变，如下图所示。<br><img src="/assets/node/process4.png"><br>主进程发送完句柄并关闭监听之后，成为了如下图所示的结构。<br><img src="/assets/node/process5.png"><br>我们神奇地发现，多个子进程可以同时监听相同端口，再没有 EADDRINUSE 异常发生了。</p><h4 id="2-5、句柄发送与还原"><a href="#2-5、句柄发送与还原" class="headerlink" title="2.5、句柄发送与还原"></a>2.5、句柄发送与还原</h4><p>上文介绍的虽然是句柄发送，但是仔细看看，句柄发送跟我们直接将服务器对象发送给子进程有没有差别？它是否真的将服务器对象发送给了子进程？为什么它可以发送到多个子进程中？发送给子进程为什么父进程中还存在这个对象？<br>目前子进程对象 send() 方法可以发送的句柄类型包括如下几种。</p><ul><li>net.Socket。TCP 套接字。</li><li>net.Server。TCP 服务器，任意建立在 TCP 服务上的应用层服务都可以享受到它带来的好处。</li><li>net.Native。C++ 层面的 TCP 套接字或 IPC 管道。</li><li>dgram.Socket。UDP 套接字。</li><li>dgram.Native。C++ 层面的 UDP 套接字。</li></ul><p>send() 方法在将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message。message 参数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cmd: &apos;NODE_HANDLE&apos;, type: &apos;net.Server&apos;, msg: message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送到 IPC 管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个 message 对象在写入到 IPC 管道时也会通过 JSON.stringify() 进行序列化。所以最终发送到 IPC 通道中的信息都是字符串，send() 方法能发送消息和句柄并不意味着它能发送任意对象。<br>连接了 IPC 通道的子进程可以读取到父进程发来的消息，将字符串通过 JSON.parse() 解析还原为对象后，才触发 message 事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd 的值如果以 NODE_ 为前缀，它将响应一个内部事件 internalMessage。如果 message.cmd 值为 NODE_HANDLE，它将取出 message.type 值和得到的文件描述符一起还原出一个对应的对象。<br>以发送的 TCP 服务器句柄为例，子进程收到消息后的还原过程如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(message, handle, emit) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var server = new net.Server();</span><br><span class="line">    server.listen(handle, function () &#123;</span><br><span class="line">        emit(server);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，子进程根据 message.type 创建对应 TCP 服务器对象，然后监听到文件描述符上。由于底层细节不被应用层感知，所以在子进程中，开发者会有一种服务器就是从父进程中直接传递过来的错觉。值得注意的是，Node 进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果。<br>目前 Node 只支持上述提到的几种句柄，并非任意类型的句柄都能在进程之间传递，除非它有完整的发送和还原的过程。</p><h4 id="2-4、端口共同监听"><a href="#2-4、端口共同监听" class="headerlink" title="2.4、端口共同监听"></a>2.4、端口共同监听</h4><p>在了解了句柄传递背后的原理后，我们继续探究为何通过发送句柄后，多个进程可以监听到相同的端口而不引起 EADDRINUSE 异常。其答案也很简单，我们独立启动的进程中，TCP 服务器端 socket 套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。<br>Node 底层对每个端口监听都设置了 SO_REUSEADDR 选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(tcp-&gt;io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))</span><br></pre></td></tr></table></figure></p><p>由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于 send() 发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。<br>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的。</p><h3 id="三、集群稳定之路"><a href="#三、集群稳定之路" class="headerlink" title="三、集群稳定之路"></a>三、集群稳定之路</h3><p>搭建好了集群，充分利用了多核 CPU 资源，似乎就可以迎接客户端大量的请求了。但是我们还有一些细节需要考虑，性能问题、多个工作进程的存活状态管理、工作进程的平滑重启、配置或者静态数据的动态重新载入、其他细节。<br>虽然我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，它的稳定性还不能得到完全的保障。我们需要建立起一个健全的机制来保障 Node 应用的健壮性。</p><h4 id="3-1、进程事件"><a href="#3-1、进程事件" class="headerlink" title="3.1、进程事件"></a>3.1、进程事件</h4><p>再次回归到子进程对象上，除了引人关注的 send() 方法和 message 事件外，子进程还有些什么呢？首先除了 message 事件外，Node 还有如下这些事件。</p><ul><li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。</li><li>exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为 null。如果进程是通过 kill() 方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。</li><li>close：在子进程的标准输入输出流中止时触发该事件，参数与 exit 相同。</li><li>disconnect：在父进程或子进程中调用 disconnect() 方法时触发该事件，在调用该方法时将关闭监听 IPC 通道。</li></ul><p>上述这些事件是父进程能监听到的与子进程相关的事件。除了 send() 外，还能通过 kill() 方法给子进程发送消息。kill() 方法并不能真正地将通过 IPC 相连的子进程杀死，它只是给子进程发送了一个系统信号。默认情况下，父进程将通过 kill() 方法给子进程发送一个 SIGTERM 信号。它与进程默认的 kill() 方法类似，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 子进程</span><br><span class="line">child.kill([signal]);</span><br><span class="line">// 当前进程</span><br><span class="line">process.kill(pid, [signal]);</span><br></pre></td></tr></table></figure></p><p>它们一个发给子进程，一个发给目标进程。在 POSIX 标准中，有一套完备的信号系统，在命令行中执行 kill -l 可以看到详细的信号列表，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL</span><br><span class="line"> 5) SIGTRAP 6) SIGABRT 7) SIGEMT 8) SIGFPE</span><br><span class="line"> 9) SIGKILL10) SIGBUS11) SIGSEGV12) SIGSYS</span><br><span class="line">13) SIGPIPE14) SIGALRM15) SIGTERM16) SIGURG</span><br><span class="line">17) SIGSTOP18) SIGTSTP19) SIGCONT20) SIGCHLD</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGIO24) SIGXCPU</span><br><span class="line">25) SIGXFSZ26) SIGVTALRM27) SIGPROF28) SIGWINCH</span><br><span class="line">29) SIGINFO30) SIGUSR131) SIGUSR2</span><br></pre></td></tr></table></figure></p><p>Node 提供了这些信号对应的信号事件，每个进程都可以监听这些信号事件。这些信号事件是用来通知进程的，每个信号事件有不同的含义，进程在收到响应信号时，应当做出约定的行为，如SIGTERM是软件终止信号，进程收到该信号时应当退出。示例代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</span><br><span class="line">    console.log(&apos;Got a SIGTERM, exiting...&apos;);</span><br><span class="line">    process.exit(1);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;server running with PID:&apos;, process.pid);</span><br><span class="line">process.kill(process.pid, &apos;SIGTERM&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="3-2、自动重启"><a href="#3-2、自动重启" class="headerlink" title="3.2、自动重启"></a>3.2、自动重启</h4><p>有了父子进程之间的相关事件之后，就可以在这些关系之间创建出需要的机制了。至少能够通过监听子进程的 exit 事件来获知其退出的信息，在主进程上要加入一些子进程管理的机制，比如重新启动一个工作进程来继续服务。<br>实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// master.js</span><br><span class="line">var fork = require(&apos;child_process&apos;).fork;</span><br><span class="line">var cpus = require(&apos;os&apos;).cpus();</span><br><span class="line">var server = require(&apos;net&apos;).createServer();</span><br><span class="line">server.listen(1337);</span><br><span class="line">var workers = &#123;&#125;;</span><br><span class="line">var createWorker = function () &#123;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    // 退出时重新启动新的进程</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">        createWorker();</span><br><span class="line">    &#125;);</span><br><span class="line">    // 句柄转发</span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br><span class="line">for (var i = 0; i &lt; cpus.length; i++) &#123;</span><br><span class="line">    createWorker();</span><br><span class="line">&#125;</span><br><span class="line">// 进程自己退出时，让所有工作进程退出 </span><br><span class="line">process.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">    for (var pid in workers) &#123;</span><br><span class="line">        workers[pid].kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>测试一下上面的代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node master.js</span><br><span class="line">Create worker. pid: 28939</span><br><span class="line">Create worker. pid: 28940</span><br><span class="line">Create worker. pid: 28941</span><br><span class="line">Create worker. pid: 28942</span><br><span class="line">Create worker. pid: 28943</span><br><span class="line">Create worker. pid: 28944</span><br><span class="line">Create worker. pid: 28945</span><br><span class="line">Create worker. pid: 28946</span><br></pre></td></tr></table></figure></p><p>通过 kill 命令杀死某个进程试试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill 28939</span><br></pre></td></tr></table></figure></p><p>结果是 28939 进程退出后，自动启动了一个新的工作进程 28959，总体进程数量并没有发生改变，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker 28939 exited.</span><br><span class="line">Create worker. pid: 28959</span><br></pre></td></tr></table></figure></p><p>在这个场景中我们主动杀死了一个进程，在实际业务中，可能有隐藏的 bug 导致工作进程退出，那么我们需要仔细地处理这种异常，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// worker.js </span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var worker;</span><br><span class="line">process.on(&apos;message&apos;, function (m, tcp) &#123;</span><br><span class="line">    if (m === &apos;server&apos;) &#123;</span><br><span class="line">        worker = tcp;</span><br><span class="line">        worker.on(&apos;connection&apos;, function (socket) &#123;</span><br><span class="line">            server.emit(&apos;connection&apos;, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&apos;uncaughtException&apos;, function () &#123;</span><br><span class="line">    // 停止接收新的连接  </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程  </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述代码的处理流程是，一旦有未捕获的异常出现，工作进程就会立即停止接收新的连接；当所有连接断开后，退出进程。主进程在侦听到工作进程的 exit 后，将会立即启动新的进程服务，以此保证整个集群中总是有进程在为用户服务的。</p><h4 id="3-3、自杀信号"><a href="#3-3、自杀信号" class="headerlink" title="3.3、自杀信号"></a>3.3、自杀信号</h4><p>当然上述代码存在的问题是要等到已有的所有连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，全处在等待退出的状态。但在等到进程完全退出才重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，这会丢掉大部分请求。<br>为此需要改进这个过程，不能等到工作进程退出后才重启新的工作进程。当然也不能暴力退出进程，因为这样会导致已连接的用户直接断开。于是在退出的流程中增加一个自杀（suicide）信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。代码改动如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// worker.js </span><br><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接   </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程 </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>主进程将重启工作进程的任务，从 exit 事件的处理函数中转移到 message 事件的处理函数中，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var createWorker = function () &#123;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    // 启动新的进程   </span><br><span class="line">    worker.on(&apos;message&apos;, function (message) &#123;</span><br><span class="line">        if (message.act === &apos;suicide&apos;) &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">    &#125;);</span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了模拟未捕获的异常，我们将工作进程的处理代码改为抛出异常，一旦有用户请求，就会有一个可怜的工作进程退出，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var server = http.createServer(function (req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">    res.end(&apos;handled by child, pid is &apos; + process.pid + &apos;\n&apos;);</span><br><span class="line">    throw new Error(&apos;throw exception&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后启动所有进程，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ node master.js</span><br><span class="line">Create worker. pid: 29428</span><br><span class="line">Create worker. pid: 29429</span><br><span class="line">Create worker. pid: 29430</span><br><span class="line">Create worker. pid: 29431</span><br><span class="line">Create worker. pid: 29432</span><br><span class="line">Create worker. pid: 29433</span><br><span class="line">Create worker. pid: 29434</span><br><span class="line">Create worker. pid: 29435</span><br></pre></td></tr></table></figure></p><p>用curl工具测试效果，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:8001</span><br><span class="line">handled by child, pid is 29433</span><br></pre></td></tr></table></figure></p><p>再回头看重启信息，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Create worker. pid: 29472</span><br><span class="line">Worker 29462 exited.</span><br></pre></td></tr></table></figure></p><p>与前一种方案相比，创建新工作进程在前，退出异常进程在后。在这个可怜的异常进程退出之前，总是有新的工作进程来替上它的岗位。至此我们完成了进程的平滑重启，一旦有异常出现，主进程会创建新的工作进程来为用户服务，旧的进程一旦处理完已有连接就自动断开。整个过程使得我们的应用的稳定性和健壮性大大提高。<br>这里存在问题的是有可能我们的连接是长连接，不是 HTTP 服务的这种短连接，等待长连接断开可能需要较久的时间。为此为已有连接的断开设置一个超时时间是必要的，在限定时间里强制退出的设置如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接</span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程   </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 5秒后退出进程 </span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;, 5000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>进程中如果出现未能捕获的异常，就意味着有那么一段代码在健壮性上是不合格的。为此退出进程前，通过日志记录下问题所在是必须要做的事情，它可以帮我们很好地定位和追踪代码异常出现的位置，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</span><br><span class="line">    // 记录日志  </span><br><span class="line">    logger.error(err);</span><br><span class="line">    // 发送自杀信号   </span><br><span class="line">    process.send(&#123; act: &apos;suicide&apos; &#125;);</span><br><span class="line">    // 停止接收新的连接  </span><br><span class="line">    worker.close(function () &#123;</span><br><span class="line">        // 所有已有连接断开后，退出进程    </span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 5秒后退出进程 </span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        process.exit(1);</span><br><span class="line">    &#125;, 5000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="3-4、限量重启"><a href="#3-4、限量重启" class="headerlink" title="3.4、限量重启"></a>3.4、限量重启</h4><p>通过自杀信号告知主进程可以使得新连接总是有进程服务，但是依然还是有极端的情况。工作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误，会导致工作进程被频繁重启，这种频繁重启不属于我们捕捉未知异常的情况，因为这种短时间内频繁重启已经不符合预期的设置，极有可能是程序编写的错误。<br>为了消除这种无意义的重启，在满足一定规则的限制下，不应当反复重启。比如在单位时间内规定只能重启多少次，超过限制就触发 giveup 事件，告知放弃重启工作进程这个重要事件。<br>为了完成限量重启的统计，我们引入一个队列来做标记，在每次重启工作进程之间进行打点并判断重启是否太过频繁，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 重启次数 </span><br><span class="line">var limit = 10;</span><br><span class="line">// 时间单位 </span><br><span class="line">var during = 60000;</span><br><span class="line">var restart = [];</span><br><span class="line">var isTooFrequently = function () &#123;</span><br><span class="line">    // 记录重启时间   </span><br><span class="line">    var time = Date.now();</span><br><span class="line">    var length = restart.push(time);</span><br><span class="line">    if (length &gt; limit) &#123;</span><br><span class="line">        // 取出最后 10 个记录     </span><br><span class="line">        restart = restart.slice(limit * -1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后一次重启到前 10 次重启之间的时间间隔  </span><br><span class="line">    return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during;</span><br><span class="line">&#125;;</span><br><span class="line">var workers = &#123;&#125;;</span><br><span class="line">var createWorker = function () &#123;</span><br><span class="line">    // 检查是否太过频繁  </span><br><span class="line">    if (isTooFrequently()) &#123;</span><br><span class="line">        // 触发 giveup 事件后，不再重启  </span><br><span class="line">        process.emit(&apos;giveup&apos;, length, during);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var worker = fork(__dirname + &apos;/worker.js&apos;);</span><br><span class="line">    worker.on(&apos;exit&apos;, function () &#123;</span><br><span class="line">        console.log(&apos;Worker &apos; + worker.pid + &apos; exited.&apos;);</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">    &#125;);</span><br><span class="line">    // 重新启动新的进程   </span><br><span class="line">    worker.on(&apos;message&apos;, function (message) &#123;</span><br><span class="line">        if (message.act === &apos;suicide&apos;) &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 句柄转发   </span><br><span class="line">    worker.send(&apos;server&apos;, server);</span><br><span class="line">    workers[worker.pid] = worker;</span><br><span class="line">    console.log(&apos;Create worker. pid: &apos; + worker.pid);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>giveup 事件是比 uncaughtException 更严重的异常事件。uncaughtException 只代表集群中某个工作进程退出，在整体性保证下，不会出现用户得不到服务的情况，但是这个 giveup 事件则表示集群中没有任何进程服务了，十分危险。为了健壮性考虑，我们应在 giveup 事件中添加重要日志，并让监控系统监视到这个严重错误，进而报警等。</p><h4 id="3-5、负载均衡"><a href="#3-5、负载均衡" class="headerlink" title="3.5、负载均衡"></a>3.5、负载均衡</h4><p>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将 CPU 资源都调用起来。这犹如饭店将客人的点单分发给多个厨师进行餐点制作，这种保证多个处理单元工作量公平的策略叫负载均衡。<br>Node 默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。<br>一般而言，这种抢占式策略对大家是公平的，各个进程可以根据自己的繁忙度来进行抢占。但是对于 Node 而言，需要分清的是它的繁忙是由 CPU、I/O 两个部分构成的，影响抢占的是 CPU 的繁忙度。对不同的业务，可能存在 I/O 繁忙，而 CPU 较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况。<br>为此 Node 在 v0.11 中提供了一种新的策略使得负载均衡更合理，这种新的策略叫 Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在 N 个工作进程中，每次选择第 i = (i + 1) mod n 个进程来发送连接。在 cluster 模块中启用它的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 启用 Round-Robin  </span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_RR</span><br><span class="line">// 不启用 Round-Robin</span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure></p><p>或者在环境变量中设置 NODE_CLUSTER_SCHED_POLICY 的值，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_CLUSTER_SCHED_POLICY = rr </span><br><span class="line">export NODE_CLUSTER_SCHED_POLICY = none</span><br></pre></td></tr></table></figure></p><p>Round-Robin 非常简单，可以避免 CPU 和 I/O 繁忙差异导致的负载不均衡。Round-Robin 策略也可以通过代理服务器来实现，但是它会导致服务器上消耗的文件描述符是平常方式的两倍。</p><h4 id="3-6、状态共享"><a href="#3-6、状态共享" class="headerlink" title="3.6、状态共享"></a>3.6、状态共享</h4><p>在 Node 进程中不宜存放太多数据，因为它会加重垃圾回收的负担，进而影响性能。同时，Node 也不允许在多个进程之间共享数据。但在实际的业务中，往往需要共享一些数据，譬如配置数据，这在多个进程中应当是一致的。为此，在不允许共享数据的情况下，我们需要一种方案和机制来实现数据在多个进程之间的共享。</p><ul><li>第三方数据存储<br>解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如Redis）中，所有工作进程启动时将其读取进内存中。但这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。<br>实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询。<br>定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟。</li><li>主动通知<br>一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。为了不混合业务逻辑，可以将这个进程设计为只进行轮询和通知，不处理任何业务逻辑。<br>这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用 TCP 或 UDP 的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。由于不涉及太多进程去向同一地方进行状态查询，状态响应处的压力不至于太过巨大，单一的通知服务轮询带来的压力并不大，所以可以将轮询时间调整得较短，一旦发现更新，就能实时地推送到各个子进程中。</li></ul><h3 id="四、Cluster-模块"><a href="#四、Cluster-模块" class="headerlink" title="四、Cluster 模块"></a>四、Cluster 模块</h3><p>Node v0.8 时直接引入了 cluster 模块，用以解决多核 CPU 的利用率问题，同时也提供了较完善的 API，用以处理进程的健壮性问题，cluster 实现创建 Node 进程集群也是很轻松的事情，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// cluster.js</span><br><span class="line">var cluster = require(&apos;cluster&apos;);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">    exec: &quot;./worker.js&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var cpus = require(&apos;os&apos;).cpus(), works = [];</span><br><span class="line">for (var i = 0; i &lt; cpus.length; i++) &#123;</span><br><span class="line">    works[i] = cluster.fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行 node cluster.js 将会得到与前文创建子进程集群的效果相同。就官方的文档而言，它更喜欢如下的形式作为示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var cluster = require(&apos;cluster&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var numCPUs = require(&apos;os&apos;).cpus().length;</span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">    // Fork workers  </span><br><span class="line">    for (var i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.on(&apos;exit&apos;, function (worker, code, signal) &#123;</span><br><span class="line">        console.log(&apos;worker &apos; + worker.process.pid + &apos; died&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Workers can share any TCP connection  </span><br><span class="line">    // In this case its a HTTP server   </span><br><span class="line">    http.createServer(function (req, res) &#123;</span><br><span class="line">        res.writeHead(200);</span><br><span class="line">        res.end(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;).listen(8000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有 NODE_UNIQUE_ID，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster.isWorker = (&apos;NODE_UNIQUE_ID&apos; in process.env);</span><br><span class="line">cluster.isMaster = (cluster.isWorker === false);</span><br></pre></td></tr></table></figure></p><p>但是官方示例中忽而判断 cluster.isMaster、忽而判断 cluster.isWorker，对于代码的可读性十分差。建议用 cluster.setupMaster() 这个 API，将主进程和工作进程从代码上完全剥离，如同 send() 方法看起来直接将服务器从主进程发送到子进程那样神奇，剥离代码之后，甚至都感觉不到主进程中有任何服务器相关的代码。<br>通过 cluster.setupMaster() 创建子进程而不是使用 cluster.fork()，程序结构不再凌乱，逻辑分明，代码的可读性和可维护性较好。</p><h4 id="4-1、Cluster-工作原理"><a href="#4-1、Cluster-工作原理" class="headerlink" title="4.1、Cluster 工作原理"></a>4.1、Cluster 工作原理</h4><p>事实上 cluster 模块就是 child_process 和 net 模块的组合应用。cluster 启动时，会在内部启动 TCP 服务器，在 cluster.fork() 子进程时，将这个 TCP 服务器端 socket 的文件描述符发送给工作进程。如果进程是通过 cluster.fork() 复制出来的，那么它的环境变量里就存在 NODE_UNIQUE_ID，如果工作进程中存在 listen() 侦听网络端口的调用，它将拿到该文件描述符，通过 SO_REUSEADDR 端口重用，从而实现多个子进程共享端口。对于普通方式启动的进程，则不存在文件描述符传递共享等事情。<br>在 cluster 内部隐式创建 TCP 服务器的方式对使用者来说十分透明，但也正是这种方式使得它无法如直接使用 child_process 那样灵活。在 cluster 模块应用中，一个主进程只能管理一组工作进程。<br>对于自行通过 child_process 来操作时，则可以更灵活地控制工作进程，甚至控制多组工作进程。其原因在于自行通过 child_process 操作子进程时，可以隐式地创建多个 TCP 服务器，使得子进程可以共享多个的服务器端 socket。</p><h4 id="4-2、Cluster事件"><a href="#4-2、Cluster事件" class="headerlink" title="4.2、Cluster事件"></a>4.2、Cluster事件</h4><p>对于健壮性处理，cluster 模块也暴露了相当多的事件。</p><ul><li>fork：复制一个工作进程后触发该事件。</li><li>online：复制好一个工作进程后，工作进程主动发送一条 online 消息给主进程，主进程收到消息后，触发该事件。</li><li>listening：工作进程中调用 listen() 后，发送一条 listening 消息给主进程，主进程收到消息后，触发该事件。</li><li>disconnect：主进程和工作进程之间 IPC 通道断开后会触发该事件。</li><li>exit：有工作进程退出时触发该事件。</li><li>setup：cluster.setupMaster() 执行后触发该事件。</li></ul><p>这些事件大多跟 child_process 模块的事件相关，在进程间消息传递的基础上完成的封装。这些事件对于增强应用的健壮性已经足够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 运行在单个进程的单个线程上，它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高 CPU 的使用率，但是单进程单线程并非完美的结构。如何充分利用多核CPU服务器、如何保证进程的健壮性和稳定性，前者只是利用率不足的问题，后者对于实际产品化带来一定的顾虑，本文关于进程的介绍和讨论将会解决掉这两个问题。&lt;br&gt;Node 自身还有一定的 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 开发者而言是透明的，本文将围绕 JavaScript 部分展开，屏蔽底层细节的讨论。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>nvm 简介</title>
    <link href="http://blog.master-ss.cn/node/nvm/"/>
    <id>http://blog.master-ss.cn/node/nvm/</id>
    <published>2019-02-20T09:11:22.098Z</published>
    <updated>2019-02-26T03:04:41.357Z</updated>
    
    <content type="html"><![CDATA[<p>前不久有个旧项目需要低版本的 node 才能跑起来，但是新项目又需要新版本，还好有个工具叫 nvm 能够切换不同版本的 node。<br><a id="more"></a> </p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><h4 id="1-1、mac-或-linux"><a href="#1-1、mac-或-linux" class="headerlink" title="1.1、mac 或 linux"></a>1.1、mac 或 linux</h4><p>安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/cnpm/nvm/master/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功，当出现 “Node Version Manager” 时，说明已安装成功。</p><h4 id="1-2、windows"><a href="#1-2、windows" class="headerlink" title="1.2、windows"></a>1.2、windows</h4><p>nvm-windows 最新下载地址 <code>https://github.com/coreybutler/nvm-windows/releases</code>，这里有四个可下载的文件：</p><ul><li>nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置</li><li>nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便</li><li>Source code(zip)：zip 压缩的源码</li><li>Sourc code(tar.gz)：tar.gz 的源码，一般用于 *nix 系统</li></ul><h3 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h3><ul><li>nvm install <version>：可以是 node.js 版本或最新稳定版本 latest</version></li><li>nvm list：列出已经安装的 node.js 版本</li><li>nvm uninstall <version>：卸载指定版本的 nodejs</version></li><li>nvm use [version]：切换到使用指定的 nodejs 版本</li><li>nvm –version：显示当前运行的 nvm 版本</li></ul><h3 id="三、不同版本的-Nodejs-共享全局的-npm"><a href="#三、不同版本的-Nodejs-共享全局的-npm" class="headerlink" title="三、不同版本的 Nodejs 共享全局的 npm"></a>三、不同版本的 Nodejs 共享全局的 npm</h3><p>用 nvm 管理 node 版本，会碰到这样一个问题：对于各个版本的全局 npm 模块，是各自独立的。因此，当你在 6.16.0 下全局安装了某个模块，然后切换到 8.14.1 之后又得重新安装。所以，解法就是 npm prefix：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前的 prefix</span><br><span class="line">npm config get prefix   // ~/.nvm/versions/node/v8.14.1</span><br><span class="line"></span><br><span class="line">// 将 prefix 设置到一个全局目录下，比如新建一个 /Users/songsong.zhang/npm-global, 这个文件不要放在需要 sudo 的文件夹下</span><br><span class="line">npm config set prefix /Users/songsong.zhang/npm-global</span><br></pre></td></tr></table></figure></p><p>设置之后，再用 npm 安装全局模块时就会放在 npm-global 下，注意 npm/cnpm 的 prefix 是各自独立的，因此每个都需要设置一下。<br>然后呢，全局模块的可执行文件也会放在 npm-global/bin 目录下，想要执行这些命令的话，还需要添加一条 PATH，打开 .bashrc，末尾添加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/Users/songsong.zhang/npm-global/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>如果是 windows 的话，则需要配置环境变量。</p><h3 id="四、使用-nvmrc-文件"><a href="#四、使用-nvmrc-文件" class="headerlink" title="四、使用 .nvmrc 文件"></a>四、使用 .nvmrc 文件</h3><p>如果你的 node 版本与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat .nvmrc</span><br><span class="line">// 6.16.0</span><br><span class="line"></span><br><span class="line">nvm use</span><br><span class="line">// Found &apos;/Users/songsong.zhang/study/es6test/.nvmrc&apos; with version &lt;6.16.0&gt;</span><br><span class="line">// Now using node v6.16.0 (npm v3.10.10)</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">// v6.16.0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久有个旧项目需要低版本的 node 才能跑起来，但是新项目又需要新版本，还好有个工具叫 nvm 能够切换不同版本的 node。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之文件路径</title>
    <link href="http://blog.master-ss.cn/node/path/"/>
    <id>http://blog.master-ss.cn/node/path/</id>
    <published>2019-02-20T07:58:36.239Z</published>
    <updated>2019-02-20T08:42:34.453Z</updated>
    
    <content type="html"><![CDATA[<p>node 有好几种表达文件路径的方式，但是他们之间有细微的区别，很容易搞混，现在梳理一遍。<br><a id="more"></a> </p><h3 id="一、文件路径"><a href="#一、文件路径" class="headerlink" title="一、文件路径"></a>一、文件路径</h3><p>Node 中的文件路径大概有 <code>__dirname</code>, <code>__filename</code>, <code>process.cwd()</code>, <code>./</code> 或者 <code>../</code>，前三个都是绝对路径，为了便于比较，<code>./</code> 和 <code>../</code> 我们通过 <code>path.resolve(&#39;./&#39;)</code>来转换为绝对路径。</p><h4 id="1-1、-dirname"><a href="#1-1、-dirname" class="headerlink" title="1.1、__dirname"></a>1.1、__dirname</h4><p>当前模块的目录名，与 <code>__filename</code> 的 <code>path.dirname()</code> 相同。<br>示例，从 /Users/songsong.zhang/study/es6test/path 运行 node example.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(__dirname);</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">console.log(path.dirname(__filename));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><h4 id="1-2、-filename"><a href="#1-2、-filename" class="headerlink" title="1.2、__filename"></a>1.2、__filename</h4><p>当前模块的文件名，这是当前模块文件的已解析的绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(__filename);</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path/example.js</span><br></pre></td></tr></table></figure></p><h4 id="1-3、process-cwd"><a href="#1-3、process-cwd" class="headerlink" title="1.3、process.cwd()"></a>1.3、process.cwd()</h4><p>process.cwd() 方法返回 Node.js 进程的当前工作目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(`当前工作目录是: $&#123;process.cwd()&#125;`);</span><br><span class="line">// 打印: 当前工作目录是: /Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><h4 id="1-4、-与"><a href="#1-4、-与" class="headerlink" title="1.4、./ 与 ../"></a>1.4、./ 与 ../</h4><p>我们通过 path.resolve() 方法将路径或路径片段的序列解析为绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">console.log(path.resolve(&apos;./&apos;));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test/path</span><br><span class="line">console.log(path.resolve(&apos;../&apos;));</span><br><span class="line">// 打印: /Users/songsong.zhang/study/es6test</span><br></pre></td></tr></table></figure></p><h3 id="二、综合实例"><a href="#二、综合实例" class="headerlink" title="二、综合实例"></a>二、综合实例</h3><p>假如我们有这样的文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path/</span><br><span class="line">    -lib/</span><br><span class="line">        -common.js</span><br><span class="line">    -model</span><br><span class="line">        -task.js</span><br></pre></td></tr></table></figure></p><p>在 task.js 里编写如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">console.log(__dirname);</span><br><span class="line">console.log(__filename);</span><br><span class="line">console.log(process.cwd());</span><br><span class="line">console.log(path.resolve(&apos;./&apos;));</span><br></pre></td></tr></table></figure></p><p>在 <code>model</code> 目录下运行 <code>node task.js</code> 得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model/task.js</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br></pre></td></tr></table></figure></p><p>然后在 <code>path</code> 目录下运行 <code>node model/task.js</code>，得到的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Users/songsong.zhang/study/es6test/path/model</span><br><span class="line">/Users/songsong.zhang/study/es6test/path/model/task.js</span><br><span class="line">/Users/songsong.zhang/study/es6test/path</span><br><span class="line">/Users/songsong.zhang/study/es6test/path</span><br></pre></td></tr></table></figure></p><p>可以得出一些<strong>肤浅的结论</strong>了：</p><ul><li>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</li><li>__filename: 总是返回被执行的 js 的绝对路径</li><li>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</li><li>./: 跟 process.cwd() 貌似一样</li></ul><p>但是在 <code>require(&#39;../lib/common&#39;)</code> 里一直都是各种相对路径写，也没见报什么错啊，我们再来个栗子吧，还是上面的结构，<code>model/task.js</code> 里的代码改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var common = require(&apos;../lib/common&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;../lib/common.js&apos;, function (err, data) &#123;</span><br><span class="line">    if (err) return console.log(err);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在 model 目录下运行 <code>node task.js</code>，一切 Ok，没有报错。然后在 path 目录下运行 <code>node model/task.js</code>，然后很果断滴报错了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; Error: ENOENT: no such file or directory, open &apos;../lib/common.js&apos;</span><br><span class="line">  errno: -2,</span><br><span class="line">  code: &apos;ENOENT&apos;,</span><br><span class="line">  syscall: &apos;open&apos;,</span><br><span class="line">  path: &apos;../lib/common.js&apos; &#125;</span><br></pre></td></tr></table></figure></p><p>那么这下问题真的都是来了，按照上面的理论，在 path 下运行时，<code>../lib/common.js</code> 会被转成 <code>/Users/songsong.zhang/study/es6test/lib/common.js</code>，这个路径显然是不存在的，但是从运行结果可以看出 <code>require(&#39;../lib/common&#39;)</code> 是 OK 的，只是 readFile 时报错了。</p><p>那么关于 <code>./</code> 正确的结论是：<br>在 <code>require()</code> 中使用是跟 <code>__dirname</code> 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 <code>process.cwd()</code> 效果相同，是相对于启动脚本所在目录的路径。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>只有在 <code>require()</code> 时才使用相对路径 <code>(./, ../)</code> 的写法，其他地方一律使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前目录下</span><br><span class="line">path.dirname(__filename) + &apos;/test.js&apos;;</span><br><span class="line">// 相邻目录下</span><br><span class="line">path.resolve(__dirname, &apos;../lib/common.js&apos;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node 有好几种表达文件路径的方式，但是他们之间有细微的区别，很容易搞混，现在梳理一遍。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之内存控制</title>
    <link href="http://blog.master-ss.cn/node/memory/"/>
    <id>http://blog.master-ss.cn/node/memory/</id>
    <published>2019-02-14T03:10:17.662Z</published>
    <updated>2019-02-14T06:25:06.375Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Node 的发展，JavaScript 已经实现了 CommonJS 的生态圈大一统的梦想，JavaScript 的应用场景早已不再局限在浏览器中。在那些短时间执行的场景，比如网页应用、命令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务器端的广泛应用，其他语言里存在着的问题在 JavaScript 中也暴露出来了。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用，本文将介绍在 Node 中如何合理高效地使用内存。<br><a id="more"></a></p><h3 id="一、V8-的垃圾回收机制与内存限制"><a href="#一、V8-的垃圾回收机制与内存限制" class="headerlink" title="一、V8 的垃圾回收机制与内存限制"></a>一、V8 的垃圾回收机制与内存限制</h3><p>Node 极大地拓宽了 JavaScript 的应用场景，当主流应用场景从客户端延伸到服务器端之后，对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。而在 Node 中，这一切都与 Node 的 JavaScript 执行引擎 V8 息息相关。</p><h4 id="1-1、Node-与-V8"><a href="#1-1、Node-与-V8" class="headerlink" title="1.1、Node 与 V8"></a>1.1、Node 与 V8</h4><p>Node 在发展历程中离不开 V8，所以在官方的主页介绍中就提到 Node 是一个构建在 Chrome 的 JavaScript 运行时上的平台。<br>关于 V8，它的来历与背景亦是大有来头。作为虚拟机，V8 的性能表现优异，这与它的领导者有莫大的渊源，Chrome 的成功也离不开它背后的天才——Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JavaScript 虚拟机。</p><h4 id="1-2、V8-的内存限制"><a href="#1-2、V8-的内存限制" class="headerlink" title="1.2、V8 的内存限制"></a>1.2、V8 的内存限制</h4><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象，比如无法将一个 2 GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32 GB。这样在单个 Node 进程的情况下，计算机的内存资源无法得到充足的使用。<br>造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。<br>至于 V8 为何要限制堆的大小，表层原因为 V8 最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8 的限制值已经绰绰有余。深层原因是 V8 的垃圾回收机制的限制。按官方的说法，以 1.5 GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。<br>当然，这个限制也不是不能打开，V8 依然提供了选项让我们使用更多的内存。Node 在启动时可以传递 –max-old-space-size 或–max-new-space-size 来调整内存限制的大小，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=1700 test.js // 单位为MB </span><br><span class="line">// 或者</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位为KB</span><br></pre></td></tr></table></figure></p><p>上述参数在 V8 初始化时生效，一旦生效就不能再动态改变。如果遇到 Node 无法分配足够内存给 JavaScript 对象的情况，可以用这个办法来放宽 V8 默认的内存限制，避免在执行过程中稍微多用了一些内存就轻易崩溃。</p><h4 id="1-3、V8-的内存分代"><a href="#1-3、V8-的内存分代" class="headerlink" title="1.3、V8 的内存分代"></a>1.3、V8 的内存分代</h4><p>在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 –max-old-space-size 命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着 V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。</p><h3 id="二、内存指标"><a href="#二、内存指标" class="headerlink" title="二、内存指标"></a>二、内存指标</h3><h4 id="2-1、高效使用内存"><a href="#2-1、高效使用内存" class="headerlink" title="2.1、高效使用内存"></a>2.1、高效使用内存</h4><p>在 V8 面前，开发者所要具备的责任是如何让垃圾回收机制更高效地工作。<br>在正常的 JavaScript 执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于 V8 的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。</p><h4 id="2-2、查看内存使用情况"><a href="#2-2、查看内存使用情况" class="headerlink" title="2.2、查看内存使用情况"></a>2.2、查看内存使用情况</h4><p>process.memoryUsage() 可以查看内存使用情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage()</span><br><span class="line">&#123; rss: 21708800,</span><br><span class="line">  heapTotal: 7684096,</span><br><span class="line">  heapUsed: 4975704,</span><br><span class="line">  external: 8676 &#125;</span><br></pre></td></tr></table></figure></p><p>rss 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中。<br>除了 rss 外，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息。heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。这 3 个值的单位都是字节。为了更好地查看效果，我们格式化一下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var showMem = function () &#123;</span><br><span class="line">    var mem = process.memoryUsage();</span><br><span class="line">    var format = function (bytes) &#123;</span><br><span class="line">        return (bytes / 1024 / 1024).toFixed(2) + &apos; MB&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&apos;Process: heapTotal &apos; + format(mem.heapTotal) + &apos; heapUsed &apos; + format(mem.heapUsed) + &apos; rss &apos; + format(mem.rss));</span><br><span class="line">    console.log(&apos;-----------------------------------------------------------&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同时，写一个方法用于不停地分配内存但不释放内存，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var useMem = function () &#123;</span><br><span class="line">    var size = 20 * 1024 * 1024;</span><br><span class="line">    var arr = new Array(size);</span><br><span class="line">    for(var i = 0; i &lt; size; i++)&#123;</span><br><span class="line">        arr[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;;</span><br><span class="line">var total = [];</span><br><span class="line">for(var j = 0; j &lt; 15; j++)&#123; </span><br><span class="line">    showMem();</span><br><span class="line">    total.push(useMem());</span><br><span class="line">&#125;</span><br><span class="line">showMem();</span><br></pre></td></tr></table></figure></p><p>将以上代码存为 outofmemory.js 并执行它，得到的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 20.14 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 166.84 MB heapUsed 164.25 MB rss 181.61 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 326.85 MB heapUsed 324.25 MB rss 341.66 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 486.86 MB heapUsed 484.26 MB rss 501.73 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 646.88 MB heapUsed 644.26 MB rss 661.78 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 806.89 MB heapUsed 804.26 MB rss 821.81 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 966.90 MB heapUsed 964.26 MB rss 981.82 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 1126.91 MB heapUsed 1124.27 MB rss 1141.84 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 1286.92 MB heapUsed 1284.27 MB rss 1301.86 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[8918:0x102802400]     1415 ms: Mark-sweep 1284.0 (1290.9) -&gt; 1283.9 (1290.9) MB, 130.2 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[8918:0x102802400]     1547 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 131.9 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[8918:0x102802400]     1681 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 133.5 / 0.0 ms  last resort GC in old space requested</span><br></pre></td></tr></table></figure></p><p>可以看到，每次调用 useMem 都导致了 3 个值的增长。在接近 1500 MB 的时候，无法继续分配内存，然后进程内存溢出了，连循环体都无法执行完成。</p><h4 id="2-3、查看系统的内存占用"><a href="#2-3、查看系统的内存占用" class="headerlink" title="2.3、查看系统的内存占用"></a>2.3、查看系统的内存占用</h4><p>与 process.memoryUsage() 不同的是，os 模块中的 totalmem() 和 freemem() 这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; os.totalmem()</span><br><span class="line">17179869184</span><br><span class="line">&gt; os.freemem()</span><br><span class="line">4527833088</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>从输出信息可以看到我的电脑的总内存为 16 GB，当前闲置内存大致为 4.2 GB。</p><h4 id="2-4、堆外内存"><a href="#2-4、堆外内存" class="headerlink" title="2.4、堆外内存"></a>2.4、堆外内存</h4><p>通过 process.memoryUsage() 的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。我们将那些不是通过 V8 分配的内存称为堆外内存。<br>这里我们将前面的 useMem() 方法稍微改造一下，将 Array 变为 Buffer，将 size 变大，每一次构造 200 MB 的对象，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var useMem = function () &#123;</span><br><span class="line">    var size = 200 * 1024 * 1024;</span><br><span class="line">    var buffer = new Buffer(size);</span><br><span class="line">    for (var i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        buffer[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>重新执行该代码，得到的输出结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Process: heapTotal 6.83 MB heapUsed 4.21 MB rss 19.86 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.83 MB heapUsed 4.25 MB rss 221.35 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.83 MB heapUsed 4.26 MB rss 421.52 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 621.91 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 821.91 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.98 MB rss 1021.92 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1222.19 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1422.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 9.33 MB heapUsed 3.95 MB rss 1622.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 1822.21 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.95 MB rss 2021.24 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.96 MB rss 2221.24 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 2421.28 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2620.31 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.93 MB rss 2820.31 MB</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Process: heapTotal 6.33 MB heapUsed 3.92 MB rss 3020.34 MB</span><br><span class="line">-----------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>我们看到 15 次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heapTotal 与 heapUsed 的变化极小，唯一变化的是 rss 的值，并且该值已经远远超过 V8 的限制值。这其中的原因是 Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以也不会有堆内存的大小限制。<br>为何 Buffer 对象并非通过 V8 分配？这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流，操作字符串远远不能满足传输的性能需求。<br>所以从上面的介绍可以得知，Node 的内存构成主要由通过 V8 进行分配的部分和 Node 自行分配的部分。受 V8 的垃圾回收限制的主要是 V8 的堆内存。</p><h3 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h3><p>Node 对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。<br>在 V8 的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。<br>通常，造成内存泄漏的原因有几个：缓存、队列消费不及时与作用域未释放。</p><h4 id="3-1、慎将内存当做缓存"><a href="#3-1、慎将内存当做缓存" class="headerlink" title="3.1、慎将内存当做缓存"></a>3.1、慎将内存当做缓存</h4><p>缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间。<br>但是在 Node 中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。<br>另一个问题在于，JavaScript 开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。<br>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。<br>如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。它的好处多多，在 Node 中主要可以解决两个问题：将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效；进程之间可以共享缓存。<br>目前，市面上较好的缓存有 Redis 和 Memcached。Node 模块的生态系统十分完善，这两个产品的客户端都有。</p><h4 id="3-2、关注队列状态"><a href="#3-2、关注队列状态" class="headerlink" title="3.2、关注队列状态"></a>3.2、关注队列状态</h4><p>有的应用会收集日志，如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而 JavaScript 中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。<br>遇到这种场景，表层的解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。</p><h3 id="四、大内存应用"><a href="#四、大内存应用" class="headerlink" title="四、大内存应用"></a>四、大内存应用</h3><p>在 Node 中，不可避免地还是会存在操作大文件的场景。由于 Node 的内存限制，操作大文件也需要小心，好在 Node 提供了 stream 模块用于处理大文件。<br>stream 模块是 Node 的原生模块，直接引用即可。stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node 中的大多数模块都有 stream 的应用，比如 fs 的 createReadStream() 和 createWriteStream() 方法可以分别用于创建文件的可读流和可写流，process 模块中的 stdin 和 stdout 则分别是可读流和可写流的示例。<br>由于 V8 的内存限制，我们无法通过 fs.readFile() 和 fs.writeFile() 直接进行大文件的操作，而改用 fs.createReadStream() 和 fs.createWriteStream() 方法通过流的方式实现对大文件的操作。下面的代码展示了如何读取一个文件，然后将数据写入到另一个文件的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reader = fs.createReadStream(&apos;in.txt&apos;);</span><br><span class="line">var writer = fs.createWriteStream(&apos;out.txt&apos;);</span><br><span class="line">reader.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">    writer.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">reader.on(&apos;end&apos;, function () &#123;</span><br><span class="line">    writer.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>由于读写模型固定，上述方法有更简洁的方式，具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reader = fs.createReadStream(&apos;in.txt&apos;);</span><br><span class="line">var writer = fs.createWriteStream(&apos;out.txt&apos;);</span><br><span class="line">reader.pipe(writer);</span><br></pre></td></tr></table></figure></p><p>可读流提供了管道方法 pipe()，封装了 data 事件和写入操作。通过流的方式，上述代码不会受到 V8 内存限制的影响，有效地提高了程序的健壮性。<br>如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试进行纯粹的 Buffer 操作，这不会受到 V8 堆内存的限制。但是这种大片使用内存的情况依然要小心，即使 V8 不限制堆内存的大小，物理内存依然有限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Node 的发展，JavaScript 已经实现了 CommonJS 的生态圈大一统的梦想，JavaScript 的应用场景早已不再局限在浏览器中。在那些短时间执行的场景，比如网页应用、命令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务器端的广泛应用，其他语言里存在着的问题在 JavaScript 中也暴露出来了。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用，本文将介绍在 Node 中如何合理高效地使用内存。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之 module</title>
    <link href="http://blog.master-ss.cn/node/module/"/>
    <id>http://blog.master-ss.cn/node/module/</id>
    <published>2019-01-28T03:28:06.307Z</published>
    <updated>2019-01-28T07:16:23.780Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种网页小脚本而已，在 Web 1.0 时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到 Web 2.0 时代，前端工程师利用它大大提升了网页上的用户体验。<br>长长的后天努力过程中，JavaScript 不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了 JavaScript 先天就缺乏的一项功能：模块。经历十多年的发展后，社区也为 JavaScript 制定了相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。<br><a id="more"></a> </p><h3 id="一、模块实现"><a href="#一、模块实现" class="headerlink" title="一、模块实现"></a>一、模块实现</h3><p><img src="/assets/node/commonjs.png"><br>Node 与浏览器以及 W3C 组织、CommonJS 组织、ECMAScript 之间的关系<br>Node 在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。在 Node 中引入模块，需要经历如下 3 个步骤：路径分析、文件定位、编译执行。在 Node 中，模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最 快的。</li><li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</li></ul><h3 id="二、优先从缓存加载"><a href="#二、优先从缓存加载" class="headerlink" title="二、优先从缓存加载"></a>二、优先从缓存加载</h3><p>与前端浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。<br>不论是核心模块还是文件模块，require() 方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。</p><h3 id="三、路径分析和文件定位"><a href="#三、路径分析和文件定位" class="headerlink" title="三、路径分析和文件定位"></a>三、路径分析和文件定位</h3><h4 id="3-1、模块标识符分析"><a href="#3-1、模块标识符分析" class="headerlink" title="3.1、模块标识符分析"></a>3.1、模块标识符分析</h4><p>前面提到过，require()方法接受一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为几类：核心模块，如 http、fs、path 等；. 或 .. 开始的相对路径文件模块；以 / 开始的绝对路径文件模块；非路径形式的文件模块，如自定义的 connect 模块。</p><ul><li>核心模块<br>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个 http 用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。</li><li>路径形式的文件模块<br>以 .、.. 和 / 开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，require() 方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给 Node 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。</li><li>自定义模块<br>自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。<br>在介绍自定义模块的查找方式之前，需要先介绍一下模块路径这个概念。<br>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。<ul><li>创建module_path.js文件，其内容为console.log(module.paths);</li><li>将其放到任意一个目录中然后执行node module_path.js<br>在Linux下，你可能得到的是这样一个数组输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;/home/jackson/research/node_modules&apos;,</span><br><span class="line">&apos;/home/jackson/node_modules&apos;,</span><br><span class="line">&apos;/home/node_modules&apos;,</span><br><span class="line">&apos;/node_modules&apos; ]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>而在 Windows 下，也许是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;c:\\nodejs\\node_modules&apos;, &apos;c:\\node_modules&apos; ]</span><br></pre></td></tr></table></figure></p><p>可以看出，模块路径的生成规则如下所示：</p><ul><li>当前文件目录下的node_modules目录</li><li>父目录下的node_modules目录</li><li>父目录的父目录下的node_modules目录</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录</li></ul><p>它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</p><h4 id="3-2、文件定位"><a href="#3-2、文件定位" class="headerlink" title="3.2、文件定位"></a>3.2、文件定位</h4><p>从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。<br>但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。</p><ul><li>文件扩展名分析<br>require() 在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS 模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 .js、.json、.node 的次序补足扩展名，依次尝试。<br>在尝试的过程中，需要调用 fs 模块同步阻塞式地判断文件是否存在。因为 Node 是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度。</li><li>目录分析和包<br>在分析标识符的过程中，require() 通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当做一个包来处理。<br>在这个过程中，Node 对 CommonJS 包规范进行了一定程度的支持。首先，Node 在当前目录下查找package.json（CommonJS 包规范定义的包描述文件），通过 JSON.parse() 解析出包描述对象，从中取出 main 属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。<br>而如果 main 属性指定的文件名错误，或者压根没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.node、index.json。<br>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li></ul><h3 id="四、模块编译"><a href="#四、模块编译" class="headerlink" title="四、模块编译"></a>四、模块编译</h3><p>在 Node 中，每个文件模块都是一个对象，编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能。对于不同的文件扩展名，其载入方法也有所不同:</p><h4 id="4-1、JavaScript-模块的编译"><a href="#4-1、JavaScript-模块的编译" class="headerlink" title="4.1、JavaScript 模块的编译"></a>4.1、JavaScript 模块的编译</h4><p>回到 CommonJS 模块规范，我们知道每个模块文件中存在着 require、exports、module 这 3 个变量，但是它们在模块文件中并没有定义，那么从何而来呢？<br>事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。一个正常的JavaScript文件会被包装成如下的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    var math = require(&apos;math&apos;);</span><br><span class="line">    exports.area = function (radius) &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过 vm 原生模块的 runInThisContext() 方法执行（类似 eval，只是具有明确上下文，不污染全局），返回一个具体的 function 对象。最后，将当前模块对象的 exports 属性、require() 方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 function() 执行。<br>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。此外，许多初学者都曾经纠结过为何存在 exports 的情况下，还存在 module.exports。其原因在于，exports 对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。</p><h4 id="4-2、C-C-模块的编译"><a href="#4-2、C-C-模块的编译" class="headerlink" title="4.2、C/C++模块的编译"></a>4.2、C/C++模块的编译</h4><p>Node 调用 process.dlopen() 方法进行加载和执行。在 Node 的架构下，dlopen() 方法在 Windows 和<code>*nix</code>平台下分别有不同的实现，通过 libuv 兼容层进行了封装。<br>实际上，.node 的模块文件并不需要编译，因为它是编写 C/C++ 模块之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的 exports 对象与 .node 模块产生联系，然后返回给调用者。</p><h4 id="4-3、JSON文件的编译"><a href="#4-3、JSON文件的编译" class="headerlink" title="4.3、JSON文件的编译"></a>4.3、JSON文件的编译</h4><p>.json 文件的编译是 3 种编译方式中最简单的。Node 利用 fs 模块同步读取 JSON 文件的内容之后，调用 JSON.parse() 方法得到对象，然后将它赋给模块对象的 exports，以供外部调用。<br>JSON 文件在用作项目的配置文件时比较有用。如果你定义了一个 JSON 文件作为配置，那就不必调用 fs 模块去异步读取和解析，直接调用 require() 引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p><h3 id="五、核心模块及模块调用栈"><a href="#五、核心模块及模块调用栈" class="headerlink" title="五、核心模块及模块调用栈"></a>五、核心模块及模块调用栈</h3><h4 id="5-1、核心模块"><a href="#5-1、核心模块" class="headerlink" title="5.1、核心模块"></a>5.1、核心模块</h4><p>前面提到，Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为 C/C++ 编写的和 JavaScript 编写的两部分，其中 C/C++ 文件存放在 Node 项目的 src 目录下，JavaScript 文件存放在 lib 目录下。<br>在核心模块中，有些模块全部由 C/C++ 编写，有些模块则由 C/C++ 完成核心部分，其他部分则由 JavaScript 实现包装或向外导出，以满足性能需求。这种 C++ 模块主内完成核心，JavaScript 主外实现封装的模式是 Node 能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能则弱于静态语言。而 Node 的这种复合模式可以在开发速度和性能之间找到平衡点。</p><h4 id="5-2、模块调用栈"><a href="#5-2、模块调用栈" class="headerlink" title="5.2、模块调用栈"></a>5.2、模块调用栈</h4><p>C/C++ 内建模块属于最底层的模块，它属于核心模块，主要提供 API 给 JavaScript 核心模块和第三方 JavaScript 文件模块调用。如果你不是非常了解要调用的 C/C++ 内建模块，请尽量避免通过 process.binding() 方法直接调用，这是不推荐的。<br>JavaScript 核心模块主要扮演的职责有两类：一类是作为 C/C++ 内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。<br><img src="/assets/node/module.png"><br>模块之间的调用关系<br>文件模块通常由第三方编写，包括普通 JavaScript 模块和 C/C++ 扩展模块，主要调用方向为普通 JavaScript 模块调用扩展模块。</p><h3 id="六、包与NPM"><a href="#六、包与NPM" class="headerlink" title="六、包与NPM"></a>六、包与NPM</h3><p>Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用。而在模块之外，包和NPM则是将模块联系起来的一种机制，详情见 <a href="/node/npm">node 之 npm</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种网页小脚本而已，在 Web 1.0 时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到 Web 2.0 时代，前端工程师利用它大大提升了网页上的用户体验。&lt;br&gt;长长的后天努力过程中，JavaScript 不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了 JavaScript 先天就缺乏的一项功能：模块。经历十多年的发展后，社区也为 JavaScript 制定了相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之异步 I/O</title>
    <link href="http://blog.master-ss.cn/node/io/"/>
    <id>http://blog.master-ss.cn/node/io/</id>
    <published>2019-01-28T01:27:34.321Z</published>
    <updated>2019-01-28T07:16:40.116Z</updated>
    
    <content type="html"><![CDATA[<p>在绝大多数高级编程语言中，异步并不多见，造成这个现象的主要原因是：程序员不太适合通过异步编程来进行程序设计。在众多语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。伴随着异步 I/O 的还有事件驱动和单线程，他们构成了 Node 的基调。与 Node 的事件驱动、异步 I/O 设计理念比较相近的一个知名产品为 Nginx。Nginx 采用纯 C 编写，性能表现非常优异。<br><a id="more"></a> </p><h3 id="一、为什么要异步-I-O"><a href="#一、为什么要异步-I-O" class="headerlink" title="一、为什么要异步 I/O"></a>一、为什么要异步 I/O</h3><h4 id="1-1、用户体验"><a href="#1-1、用户体验" class="headerlink" title="1.1、用户体验"></a>1.1、用户体验</h4><p>异步的概念之所以首先在 Web 2.0 中火起来，是因为浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。在 B/S 模型中，网络速度的限制给网页的实时体验造成很大的麻烦，而采用异步请求，在下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。<br>同理，前端通过异步可以消除掉 UI 阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源需要 M 毫秒的耗时，第二个资源需要 N 毫秒的耗时。如果采用同步的方式，代码大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 时间为 M</span><br><span class="line">getData(&apos;from_db&apos;);</span><br><span class="line">// 时间为 N</span><br><span class="line">getData(&apos;from_remote_api&apos;);</span><br></pre></td></tr></table></figure></p><p>但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源，如此我们可以享受到并发的优势，代码大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getData(&apos;from_db&apos;, function (result) &#123;</span><br><span class="line">    // 时间为 M</span><br><span class="line">&#125;);</span><br><span class="line">getData(&apos;from_remote_api&apos;, function (result) &#123;</span><br><span class="line">    // 时间为 N</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>对比两者的时间总消耗，前者为 M+N，后者为 max(M, N)。随着应用复杂性的增加，情景将会变成 M+N+… 和 max(M, N, …)，同步和异步的优劣势将会凸显出来。这就是异步 I/O 在 Node 中如此盛行，甚至将其作为主要理念进行设计的原因。</p><h4 id="1-2、资源分配"><a href="#1-2、资源分配" class="headerlink" title="1.2、资源分配"></a>1.2、资源分配</h4><p>假设业务场景有一组互不相干的任务需要完成，现行主流方法有两种：单线程串行依次执行、多线程并行完成。如果创建多线程的开销小于并行执行，那么多线程的方式是首先的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。在复杂的业务中，多线程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核 CPU 上能够有效提升 CPU 的利用率，这个优势是毋庸置疑的。<br>单线程顺序执行比较符合编程人员按顺序思考的思维方式，而且目前依然是最主流的编程方式，因为它易于表达，但是缺点在于性能。<br>所以单线程同步编程模型会因阻塞 I/O 导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。Node 在两者之间给出了它的方案：利用单线程，远离死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好的使用 CPU。<br>异步 I/O 可以算 Node 的特色，因为它是首个大规模的将异步 I/O 应用在应用层的平台，力求在单线程上将资源分配的更高效。为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览中 Web Workers 的子进程，该子进程可以通过工作进程高效地利用 CPU 和 I/O。</p><h3 id="二、实现现状"><a href="#二、实现现状" class="headerlink" title="二、实现现状"></a>二、实现现状</h3><h4 id="2-1、异步-I-O-与非阻塞-I-O"><a href="#2-1、异步-I-O-与非阻塞-I-O" class="headerlink" title="2.1、异步 I/O 与非阻塞 I/O"></a>2.1、异步 I/O 与非阻塞 I/O</h4><p>操作系统内核对于 I/O 只有阻塞和非阻塞两种。阻塞 I/O 的特点是调用之后要等待系统内核层面完成所有操作后调用才结束。非阻塞 I/O 在于获取数据的过程中不带数据直接返回，要获取数据，还需要通过文件描述符再次读取，这对性能的提升是明显的。<br>任何技术都并非完美，阻塞 I/O 造成 CPU 等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让 CPU 处理状态判断，是对 CPU 资源的浪费。现存的轮询技术主要有：read、select、poll、epoll、kqueue，其中 epoll 是 Linux 下效率最高的 I/O 事件通知机制。</p><h4 id="2-2、非阻塞异步-I-O"><a href="#2-2、非阻塞异步-I-O" class="headerlink" title="2.2、非阻塞异步 I/O"></a>2.2、非阻塞异步 I/O</h4><p>可以使用多线程的方式，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O。<br><img src="/assets/node/async-io.png"><br>Node 在<code>*nix</code>平台下自行实现了线程池来完成异步 I/O，而在 Windows 平台下采用了 IOCP。由于 Windows 平台和<code>*nix</code>平台的差异，Node 提供了 libuv 作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。<br><img src="/assets/node/lib-uv.png"></p><h3 id="三、异步-I-O"><a href="#三、异步-I-O" class="headerlink" title="三、异步 I/O"></a>三、异步 I/O</h3><h4 id="3-1、事件循环"><a href="#3-1、事件循环" class="headerlink" title="3.1、事件循环"></a>3.1、事件循环</h4><p>Node 自身的执行模型：事件循环，正是它使得回调函数十分普遍。<br>在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。</p><h4 id="3-2、观察者"><a href="#3-2、观察者" class="headerlink" title="3.2、观察者"></a>3.2、观察者</h4><p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。<br>浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。<br>事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p><h4 id="3-3、非-I-O-的异步-API"><a href="#3-3、非-I-O-的异步-API" class="headerlink" title="3.3、非 I/O 的异步 API"></a>3.3、非 I/O 的异步 API</h4><ul><li>定时器</li></ul><p>setTimeout() 和 setInterval() 与浏览器中的 API 是一致的，分别用于单次和多次定时执行任务。它们的实现原理与异步 I/O 比较类似，只是不需要 I/O 线程池的参与。</p><ul><li>process.nextTick()</li></ul><p>也许为了立即异步执行一个任务，会这样调用 setTimeout() 来达到所需的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    // TODO</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure></p><p>由于事件循环自身的特点，定时器的精确度不够，而且创建定时器对象和迭代等操作较为浪费性能。实际上，process.nextTick() 方法的操作相对较为轻量。每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。</p><ul><li>setImmediate()</li></ul><p>setImmediate() 方法与 process.nextTick() 方法十分类似，详情见 <a href="/node/event-loop">node 之 event-loop</a>。</p><h3 id="四、浏览器与-Node-事件循环细微区别"><a href="#四、浏览器与-Node-事件循环细微区别" class="headerlink" title="四、浏览器与 Node 事件循环细微区别"></a>四、浏览器与 Node 事件循环细微区别</h3><p>通过一个例子来说明两者区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;timer1&apos;)</span><br><span class="line">    Promise.resolve().then(function() &#123;</span><br><span class="line">        console.log(&apos;promise1&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;timer2&apos;)</span><br><span class="line">    Promise.resolve().then(function() &#123;</span><br><span class="line">        console.log(&apos;promise2&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure></p><p>浏览器端运行结果：timer1 =&gt; promise1 =&gt; timer2 =&gt; promise2<br>Node端运行结果分两种情况：</p><ul><li>如果是 node11 版本一旦执行一个阶段里的一个宏任务 (setTimeout, setInterval 和 setImmediate) 就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为 timer1 =&gt; promise1 =&gt; timer2 =&gt; promise2</li><li>如果是 node10 及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中：<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为 timer1 =&gt; promise1 =&gt; timer2 =&gt; promise2</li><li>如果是第二个定时器已经在完成队列中，则最后的结果为 timer1 =&gt; timer2 =&gt; promise1 =&gt; promise2</li></ul></li></ul><p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同：Node 端，microtask 在事件循环的各个阶段之间执行；浏览器端，microtask 在事件循环的 macrotask 执行完之后执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在绝大多数高级编程语言中，异步并不多见，造成这个现象的主要原因是：程序员不太适合通过异步编程来进行程序设计。在众多语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。伴随着异步 I/O 的还有事件驱动和单线程，他们构成了 Node 的基调。与 Node 的事件驱动、异步 I/O 设计理念比较相近的一个知名产品为 Nginx。Nginx 采用纯 C 编写，性能表现非常优异。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>node 之 Buffer</title>
    <link href="http://blog.master-ss.cn/node/buffer/"/>
    <id>http://blog.master-ss.cn/node/buffer/</id>
    <published>2019-01-24T01:13:59.353Z</published>
    <updated>2019-01-24T03:05:51.391Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 对于字符串的操作十分友好，无论是多字节字符还是单字节字符，都被认为是一个字符。在体验过 JavaScript 友好的字符串操作后，有些开发者可能会形成思维定势，将 Buffer 当做字符串来理解。但字符串与 Buffer 之间有实质上的差异，即 Buffer 是二进制数据，字符串与 Buffer 之间存在编码关系。<br>在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是 Buffer 对象应运而生。<br><a id="more"></a> </p><h3 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h3><h4 id="1-1、模块结构"><a href="#1-1、模块结构" class="headerlink" title="1.1、模块结构"></a>1.1、模块结构</h4><p>Buffer 是一个像 Array 的对象，但它主要用于操作字节。</p><h4 id="1-2、Buffer-对象"><a href="#1-2、Buffer-对象" class="headerlink" title="1.2、Buffer 对象"></a>1.2、Buffer 对象</h4><p>Buffer 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现。Buffer 所占用的内存不是通过 V8 分配的，属于堆外内存。由于 Buffer 太过常见，Node 在进程启动时就已经加载了它，并将其放在全局对象上。所以在使用 Buffer 时，无须通过 require() 即可直接使用。<br>Buffer 对象类似于数组，它的元素为 16 进制的两位数，即 0 到 255 的数值，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;深入浅出node.js&apos;</span><br><span class="line">var buff = new Buffer(str, &apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">// &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span><br><span class="line">console.log(buff)</span><br></pre></td></tr></table></figure></p><p>由上可见，不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8 编码下占用 3 个元素，字母和半角标点符号占用 1 个元素。Buffer 受 Array 类型的影响很大，可以访问 length 属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buff = new Buffer(100)</span><br><span class="line">// 100</span><br><span class="line">console.log(buff.length)</span><br></pre></td></tr></table></figure></p><p>可以通过下标对 Buffer 进行赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buff[10] = 100</span><br><span class="line">// 100</span><br><span class="line">console.log(buff[10])</span><br></pre></td></tr></table></figure></p><p>如果给元素赋值不是 0-255 而是小数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buff[20] = -100</span><br><span class="line">// 156</span><br><span class="line">console.log(buff[20])</span><br><span class="line">buff[21] = 300</span><br><span class="line">// 44</span><br><span class="line">console.log(buff[21])</span><br><span class="line">buff[22] = 3.1415</span><br><span class="line">// 3</span><br><span class="line">console.log(buff[22])</span><br></pre></td></tr></table></figure></p><p>给元素的赋值如果小于 0，就将该值逐次加 256，直到得到一个 0 到 255 之间的整数。如果得到的数值大于 255，将逐次减 256，直到 0-255 区间内的数值。如果是小数，舍弃小数部分，只保留整数部分。</p><h3 id="二、Buffer-的转换"><a href="#二、Buffer-的转换" class="headerlink" title="二、Buffer 的转换"></a>二、Buffer 的转换</h3><p>Buffer 对象可以与字符串之间相互转换。</p><h4 id="2-1、字符串转-Buffer"><a href="#2-1、字符串转-Buffer" class="headerlink" title="2.1、字符串转 Buffer"></a>2.1、字符串转 Buffer</h4><p>字符串转 Buffer 对象主要是通过构造函数完成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Buffer(str, [encoding])</span><br></pre></td></tr></table></figure></p><p>通过构造函数转换的 Buffer 对象，存储的只能是一种编码类型。encoding 参数不传递时，默认按 UTF-8 编码进行转码和存储。一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法可以实现该目的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure></p><p>由于可以不断写入内容到 Buffer 对象中，并且每次写入可以指定编码，所以 Buffer 对象中可以存在多种编码转化后的内容。需要小心的是，每种编码所用的字节长度不同，将 Buffer 反转回字符串时需要谨慎处理。</p><h4 id="2-2、Buffer-转字符串"><a href="#2-2、Buffer-转字符串" class="headerlink" title="2.2、Buffer 转字符串"></a>2.2、Buffer 转字符串</h4><p>实现 Buffer 向字符串的转换也十分简单，Buffer 对象的 toString() 可以将 Buffer 对象转换为字符串，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff.toString([encoding], [start], [end])</span><br></pre></td></tr></table></figure></p><p>比较精巧的是，可以设置 encoding（默认为 UTF-8）、start、end 这 3 个参数实现整体或局部的转换。如果 Buffer 对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</p><h3 id="三、Buffer-的拼接"><a href="#三、Buffer-的拼接" class="headerlink" title="三、Buffer 的拼接"></a>三、Buffer 的拼接</h3><p>Buffer 在使用场景中，通常是以一段一段的方式传输，以下是常见的从输入流中读取内容的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">var rs = fs.createReadStream(&apos;test.md&apos;)</span><br><span class="line">var data = &apos;&apos;</span><br><span class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">    data += chunk</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(&apos;end&apos;, function (chunk) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面这段代码常见于国外，用于流读取的示范，data 事件中获取的 chunk 对象即是 Buffer 对象。一旦输入流中有多字节编码时，问题就会暴露出来。这里潜在的问题在于如下这句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data += chunk</span><br></pre></td></tr></table></figure></p><p>这句代码里隐藏了 toString() 操作，它等价于如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data += data.toString() + chunk.toString()</span><br></pre></td></tr></table></figure></p><p>值得注意的是，外国人语境通常是指英文环境，在他们的场景下，这个 toString() 不会造成任何问题。但对于多字节的中文，却会形成问题。为了重现这个问题，下面模拟近似的场景，将文件可读流的每次读取 Buffer 长度限制为 11，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var rs = fs.createReadStream(&apos;test.md&apos;, &#123;highWaterMark: 11&#125;)</span><br></pre></td></tr></table></figure></p><p>搭配该代码的测试数据为李白的《静夜思》。执行该程序，将会得到以下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗前明��光，疑���地上霜。举头��明月，���头思故乡</span><br></pre></td></tr></table></figure></p><h4 id="3-1、乱码产生原因"><a href="#3-1、乱码产生原因" class="headerlink" title="3.1、乱码产生原因"></a>3.1、乱码产生原因</h4><p>上面的诗歌中，“月”、“是”、“望”、“低” 4个字没有被正常输出，取而代之的是�，产生这个输出结果的原因在于文件可读流在读取时会逐个读取 Buffer。这首歌原始 Buffer 应存储为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c 88 e5 85 89 ef bc 8c e7 96 91 e6 98 af e5 9c b0 e4 b8 8a e9 9c 9c ef bc 9b e4 b8 be e5 a4 b4 e6 9c 9b e6 98 8e e6 9c 88...&gt;</span><br></pre></td></tr></table></figure></p><p>由于限定了 Buffer 对象的长度为 11，因此只读流需要读取 7 次才能完成完成的读取，结果是以下几个 Buffer 对象依次输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c&gt;</span><br><span class="line">&lt;Buffer 88 e5 85 89 ef bc 8c e7 96 91 e6&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>上文提到 buff.toString() 方法默认以 UTF-8 为编码，中文字在 UTF-8 下占 3 个字节。所以第一个 Buffer 对象在输出时，只能显示 3 个字符，Buffer 中剩下的 2 个字节（e6 9c）将会以乱码的形式显示。第二个 Buffer 对象的第一个字节也不能形成文字，只能显示乱码，于是形成一些文字无法正常显示的问题。<br>在这个示例中，我们构造了 11 这个限制，但是对于任意长度的 Buffer 而言，多字节字符都有可能存在被截断的情况，只不过 Buffer 的长度越大出现的概率越低而已，但该问题依然不可忽视。</p><h4 id="3-2、setEncoding"><a href="#3-2、setEncoding" class="headerlink" title="3.2、setEncoding()"></a>3.2、setEncoding()</h4><p>在看过上述的示例后，也许我们忘记了可读流还有一个设置编码的方法 setEncoding()，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure></p><p>改方法的作用是让 data 事件中传递不再是一个 Buffer 对象，而是编码后的字符串。为此，我们继续改进前面的诗歌的程序，添加 setEncoding() 的步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var rs = fs.createReadStream(&apos;test.md&apos;, &#123; highWaterMark: 11 &#125;)</span><br><span class="line">rs.setEncoding(&apos;utf8&apos;)</span><br></pre></td></tr></table></figure></p><p>重新执行程序，得到输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗前明月光，疑是地上霜。举头望明月，低头思故乡</span><br></pre></td></tr></table></figure></p><p>那 Node 是如何实现这个输出结果的呢？要知道，无论如何设置编码，触发 data 事件的次数依旧相同，这意味着设置编码并未改变按段读取的基本方式。<br>事实上，在用 setEncoding() 时，可读流对象在内部设置了一个 decoder，它来自于 string_decoder 模块 StringDecoder 的实例对象。下面以代码来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder</span><br><span class="line">var decoder = new StringDecoder(&apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line">var buf1 = new Buffer([0xE5, 0xBA, 0x8A, 0xE5, 0x89, 0x8D, 0xE6, 0x98, 0x8E, 0xE6, 0x9C])</span><br><span class="line">console.log(decoder.write(buf1))</span><br><span class="line">// =&gt; 床前月</span><br><span class="line"></span><br><span class="line">var buf2 = new Buffer([0x88, 0xE5, 0x85, 0x89, 0xEF, 0xBC, 0x8C, 0xE7, 0x96, 0x91, 0xE6])</span><br><span class="line">console.log(decoder.write(buf2))</span><br><span class="line">// =&gt; 月光，疑</span><br></pre></td></tr></table></figure></p><p>StringDecoder 在得到编码后，知道多字节字符在 UTF-8 编码下以 3 个字节的方式存储，所以第一次 write() 时，只输出前 9 个字节转码形成的字符，“月”字的前两个字节被保留在 StringDecoder 实例内部，第二次 write() 时，会将 2 个剩余字节和后续 11 个字节组合在一起，再次用 3 的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了。<br>虽然 string_decoder 模块很奇妙，但是它只能处理几种编码，如 UTF-8、Base64、UCS-2/UTF-16LE。所以通过 setEncoding() 可以解决大部分的乱码问题，但并不能从根本上解决问题。</p><h4 id="3-3、正确拼接-Buffer"><a href="#3-3、正确拼接-Buffer" class="headerlink" title="3.3、正确拼接 Buffer"></a>3.3、正确拼接 Buffer</h4><p>淘汰掉 setEncoding() 方法后，剩下的解决方案只有将多个小 Buffer 对象拼接为一个 Buffer 对象，然后通过 iconv-lite 一类的模块来转码这种方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var chunks = []</span><br><span class="line">var size = 0</span><br><span class="line">res.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">  chunks.push(chunk)</span><br><span class="line">  size += chunk.length</span><br><span class="line">&#125;)</span><br><span class="line">res.on(&apos;end&apos;, function () &#123;</span><br><span class="line">  var buf = Buffer.concat(chunks, size)</span><br><span class="line">  var str = iconv.decode(buf, &apos;utf8&apos;)</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>正确的拼接方式是用一个数组来存储接收到的所有 Buffer 片段，并记录下总长度，然后调用 Buffer.concat() 方法来生成一个合并的 Buffer 对象。Buffer.concat() 方法封装了从小 Buffer 对象向大 Buffer 对象的复制过程，实现十分细腻，值得学习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = function(list, length) &#123;</span><br><span class="line">  if (!Array.isArray(list)) &#123;</span><br><span class="line">    throw new Error(&apos;Usage: Buffer.concat(list, [length])&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (list.length === 0) &#123;</span><br><span class="line">    return new Buffer(0);</span><br><span class="line">  &#125; else if (list.length === 1) &#123;</span><br><span class="line">    return list[0];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (typeof length !== &apos;number&apos;) &#123;</span><br><span class="line">    length = 0;</span><br><span class="line">    for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">      var buf = list[i];</span><br><span class="line">      length += buf.length; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var buffer = new Buffer(length);</span><br><span class="line">  varpos = 0;</span><br><span class="line">  for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    var buf = list[i];</span><br><span class="line">    buf.copy(buffer, pos);</span><br><span class="line">    pos += buf.length;</span><br><span class="line">  &#125;</span><br><span class="line">  return buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 对于字符串的操作十分友好，无论是多字节字符还是单字节字符，都被认为是一个字符。在体验过 JavaScript 友好的字符串操作后，有些开发者可能会形成思维定势，将 Buffer 当做字符串来理解。但字符串与 Buffer 之间有实质上的差异，即 Buffer 是二进制数据，字符串与 Buffer 之间存在编码关系。&lt;br&gt;在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是 Buffer 对象应运而生。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://blog.master-ss.cn/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>网络之 https 协议</title>
    <link href="http://blog.master-ss.cn/essay/https/"/>
    <id>http://blog.master-ss.cn/essay/https/</id>
    <published>2019-01-22T01:58:29.765Z</published>
    <updated>2019-01-22T02:59:11.710Z</updated>
    
    <content type="html"><![CDATA[<p>https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。<br><a id="more"></a></p><h3 id="一、http-困境"><a href="#一、http-困境" class="headerlink" title="一、http 困境"></a>一、http 困境</h3><p>http 协议是明文传递内容，一旦在网络被人监控，数据可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使被截取和窃听，窃听者也无法知道数据的真实内容是什么。</p><h3 id="二、加密"><a href="#二、加密" class="headerlink" title="二、加密"></a>二、加密</h3><p>让我们设想这样一个情景：海绵宝宝想和蟹老板秘密协商新的蟹黄堡配方，如果让你来设计加密过程，你有几种方法呢？</p><h4 id="2-1、对称加密"><a href="#2-1、对称加密" class="headerlink" title="2.1、对称加密"></a>2.1、对称加密</h4><p>海绵宝宝和蟹老板约定一个密钥，传输和解读都通过这个密钥解密，这个密钥称为公钥。<br><img src="/assets/essay/https-symmetry.png"></p><h4 id="2-2、非对称加密"><a href="#2-2、非对称加密" class="headerlink" title="2.2、非对称加密"></a>2.2、非对称加密</h4><p>小心谨慎的蟹老板有一个只有自己知道的密钥(称为私钥)和公钥，他把公钥发给海绵宝宝，海绵宝宝可以通过公钥解密私钥加密的消息，但是公钥加密的消息只有私钥能解开，这在一定程度上做到了单向安全。<br><img src="/assets/essay/https-asymmetry.png"></p><h4 id="2-3、协商"><a href="#2-3、协商" class="headerlink" title="2.3、协商"></a>2.3、协商</h4><p>那么HTTPS中用的哪种加密方式呢？<br>如果采用对称加密，那么蟹老板和所有人都拥有同一个密钥，这无异于没有加密！！！<br><img src="/assets/essay/https-negotiate1.png"><br>所以蟹老板需要和每个人协商一个密钥，每个人互不相同，这样就能保证加密了。<br><img src="/assets/essay/https-negotiate2.png"><br>在HTTPS中，这个协商的过程一般是用非对称加密来进行的。客户端一旦得到了真的服务器公钥，往服务端传消息就是安全的。因为只有服务端的私钥才能解密公钥加密的数据。<br>但是，客户端可没那么容易得到真正的公钥，因为发送公钥的过程存在被别人调包的可能性，这就是传说中的中间人攻击。</p><h4 id="2-4、中间人攻击"><a href="#2-4、中间人攻击" class="headerlink" title="2.4、中间人攻击"></a>2.4、中间人攻击</h4><p>让我们回到情景中。<br>痞老板听闻消息，企图在协商过程通过中间人的方式截取蟹黄包配方。<br><img src="/assets/essay/https-middleman.png"><br>如图，蟹老板想告诉海绵宝宝自己的公钥，此时痞老板出现，替换了蟹老板的公钥，海绵宝宝收到一个来自痞老板的公钥并以为是蟹老板的，由此在之后的传输中痞老板便可以轻松的浏览蟹老板和海绵宝宝的所有沟通内容了。为了防止痞老板窃听，那这个协商的过程也必须加密，这样下去协商加密也要加密，……问题没有穷尽。那怎么办呢？</p><h4 id="2-5、HTTPS-数字证书"><a href="#2-5、HTTPS-数字证书" class="headerlink" title="2.5、HTTPS 数字证书"></a>2.5、HTTPS 数字证书</h4><p>现在美人鱼战士和企鹅男孩登场了，他们保证作为一个权威中间机构为大家提供认证服务，负责为大家发放统一的公钥。<br><img src="/assets/essay/https-ca.png"><br>蟹老板先将自己要传输的公钥给美人鱼战士，美人鱼战士用自己的私钥加密后返回给蟹老板。这样大家只要能通过这个公钥解密蟹老板发来的密文，提取蟹老板的公钥，就能保证这个公钥不是来自痞老板。这个时候即便痞老板想替换公钥，伪造的公钥也不能用美人鱼战士的公钥解开了。<br>这就是数字证书。服务器通过CA认证得到证书，这个证书包含CA的私钥加密后的服务器公钥，客户端用预先存储在本地的CA公钥即可解密得到服务器的公钥，从而避免公钥被替换。</p><h4 id="2-6、HTTPS-数字签名"><a href="#2-6、HTTPS-数字签名" class="headerlink" title="2.6、HTTPS 数字签名"></a>2.6、HTTPS 数字签名</h4><p>如果你是痞老板，你有什么方法可以再次窃取消息呢？<br>显然不能通过简单替换公钥来窃取了，海绵宝宝只能解开美人鱼战士颁发的证书，那我也去申请一个证书，直接替换整个证书不就可以从而替换掉公钥了吗？<br><img src="/assets/essay/https-sign.png"><br>企鹅男孩发现了这个问题，他决定在证书里面添加一些额外的信息以供验证。现在企鹅男孩颁发的证书格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：蟹堡王</span><br><span class="line">加密算法：MD5</span><br><span class="line">公钥：xxxx（已通过私钥加密，可通过公钥解密）</span><br></pre></td></tr></table></figure></p><p>海绵宝宝只要通过企鹅男孩的公钥提取到“蟹堡王”+“MD5” 计算出一个公钥，与证书内的公钥进行对比，就可以验证证书是否经过替换，如下图。<br><img src="/assets/essay/https-md5.png"><br>带有签名的证书<br><img src="/assets/essay/https-sign-md5.png"><br>对比发现证书被替换<br>虽然痞老板依旧可以截取证书，但是他却不能替换其中任何的信息，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：痞老板工厂</span><br><span class="line">加密算法：MD5</span><br><span class="line">公钥：djawdn888</span><br></pre></td></tr></table></figure></p><p>此时海绵宝宝可以发现来自不是蟹堡王而拒绝信任，并且<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">痞老板工厂 + MD5 !== djawdn888</span><br></pre></td></tr></table></figure></p><p>现在假设<code>蟹堡王+ MD4 = aaaa</code>，那只要修改公钥为aaaa不就可以通过海绵宝宝的验证了吗？痞老板的证书修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：蟹堡王</span><br><span class="line">加密算法：MD4</span><br><span class="line">公钥：aaaa</span><br></pre></td></tr></table></figure></p><p>实际上并不能，尽管可以修改公钥，但是前面提到，公钥经过企鹅男孩的私钥加密，现在海绵宝宝发现用企鹅男孩的公钥打不开了！于是发现证书已经被篡改了，从而结束通讯。 这便是数字签名的意义。</p><h4 id="2-7、小结"><a href="#2-7、小结" class="headerlink" title="2.7、小结"></a>2.7、小结</h4><p>综上，用一句话总结https：在https协议下，服务器与客户端通过非对称加密的方式协商出一个对称加密的密钥完成加密过程。其中数字证书的作用是避免公钥被替换，而数字签名的作用是校验公钥的合法性。<br>ps：权威机构的公钥是由操作系统和浏览器共同维护，预先存储在本地的。并由上可知 https 具有使用密文，安全性高的优点，同样的，存在协商过程低效，影响用户访问速度的缺点。</p><h3 id="三、握手过程"><a href="#三、握手过程" class="headerlink" title="三、握手过程"></a>三、握手过程</h3><p>明白了HTTPS的原理，握手过程就十分简单，总结如下：</p><ul><li>客户端：发送 random1 + 支持的加密算法 + SSL Version 等信息</li><li>服务端：发送 random2 + 选择的加密算法 A + 证书</li><li>客户端：验证证书 + 公钥加密的 random3</li><li>服务端：解密 random3，此时两端共有 random1，random2，random3，使用这3个随机数通过加密算法计算对称密钥即可。</li></ul><p>以上只有 random3 是加密的，所以用 random1 + 2 + 3 这3个随机数加密生成密钥。</p><h3 id="四、https-服务器"><a href="#四、https-服务器" class="headerlink" title="四、https 服务器"></a>四、https 服务器</h3><h4 id="4-1、搭建"><a href="#4-1、搭建" class="headerlink" title="4.1、搭建"></a>4.1、搭建</h4><p>这里以腾讯云为例，首先申请 SSL 证书：企业型、企业型专业版、域名型、域名型免费版、增强型、增强型专业版。如果对安全性要求不是那么高的话，则使用<code>域名型免费版</code>。审批通过后下载证书压缩包（对于中小型企业，如果服务器厂商不提供免费版，也可以在自己服务器上自建 CA 机构）。<br>获取到证书后，将<code>Nginx</code>文件夹目录下的证书文件<code>1_www.domain.com_bundle.crt</code>、私钥文件<code>2_www.domain.com.key</code>保存到同一个目录，如 <code>/etc/nginx/conf.d/ssl</code> 目录下，修改 nginx 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /etc/nginx/conf.d/ssl/1_www.domain.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/conf.d/2_www.domain.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置完成后，请先执行命令 nginx –t 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用<code>https://www.domain.com</code>来访问。</p><h4 id="4-2、自动跳转"><a href="#4-2、自动跳转" class="headerlink" title="4.2、自动跳转"></a>4.2、自动跳转</h4><p>对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。nginx 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.domain.com;</span><br><span class="line">  rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><ul><li><a href="https://juejin.im/post/5c341549e51d45524860cf99?utm_source=gold_browser_extension" target="_blank" rel="noopener">海绵宝宝也懂的HTTPS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之源码</title>
    <link href="http://blog.master-ss.cn/essay/clipboard3/"/>
    <id>http://blog.master-ss.cn/essay/clipboard3/</id>
    <published>2019-01-10T08:40:20.171Z</published>
    <updated>2019-01-10T09:24:22.664Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。<br><a id="more"></a></p><h3 id="一、clipboard-js"><a href="#一、clipboard-js" class="headerlink" title="一、clipboard.js"></a>一、clipboard.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">import ClipboardAction from &apos;./clipboard-action&apos;;</span><br><span class="line">import Emitter from &apos;tiny-emitter&apos;;</span><br><span class="line">import listen from &apos;good-listener&apos;;</span><br><span class="line"></span><br><span class="line">// 继承 tiny-emitter，存在 on、once、emit、off 方法</span><br><span class="line">class Clipboard extends Emitter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; trigger</span><br><span class="line">     * @param &#123;Object&#125; options</span><br><span class="line">     */</span><br><span class="line">    constructor(trigger, options) &#123;</span><br><span class="line">        super();</span><br><span class="line"></span><br><span class="line">        this.resolveOptions(options);</span><br><span class="line">        this.listenClick(trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义选项</span><br><span class="line">    resolveOptions(options = &#123;&#125;) &#123;</span><br><span class="line">        this.action    = (typeof options.action    === &apos;function&apos;) ? options.action    : this.defaultAction;</span><br><span class="line">        this.target    = (typeof options.target    === &apos;function&apos;) ? options.target    : this.defaultTarget;</span><br><span class="line">        this.text      = (typeof options.text      === &apos;function&apos;) ? options.text      : this.defaultText;</span><br><span class="line">        this.container = (typeof options.container === &apos;object&apos;)   ? options.container : document.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对触发器添加监听函数</span><br><span class="line">    listenClick(trigger) &#123;</span><br><span class="line">        this.listener = listen(trigger, &apos;click&apos;, (e) =&gt; this.onClick(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发器点击时触发</span><br><span class="line">    onClick(e) &#123;</span><br><span class="line">        const trigger = e.delegateTarget || e.currentTarget;</span><br><span class="line"></span><br><span class="line">        if (this.clipboardAction) &#123;</span><br><span class="line">            this.clipboardAction = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.clipboardAction = new ClipboardAction(&#123;</span><br><span class="line">            action    : this.action(trigger),</span><br><span class="line">            target    : this.target(trigger),</span><br><span class="line">            text      : this.text(trigger),</span><br><span class="line">            container : this.container,</span><br><span class="line">            trigger   : trigger,</span><br><span class="line">            emitter   : this</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 action</span><br><span class="line">    defaultAction(trigger) &#123;</span><br><span class="line">        return getAttributeValue(&apos;action&apos;, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 target</span><br><span class="line">    defaultTarget(trigger) &#123;</span><br><span class="line">        const selector = getAttributeValue(&apos;target&apos;, trigger);</span><br><span class="line"></span><br><span class="line">        if (selector) &#123;</span><br><span class="line">            return document.querySelector(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否支持 execCommand 命令</span><br><span class="line">    static isSupported(action = [&apos;copy&apos;, &apos;cut&apos;]) &#123;</span><br><span class="line">        const actions = (typeof action === &apos;string&apos;) ? [action] : action;</span><br><span class="line">        let support = !!document.queryCommandSupported;</span><br><span class="line"></span><br><span class="line">        actions.forEach((action) =&gt; &#123;</span><br><span class="line">            support = support &amp;&amp; !!document.queryCommandSupported(action);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return support;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 Text</span><br><span class="line">    defaultText(trigger) &#123;</span><br><span class="line">        return getAttributeValue(&apos;text&apos;, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用 destroy 移除事件监听，并调用 clipboardAction 的 destroy 方法</span><br><span class="line">    destroy() &#123;</span><br><span class="line">        this.listener.destroy();</span><br><span class="line"></span><br><span class="line">        if (this.clipboardAction) &#123;</span><br><span class="line">            this.clipboardAction.destroy();</span><br><span class="line">            this.clipboardAction = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取 data-clipboard-xxx 属性值</span><br><span class="line">function getAttributeValue(suffix, element) &#123;</span><br><span class="line">    const attribute = `data-clipboard-$&#123;suffix&#125;`;</span><br><span class="line"></span><br><span class="line">    if (!element.hasAttribute(attribute)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return element.getAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Clipboard;</span><br></pre></td></tr></table></figure><h3 id="二、clipboard-action-js"><a href="#二、clipboard-action-js" class="headerlink" title="二、clipboard-action.js"></a>二、clipboard-action.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">import select from &apos;select&apos;;</span><br><span class="line"></span><br><span class="line">// 执行 copy 或 cut 操作</span><br><span class="line">class ClipboardAction &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param &#123;Object&#125; options</span><br><span class="line">     */</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.resolveOptions(options);</span><br><span class="line">        this.initSelection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取属性</span><br><span class="line">    resolveOptions(options = &#123;&#125;) &#123;</span><br><span class="line">        this.action    = options.action;</span><br><span class="line">        this.container = options.container;</span><br><span class="line">        this.emitter   = options.emitter;</span><br><span class="line">        this.target    = options.target;</span><br><span class="line">        this.text      = options.text;</span><br><span class="line">        this.trigger   = options.trigger;</span><br><span class="line"></span><br><span class="line">        this.selectedText = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据 text 和 target 选择不同的策略</span><br><span class="line">    initSelection() &#123;</span><br><span class="line">        if (this.text) &#123;</span><br><span class="line">            this.selectFake();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (this.target) &#123;</span><br><span class="line">            this.selectTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个 textarea 元素，为它设置值，并选中</span><br><span class="line">    selectFake() &#123;</span><br><span class="line">        const isRTL = document.documentElement.getAttribute(&apos;dir&apos;) == &apos;rtl&apos;;</span><br><span class="line"></span><br><span class="line">        this.removeFake();</span><br><span class="line"></span><br><span class="line">        this.fakeHandlerCallback = () =&gt; this.removeFake();</span><br><span class="line">        this.fakeHandler = this.container.addEventListener(&apos;click&apos;, this.fakeHandlerCallback) || true;</span><br><span class="line"></span><br><span class="line">        this.fakeElem = document.createElement(&apos;textarea&apos;);</span><br><span class="line">        // Prevent zooming on iOS</span><br><span class="line">        this.fakeElem.style.fontSize = &apos;12pt&apos;;</span><br><span class="line">        // Reset box model</span><br><span class="line">        this.fakeElem.style.border = &apos;0&apos;;</span><br><span class="line">        this.fakeElem.style.padding = &apos;0&apos;;</span><br><span class="line">        this.fakeElem.style.margin = &apos;0&apos;;</span><br><span class="line">        // Move element out of screen horizontally</span><br><span class="line">        this.fakeElem.style.position = &apos;absolute&apos;;</span><br><span class="line">        this.fakeElem.style[ isRTL ? &apos;right&apos; : &apos;left&apos; ] = &apos;-9999px&apos;;</span><br><span class="line">        // Move element to the same position vertically</span><br><span class="line">        let yPosition = window.pageYOffset || document.documentElement.scrollTop;</span><br><span class="line">        this.fakeElem.style.top = `$&#123;yPosition&#125;px`;</span><br><span class="line"></span><br><span class="line">        this.fakeElem.setAttribute(&apos;readonly&apos;, &apos;&apos;);</span><br><span class="line">        this.fakeElem.value = this.text;</span><br><span class="line"></span><br><span class="line">        this.container.appendChild(this.fakeElem);</span><br><span class="line"></span><br><span class="line">        this.selectedText = select(this.fakeElem);</span><br><span class="line">        this.copyText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除添加的元素，只在点击后才移除，因为用户可能使用 `Ctrl+C` 来赋值当前选中的值</span><br><span class="line">    removeFake() &#123;</span><br><span class="line">        if (this.fakeHandler) &#123;</span><br><span class="line">            this.container.removeEventListener(&apos;click&apos;, this.fakeHandlerCallback);</span><br><span class="line">            this.fakeHandler = null;</span><br><span class="line">            this.fakeHandlerCallback = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.fakeElem) &#123;</span><br><span class="line">            this.container.removeChild(this.fakeElem);</span><br><span class="line">            this.fakeElem = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 选中目标元素</span><br><span class="line">    selectTarget() &#123;</span><br><span class="line">        this.selectedText = select(this.target);</span><br><span class="line">        this.copyText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在当前选中的元素上执行 copy 操作</span><br><span class="line">    copyText() &#123;</span><br><span class="line">        let succeeded;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            succeeded = document.execCommand(this.action);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (err) &#123;</span><br><span class="line">            succeeded = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.handleResult(succeeded);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发 copy 操作的回调函数</span><br><span class="line">    handleResult(succeeded) &#123;</span><br><span class="line">        this.emitter.emit(succeeded ? &apos;success&apos; : &apos;error&apos;, &#123;</span><br><span class="line">            action: this.action,</span><br><span class="line">            text: this.selectedText,</span><br><span class="line">            trigger: this.trigger,</span><br><span class="line">            clearSelection: this.clearSelection.bind(this)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将焦点从目标元素移动到触发器，并移除 selection</span><br><span class="line">    clearSelection() &#123;</span><br><span class="line">        if (this.trigger) &#123;</span><br><span class="line">            this.trigger.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.getSelection().removeAllRanges();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 action，并检测操作</span><br><span class="line">    set action(action = &apos;copy&apos;) &#123;</span><br><span class="line">        this._action = action;</span><br><span class="line"></span><br><span class="line">        if (this._action !== &apos;copy&apos; &amp;&amp; this._action !== &apos;cut&apos;) &#123;</span><br><span class="line">            throw new Error(&apos;Invalid &quot;action&quot; value, use either &quot;copy&quot; or &quot;cut&quot;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get action() &#123;</span><br><span class="line">        return this._action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 target 并判断</span><br><span class="line">    set target(target) &#123;</span><br><span class="line">        if (target !== undefined) &#123;</span><br><span class="line">            if (target &amp;&amp; typeof target === &apos;object&apos; &amp;&amp; target.nodeType === 1) &#123;</span><br><span class="line">                if (this.action === &apos;copy&apos; &amp;&amp; target.hasAttribute(&apos;disabled&apos;)) &#123;</span><br><span class="line">                    throw new Error(&apos;Invalid &quot;target&quot; attribute. Please use &quot;readonly&quot; instead of &quot;disabled&quot; attribute&apos;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (this.action === &apos;cut&apos; &amp;&amp; (target.hasAttribute(&apos;readonly&apos;) || target.hasAttribute(&apos;disabled&apos;))) &#123;</span><br><span class="line">                    throw new Error(&apos;Invalid &quot;target&quot; attribute. You can\&apos;t cut text from elements with &quot;readonly&quot; or &quot;disabled&quot; attributes&apos;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this._target = target;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                throw new Error(&apos;Invalid &quot;target&quot; value, use a valid Element&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get target() &#123;</span><br><span class="line">        return this._target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁</span><br><span class="line">    destroy() &#123;</span><br><span class="line">        this.removeFake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = ClipboardAction;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之依赖</title>
    <link href="http://blog.master-ss.cn/essay/clipboard2/"/>
    <id>http://blog.master-ss.cn/essay/clipboard2/</id>
    <published>2019-01-10T07:41:18.150Z</published>
    <updated>2019-01-10T08:05:45.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。<br><a id="more"></a></p><h3 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function select(element) &#123;</span><br><span class="line">    var selectedText;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 表单元素下拉框 --&gt;</span><br><span class="line">    if (element.nodeName === &apos;SELECT&apos;) &#123;</span><br><span class="line">        element.focus();</span><br><span class="line"></span><br><span class="line">        selectedText = element.value;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!-- input 或者 textarea --&gt;</span><br><span class="line">    else if (element.nodeName === &apos;INPUT&apos; || element.nodeName === &apos;TEXTAREA&apos;) &#123;</span><br><span class="line">        var isReadOnly = element.hasAttribute(&apos;readonly&apos;);</span><br><span class="line"></span><br><span class="line">        if (!isReadOnly) &#123;</span><br><span class="line">            element.setAttribute(&apos;readonly&apos;, &apos;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        element.select();</span><br><span class="line">        element.setSelectionRange(0, element.value.length);</span><br><span class="line"></span><br><span class="line">        if (!isReadOnly) &#123;</span><br><span class="line">            element.removeAttribute(&apos;readonly&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        selectedText = element.value;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!-- 其他 DOM 元素 --&gt;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (element.hasAttribute(&apos;contenteditable&apos;)) &#123;</span><br><span class="line">            element.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var selection = window.getSelection();</span><br><span class="line">        var range = document.createRange();</span><br><span class="line"></span><br><span class="line">        range.selectNodeContents(element);</span><br><span class="line">        selection.removeAllRanges();</span><br><span class="line">        selection.addRange(range);</span><br><span class="line"></span><br><span class="line">        selectedText = selection.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return selectedText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = select;</span><br></pre></td></tr></table></figure><p>可以看到<code>select</code>包非常精简，主要用来选中元素，并复制元素值。其中有以下知识点：</p><ul><li>如果元素是 input 或者 textarea，则调用 select api 选中元素，其中 select 方法是选中所有文本，而 setSelectionRange 这个方法可以接收起始位置，终止位置，和方向要看到选择的文本；</li><li>contenteditable 属性规定元素内容是否可编辑，可以使<code>&lt;p&gt;</code>等标签变成可编辑状态；</li><li>getSelection 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置；</li><li>createRange 返回一个 Range 对象，Range 表示包含节点和部分文本节点的文档片段；</li><li>selection().toString() 获取选中的内容</li></ul><h3 id="二、tiny-emitter"><a href="#二、tiny-emitter" class="headerlink" title="二、tiny-emitter"></a>二、tiny-emitter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">function E () &#123;</span><br><span class="line">  // Keep this empty so it&apos;s easier to inherit from</span><br><span class="line">  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.prototype = &#123;</span><br><span class="line">  on: function (name, callback, ctx) &#123;</span><br><span class="line">    var e = this.e || (this.e = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    (e[name] || (e[name] = [])).push(&#123;</span><br><span class="line">      fn: callback,</span><br><span class="line">      ctx: ctx</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  once: function (name, callback, ctx) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    function listener () &#123;</span><br><span class="line">      self.off(name, listener);</span><br><span class="line">      callback.apply(ctx, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    listener._ = callback</span><br><span class="line">    return this.on(name, listener, ctx);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emit: function (name) &#123;</span><br><span class="line">    var data = [].slice.call(arguments, 1);</span><br><span class="line">    var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice();</span><br><span class="line">    var i = 0;</span><br><span class="line">    var len = evtArr.length;</span><br><span class="line"></span><br><span class="line">    for (i; i &lt; len; i++) &#123;</span><br><span class="line">      evtArr[i].fn.apply(evtArr[i].ctx, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  off: function (name, callback) &#123;</span><br><span class="line">    var e = this.e || (this.e = &#123;&#125;);</span><br><span class="line">    var evts = e[name];</span><br><span class="line">    var liveEvents = [];</span><br><span class="line"></span><br><span class="line">    if (evts &amp;&amp; callback) &#123;</span><br><span class="line">      for (var i = 0, len = evts.length; i &lt; len; i++) &#123;</span><br><span class="line">        // 为了兼容 once</span><br><span class="line">        if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback)</span><br><span class="line">          liveEvents.push(evts[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remove event from queue to prevent memory leak</span><br><span class="line">    // Suggested by https://github.com/lazd</span><br><span class="line">    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910</span><br><span class="line"></span><br><span class="line">    (liveEvents.length)</span><br><span class="line">      ? e[name] = liveEvents</span><br><span class="line">      : delete e[name];</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = E;</span><br></pre></td></tr></table></figure><p>事件管理模型主要由 4 个函数构成：</p><ul><li>on 用于订阅事件，一个事件订阅多个触发函数</li><li>emit 用于发布事件，发布时会以此触发事件订阅的函数</li><li>once 订阅的事件只触发一次</li><li>off 取消订阅事件，支持指定取消，批量取消和全部取消</li></ul><h3 id="三、good-listener"><a href="#三、good-listener" class="headerlink" title="三、good-listener"></a>三、good-listener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 类型判断，不展开说明 --&gt;</span><br><span class="line">var is = require(&apos;./is&apos;);</span><br><span class="line">&lt;!-- 事件委托，不展开说明 --&gt;</span><br><span class="line">var delegate = require(&apos;delegate&apos;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Validates all params and calls the right</span><br><span class="line"> * listener function based on its target type.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; target</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listen(target, type, callback) &#123;</span><br><span class="line">    if (!target &amp;&amp; !type &amp;&amp; !callback) &#123;</span><br><span class="line">        throw new Error(&apos;Missing required arguments&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!is.string(type)) &#123;</span><br><span class="line">        throw new TypeError(&apos;Second argument must be a String&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!is.fn(callback)) &#123;</span><br><span class="line">        throw new TypeError(&apos;Third argument must be a Function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (is.node(target)) &#123;</span><br><span class="line">        return listenNode(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (is.nodeList(target)) &#123;</span><br><span class="line">        return listenNodeList(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (is.string(target)) &#123;</span><br><span class="line">        return listenSelector(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        throw new TypeError(&apos;First argument must be a String, HTMLElement, HTMLCollection, or NodeList&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Adds an event listener to a HTML element</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;HTMLElement&#125; node</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenNode(node, type, callback) &#123;</span><br><span class="line">    node.addEventListener(type, callback);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        destroy: function() &#123;</span><br><span class="line">            node.removeEventListener(type, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add an event listener to a list of HTML elements</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;NodeList|HTMLCollection&#125; nodeList</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenNodeList(nodeList, type, callback) &#123;</span><br><span class="line">    Array.prototype.forEach.call(nodeList, function(node) &#123;</span><br><span class="line">        node.addEventListener(type, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        destroy: function() &#123;</span><br><span class="line">            Array.prototype.forEach.call(nodeList, function(node) &#123;</span><br><span class="line">                node.removeEventListener(type, callback);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add an event listener to a selector</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String&#125; selector</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenSelector(selector, type, callback) &#123;</span><br><span class="line">    return delegate(document.body, selector, type, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = listen;</span><br></pre></td></tr></table></figure><p>可以看到<code>good-listener</code>包就是在元素上添加事件监听，并且返回对象，其含 destroy 属性，即移除事件的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之介绍</title>
    <link href="http://blog.master-ss.cn/essay/clipboard1/"/>
    <id>http://blog.master-ss.cn/essay/clipboard1/</id>
    <published>2019-01-10T06:10:00.969Z</published>
    <updated>2019-01-10T07:38:01.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。<br><a id="more"></a></p><h3 id="一、为什么使用它"><a href="#一、为什么使用它" class="headerlink" title="一、为什么使用它"></a>一、为什么使用它</h3><p>复制文字到剪切板不应该很难去实现。它不需要配置几十个步骤或者加载几百 KB 的文件。最重要的是，它不应该依赖 Flash 或其他臃肿的框架。这是 clipboard.js 诞生的原因。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clipboard --save</span><br></pre></td></tr></table></figure><p>可以通过 npm 来安装它，如果你不使用包管理，仅需要下载一个 <a href="https://github.com/zenorocha/clipboard.js/archive/master.zip" target="_blank" rel="noopener">ZIP</a> 文件。<br>首先，引入位于 dist 目录下的脚本文件，或者引入一个第三方<a href="https://github.com/zenorocha/clipboard.js/wiki/CDN-Providers" target="_blank" rel="noopener">CDN</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>然后，你需要通过传入一个<a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-selector.html#L18" target="_blank" rel="noopener">DOM 选择器</a>, <a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-node.html#L16-L17" target="_blank" rel="noopener">HTML 元素</a>, 或者 <a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-nodelist.html#L18-L19" target="_blank" rel="noopener">HTML 元素数组</a>作为参数，来实例化对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;);</span><br></pre></td></tr></table></figure></p><p>本质上，我们需要获取所有选择器匹配到的元素，并为每一个选择器设置监听事件。但仔细想想，如果有成百上千个匹配到的元素，这样做会耗费大量内存。因此，我们使用<a href="http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation" target="_blank" rel="noopener">事件代理</a>，通过一个事件监听器来取代多个事件监听。毕竟，<a href="https://twitter.com/hashtag/perfmatters" target="_blank" rel="noopener">性能是问题</a>。</p><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><p>我们正在经历一场声明式的复兴，这就是为什么我们决定利用 HTML5 data 属性 来提高可用性的原因。</p><h4 id="3-1、从另一个元素复制文本"><a href="#3-1、从另一个元素复制文本" class="headerlink" title="3.1、从另一个元素复制文本"></a>3.1、从另一个元素复制文本</h4><p>一个很常见的用例是从另一个元素复制内容。你可以给目标元素添加一个<code>data-clipboard-target</code>属性来实现这个功能。这个属性的值就是能匹配到另一个元素的选择器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Target --&gt;</span><br><span class="line">&lt;input id=&quot;foo&quot; value=&quot;https://github.com/zenorocha/clipboard.js.git&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#foo&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;assets/clippy.svg&quot; alt=&quot;Copy to clipboard&quot;&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-2、从另一个元素剪切文本"><a href="#3-2、从另一个元素剪切文本" class="headerlink" title="3.2、从另一个元素剪切文本"></a>3.2、从另一个元素剪切文本</h4><p>此外，你可以定义一个<code>data-clipboard-action</code>属性来指明你想要复制（copy）还是剪切（cut）内容。如果你省略这个属性，则默认为复制（copy）。正如你所预料的，剪切（cut）动作只在<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>元素起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Target --&gt;</span><br><span class="line">&lt;textarea id=&quot;bar&quot;&gt;Mussum ipsum cacilds...&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-action=&quot;cut&quot; data-clipboard-target=&quot;#bar&quot;&gt;</span><br><span class="line">    Cut to clipboard</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-3、从属性复制文本"><a href="#3-3、从属性复制文本" class="headerlink" title="3.3、从属性复制文本"></a>3.3、从属性复制文本</h4><p>事实上，你甚至不需要从另一个元素来复制内容。你仅需要给目标元素设置一个<code>data-clipboard-text</code>属性就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-text=&quot;Just because you can doesn&apos;t mean you should — clipboard.js&quot;&gt;</span><br><span class="line">    Copy to clipboard</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h3 id="四、事件"><a href="#四、事件" class="headerlink" title="四、事件"></a>四、事件</h3><p>如果你想要展示一些用户反馈，或者在用户复制/剪切后获取已经选择的文字，这里有个示例供你参考。我们通过触发自定义事件，例如<code>success</code>和<code>error</code>，让你可以设置监听并实现自定义逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var clipboard = new Clipboard(&apos;.btn&apos;);</span><br><span class="line"></span><br><span class="line">clipboard.on(&apos;success&apos;, function(e) &#123;</span><br><span class="line">    console.info(&apos;Action:&apos;, e.action);</span><br><span class="line">    console.info(&apos;Text:&apos;, e.text);</span><br><span class="line">    console.info(&apos;Trigger:&apos;, e.trigger);</span><br><span class="line"></span><br><span class="line">    e.clearSelection();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">clipboard.on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">    console.error(&apos;Action:&apos;, e.action);</span><br><span class="line">    console.error(&apos;Trigger:&apos;, e.trigger);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="五、高级选项"><a href="#五、高级选项" class="headerlink" title="五、高级选项"></a>五、高级选项</h3><p>如果你不想修改 HTML，我们提供了一个非常方面的命令式的 API 给你使用。你需要做的就是声明一个函数，做一些处理，并返回一个值。例如，如果你希望动态设置 target，你需要返回一个节点（Node）.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    target: function(trigger) &#123;</span><br><span class="line">        return trigger.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果你希望动态设置 text，你需要返回一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    text: function(trigger) &#123;</span><br><span class="line">        return trigger.getAttribute(&apos;aria-label&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果在 Bootstrap 模态框（Modals）中使用，或是在其他修改焦点的类库中使用，你会希望将获得焦点的元素设置为 container 属性的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    container: document.getElementById(&apos;modal&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>同样地，如果你使用单页应用，你可能想要更加精确地管理 DOM 的生命周期。你可以清理事件以及创建的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var clipboard = new Clipboard(&apos;.btn&apos;);</span><br><span class="line">clipboard.destroy();</span><br></pre></td></tr></table></figure></p><h3 id="六、浏览器支持"><a href="#六、浏览器支持" class="headerlink" title="六、浏览器支持"></a>六、浏览器支持</h3><p>这个库依赖于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection" target="_blank" rel="noopener">Selection</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">execCommand</a> 的 API。前者 <a href="http://caniuse.com/#search=selection" target="_blank" rel="noopener">兼容所有的浏览器</a>，后者兼容以下浏览器。<br><img src="/assets/essay/clipboard.png" alt="通用的占位符缩略图"><br>好消息是，如果你需要支持旧浏览器，clipboard.js 可以优雅降级。你所要做的就是在<code>success</code>事件触发时提示用户“已复制！”，<code>error</code>事件触发时提示用户“按 Ctrl+C 复制文字”（此时用户要复制的文字已经选择了）。你也可以通过运行<code>Clipboard.isSupported()</code>来检查浏览器是否支持 clipboard.js，如果不支持，你可以隐藏复制/剪切按钮。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 之博客建站</title>
    <link href="http://blog.master-ss.cn/essay/hexo/"/>
    <id>http://blog.master-ss.cn/essay/hexo/</id>
    <published>2018-12-23T02:37:39.539Z</published>
    <updated>2018-12-23T03:16:02.853Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结分享下我用 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo</a> 建站的过程。<br><a id="more"></a></p><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="1-2、建站"><a href="#1-2、建站" class="headerlink" title="1.2、建站"></a>1.2、建站</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装全局依赖 --&gt;</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">&lt;!-- 初始化工程项目 --&gt;</span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line">&lt;!-- 进入目录 --&gt;</span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装依赖 --&gt;</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启本地服务 --&gt;</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译生成静态文件 --&gt;</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">&lt;!-- 清除缓存 --&gt;</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><h4 id="2-1、安装主题"><a href="#2-1、安装主题" class="headerlink" title="2.1、安装主题"></a>2.1、安装主题</h4><p>默认主题是 landscape，这里选择 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> 主题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装主题 --&gt;</span><br><span class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装主题依赖包 --&gt;</span><br><span class="line">npm install hexo-renderer-less --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-helper-qrcode --save</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启分类页 --&gt;</span><br><span class="line">hexo new page categories</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改 hexo/source/categories/index.md 数据 --&gt;</span><br><span class="line">layout: categories</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h4 id="2-2、配置主题"><a href="#2-2、配置主题" class="headerlink" title="2.2、配置主题"></a>2.2、配置主题</h4><p>更详细配置信息参考<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">官方主题文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编辑站点配置文件，/_config.yml，启用主题，且配置基础信息 --&gt;</span><br><span class="line">theme: indigo</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改访问链接和目录格式 --&gt;</span><br><span class="line">url: http://blog.master-ss.cn</span><br><span class="line">permalink: :title/</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置主题 /themes/indigo/_config.yml --&gt;</span><br><span class="line">1、配置菜单</span><br><span class="line">2、配置 favicon</span><br><span class="line">3、配置头像</span><br><span class="line">4、配置 email</span><br><span class="line">5、替换打赏图片</span><br><span class="line">6、配置 ‘ICP 备案号’</span><br><span class="line">7、修改留言信息 postMessage</span><br><span class="line">8、修改版权起始年份 since_year</span><br><span class="line">9、启用 valine 评论插件</span><br></pre></td></tr></table></figure></p><h4 id="2-3、部署"><a href="#2-3、部署" class="headerlink" title="2.3、部署"></a>2.3、部署</h4><p>截止目前我们就可以在本地进行文档的书写了，但是想要 hexo d 就部署到 git 上还是不够，需要进行以下操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编辑站点配置文件，/_config.yml，配置部署仓库、类型和分支 --&gt;</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/zss007/blog.git</span><br><span class="line">  branch: gh-pages</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装部署依赖包 --&gt;</span><br><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure></p><h4 id="2-4、注意事项"><a href="#2-4、注意事项" class="headerlink" title="2.4、注意事项"></a>2.4、注意事项</h4><p>由于我们是使用 <code>git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</code> 方式进行主题安装，所以我们在提交代码到 git 时 <code>/themes/indigo</code> 文件夹中的所有文件均不会被提交。所以如果想刚才修改配置的主题信息同样提交到 git 上的话，可以 <code>cd /themes/indigo</code>，如果移除主题的仓库信息，即 <code>rm -rf .git</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结分享下我用 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt; 建站的过程。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之 H5 终端适配</title>
    <link href="http://blog.master-ss.cn/css/flexible/"/>
    <id>http://blog.master-ss.cn/css/flexible/</id>
    <published>2018-12-22T08:58:39.151Z</published>
    <updated>2018-12-22T14:21:24.023Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要是研究手淘团队的适配方案 amfe-flexible，及<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">源码</a>解析。<br><a id="more"></a></p><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-1、css-中的-1px-并不等于设备的-1px"><a href="#1-1、css-中的-1px-并不等于设备的-1px" class="headerlink" title="1.1、css 中的 1px 并不等于设备的 1px"></a>1.1、css 中的 1px 并不等于设备的 1px</h4><p>在 css 中我们一般使用 px 作为单位，在桌面浏览器中 css 的 1 个像素往往都是对应着电脑屏幕的 1 个物理像素，这可能会造成我们的一个错觉，那就是 css 中的像素就是设备的物理像素。但实际情况却并非如此，css 中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css 中的 1px 所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如 iphone3，它的分辨率为 320x480，在 iphone3 上，一个 css 像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从 iphone4 开始，苹果公司便推出了所谓的 Retina 屏，分辨率提高了一倍，变成 640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个 css 像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为 ldpi、mdpi、hdpi、xhdpi 等不同的等级，分辨率也是五花八门，安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><h4 id="1-2、devicePixelRatio"><a href="#1-2、devicePixelRatio" class="headerlink" title="1.2、devicePixelRatio"></a>1.2、devicePixelRatio</h4><p>在移动端浏览器中以及某些桌面浏览器中，window 对象有一个 devicePixelRatio 属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css 中的 px 就可以看做是设备的独立像素，所以通过 devicePixelRatio，我们可以知道该设备上一个 css 像素代表多少个物理像素。例如，在 Retina 屏的iphone上，devicePixelRatio 的值为 2，也就是说 1 个 css 像素相当于 2 个物理像素。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h5 id="2-1、源码"><a href="#2-1、源码" class="headerlink" title="2.1、源码"></a>2.1、源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(function flexible (window, document) &#123;</span><br><span class="line">  var docEl = document.documentElement</span><br><span class="line">  var dpr = window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">  // adjust body font size</span><br><span class="line">  function setBodyFontSize () &#123;</span><br><span class="line">    if (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize = (12 * dpr) + &apos;px&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  // set 1rem = viewWidth / 10</span><br><span class="line">  function setRemUnit () &#123;</span><br><span class="line">    var rem = docEl.clientWidth / 10</span><br><span class="line">    docEl.style.fontSize = rem + &apos;px&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  // reset rem unit on page resize</span><br><span class="line">  window.addEventListener(&apos;resize&apos;, setRemUnit)</span><br><span class="line">  window.addEventListener(&apos;pageshow&apos;, function (e) &#123;</span><br><span class="line">    if (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // detect 0.5px supports</span><br><span class="line">  if (dpr &gt;= 2) &#123;</span><br><span class="line">    var fakeBody = document.createElement(&apos;body&apos;)</span><br><span class="line">    var testElement = document.createElement(&apos;div&apos;)</span><br><span class="line">    testElement.style.border = &apos;.5px solid transparent&apos;</span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    if (testElement.offsetHeight === 1) &#123;</span><br><span class="line">      docEl.classList.add(&apos;hairlines&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure><h5 id="2-2、源码分析"><a href="#2-2、源码分析" class="headerlink" title="2.2、源码分析"></a>2.2、源码分析</h5><ul><li>setBodyFontSize 用来设置 body 的 fontSize，值为 (12 * dpr) + ‘px’</li><li>setRemUnit 用来设置 document.documentElement 即 html 标签的 fontSize，值为 clientWidth 的 1/10</li><li>resize、pageshow 在窗口大小调整或<a href="http://www.runoob.com/jsref/event-onpageshow.html" target="_blank" rel="noopener">从缓存中载入页面</a>时，重新调用 setRemUnit</li></ul><h5 id="2-3、-5px-方案"><a href="#2-3、-5px-方案" class="headerlink" title="2.3、.5px 方案"></a>2.3、.5px 方案</h5><p>2014 年的 WWDC 大会中，Ted O’Conor 在分享 “设计响应的Web体验” 主题时提到关于 Retina Hairlines 一词，也就是 Retina 极细的线：在 Retina 屏上仅仅显示 1 物理像素的边框。<br>amfe-flexible 的源码中，在页面上添加 div 元素，设置边框为 0.5px，并判断 offsetHeight 是否为 1 来判断是否支持 .5px，即如果支持 .5px 的话，那么在其 html 标签上添加 hairlines 类。这样就可以在写样式时进行 ”渐进增强“，即在支持 .5px 时使用其来显示极细的线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这节主要是研究手淘团队的适配方案 amfe-flexible，及&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;解析。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之面对对象</title>
    <link href="http://blog.master-ss.cn/js/extend/"/>
    <id>http://blog.master-ss.cn/js/extend/</id>
    <published>2018-10-14T14:06:31.000Z</published>
    <updated>2018-10-14T14:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。<br><a id="more"></a></p><h3 id="一、类的声明和实例化"><a href="#一、类的声明和实例化" class="headerlink" title="一、类的声明和实例化"></a>一、类的声明和实例化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 类的声明</span><br><span class="line">function Animal() &#123;</span><br><span class="line">    this.name = &apos;name&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6 中的 class 声明</span><br><span class="line">class Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &apos;name&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类的实例化</span><br><span class="line">console.log(new Animal(), new Animal2())</span><br></pre></td></tr></table></figure><h3 id="二、构造函数继承"><a href="#二、构造函数继承" class="headerlink" title="二、构造函数继承"></a>二、构造函数继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.say = function () &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  Parent1.call(this);</span><br><span class="line">  this.type = &apos;child1&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Child1());  // Child1 &#123;name: &quot;parent1&quot;, type: &quot;child1&quot;&#125;</span><br><span class="line">console.log(new Child1().say());  // Uncaught TypeError: xxx say is not a function</span><br></pre></td></tr></table></figure><p>优点：继承了 Parent1 的 name 属性；<br>缺点：没有继承 Parent1 原型链上的方法。</p><h3 id="二、原型链方法继承"><a href="#二、原型链方法继承" class="headerlink" title="二、原型链方法继承"></a>二、原型链方法继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent2() &#123;</span><br><span class="line">  this.name = &apos;parent2&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent2.prototype.say = function () &#123;</span><br><span class="line">  console.log(&apos;Parent2 say&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child2() &#123;</span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child2.prototype = new Parent2();</span><br><span class="line"></span><br><span class="line">var s1 = new Child2();</span><br><span class="line">s1.say();  //P arent2 say</span><br><span class="line">console.log(s1.name, s1.type); // parent2 child2</span><br><span class="line">var s2 = new Child2();</span><br><span class="line">s1.play.push(4);</span><br><span class="line">console.log(s1.play, s2.play);  // [1, 2, 3, 4]、[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>优点：不仅继承了 Parent2 的 name、play 属性而且继承了其原型链上的方法；<br>缺点：由于将 Parent2 的实例作为 Child2 的原型，导致所有 Child2 实例共享 Parent2 的属性方法，其中一个 Child2 实例改变了原型链上 Parent2 的实例属性，其他实例会受到影响跟着改变。</p><h3 id="三、组合方法继承"><a href="#三、组合方法继承" class="headerlink" title="三、组合方法继承"></a>三、组合方法继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3 () &#123;</span><br><span class="line">  Parent3.call(this);</span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line">var s4 = new Child3();</span><br><span class="line">s3.play.push(4);</span><br><span class="line">console.log(s3.play, s4.play); // [1, 2, 3, 4]、[1, 2, 3]</span><br></pre></td></tr></table></figure><p>优点：避免了原型链方法中出现的实例间相互影响(调用 Parent3.call(this) 使得 Child3 实例上有 play 属性，不必找到原型链上)；<br>缺点：每次得到一个 Child3 实例，都会调用两次 Parent3 函数。</p><h3 id="四、组合方法-优化一"><a href="#四、组合方法-优化一" class="headerlink" title="四、组合方法(优化一)"></a>四、组合方法(优化一)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent4 () &#123;</span><br><span class="line">  this.name = &apos;parent4&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child4 () &#123;</span><br><span class="line">  Parent4.call(this);</span><br><span class="line">  this.type = &apos;child4&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child4.prototype = Parent4.prototype;</span><br><span class="line"></span><br><span class="line">var s5 = new Child4();</span><br><span class="line">var s6 = new Child4();</span><br><span class="line">console.log(s5); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;</span><br><span class="line">console.log(s6); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;</span><br><span class="line">console.log(s5 instanceof Child4, s5 instanceof Parent4); // true true</span><br><span class="line">console.log(s5.constructor); // Parent4() &#123;this.name = &apos;parent4&apos;;this.play = [1, 2, 3];&#125;</span><br></pre></td></tr></table></figure><p>优点：避免了 Parent4 重复调用问题；<br>缺点：Child4 实例的构造函数不是 Child4，而是 Parent4(其实这不是优化带来的问题，优化前同样存在这个问题,赋值后 child 上的 constructor 只能在原型链上查找)</p><h3 id="五、组合方法-优化二"><a href="#五、组合方法-优化二" class="headerlink" title="五、组合方法(优化二)"></a>五、组合方法(优化二)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent5 () &#123;</span><br><span class="line">  this.name = &apos;parent5&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child5 () &#123;</span><br><span class="line">  Parent5.call(this);</span><br><span class="line">  this.type = &apos;child5&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child5.prototype = Object.create(Parent5.prototype);</span><br><span class="line">Child5.prototype.constructor = Child5;</span><br><span class="line"></span><br><span class="line">var s7 = new Child5();</span><br><span class="line">console.log(s7 instanceof Child5, s7 instanceof Parent5); //true true</span><br><span class="line">console.log(s7.constructor); //Child5() &#123;Parent5.call(this);this.type = &apos;child5&apos;;&#125;</span><br></pre></td></tr></table></figure><p>优点：Child5 实例的构造函数是 Child5(这里采用 Object.create 方法而不是直接 Parent4.prototype 赋值，直接赋值会影响到 Parent5 实例的构造函数)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之原型链</title>
    <link href="http://blog.master-ss.cn/js/prototype/"/>
    <id>http://blog.master-ss.cn/js/prototype/</id>
    <published>2018-10-14T07:42:12.000Z</published>
    <updated>2018-10-14T15:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 的原型有好好的研究过，现在重新捡起来整理下。<br><a id="more"></a></p><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><h5 id="1-1、对面字向量-new-Object"><a href="#1-1、对面字向量-new-Object" class="headerlink" title="1.1、对面字向量 | new Object"></a>1.1、对面字向量 | new Object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;name:&apos;o1&apos;&#125;</span><br><span class="line">var o11 = new Object(&#123;name:&apos;o11&apos;&#125;)</span><br></pre></td></tr></table></figure><h5 id="1-2、new-创建"><a href="#1-2、new-创建" class="headerlink" title="1.2、new 创建"></a>1.2、new 创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var M = function()&#123;this.name=&apos;o2&apos;&#125;</span><br><span class="line">var o2 = new M()</span><br></pre></td></tr></table></figure><h5 id="1-3、Object-create"><a href="#1-3、Object-create" class="headerlink" title="1.3、Object.create()"></a>1.3、Object.create()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var P = &#123;name:&apos;o3&apos;&#125;</span><br><span class="line">var o3 = Object.create(P)</span><br></pre></td></tr></table></figure><h3 id="二、proto"><a href="#二、proto" class="headerlink" title="二、proto"></a>二、<strong>proto</strong></h3><p>JS 的原始数据类型有六种：undefined、null、boolean、string、number、Symbol。引用类型通常叫做类，常见有：array、object 等。引用类型 object 的每个实例称之为对象，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则<code>__proto__</code>，通过它可以从中继承原型对象的属性，原型是 JavaScript 中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array();</span><br><span class="line">console.log(&apos;prototype&apos;, a.__proto__ === Array.prototype); // true</span><br></pre></td></tr></table></figure></p><p>Array.prototype 本身也是一个对象，也有继承的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__.__proto__ === Object.prototype  // true</span><br><span class="line">// 等同于 </span><br><span class="line">Array.prototype.__proto__ === Object.prototype  // true</span><br></pre></td></tr></table></figure></p><p>这就说明，array 本身也是继承自 object，而 object 的原型则是指向原始类型 null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__.__proto__.__proto__ === null  // true</span><br><span class="line">// 等同于 </span><br><span class="line">Object.prototype.__proto__ === null  // true</span><br></pre></td></tr></table></figure></p><p><img src="/assets/js/proto1.png"><br>除了使用<code>__proto__</code>方法访问对象的原型，还可以通过 Object.getPrototypeOf 方法来获取对象的原型，以及通过<br>Object.setPrototypeOf 方法来重写对象的原型。值得注意的是，按照语言的标准，<code>__proto__</code>属性只有浏览器才能部署，其他环境可以没有这个属性，而且前后的两根下划线表示它本地是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 Object.getPrototypeOf 和 Object.setPrototypeOf，进行原型对象的读写操作。这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来的更加形象，而且容易理解。</p><h3 id="三、prototype"><a href="#三、prototype" class="headerlink" title="三、prototype"></a>三、prototype</h3><p>函数作为 JavaScript 中的一等公民，它既是函数又是对象，函数的原型指向 Function.prototype。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Foo = function() &#123;&#125;</span><br><span class="line">Foo.__proto__ === Function.prototype // true</span><br></pre></td></tr></table></figure></p><p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有 prototype 属性。通过该函数构造的实例对象，其原型指针<code>__proto__</code><br>会指向该函数的 prototype 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Foo();</span><br><span class="line">a.__proto__ === Foo.prototype; // true</span><br></pre></td></tr></table></figure></p><p>而函数的 prototype 属性，本身是一个由 object 构造的实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">// prototype 属性很特殊，它还有一个隐式的 constructor，指向了构造函数本身。</span><br><span class="line">Foo.prototype.constructor === Foo; // true</span><br><span class="line">a.constructor === Foo; // true</span><br><span class="line">a.constructor === Foo.prototype.constructor; // true</span><br></pre></td></tr></table></figure></p><p><img src="/assets/js/proto2.png"></p><h3 id="四、原型链"><a href="#四、原型链" class="headerlink" title="四、原型链"></a>四、原型链</h3><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，如此就构造了原型链的基本概念。<br>“原型链”的作用在于，当读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的 Object.prototype 还是找不到，则返回 undefined。</p><h3 id="五、判断方法"><a href="#五、判断方法" class="headerlink" title="五、判断方法"></a>五、判断方法</h3><p>原始数据类型一般使用 typeof 来判断（两种情况下回返回 undefined：1、变量没有声明；2、变量为 undefined）。</p><ul><li>typeof null 返回 object，其他引用类型均返回 object。</li><li>instanceof 判断是否由某个构造函数创建，返回 boolean 类型值（只要处在原型链上就返回 true，可使用 <code>__proto__.constructor</code>准确返回构造函数）。</li><li>Object.isPrototypeOf() 只要某个对象处在原型链上，isProtypeOf 都返回 true</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Bar = function() &#123;&#125;</span><br><span class="line">var b = new Bar();</span><br><span class="line">b instanceof Bar // true</span><br><span class="line">b instanceof Object // true</span><br><span class="line">b.__proto__.constructor // ƒ Bar() &#123;&#125;</span><br><span class="line">Bar.prototype.isPrototypeOf(b) // true</span><br><span class="line">Object.prototype.isPrototypeOf(Bar) // true</span><br></pre></td></tr></table></figure><p>要注意，实例 b 的原型是 Bar.prototype 而不是 Bar。<br><img src="/assets/js/proto3.png"><br>从上图中，能看到一个有趣的地方。<code>Function.prototype.__proto__</code>指向了 Object.prototype，这说明Function.prototype 是一个 Object 实例，那么应当是先有的 Object 再有 Function。但是<code>Object.prototype.constructor.__proto__</code>又指向了 Function.prototype。这样看来，没有 Function，Object 也不能创建实例。 这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的 Object 还是先有的 Function 呢？ </p><h3 id="六、Object-create"><a href="#六、Object-create" class="headerlink" title="六、Object.create"></a>六、Object.create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Point()&#123;&#125;;</span><br><span class="line">var Circle = Object.create(Point);</span><br><span class="line">console.log(Circle.__proto__ === Point); // true</span><br><span class="line">console.log(Circle.__proto__ === Point.prototype); // false</span><br></pre></td></tr></table></figure><p>使用指定的原型对象和其属性创建了一个新的对象，在例子中实例 Circle 的原型指向 Point。</p><h3 id="七、new-运算符"><a href="#七、new-运算符" class="headerlink" title="七、new 运算符"></a>七、new 运算符</h3><p>使用 new 运算符创建对象过程如下：</p><ul><li>7.1、一个新对象被创建，他继承自 foo.prototype</li><li>7.2、构造函数 foo 被执行，执行的时候相应的传参会被传入，同时上下文（this）会被指定为这个新实例，new foo 等同于 new foo()，只能用在不传递任何参数的情况</li><li>7.3、如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果，如果构造函数没有返回对象，那么 new 出来的结果是步骤 7.1 创建的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var new2 = function (func) &#123;</span><br><span class="line">  var o = Object.create(func.prototype)</span><br><span class="line">  var k = func.call(o)</span><br><span class="line">  if (typeof k === &apos;object&apos;) &#123;</span><br><span class="line">    return k</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return o</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 的原型有好好的研究过，现在重新捡起来整理下。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>网络之 http 协议</title>
    <link href="http://blog.master-ss.cn/essay/http/"/>
    <id>http://blog.master-ss.cn/essay/http/</id>
    <published>2018-10-14T06:44:09.000Z</published>
    <updated>2019-01-10T06:04:38.979Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。<br><a id="more"></a></p><h3 id="一、http-协议特点"><a href="#一、http-协议特点" class="headerlink" title="一、http 协议特点"></a>一、http 协议特点</h3><ul><li>简单快速</li><li>灵活</li><li>无状态</li><li>无连接</li></ul><h3 id="二、报文组成部分"><a href="#二、报文组成部分" class="headerlink" title="二、报文组成部分"></a>二、报文组成部分</h3><h4 id="2-1、请求报文"><a href="#2-1、请求报文" class="headerlink" title="2.1、请求报文"></a>2.1、请求报文</h4><ul><li>请求行：http 方法、页面地址、http 协议以及版本；</li><li>请求头</li><li>空行：隔开请求头和请求体；</li><li>请求体</li></ul><h4 id="2-2、响应报文"><a href="#2-2、响应报文" class="headerlink" title="2.2、响应报文"></a>2.2、响应报文</h4><ul><li>状态行：http 协议以及版本号、http 状态码；</li><li>响应头</li><li>空行：隔开响应头和响应体；</li><li>响应体</li></ul><h3 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h3><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获取报文首部</li></ul><h3 id="四、GET-amp-POST"><a href="#四、GET-amp-POST" class="headerlink" title="四、GET &amp; POST"></a>四、GET &amp; POST</h3><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</li><li>GET 产生的 URL 地址可以被收藏，而 POST 不可以</li><li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</li><li>GET 请求参数会被完整的保留在浏览器历史记录里，而 POST 中的参数不会被保留</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li></ul><h3 id="五、状态码"><a href="#五、状态码" class="headerlink" title="五、状态码"></a>五、状态码</h3><ul><li>1XX：信息相关</li><li>2XX：成功 204 no content</li><li>3XX：重定向 301 304</li><li>4XX：客户端错误 401 403 404</li><li>5XX：服务器错误 500</li></ul><h3 id="持久链接-amp-管线化"><a href="#持久链接-amp-管线化" class="headerlink" title="持久链接 &amp; 管线化"></a>持久链接 &amp; 管线化</h3><ul><li>持久链接使用 keep-alive，不用每次都重新建立一次连接，需要 http 1.1</li><li>通常 keep-alive 是 Q1 -&gt; R1 -&gt; Q2 -&gt; R2，而管线化后是 Q1 -&gt; Q2 -&gt; R1 -&gt; R2，需要通过持久连接完成且要求服务端支持</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之类型转换</title>
    <link href="http://blog.master-ss.cn/js/type/"/>
    <id>http://blog.master-ss.cn/js/type/</id>
    <published>2018-10-13T03:13:41.000Z</published>
    <updated>2018-10-13T03:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 基础常考内容，一定要融会贯通。<br><a id="more"></a></p><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>JS 中有 7 中数据类型：<br>原始数据类型： Null、Boolean、String、Number、Symbol、Undefined<br>复合数据类型： Object</p><h3 id="二、显式类型转换"><a href="#二、显式类型转换" class="headerlink" title="二、显式类型转换"></a>二、显式类型转换</h3><p>先说明下面几个函数：<br>valueOf(): 将该对象原始值返回<br>toString(): 将该对象原始值以字符串返回</p><ul><li><p>Number 转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 基本数据转换</span><br><span class="line">Number(1) // 数字： 数字 -&gt; 数字</span><br><span class="line">Number(&apos;123&apos;) // 字符串： 纯数字 -&gt; 数字，不是纯数字 -&gt; NaN，空字符串 -&gt; 0</span><br><span class="line">Number(true) // 布尔值： true -&gt; 1，false -&gt; 0</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line">Number(null) // 0</span><br><span class="line">// 复合类型数据转换</span><br><span class="line">// 先调用 valueOf，如果输出为基本类型，则调用 Number，如果为复合类型，继续调用 toString，如果还不是基本数据类型就报错，如果是则调用 Number</span><br></pre></td></tr></table></figure></li><li><p>String 转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// String() 很简单，就是将这些基本类型都变成字符串：</span><br><span class="line">// 123 -&gt; &apos;123&apos;</span><br><span class="line">// true -&gt; &apos;true&apos;</span><br><span class="line">// undefined -&gt; &apos;undefined&apos;</span><br><span class="line">// null -&gt; &apos;null&apos;</span><br><span class="line">// 复合类型转换</span><br><span class="line">// 先调用 toString，如果输出为基本类型，则调用 String，如果为复合类型，继续调用 valueOf，如果还不是基本数据类型就报错，如果是则调用 String</span><br></pre></td></tr></table></figure></li><li><p>Boolean 转换<br>+0、-0、undefined、null、’’、NaN -&gt; false，其余都为 true</p></li></ul><h3 id="三、显式类型转换"><a href="#三、显式类型转换" class="headerlink" title="三、显式类型转换"></a>三、显式类型转换</h3><ul><li>四则运算</li><li>判断语句</li><li>Native 调用: 比如说 console.log()、alert()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Boolean()</span><br><span class="line">![]  // false</span><br><span class="line">!![] // true</span><br><span class="line">!&#123;&#125;  // false</span><br><span class="line">!!&#123;&#125; // true</span><br><span class="line">[]+[] // &quot;&quot;，调用 String 处理 []</span><br><span class="line">[]+1 // &quot;1&quot;，调用 String 处理 []</span><br><span class="line">&#123;&#125;+&#123;&#125; // &quot;[object Object][object Object]&quot;，这里 chrome 和 firefox 解释不同</span><br><span class="line">&#123;&#125;+[] // 0，这里 &#123;&#125; 被当前代码块，不做任何处理，然后调用 Number 处理 []</span><br><span class="line">[]+&#123;&#125; // &quot;[object Object]&quot;，调用 String 处理 [] 和 &#123;&#125;</span><br><span class="line">1+&#123;&#125; // &quot;1[object Object]&quot;，调用 &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 基础常考内容，一定要融会贯通。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之 DOM 事件</title>
    <link href="http://blog.master-ss.cn/js/dom/"/>
    <id>http://blog.master-ss.cn/js/dom/</id>
    <published>2018-10-13T02:16:29.000Z</published>
    <updated>2018-10-13T02:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML DOM 允许 JavaScript 对 HTML 事件作出反应。<br><a id="more"></a></p><h3 id="一、DOM-事件级别"><a href="#一、DOM-事件级别" class="headerlink" title="一、DOM 事件级别"></a>一、DOM 事件级别</h3><ul><li>DOM0 级：DOM0 级事件就是将一个函数赋值给一个事件处理属性，element.onclick=function(){}</li><li>DOM1 级：没有与事件相关的东西</li><li>DOM2 级：DOM2 级事件定义了 addEventListener 和 removeEventListener 两个方法，分别用来绑定和解绑事件，element.addEventListener(‘click’,function(){},false)</li><li>DOM3 级：DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，element.addEventListener(‘keyup’,function(){},false)</li></ul><h3 id="二、DOM-事件模型-amp-事件流"><a href="#二、DOM-事件模型-amp-事件流" class="headerlink" title="二、DOM 事件模型 &amp; 事件流"></a>二、DOM 事件模型 &amp; 事件流</h3><ul><li>冒泡：从当前元素到最外层元素</li><li>捕获：从最外层元素到目标元素</li><li>事件流：捕获 -&gt; 目标阶段 -&gt; 冒泡</li></ul><h3 id="三、描述-Dom-事件流捕获的具体流程"><a href="#三、描述-Dom-事件流捕获的具体流程" class="headerlink" title="三、描述 Dom 事件流捕获的具体流程"></a>三、描述 Dom 事件流捕获的具体流程</h3><ul><li>window - document - html - body - … - 目标元素</li><li>获取 html 标签：document.documentElement</li></ul><h3 id="四、Event-对象常见应用"><a href="#四、Event-对象常见应用" class="headerlink" title="四、Event 对象常见应用"></a>四、Event 对象常见应用</h3><ul><li>e.preventDefault()</li><li>e.stopPropagation()</li><li>e.target: 获取触发事件的元素</li><li>e.currentTarget: 指的是绑定事件的元素</li><li>e.stopImmediatePropagation: 事件响应优先级</li></ul><h3 id="五、自定义事件"><a href="#五、自定义事件" class="headerlink" title="五、自定义事件"></a>五、自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const eve = new Event(&apos;custom&apos;);</span><br><span class="line">ev.addEventListener(&apos;custom&apos;, () =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">ev.dispathEvent(eve);</span><br><span class="line"></span><br><span class="line">// Event 不足，只能指定事件名，如果要传参数，可以使用 CustomEvent，如：</span><br><span class="line">var obj = document</span><br><span class="line">// 添加一个适当的事件监听器</span><br><span class="line">obj.addEventListener(&quot;cat&quot;, function (e) &#123; console.log(e.detail) &#125;)</span><br><span class="line">// 创建并分发事件</span><br><span class="line">var event = new CustomEvent(&quot;cat&quot;, &#123; &quot;detail&quot;: &#123; &quot;hazcheeseburger&quot;: true &#125; &#125;)</span><br><span class="line">obj.dispatchEvent(event)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML DOM 允许 JavaScript 对 HTML 事件作出反应。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之盒模型及 BFC</title>
    <link href="http://blog.master-ss.cn/css/boxer/"/>
    <id>http://blog.master-ss.cn/css/boxer/</id>
    <published>2018-10-13T01:55:58.000Z</published>
    <updated>2018-10-13T02:11:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 盒模型是 CSS 的基石，非常重要的一块内容。<br><a id="more"></a></p><h3 id="一、盒模型基本概念"><a href="#一、盒模型基本概念" class="headerlink" title="一、盒模型基本概念"></a>一、盒模型基本概念</h3><ul><li>margin + border + padding + content</li><li>标准模型： 计算内容宽度时 width = content width，高度计算相同</li><li>IE 模型： 计算内容宽度时 width = content + padding + border</li><li>box-sizing: border-box（IE 模型）、content-box（标准模型）</li></ul><h3 id="二、JS-获取盒模型的宽高"><a href="#二、JS-获取盒模型的宽高" class="headerlink" title="二、JS 获取盒模型的宽高"></a>二、JS 获取盒模型的宽高</h3><ul><li>dom.style.width/height: 只能取到内联样式</li><li>dom.currentStyle.width/height: 拿到计算后的宽高，但只有 IE 支持</li><li>window.getComputedStyle(dom).width/height: 拿到计算后的宽高，兼容所有浏览器</li><li>dom.getBoundingClientRect().width/height: 拿到四条边相对左边上边的距离，然后获取宽高</li></ul><h3 id="三、边距重叠"><a href="#三、边距重叠" class="headerlink" title="三、边距重叠"></a>三、边距重叠</h3><p>父子边距重叠、兄弟边距重叠、空元素边距重叠(自身上下边距重叠)，取最大值</p><h3 id="四、BFC"><a href="#四、BFC" class="headerlink" title="四、BFC"></a>四、BFC</h3><h5 id="4-1、块级格式化上下文，其原理"><a href="#4-1、块级格式化上下文，其原理" class="headerlink" title="4.1、块级格式化上下文，其原理"></a>4.1、块级格式化上下文，其原理</h5><ul><li>在同一个 BFC 元素内部垂直方向发生边距重叠</li><li>BFC 区域不会与浮动元素 box 重叠</li><li>独立容器，内外互不影响</li><li>计算 BFC 高度，浮动元素参与计算</li></ul><h5 id="4-2、创建-BFC"><a href="#4-2、创建-BFC" class="headerlink" title="4.2、创建 BFC"></a>4.2、创建 BFC</h5><ul><li>position的值不为 static 或者 relative</li><li>float 不为 none</li><li>display 为 table 相关</li><li>overflow 不为 visible</li></ul><h5 id="4-3、BFC-实例"><a href="#4-3、BFC-实例" class="headerlink" title="4.3、BFC 实例"></a>4.3、BFC 实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;section id=&quot;sec&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #sec &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background: #f00;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .child &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h5 id="4-4、BFC-应用"><a href="#4-4、BFC-应用" class="headerlink" title="4.4、BFC 应用"></a>4.4、BFC 应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BFC 垂直方向边距重叠 --&gt;</span><br><span class="line">&lt;section id=&quot;margin&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #margin &#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #margin&gt;p &#123;</span><br><span class="line">            margin: 5px auto 25px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;p&gt;垂直 1&lt;/p&gt;</span><br><span class="line">    &lt;!-- 创建一个 BFC 来消除边距重合 --&gt;</span><br><span class="line">    &lt;div style=&quot;overflow: hidden;&quot;&gt;</span><br><span class="line">        &lt;p&gt;垂直 2&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;垂直 3&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- BFC 不与 float 重叠 --&gt;</span><br><span class="line">&lt;section id=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #layout .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #layout .right &#123;</span><br><span class="line">            height: 110px;</span><br><span class="line">            background: #ccc;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;float left&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;float right&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- BFC 子元素即使是 float 也会参与高度计算 --&gt;</span><br><span class="line">&lt;section id=&quot;float&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #float &#123;</span><br><span class="line">            background: red;</span><br><span class="line">            overflow: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #float .float &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            font-size: 25px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;float&quot;&gt;我是浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 盒模型是 CSS 的基石，非常重要的一块内容。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之页面布局二</title>
    <link href="http://blog.master-ss.cn/css/layout2/"/>
    <id>http://blog.master-ss.cn/css/layout2/</id>
    <published>2018-10-13T01:43:17.000Z</published>
    <updated>2018-10-13T01:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。<br><a id="more"></a></p><h3 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h3><p>三栏布局：要求：上下高度固定，中间自适应。先设置初始化样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html,</span><br><span class="line">body,</span><br><span class="line">section &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、绝对定位布局"><a href="#二、绝对定位布局" class="headerlink" title="二、绝对定位布局"></a>二、绝对定位布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绝对定位解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container absolute&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .absolute &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute div &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .top &#123;</span><br><span class="line">            top: 0;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .bottom &#123;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .middle &#123;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            top: 100px;</span><br><span class="line">            bottom: 100px;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;绝对定位解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单快捷，可拓展性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="三、flex-布局"><a href="#三、flex-布局" class="headerlink" title="三、flex 布局"></a>三、flex 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- flex 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container flex&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .flex &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-direction: column;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .top &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .bottom &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .middle &#123;</span><br><span class="line">            flex: 1;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;flex解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单快捷，兼容性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="四、table-布局"><a href="#四、table-布局" class="headerlink" title="四、table 布局"></a>四、table 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- table 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container table&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table div &#123;</span><br><span class="line">            display: table-row;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .top &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .middle &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            height: 100%;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .bottom &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;table 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;兼容性非常好，但是不太推荐&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="五、grid-布局"><a href="#五、grid-布局" class="headerlink" title="五、grid 布局"></a>五、grid 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- grid 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container grid&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .grid &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            grid-template-columns: 200px;</span><br><span class="line">            grid-template-rows: 100px auto 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .top &#123;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .bottom &#123;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .middle &#123;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;grid 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;功能强大，兼容性不好&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
</feed>
