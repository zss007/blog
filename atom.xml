<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青松的博客</title>
  
  <subtitle>天行健，君子以自强不息；地势坤，君子以厚德载物。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.master-ss.cn/"/>
  <updated>2019-01-22T02:59:11.710Z</updated>
  <id>http://blog.master-ss.cn/</id>
  
  <author>
    <name>张松松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络之 https 协议</title>
    <link href="http://blog.master-ss.cn/essay/https/"/>
    <id>http://blog.master-ss.cn/essay/https/</id>
    <published>2019-01-22T01:58:29.765Z</published>
    <updated>2019-01-22T02:59:11.710Z</updated>
    
    <content type="html"><![CDATA[<p>https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。<br><a id="more"></a></p><h3 id="一、http-困境"><a href="#一、http-困境" class="headerlink" title="一、http 困境"></a>一、http 困境</h3><p>http 协议是明文传递内容，一旦在网络被人监控，数据可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使被截取和窃听，窃听者也无法知道数据的真实内容是什么。</p><h3 id="二、加密"><a href="#二、加密" class="headerlink" title="二、加密"></a>二、加密</h3><p>让我们设想这样一个情景：海绵宝宝想和蟹老板秘密协商新的蟹黄堡配方，如果让你来设计加密过程，你有几种方法呢？</p><h4 id="2-1、对称加密"><a href="#2-1、对称加密" class="headerlink" title="2.1、对称加密"></a>2.1、对称加密</h4><p>海绵宝宝和蟹老板约定一个密钥，传输和解读都通过这个密钥解密，这个密钥称为公钥。<br><img src="/assets/essay/https-symmetry.png"></p><h4 id="2-2、非对称加密"><a href="#2-2、非对称加密" class="headerlink" title="2.2、非对称加密"></a>2.2、非对称加密</h4><p>小心谨慎的蟹老板有一个只有自己知道的密钥(称为私钥)和公钥，他把公钥发给海绵宝宝，海绵宝宝可以通过公钥解密私钥加密的消息，但是公钥加密的消息只有私钥能解开，这在一定程度上做到了单向安全。<br><img src="/assets/essay/https-asymmetry.png"></p><h4 id="2-3、协商"><a href="#2-3、协商" class="headerlink" title="2.3、协商"></a>2.3、协商</h4><p>那么HTTPS中用的哪种加密方式呢？<br>如果采用对称加密，那么蟹老板和所有人都拥有同一个密钥，这无异于没有加密！！！<br><img src="/assets/essay/https-negotiate1.png"><br>所以蟹老板需要和每个人协商一个密钥，每个人互不相同，这样就能保证加密了。<br><img src="/assets/essay/https-negotiate2.png"><br>在HTTPS中，这个协商的过程一般是用非对称加密来进行的。客户端一旦得到了真的服务器公钥，往服务端传消息就是安全的。因为只有服务端的私钥才能解密公钥加密的数据。<br>但是，客户端可没那么容易得到真正的公钥，因为发送公钥的过程存在被别人调包的可能性，这就是传说中的中间人攻击。</p><h4 id="2-4、中间人攻击"><a href="#2-4、中间人攻击" class="headerlink" title="2.4、中间人攻击"></a>2.4、中间人攻击</h4><p>让我们回到情景中。<br>痞老板听闻消息，企图在协商过程通过中间人的方式截取蟹黄包配方。<br><img src="/assets/essay/https-middleman.png"><br>如图，蟹老板想告诉海绵宝宝自己的公钥，此时痞老板出现，替换了蟹老板的公钥，海绵宝宝收到一个来自痞老板的公钥并以为是蟹老板的，由此在之后的传输中痞老板便可以轻松的浏览蟹老板和海绵宝宝的所有沟通内容了。为了防止痞老板窃听，那这个协商的过程也必须加密，这样下去协商加密也要加密，……问题没有穷尽。那怎么办呢？</p><h4 id="2-5、HTTPS-数字证书"><a href="#2-5、HTTPS-数字证书" class="headerlink" title="2.5、HTTPS 数字证书"></a>2.5、HTTPS 数字证书</h4><p>现在美人鱼战士和企鹅男孩登场了，他们保证作为一个权威中间机构为大家提供认证服务，负责为大家发放统一的公钥。<br><img src="/assets/essay/https-ca.png"><br>蟹老板先将自己要传输的公钥给美人鱼战士，美人鱼战士用自己的私钥加密后返回给蟹老板。这样大家只要能通过这个公钥解密蟹老板发来的密文，提取蟹老板的公钥，就能保证这个公钥不是来自痞老板。这个时候即便痞老板想替换公钥，伪造的公钥也不能用美人鱼战士的公钥解开了。<br>这就是数字证书。服务器通过CA认证得到证书，这个证书包含CA的私钥加密后的服务器公钥，客户端用预先存储在本地的CA公钥即可解密得到服务器的公钥，从而避免公钥被替换。</p><h4 id="2-6、HTTPS-数字签名"><a href="#2-6、HTTPS-数字签名" class="headerlink" title="2.6、HTTPS 数字签名"></a>2.6、HTTPS 数字签名</h4><p>如果你是痞老板，你有什么方法可以再次窃取消息呢？<br>显然不能通过简单替换公钥来窃取了，海绵宝宝只能解开美人鱼战士颁发的证书，那我也去申请一个证书，直接替换整个证书不就可以从而替换掉公钥了吗？<br><img src="/assets/essay/https-sign.png"><br>企鹅男孩发现了这个问题，他决定在证书里面添加一些额外的信息以供验证。现在企鹅男孩颁发的证书格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：蟹堡王</span><br><span class="line">加密算法：MD5</span><br><span class="line">公钥：xxxx（已通过私钥加密，可通过公钥解密）</span><br></pre></td></tr></table></figure></p><p>海绵宝宝只要通过企鹅男孩的公钥提取到“蟹堡王”+“MD5” 计算出一个公钥，与证书内的公钥进行对比，就可以验证证书是否经过替换，如下图。<br><img src="/assets/essay/https-md5.png"><br>带有签名的证书<br><img src="/assets/essay/https-sign-md5.png"><br>对比发现证书被替换<br>虽然痞老板依旧可以截取证书，但是他却不能替换其中任何的信息，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：痞老板工厂</span><br><span class="line">加密算法：MD5</span><br><span class="line">公钥：djawdn888</span><br></pre></td></tr></table></figure></p><p>此时海绵宝宝可以发现来自不是蟹堡王而拒绝信任，并且<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">痞老板工厂 + MD5 !== djawdn888</span><br></pre></td></tr></table></figure></p><p>现在假设<code>蟹堡王+ MD4 = aaaa</code>，那只要修改公钥为aaaa不就可以通过海绵宝宝的验证了吗？痞老板的证书修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来自：蟹堡王</span><br><span class="line">加密算法：MD4</span><br><span class="line">公钥：aaaa</span><br></pre></td></tr></table></figure></p><p>实际上并不能，尽管可以修改公钥，但是前面提到，公钥经过企鹅男孩的私钥加密，现在海绵宝宝发现用企鹅男孩的公钥打不开了！于是发现证书已经被篡改了，从而结束通讯。 这便是数字签名的意义。</p><h4 id="2-7、小结"><a href="#2-7、小结" class="headerlink" title="2.7、小结"></a>2.7、小结</h4><p>综上，用一句话总结https：在https协议下，服务器与客户端通过非对称加密的方式协商出一个对称加密的密钥完成加密过程。其中数字证书的作用是避免公钥被替换，而数字签名的作用是校验公钥的合法性。<br>ps：权威机构的公钥是由操作系统和浏览器共同维护，预先存储在本地的。并由上可知 https 具有使用密文，安全性高的优点，同样的，存在协商过程低效，影响用户访问速度的缺点。</p><h3 id="三、握手过程"><a href="#三、握手过程" class="headerlink" title="三、握手过程"></a>三、握手过程</h3><p>明白了HTTPS的原理，握手过程就十分简单，总结如下：</p><ul><li>客户端：发送 random1 + 支持的加密算法 + SSL Version 等信息</li><li>服务端：发送 random2 + 选择的加密算法 A + 证书</li><li>客户端：验证证书 + 公钥加密的 random3</li><li>服务端：解密 random3，此时两端共有 random1，random2，random3，使用这3个随机数通过加密算法计算对称密钥即可。</li></ul><p>以上只有 random3 是加密的，所以用 random1 + 2 + 3 这3个随机数加密生成密钥。</p><h3 id="四、https-服务器"><a href="#四、https-服务器" class="headerlink" title="四、https 服务器"></a>四、https 服务器</h3><h4 id="4-1、搭建"><a href="#4-1、搭建" class="headerlink" title="4.1、搭建"></a>4.1、搭建</h4><p>这里以腾讯云为例，首先申请 SSL 证书：企业型、企业型专业版、域名型、域名型免费版、增强型、增强型专业版。如果对安全性要求不是那么高的话，则使用<code>域名型免费版</code>。审批通过后下载证书压缩包（对于中小型企业，如果服务器厂商不提供免费版，也可以在自己服务器上自建 CA 机构）。<br>获取到证书后，将<code>Nginx</code>文件夹目录下的证书文件<code>1_www.domain.com_bundle.crt</code>、私钥文件<code>2_www.domain.com.key</code>保存到同一个目录，如 <code>/etc/nginx/conf.d/ssl</code> 目录下，修改 nginx 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /etc/nginx/conf.d/ssl/1_www.domain.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/conf.d/2_www.domain.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置完成后，请先执行命令 nginx –t 测试 Nginx 配置是否有误。若无报错，重启 Nginx 之后，即可使用<code>https://www.domain.com</code>来访问。</p><h4 id="4-2、自动跳转"><a href="#4-2、自动跳转" class="headerlink" title="4.2、自动跳转"></a>4.2、自动跳转</h4><p>对于用户不知道网站可以进行 HTTPS 访问的情况下，让服务器自动把 HTTP 的请求重定向到 HTTPS。nginx 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.domain.com;</span><br><span class="line">  rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><ul><li><a href="https://juejin.im/post/5c341549e51d45524860cf99?utm_source=gold_browser_extension" target="_blank" rel="noopener">海绵宝宝也懂的HTTPS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;https 是建立在 SSL(Secure Sockets Layer 安全套接层)上的网络安全协议，最初由 NetScape 公司提出，之后由 IETF 标准化为 TLS(Transport Layer Security 安全传输层协议），其端口为 443。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之源码</title>
    <link href="http://blog.master-ss.cn/essay/clipboard3/"/>
    <id>http://blog.master-ss.cn/essay/clipboard3/</id>
    <published>2019-01-10T08:40:20.171Z</published>
    <updated>2019-01-10T09:24:22.664Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。<br><a id="more"></a></p><h3 id="一、clipboard-js"><a href="#一、clipboard-js" class="headerlink" title="一、clipboard.js"></a>一、clipboard.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">import ClipboardAction from &apos;./clipboard-action&apos;;</span><br><span class="line">import Emitter from &apos;tiny-emitter&apos;;</span><br><span class="line">import listen from &apos;good-listener&apos;;</span><br><span class="line"></span><br><span class="line">// 继承 tiny-emitter，存在 on、once、emit、off 方法</span><br><span class="line">class Clipboard extends Emitter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; trigger</span><br><span class="line">     * @param &#123;Object&#125; options</span><br><span class="line">     */</span><br><span class="line">    constructor(trigger, options) &#123;</span><br><span class="line">        super();</span><br><span class="line"></span><br><span class="line">        this.resolveOptions(options);</span><br><span class="line">        this.listenClick(trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义选项</span><br><span class="line">    resolveOptions(options = &#123;&#125;) &#123;</span><br><span class="line">        this.action    = (typeof options.action    === &apos;function&apos;) ? options.action    : this.defaultAction;</span><br><span class="line">        this.target    = (typeof options.target    === &apos;function&apos;) ? options.target    : this.defaultTarget;</span><br><span class="line">        this.text      = (typeof options.text      === &apos;function&apos;) ? options.text      : this.defaultText;</span><br><span class="line">        this.container = (typeof options.container === &apos;object&apos;)   ? options.container : document.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对触发器添加监听函数</span><br><span class="line">    listenClick(trigger) &#123;</span><br><span class="line">        this.listener = listen(trigger, &apos;click&apos;, (e) =&gt; this.onClick(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发器点击时触发</span><br><span class="line">    onClick(e) &#123;</span><br><span class="line">        const trigger = e.delegateTarget || e.currentTarget;</span><br><span class="line"></span><br><span class="line">        if (this.clipboardAction) &#123;</span><br><span class="line">            this.clipboardAction = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.clipboardAction = new ClipboardAction(&#123;</span><br><span class="line">            action    : this.action(trigger),</span><br><span class="line">            target    : this.target(trigger),</span><br><span class="line">            text      : this.text(trigger),</span><br><span class="line">            container : this.container,</span><br><span class="line">            trigger   : trigger,</span><br><span class="line">            emitter   : this</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 action</span><br><span class="line">    defaultAction(trigger) &#123;</span><br><span class="line">        return getAttributeValue(&apos;action&apos;, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 target</span><br><span class="line">    defaultTarget(trigger) &#123;</span><br><span class="line">        const selector = getAttributeValue(&apos;target&apos;, trigger);</span><br><span class="line"></span><br><span class="line">        if (selector) &#123;</span><br><span class="line">            return document.querySelector(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否支持 execCommand 命令</span><br><span class="line">    static isSupported(action = [&apos;copy&apos;, &apos;cut&apos;]) &#123;</span><br><span class="line">        const actions = (typeof action === &apos;string&apos;) ? [action] : action;</span><br><span class="line">        let support = !!document.queryCommandSupported;</span><br><span class="line"></span><br><span class="line">        actions.forEach((action) =&gt; &#123;</span><br><span class="line">            support = support &amp;&amp; !!document.queryCommandSupported(action);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return support;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 默认 Text</span><br><span class="line">    defaultText(trigger) &#123;</span><br><span class="line">        return getAttributeValue(&apos;text&apos;, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用 destroy 移除事件监听，并调用 clipboardAction 的 destroy 方法</span><br><span class="line">    destroy() &#123;</span><br><span class="line">        this.listener.destroy();</span><br><span class="line"></span><br><span class="line">        if (this.clipboardAction) &#123;</span><br><span class="line">            this.clipboardAction.destroy();</span><br><span class="line">            this.clipboardAction = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取 data-clipboard-xxx 属性值</span><br><span class="line">function getAttributeValue(suffix, element) &#123;</span><br><span class="line">    const attribute = `data-clipboard-$&#123;suffix&#125;`;</span><br><span class="line"></span><br><span class="line">    if (!element.hasAttribute(attribute)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return element.getAttribute(attribute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Clipboard;</span><br></pre></td></tr></table></figure><h3 id="二、clipboard-action-js"><a href="#二、clipboard-action-js" class="headerlink" title="二、clipboard-action.js"></a>二、clipboard-action.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">import select from &apos;select&apos;;</span><br><span class="line"></span><br><span class="line">// 执行 copy 或 cut 操作</span><br><span class="line">class ClipboardAction &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param &#123;Object&#125; options</span><br><span class="line">     */</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.resolveOptions(options);</span><br><span class="line">        this.initSelection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取属性</span><br><span class="line">    resolveOptions(options = &#123;&#125;) &#123;</span><br><span class="line">        this.action    = options.action;</span><br><span class="line">        this.container = options.container;</span><br><span class="line">        this.emitter   = options.emitter;</span><br><span class="line">        this.target    = options.target;</span><br><span class="line">        this.text      = options.text;</span><br><span class="line">        this.trigger   = options.trigger;</span><br><span class="line"></span><br><span class="line">        this.selectedText = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据 text 和 target 选择不同的策略</span><br><span class="line">    initSelection() &#123;</span><br><span class="line">        if (this.text) &#123;</span><br><span class="line">            this.selectFake();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (this.target) &#123;</span><br><span class="line">            this.selectTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个 textarea 元素，为它设置值，并选中</span><br><span class="line">    selectFake() &#123;</span><br><span class="line">        const isRTL = document.documentElement.getAttribute(&apos;dir&apos;) == &apos;rtl&apos;;</span><br><span class="line"></span><br><span class="line">        this.removeFake();</span><br><span class="line"></span><br><span class="line">        this.fakeHandlerCallback = () =&gt; this.removeFake();</span><br><span class="line">        this.fakeHandler = this.container.addEventListener(&apos;click&apos;, this.fakeHandlerCallback) || true;</span><br><span class="line"></span><br><span class="line">        this.fakeElem = document.createElement(&apos;textarea&apos;);</span><br><span class="line">        // Prevent zooming on iOS</span><br><span class="line">        this.fakeElem.style.fontSize = &apos;12pt&apos;;</span><br><span class="line">        // Reset box model</span><br><span class="line">        this.fakeElem.style.border = &apos;0&apos;;</span><br><span class="line">        this.fakeElem.style.padding = &apos;0&apos;;</span><br><span class="line">        this.fakeElem.style.margin = &apos;0&apos;;</span><br><span class="line">        // Move element out of screen horizontally</span><br><span class="line">        this.fakeElem.style.position = &apos;absolute&apos;;</span><br><span class="line">        this.fakeElem.style[ isRTL ? &apos;right&apos; : &apos;left&apos; ] = &apos;-9999px&apos;;</span><br><span class="line">        // Move element to the same position vertically</span><br><span class="line">        let yPosition = window.pageYOffset || document.documentElement.scrollTop;</span><br><span class="line">        this.fakeElem.style.top = `$&#123;yPosition&#125;px`;</span><br><span class="line"></span><br><span class="line">        this.fakeElem.setAttribute(&apos;readonly&apos;, &apos;&apos;);</span><br><span class="line">        this.fakeElem.value = this.text;</span><br><span class="line"></span><br><span class="line">        this.container.appendChild(this.fakeElem);</span><br><span class="line"></span><br><span class="line">        this.selectedText = select(this.fakeElem);</span><br><span class="line">        this.copyText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除添加的元素，只在点击后才移除，因为用户可能使用 `Ctrl+C` 来赋值当前选中的值</span><br><span class="line">    removeFake() &#123;</span><br><span class="line">        if (this.fakeHandler) &#123;</span><br><span class="line">            this.container.removeEventListener(&apos;click&apos;, this.fakeHandlerCallback);</span><br><span class="line">            this.fakeHandler = null;</span><br><span class="line">            this.fakeHandlerCallback = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.fakeElem) &#123;</span><br><span class="line">            this.container.removeChild(this.fakeElem);</span><br><span class="line">            this.fakeElem = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 选中目标元素</span><br><span class="line">    selectTarget() &#123;</span><br><span class="line">        this.selectedText = select(this.target);</span><br><span class="line">        this.copyText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在当前选中的元素上执行 copy 操作</span><br><span class="line">    copyText() &#123;</span><br><span class="line">        let succeeded;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            succeeded = document.execCommand(this.action);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (err) &#123;</span><br><span class="line">            succeeded = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.handleResult(succeeded);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发 copy 操作的回调函数</span><br><span class="line">    handleResult(succeeded) &#123;</span><br><span class="line">        this.emitter.emit(succeeded ? &apos;success&apos; : &apos;error&apos;, &#123;</span><br><span class="line">            action: this.action,</span><br><span class="line">            text: this.selectedText,</span><br><span class="line">            trigger: this.trigger,</span><br><span class="line">            clearSelection: this.clearSelection.bind(this)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将焦点从目标元素移动到触发器，并移除 selection</span><br><span class="line">    clearSelection() &#123;</span><br><span class="line">        if (this.trigger) &#123;</span><br><span class="line">            this.trigger.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.getSelection().removeAllRanges();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 action，并检测操作</span><br><span class="line">    set action(action = &apos;copy&apos;) &#123;</span><br><span class="line">        this._action = action;</span><br><span class="line"></span><br><span class="line">        if (this._action !== &apos;copy&apos; &amp;&amp; this._action !== &apos;cut&apos;) &#123;</span><br><span class="line">            throw new Error(&apos;Invalid &quot;action&quot; value, use either &quot;copy&quot; or &quot;cut&quot;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get action() &#123;</span><br><span class="line">        return this._action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 target 并判断</span><br><span class="line">    set target(target) &#123;</span><br><span class="line">        if (target !== undefined) &#123;</span><br><span class="line">            if (target &amp;&amp; typeof target === &apos;object&apos; &amp;&amp; target.nodeType === 1) &#123;</span><br><span class="line">                if (this.action === &apos;copy&apos; &amp;&amp; target.hasAttribute(&apos;disabled&apos;)) &#123;</span><br><span class="line">                    throw new Error(&apos;Invalid &quot;target&quot; attribute. Please use &quot;readonly&quot; instead of &quot;disabled&quot; attribute&apos;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (this.action === &apos;cut&apos; &amp;&amp; (target.hasAttribute(&apos;readonly&apos;) || target.hasAttribute(&apos;disabled&apos;))) &#123;</span><br><span class="line">                    throw new Error(&apos;Invalid &quot;target&quot; attribute. You can\&apos;t cut text from elements with &quot;readonly&quot; or &quot;disabled&quot; attributes&apos;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this._target = target;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                throw new Error(&apos;Invalid &quot;target&quot; value, use a valid Element&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get target() &#123;</span><br><span class="line">        return this._target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁</span><br><span class="line">    destroy() &#123;</span><br><span class="line">        this.removeFake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = ClipboardAction;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍其源码实现。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之依赖</title>
    <link href="http://blog.master-ss.cn/essay/clipboard2/"/>
    <id>http://blog.master-ss.cn/essay/clipboard2/</id>
    <published>2019-01-10T07:41:18.150Z</published>
    <updated>2019-01-10T08:05:45.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。<br><a id="more"></a></p><h3 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function select(element) &#123;</span><br><span class="line">    var selectedText;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 表单元素下拉框 --&gt;</span><br><span class="line">    if (element.nodeName === &apos;SELECT&apos;) &#123;</span><br><span class="line">        element.focus();</span><br><span class="line"></span><br><span class="line">        selectedText = element.value;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!-- input 或者 textarea --&gt;</span><br><span class="line">    else if (element.nodeName === &apos;INPUT&apos; || element.nodeName === &apos;TEXTAREA&apos;) &#123;</span><br><span class="line">        var isReadOnly = element.hasAttribute(&apos;readonly&apos;);</span><br><span class="line"></span><br><span class="line">        if (!isReadOnly) &#123;</span><br><span class="line">            element.setAttribute(&apos;readonly&apos;, &apos;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        element.select();</span><br><span class="line">        element.setSelectionRange(0, element.value.length);</span><br><span class="line"></span><br><span class="line">        if (!isReadOnly) &#123;</span><br><span class="line">            element.removeAttribute(&apos;readonly&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        selectedText = element.value;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!-- 其他 DOM 元素 --&gt;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (element.hasAttribute(&apos;contenteditable&apos;)) &#123;</span><br><span class="line">            element.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var selection = window.getSelection();</span><br><span class="line">        var range = document.createRange();</span><br><span class="line"></span><br><span class="line">        range.selectNodeContents(element);</span><br><span class="line">        selection.removeAllRanges();</span><br><span class="line">        selection.addRange(range);</span><br><span class="line"></span><br><span class="line">        selectedText = selection.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return selectedText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = select;</span><br></pre></td></tr></table></figure><p>可以看到<code>select</code>包非常精简，主要用来选中元素，并复制元素值。其中有以下知识点：</p><ul><li>如果元素是 input 或者 textarea，则调用 select api 选中元素，其中 select 方法是选中所有文本，而 setSelectionRange 这个方法可以接收起始位置，终止位置，和方向要看到选择的文本；</li><li>contenteditable 属性规定元素内容是否可编辑，可以使<code>&lt;p&gt;</code>等标签变成可编辑状态；</li><li>getSelection 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置；</li><li>createRange 返回一个 Range 对象，Range 表示包含节点和部分文本节点的文档片段；</li><li>selection().toString() 获取选中的内容</li></ul><h3 id="二、tiny-emitter"><a href="#二、tiny-emitter" class="headerlink" title="二、tiny-emitter"></a>二、tiny-emitter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">function E () &#123;</span><br><span class="line">  // Keep this empty so it&apos;s easier to inherit from</span><br><span class="line">  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.prototype = &#123;</span><br><span class="line">  on: function (name, callback, ctx) &#123;</span><br><span class="line">    var e = this.e || (this.e = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    (e[name] || (e[name] = [])).push(&#123;</span><br><span class="line">      fn: callback,</span><br><span class="line">      ctx: ctx</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  once: function (name, callback, ctx) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    function listener () &#123;</span><br><span class="line">      self.off(name, listener);</span><br><span class="line">      callback.apply(ctx, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    listener._ = callback</span><br><span class="line">    return this.on(name, listener, ctx);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emit: function (name) &#123;</span><br><span class="line">    var data = [].slice.call(arguments, 1);</span><br><span class="line">    var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice();</span><br><span class="line">    var i = 0;</span><br><span class="line">    var len = evtArr.length;</span><br><span class="line"></span><br><span class="line">    for (i; i &lt; len; i++) &#123;</span><br><span class="line">      evtArr[i].fn.apply(evtArr[i].ctx, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  off: function (name, callback) &#123;</span><br><span class="line">    var e = this.e || (this.e = &#123;&#125;);</span><br><span class="line">    var evts = e[name];</span><br><span class="line">    var liveEvents = [];</span><br><span class="line"></span><br><span class="line">    if (evts &amp;&amp; callback) &#123;</span><br><span class="line">      for (var i = 0, len = evts.length; i &lt; len; i++) &#123;</span><br><span class="line">        // 为了兼容 once</span><br><span class="line">        if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback)</span><br><span class="line">          liveEvents.push(evts[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remove event from queue to prevent memory leak</span><br><span class="line">    // Suggested by https://github.com/lazd</span><br><span class="line">    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910</span><br><span class="line"></span><br><span class="line">    (liveEvents.length)</span><br><span class="line">      ? e[name] = liveEvents</span><br><span class="line">      : delete e[name];</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = E;</span><br></pre></td></tr></table></figure><p>事件管理模型主要由 4 个函数构成：</p><ul><li>on 用于订阅事件，一个事件订阅多个触发函数</li><li>emit 用于发布事件，发布时会以此触发事件订阅的函数</li><li>once 订阅的事件只触发一次</li><li>off 取消订阅事件，支持指定取消，批量取消和全部取消</li></ul><h3 id="三、good-listener"><a href="#三、good-listener" class="headerlink" title="三、good-listener"></a>三、good-listener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 类型判断，不展开说明 --&gt;</span><br><span class="line">var is = require(&apos;./is&apos;);</span><br><span class="line">&lt;!-- 事件委托，不展开说明 --&gt;</span><br><span class="line">var delegate = require(&apos;delegate&apos;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Validates all params and calls the right</span><br><span class="line"> * listener function based on its target type.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String|HTMLElement|HTMLCollection|NodeList&#125; target</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listen(target, type, callback) &#123;</span><br><span class="line">    if (!target &amp;&amp; !type &amp;&amp; !callback) &#123;</span><br><span class="line">        throw new Error(&apos;Missing required arguments&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!is.string(type)) &#123;</span><br><span class="line">        throw new TypeError(&apos;Second argument must be a String&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!is.fn(callback)) &#123;</span><br><span class="line">        throw new TypeError(&apos;Third argument must be a Function&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (is.node(target)) &#123;</span><br><span class="line">        return listenNode(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (is.nodeList(target)) &#123;</span><br><span class="line">        return listenNodeList(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (is.string(target)) &#123;</span><br><span class="line">        return listenSelector(target, type, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        throw new TypeError(&apos;First argument must be a String, HTMLElement, HTMLCollection, or NodeList&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Adds an event listener to a HTML element</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;HTMLElement&#125; node</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenNode(node, type, callback) &#123;</span><br><span class="line">    node.addEventListener(type, callback);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        destroy: function() &#123;</span><br><span class="line">            node.removeEventListener(type, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add an event listener to a list of HTML elements</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;NodeList|HTMLCollection&#125; nodeList</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenNodeList(nodeList, type, callback) &#123;</span><br><span class="line">    Array.prototype.forEach.call(nodeList, function(node) &#123;</span><br><span class="line">        node.addEventListener(type, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        destroy: function() &#123;</span><br><span class="line">            Array.prototype.forEach.call(nodeList, function(node) &#123;</span><br><span class="line">                node.removeEventListener(type, callback);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add an event listener to a selector</span><br><span class="line"> * and returns a remove listener function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String&#125; selector</span><br><span class="line"> * @param &#123;String&#125; type</span><br><span class="line"> * @param &#123;Function&#125; callback</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function listenSelector(selector, type, callback) &#123;</span><br><span class="line">    return delegate(document.body, selector, type, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = listen;</span><br></pre></td></tr></table></figure><p>可以看到<code>good-listener</code>包就是在元素上添加事件监听，并且返回对象，其含 destroy 属性，即移除事件的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是介绍用到的依赖包。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>clipboard 之介绍</title>
    <link href="http://blog.master-ss.cn/essay/clipboard1/"/>
    <id>http://blog.master-ss.cn/essay/clipboard1/</id>
    <published>2019-01-10T06:10:00.969Z</published>
    <updated>2019-01-10T07:38:01.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近有用到粘贴复制功能，调用了<a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">clipboard.js</a>库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。<br><a id="more"></a></p><h3 id="一、为什么使用它"><a href="#一、为什么使用它" class="headerlink" title="一、为什么使用它"></a>一、为什么使用它</h3><p>复制文字到剪切板不应该很难去实现。它不需要配置几十个步骤或者加载几百 KB 的文件。最重要的是，它不应该依赖 Flash 或其他臃肿的框架。这是 clipboard.js 诞生的原因。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clipboard --save</span><br></pre></td></tr></table></figure><p>可以通过 npm 来安装它，如果你不使用包管理，仅需要下载一个 <a href="https://github.com/zenorocha/clipboard.js/archive/master.zip" target="_blank" rel="noopener">ZIP</a> 文件。<br>首先，引入位于 dist 目录下的脚本文件，或者引入一个第三方<a href="https://github.com/zenorocha/clipboard.js/wiki/CDN-Providers" target="_blank" rel="noopener">CDN</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;dist/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>然后，你需要通过传入一个<a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-selector.html#L18" target="_blank" rel="noopener">DOM 选择器</a>, <a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-node.html#L16-L17" target="_blank" rel="noopener">HTML 元素</a>, 或者 <a href="https://github.com/zenorocha/clipboard.js/blob/master/demo/constructor-nodelist.html#L18-L19" target="_blank" rel="noopener">HTML 元素数组</a>作为参数，来实例化对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;);</span><br></pre></td></tr></table></figure></p><p>本质上，我们需要获取所有选择器匹配到的元素，并为每一个选择器设置监听事件。但仔细想想，如果有成百上千个匹配到的元素，这样做会耗费大量内存。因此，我们使用<a href="http://stackoverflow.com/questions/1687296/what-is-dom-event-delegation" target="_blank" rel="noopener">事件代理</a>，通过一个事件监听器来取代多个事件监听。毕竟，<a href="https://twitter.com/hashtag/perfmatters" target="_blank" rel="noopener">性能是问题</a>。</p><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><p>我们正在经历一场声明式的复兴，这就是为什么我们决定利用 HTML5 data 属性 来提高可用性的原因。</p><h4 id="3-1、从另一个元素复制文本"><a href="#3-1、从另一个元素复制文本" class="headerlink" title="3.1、从另一个元素复制文本"></a>3.1、从另一个元素复制文本</h4><p>一个很常见的用例是从另一个元素复制内容。你可以给目标元素添加一个<code>data-clipboard-target</code>属性来实现这个功能。这个属性的值就是能匹配到另一个元素的选择器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Target --&gt;</span><br><span class="line">&lt;input id=&quot;foo&quot; value=&quot;https://github.com/zenorocha/clipboard.js.git&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-target=&quot;#foo&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;assets/clippy.svg&quot; alt=&quot;Copy to clipboard&quot;&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-2、从另一个元素剪切文本"><a href="#3-2、从另一个元素剪切文本" class="headerlink" title="3.2、从另一个元素剪切文本"></a>3.2、从另一个元素剪切文本</h4><p>此外，你可以定义一个<code>data-clipboard-action</code>属性来指明你想要复制（copy）还是剪切（cut）内容。如果你省略这个属性，则默认为复制（copy）。正如你所预料的，剪切（cut）动作只在<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>元素起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Target --&gt;</span><br><span class="line">&lt;textarea id=&quot;bar&quot;&gt;Mussum ipsum cacilds...&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-action=&quot;cut&quot; data-clipboard-target=&quot;#bar&quot;&gt;</span><br><span class="line">    Cut to clipboard</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-3、从属性复制文本"><a href="#3-3、从属性复制文本" class="headerlink" title="3.3、从属性复制文本"></a>3.3、从属性复制文本</h4><p>事实上，你甚至不需要从另一个元素来复制内容。你仅需要给目标元素设置一个<code>data-clipboard-text</code>属性就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Trigger --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot; data-clipboard-text=&quot;Just because you can doesn&apos;t mean you should — clipboard.js&quot;&gt;</span><br><span class="line">    Copy to clipboard</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h3 id="四、事件"><a href="#四、事件" class="headerlink" title="四、事件"></a>四、事件</h3><p>如果你想要展示一些用户反馈，或者在用户复制/剪切后获取已经选择的文字，这里有个示例供你参考。我们通过触发自定义事件，例如<code>success</code>和<code>error</code>，让你可以设置监听并实现自定义逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var clipboard = new Clipboard(&apos;.btn&apos;);</span><br><span class="line"></span><br><span class="line">clipboard.on(&apos;success&apos;, function(e) &#123;</span><br><span class="line">    console.info(&apos;Action:&apos;, e.action);</span><br><span class="line">    console.info(&apos;Text:&apos;, e.text);</span><br><span class="line">    console.info(&apos;Trigger:&apos;, e.trigger);</span><br><span class="line"></span><br><span class="line">    e.clearSelection();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">clipboard.on(&apos;error&apos;, function(e) &#123;</span><br><span class="line">    console.error(&apos;Action:&apos;, e.action);</span><br><span class="line">    console.error(&apos;Trigger:&apos;, e.trigger);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="五、高级选项"><a href="#五、高级选项" class="headerlink" title="五、高级选项"></a>五、高级选项</h3><p>如果你不想修改 HTML，我们提供了一个非常方面的命令式的 API 给你使用。你需要做的就是声明一个函数，做一些处理，并返回一个值。例如，如果你希望动态设置 target，你需要返回一个节点（Node）.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    target: function(trigger) &#123;</span><br><span class="line">        return trigger.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果你希望动态设置 text，你需要返回一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    text: function(trigger) &#123;</span><br><span class="line">        return trigger.getAttribute(&apos;aria-label&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果在 Bootstrap 模态框（Modals）中使用，或是在其他修改焦点的类库中使用，你会希望将获得焦点的元素设置为 container 属性的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Clipboard(&apos;.btn&apos;, &#123;</span><br><span class="line">    container: document.getElementById(&apos;modal&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>同样地，如果你使用单页应用，你可能想要更加精确地管理 DOM 的生命周期。你可以清理事件以及创建的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var clipboard = new Clipboard(&apos;.btn&apos;);</span><br><span class="line">clipboard.destroy();</span><br></pre></td></tr></table></figure></p><h3 id="六、浏览器支持"><a href="#六、浏览器支持" class="headerlink" title="六、浏览器支持"></a>六、浏览器支持</h3><p>这个库依赖于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection" target="_blank" rel="noopener">Selection</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">execCommand</a> 的 API。前者 <a href="http://caniuse.com/#search=selection" target="_blank" rel="noopener">兼容所有的浏览器</a>，后者兼容以下浏览器。<br><img src="/assets/essay/clipboard.png" alt="通用的占位符缩略图"><br>好消息是，如果你需要支持旧浏览器，clipboard.js 可以优雅降级。你所要做的就是在<code>success</code>事件触发时提示用户“已复制！”，<code>error</code>事件触发时提示用户“按 Ctrl+C 复制文字”（此时用户要复制的文字已经选择了）。你也可以通过运行<code>Clipboard.isSupported()</code>来检查浏览器是否支持 clipboard.js，如果不支持，你可以隐藏复制/剪切按钮。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有用到粘贴复制功能，调用了&lt;a href=&quot;https://github.com/zenorocha/clipboard.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clipboard.js&lt;/a&gt;库，对其原理很感兴趣。研读源码后开始总结，这篇主要是功能介绍。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 之博客建站</title>
    <link href="http://blog.master-ss.cn/essay/hexo/"/>
    <id>http://blog.master-ss.cn/essay/hexo/</id>
    <published>2018-12-23T02:37:39.539Z</published>
    <updated>2018-12-23T03:16:02.853Z</updated>
    
    <content type="html"><![CDATA[<p>主要总结分享下我用 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo</a> 建站的过程。<br><a id="more"></a></p><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="1-2、建站"><a href="#1-2、建站" class="headerlink" title="1.2、建站"></a>1.2、建站</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装全局依赖 --&gt;</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">&lt;!-- 初始化工程项目 --&gt;</span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line">&lt;!-- 进入目录 --&gt;</span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装依赖 --&gt;</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启本地服务 --&gt;</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译生成静态文件 --&gt;</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">&lt;!-- 清除缓存 --&gt;</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><h4 id="2-1、安装主题"><a href="#2-1、安装主题" class="headerlink" title="2.1、安装主题"></a>2.1、安装主题</h4><p>默认主题是 landscape，这里选择 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> 主题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装主题 --&gt;</span><br><span class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装主题依赖包 --&gt;</span><br><span class="line">npm install hexo-renderer-less --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-helper-qrcode --save</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启分类页 --&gt;</span><br><span class="line">hexo new page categories</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改 hexo/source/categories/index.md 数据 --&gt;</span><br><span class="line">layout: categories</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h4 id="2-2、配置主题"><a href="#2-2、配置主题" class="headerlink" title="2.2、配置主题"></a>2.2、配置主题</h4><p>更详细配置信息参考<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">官方主题文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编辑站点配置文件，/_config.yml，启用主题，且配置基础信息 --&gt;</span><br><span class="line">theme: indigo</span><br><span class="line"></span><br><span class="line">&lt;!-- 修改访问链接和目录格式 --&gt;</span><br><span class="line">url: http://blog.master-ss.cn</span><br><span class="line">permalink: :title/</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置主题 /themes/indigo/_config.yml --&gt;</span><br><span class="line">1、配置菜单</span><br><span class="line">2、配置 favicon</span><br><span class="line">3、配置头像</span><br><span class="line">4、配置 email</span><br><span class="line">5、替换打赏图片</span><br><span class="line">6、配置 ‘ICP 备案号’</span><br><span class="line">7、修改留言信息 postMessage</span><br><span class="line">8、修改版权起始年份 since_year</span><br><span class="line">9、启用 valine 评论插件</span><br></pre></td></tr></table></figure></p><h4 id="2-3、部署"><a href="#2-3、部署" class="headerlink" title="2.3、部署"></a>2.3、部署</h4><p>截止目前我们就可以在本地进行文档的书写了，但是想要 hexo d 就部署到 git 上还是不够，需要进行以下操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编辑站点配置文件，/_config.yml，配置部署仓库、类型和分支 --&gt;</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/zss007/blog.git</span><br><span class="line">  branch: gh-pages</span><br><span class="line"></span><br><span class="line">&lt;!-- 安装部署依赖包 --&gt;</span><br><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure></p><h4 id="2-4、注意事项"><a href="#2-4、注意事项" class="headerlink" title="2.4、注意事项"></a>2.4、注意事项</h4><p>由于我们是使用 <code>git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</code> 方式进行主题安装，所以我们在提交代码到 git 时 <code>/themes/indigo</code> 文件夹中的所有文件均不会被提交。所以如果想刚才修改配置的主题信息同样提交到 git 上的话，可以 <code>cd /themes/indigo</code>，如果移除主题的仓库信息，即 <code>rm -rf .git</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要总结分享下我用 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt; 建站的过程。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之 H5 终端适配</title>
    <link href="http://blog.master-ss.cn/css/flexible/"/>
    <id>http://blog.master-ss.cn/css/flexible/</id>
    <published>2018-12-22T08:58:39.151Z</published>
    <updated>2018-12-22T14:21:24.023Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要是研究手淘团队的适配方案 amfe-flexible，及<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">源码</a>解析。<br><a id="more"></a></p><h3 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h3><h4 id="1-1、css-中的-1px-并不等于设备的-1px"><a href="#1-1、css-中的-1px-并不等于设备的-1px" class="headerlink" title="1.1、css 中的 1px 并不等于设备的 1px"></a>1.1、css 中的 1px 并不等于设备的 1px</h4><p>在 css 中我们一般使用 px 作为单位，在桌面浏览器中 css 的 1 个像素往往都是对应着电脑屏幕的 1 个物理像素，这可能会造成我们的一个错觉，那就是 css 中的像素就是设备的物理像素。但实际情况却并非如此，css 中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css 中的 1px 所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如 iphone3，它的分辨率为 320x480，在 iphone3 上，一个 css 像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从 iphone4 开始，苹果公司便推出了所谓的 Retina 屏，分辨率提高了一倍，变成 640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个 css 像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为 ldpi、mdpi、hdpi、xhdpi 等不同的等级，分辨率也是五花八门，安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><h4 id="1-2、devicePixelRatio"><a href="#1-2、devicePixelRatio" class="headerlink" title="1.2、devicePixelRatio"></a>1.2、devicePixelRatio</h4><p>在移动端浏览器中以及某些桌面浏览器中，window 对象有一个 devicePixelRatio 属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css 中的 px 就可以看做是设备的独立像素，所以通过 devicePixelRatio，我们可以知道该设备上一个 css 像素代表多少个物理像素。例如，在 Retina 屏的iphone上，devicePixelRatio 的值为 2，也就是说 1 个 css 像素相当于 2 个物理像素。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h5 id="2-1、源码"><a href="#2-1、源码" class="headerlink" title="2.1、源码"></a>2.1、源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(function flexible (window, document) &#123;</span><br><span class="line">  var docEl = document.documentElement</span><br><span class="line">  var dpr = window.devicePixelRatio || 1</span><br><span class="line"></span><br><span class="line">  // adjust body font size</span><br><span class="line">  function setBodyFontSize () &#123;</span><br><span class="line">    if (document.body) &#123;</span><br><span class="line">      document.body.style.fontSize = (12 * dpr) + &apos;px&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  // set 1rem = viewWidth / 10</span><br><span class="line">  function setRemUnit () &#123;</span><br><span class="line">    var rem = docEl.clientWidth / 10</span><br><span class="line">    docEl.style.fontSize = rem + &apos;px&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRemUnit()</span><br><span class="line"></span><br><span class="line">  // reset rem unit on page resize</span><br><span class="line">  window.addEventListener(&apos;resize&apos;, setRemUnit)</span><br><span class="line">  window.addEventListener(&apos;pageshow&apos;, function (e) &#123;</span><br><span class="line">    if (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // detect 0.5px supports</span><br><span class="line">  if (dpr &gt;= 2) &#123;</span><br><span class="line">    var fakeBody = document.createElement(&apos;body&apos;)</span><br><span class="line">    var testElement = document.createElement(&apos;div&apos;)</span><br><span class="line">    testElement.style.border = &apos;.5px solid transparent&apos;</span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    if (testElement.offsetHeight === 1) &#123;</span><br><span class="line">      docEl.classList.add(&apos;hairlines&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(window, document))</span><br></pre></td></tr></table></figure><h5 id="2-2、源码分析"><a href="#2-2、源码分析" class="headerlink" title="2.2、源码分析"></a>2.2、源码分析</h5><ul><li>setBodyFontSize 用来设置 body 的 fontSize，值为 (12 * dpr) + ‘px’</li><li>setRemUnit 用来设置 document.documentElement 即 html 标签的 fontSize，值为 clientWidth 的 1/10</li><li>resize、pageshow 在窗口大小调整或<a href="http://www.runoob.com/jsref/event-onpageshow.html" target="_blank" rel="noopener">从缓存中载入页面</a>时，重新调用 setRemUnit</li></ul><h5 id="2-3、-5px-方案"><a href="#2-3、-5px-方案" class="headerlink" title="2.3、.5px 方案"></a>2.3、.5px 方案</h5><p>2014 年的 WWDC 大会中，Ted O’Conor 在分享 “设计响应的Web体验” 主题时提到关于 Retina Hairlines 一词，也就是 Retina 极细的线：在 Retina 屏上仅仅显示 1 物理像素的边框。<br>amfe-flexible 的源码中，在页面上添加 div 元素，设置边框为 0.5px，并判断 offsetHeight 是否为 1 来判断是否支持 .5px，即如果支持 .5px 的话，那么在其 html 标签上添加 hairlines 类。这样就可以在写样式时进行 ”渐进增强“，即在支持 .5px 时使用其来显示极细的线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这节主要是研究手淘团队的适配方案 amfe-flexible，及&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;解析。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之面对对象</title>
    <link href="http://blog.master-ss.cn/js/extend/"/>
    <id>http://blog.master-ss.cn/js/extend/</id>
    <published>2018-10-14T14:06:31.000Z</published>
    <updated>2018-10-14T14:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。<br><a id="more"></a></p><h3 id="一、类的声明和实例化"><a href="#一、类的声明和实例化" class="headerlink" title="一、类的声明和实例化"></a>一、类的声明和实例化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 类的声明</span><br><span class="line">function Animal() &#123;</span><br><span class="line">    this.name = &apos;name&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6 中的 class 声明</span><br><span class="line">class Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &apos;name&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类的实例化</span><br><span class="line">console.log(new Animal(), new Animal2())</span><br></pre></td></tr></table></figure><h3 id="二、构造函数继承"><a href="#二、构造函数继承" class="headerlink" title="二、构造函数继承"></a>二、构造函数继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent1() &#123;</span><br><span class="line">  this.name = &apos;parent1&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent1.prototype.say = function () &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child1() &#123;</span><br><span class="line">  Parent1.call(this);</span><br><span class="line">  this.type = &apos;child1&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Child1());  // Child1 &#123;name: &quot;parent1&quot;, type: &quot;child1&quot;&#125;</span><br><span class="line">console.log(new Child1().say());  // Uncaught TypeError: xxx say is not a function</span><br></pre></td></tr></table></figure><p>优点：继承了 Parent1 的 name 属性；<br>缺点：没有继承 Parent1 原型链上的方法。</p><h3 id="二、原型链方法继承"><a href="#二、原型链方法继承" class="headerlink" title="二、原型链方法继承"></a>二、原型链方法继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Parent2() &#123;</span><br><span class="line">  this.name = &apos;parent2&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent2.prototype.say = function () &#123;</span><br><span class="line">  console.log(&apos;Parent2 say&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Child2() &#123;</span><br><span class="line">  this.type = &apos;child2&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child2.prototype = new Parent2();</span><br><span class="line"></span><br><span class="line">var s1 = new Child2();</span><br><span class="line">s1.say();  //P arent2 say</span><br><span class="line">console.log(s1.name, s1.type); // parent2 child2</span><br><span class="line">var s2 = new Child2();</span><br><span class="line">s1.play.push(4);</span><br><span class="line">console.log(s1.play, s2.play);  // [1, 2, 3, 4]、[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>优点：不仅继承了 Parent2 的 name、play 属性而且继承了其原型链上的方法；<br>缺点：由于将 Parent2 的实例作为 Child2 的原型，导致所有 Child2 实例共享 Parent2 的属性方法，其中一个 Child2 实例改变了原型链上 Parent2 的实例属性，其他实例会受到影响跟着改变。</p><h3 id="三、组合方法继承"><a href="#三、组合方法继承" class="headerlink" title="三、组合方法继承"></a>三、组合方法继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line">  this.name = &apos;parent3&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child3 () &#123;</span><br><span class="line">  Parent3.call(this);</span><br><span class="line">  this.type = &apos;child3&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line"></span><br><span class="line">var s3 = new Child3();</span><br><span class="line">var s4 = new Child3();</span><br><span class="line">s3.play.push(4);</span><br><span class="line">console.log(s3.play, s4.play); // [1, 2, 3, 4]、[1, 2, 3]</span><br></pre></td></tr></table></figure><p>优点：避免了原型链方法中出现的实例间相互影响(调用 Parent3.call(this) 使得 Child3 实例上有 play 属性，不必找到原型链上)；<br>缺点：每次得到一个 Child3 实例，都会调用两次 Parent3 函数。</p><h3 id="四、组合方法-优化一"><a href="#四、组合方法-优化一" class="headerlink" title="四、组合方法(优化一)"></a>四、组合方法(优化一)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent4 () &#123;</span><br><span class="line">  this.name = &apos;parent4&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child4 () &#123;</span><br><span class="line">  Parent4.call(this);</span><br><span class="line">  this.type = &apos;child4&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child4.prototype = Parent4.prototype;</span><br><span class="line"></span><br><span class="line">var s5 = new Child4();</span><br><span class="line">var s6 = new Child4();</span><br><span class="line">console.log(s5); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;</span><br><span class="line">console.log(s6); // Child4 &#123;name: &quot;parent4&quot;, play: [1, 2, 3] type: &quot;child4&quot;&#125;</span><br><span class="line">console.log(s5 instanceof Child4, s5 instanceof Parent4); // true true</span><br><span class="line">console.log(s5.constructor); // Parent4() &#123;this.name = &apos;parent4&apos;;this.play = [1, 2, 3];&#125;</span><br></pre></td></tr></table></figure><p>优点：避免了 Parent4 重复调用问题；<br>缺点：Child4 实例的构造函数不是 Child4，而是 Parent4(其实这不是优化带来的问题，优化前同样存在这个问题,赋值后 child 上的 constructor 只能在原型链上查找)</p><h3 id="五、组合方法-优化二"><a href="#五、组合方法-优化二" class="headerlink" title="五、组合方法(优化二)"></a>五、组合方法(优化二)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent5 () &#123;</span><br><span class="line">  this.name = &apos;parent5&apos;;</span><br><span class="line">  this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child5 () &#123;</span><br><span class="line">  Parent5.call(this);</span><br><span class="line">  this.type = &apos;child5&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child5.prototype = Object.create(Parent5.prototype);</span><br><span class="line">Child5.prototype.constructor = Child5;</span><br><span class="line"></span><br><span class="line">var s7 = new Child5();</span><br><span class="line">console.log(s7 instanceof Child5, s7 instanceof Parent5); //true true</span><br><span class="line">console.log(s7.constructor); //Child5() &#123;Parent5.call(this);this.type = &apos;child5&apos;;&#125;</span><br></pre></td></tr></table></figure><p>优点：Child5 实例的构造函数是 Child5(这里采用 Object.create 方法而不是直接 Parent4.prototype 赋值，直接赋值会影响到 Parent5 实例的构造函数)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节主要介绍类、实例和继承，并整理总结 JS 继承的几种方法，并分析各方法的优缺点。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之原型链</title>
    <link href="http://blog.master-ss.cn/js/prototype/"/>
    <id>http://blog.master-ss.cn/js/prototype/</id>
    <published>2018-10-14T07:42:12.000Z</published>
    <updated>2018-10-14T15:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 的原型有好好的研究过，现在重新捡起来整理下。<br><a id="more"></a></p><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><h5 id="1-1、对面字向量-new-Object"><a href="#1-1、对面字向量-new-Object" class="headerlink" title="1.1、对面字向量 | new Object"></a>1.1、对面字向量 | new Object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;name:&apos;o1&apos;&#125;</span><br><span class="line">var o11 = new Object(&#123;name:&apos;o11&apos;&#125;)</span><br></pre></td></tr></table></figure><h5 id="1-2、new-创建"><a href="#1-2、new-创建" class="headerlink" title="1.2、new 创建"></a>1.2、new 创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var M = function()&#123;this.name=&apos;o2&apos;&#125;</span><br><span class="line">var o2 = new M()</span><br></pre></td></tr></table></figure><h5 id="1-3、Object-create"><a href="#1-3、Object-create" class="headerlink" title="1.3、Object.create()"></a>1.3、Object.create()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var P = &#123;name:&apos;o3&apos;&#125;</span><br><span class="line">var o3 = Object.create(P)</span><br></pre></td></tr></table></figure><h3 id="二、proto"><a href="#二、proto" class="headerlink" title="二、proto"></a>二、<strong>proto</strong></h3><p>JS 的原始数据类型有六种：undefined、null、boolean、string、number、Symbol。引用类型通常叫做类，常见有：array、object 等。引用类型 object 的每个实例称之为对象，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则<code>__proto__</code>，通过它可以从中继承原型对象的属性，原型是 JavaScript 中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array();</span><br><span class="line">console.log(&apos;prototype&apos;, a.__proto__ === Array.prototype); // true</span><br></pre></td></tr></table></figure></p><p>Array.prototype 本身也是一个对象，也有继承的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__.__proto__ === Object.prototype  // true</span><br><span class="line">// 等同于 </span><br><span class="line">Array.prototype.__proto__ === Object.prototype  // true</span><br></pre></td></tr></table></figure></p><p>这就说明，array 本身也是继承自 object，而 object 的原型则是指向原始类型 null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__.__proto__.__proto__ === null  // true</span><br><span class="line">// 等同于 </span><br><span class="line">Object.prototype.__proto__ === null  // true</span><br></pre></td></tr></table></figure></p><p><img src="/assets/js/proto1.png"><br>除了使用<code>__proto__</code>方法访问对象的原型，还可以通过 Object.getPrototypeOf 方法来获取对象的原型，以及通过<br>Object.setPrototypeOf 方法来重写对象的原型。值得注意的是，按照语言的标准，<code>__proto__</code>属性只有浏览器才能部署，其他环境可以没有这个属性，而且前后的两根下划线表示它本地是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 Object.getPrototypeOf 和 Object.setPrototypeOf，进行原型对象的读写操作。这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来的更加形象，而且容易理解。</p><h3 id="三、prototype"><a href="#三、prototype" class="headerlink" title="三、prototype"></a>三、prototype</h3><p>函数作为 JavaScript 中的一等公民，它既是函数又是对象，函数的原型指向 Function.prototype。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Foo = function() &#123;&#125;</span><br><span class="line">Foo.__proto__ === Function.prototype // true</span><br></pre></td></tr></table></figure></p><p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有 prototype 属性。通过该函数构造的实例对象，其原型指针<code>__proto__</code><br>会指向该函数的 prototype 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Foo();</span><br><span class="line">a.__proto__ === Foo.prototype; // true</span><br></pre></td></tr></table></figure></p><p>而函数的 prototype 属性，本身是一个由 object 构造的实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.__proto__ === Object.prototype; // true</span><br><span class="line">// prototype 属性很特殊，它还有一个隐式的 constructor，指向了构造函数本身。</span><br><span class="line">Foo.prototype.constructor === Foo; // true</span><br><span class="line">a.constructor === Foo; // true</span><br><span class="line">a.constructor === Foo.prototype.constructor; // true</span><br></pre></td></tr></table></figure></p><p><img src="/assets/js/proto2.png"></p><h3 id="四、原型链"><a href="#四、原型链" class="headerlink" title="四、原型链"></a>四、原型链</h3><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，如此就构造了原型链的基本概念。<br>“原型链”的作用在于，当读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的 Object.prototype 还是找不到，则返回 undefined。</p><h3 id="五、判断方法"><a href="#五、判断方法" class="headerlink" title="五、判断方法"></a>五、判断方法</h3><p>原始数据类型一般使用 typeof 来判断（两种情况下回返回 undefined：1、变量没有声明；2、变量为 undefined）。</p><ul><li>typeof null 返回 object，其他引用类型均返回 object。</li><li>instanceof 判断是否由某个构造函数创建，返回 boolean 类型值（只要处在原型链上就返回 true，可使用 <code>__proto__.constructor</code>准确返回构造函数）。</li><li>Object.isPrototypeOf() 只要某个对象处在原型链上，isProtypeOf 都返回 true</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Bar = function() &#123;&#125;</span><br><span class="line">var b = new Bar();</span><br><span class="line">b instanceof Bar // true</span><br><span class="line">b instanceof Object // true</span><br><span class="line">b.__proto__.constructor // ƒ Bar() &#123;&#125;</span><br><span class="line">Bar.prototype.isPrototypeOf(b) // true</span><br><span class="line">Object.prototype.isPrototypeOf(Bar) // true</span><br></pre></td></tr></table></figure><p>要注意，实例 b 的原型是 Bar.prototype 而不是 Bar。<br><img src="/assets/js/proto3.png"><br>从上图中，能看到一个有趣的地方。<code>Function.prototype.__proto__</code>指向了 Object.prototype，这说明Function.prototype 是一个 Object 实例，那么应当是先有的 Object 再有 Function。但是<code>Object.prototype.constructor.__proto__</code>又指向了 Function.prototype。这样看来，没有 Function，Object 也不能创建实例。 这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的 Object 还是先有的 Function 呢？ </p><h3 id="六、Object-create"><a href="#六、Object-create" class="headerlink" title="六、Object.create"></a>六、Object.create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Point()&#123;&#125;;</span><br><span class="line">var Circle = Object.create(Point);</span><br><span class="line">console.log(Circle.__proto__ === Point); // true</span><br><span class="line">console.log(Circle.__proto__ === Point.prototype); // false</span><br></pre></td></tr></table></figure><p>使用指定的原型对象和其属性创建了一个新的对象，在例子中实例 Circle 的原型指向 Point。</p><h3 id="七、new-运算符"><a href="#七、new-运算符" class="headerlink" title="七、new 运算符"></a>七、new 运算符</h3><p>使用 new 运算符创建对象过程如下：</p><ul><li>7.1、一个新对象被创建，他继承自 foo.prototype</li><li>7.2、构造函数 foo 被执行，执行的时候相应的传参会被传入，同时上下文（this）会被指定为这个新实例，new foo 等同于 new foo()，只能用在不传递任何参数的情况</li><li>7.3、如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果，如果构造函数没有返回对象，那么 new 出来的结果是步骤 7.1 创建的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var new2 = function (func) &#123;</span><br><span class="line">  var o = Object.create(func.prototype)</span><br><span class="line">  var k = func.call(o)</span><br><span class="line">  if (typeof k === &apos;object&apos;) &#123;</span><br><span class="line">    return k</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return o</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 的原型有好好的研究过，现在重新捡起来整理下。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>网络之 http 协议</title>
    <link href="http://blog.master-ss.cn/essay/http/"/>
    <id>http://blog.master-ss.cn/essay/http/</id>
    <published>2018-10-14T06:44:09.000Z</published>
    <updated>2019-01-10T06:04:38.979Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。<br><a id="more"></a></p><h3 id="一、http-协议特点"><a href="#一、http-协议特点" class="headerlink" title="一、http 协议特点"></a>一、http 协议特点</h3><ul><li>简单快速</li><li>灵活</li><li>无状态</li><li>无连接</li></ul><h3 id="二、报文组成部分"><a href="#二、报文组成部分" class="headerlink" title="二、报文组成部分"></a>二、报文组成部分</h3><h4 id="2-1、请求报文"><a href="#2-1、请求报文" class="headerlink" title="2.1、请求报文"></a>2.1、请求报文</h4><ul><li>请求行：http 方法、页面地址、http 协议以及版本；</li><li>请求头</li><li>空行：隔开请求头和请求体；</li><li>请求体</li></ul><h4 id="2-2、响应报文"><a href="#2-2、响应报文" class="headerlink" title="2.2、响应报文"></a>2.2、响应报文</h4><ul><li>状态行：http 协议以及版本号、http 状态码；</li><li>响应头</li><li>空行：隔开响应头和响应体；</li><li>响应体</li></ul><h3 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h3><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获取报文首部</li></ul><h3 id="四、GET-amp-POST"><a href="#四、GET-amp-POST" class="headerlink" title="四、GET &amp; POST"></a>四、GET &amp; POST</h3><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</li><li>GET 产生的 URL 地址可以被收藏，而 POST 不可以</li><li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</li><li>GET 请求参数会被完整的保留在浏览器历史记录里，而 POST 中的参数不会被保留</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li></ul><h3 id="五、状态码"><a href="#五、状态码" class="headerlink" title="五、状态码"></a>五、状态码</h3><ul><li>1XX：信息相关</li><li>2XX：成功 204 no content</li><li>3XX：重定向 301 304</li><li>4XX：客户端错误 401 403 404</li><li>5XX：服务器错误 500</li></ul><h3 id="持久链接-amp-管线化"><a href="#持久链接-amp-管线化" class="headerlink" title="持久链接 &amp; 管线化"></a>持久链接 &amp; 管线化</h3><ul><li>持久链接使用 keep-alive，不用每次都重新建立一次连接，需要 http 1.1</li><li>通常 keep-alive 是 Q1 -&gt; R1 -&gt; Q2 -&gt; R2，而管线化后是 Q1 -&gt; Q2 -&gt; R1 -&gt; R2，需要通过持久连接完成且要求服务端支持</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 是互联网上应用最为广泛的一种网络协议，现在简单的介绍下它的特点。&lt;br&gt;
    
    </summary>
    
      <category term="essay" scheme="http://blog.master-ss.cn/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之类型转换</title>
    <link href="http://blog.master-ss.cn/js/type/"/>
    <id>http://blog.master-ss.cn/js/type/</id>
    <published>2018-10-13T03:13:41.000Z</published>
    <updated>2018-10-13T03:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 基础常考内容，一定要融会贯通。<br><a id="more"></a></p><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><p>JS 中有 7 中数据类型：<br>原始数据类型： Null、Boolean、String、Number、Symbol、Undefined<br>复合数据类型： Object</p><h3 id="二、显式类型转换"><a href="#二、显式类型转换" class="headerlink" title="二、显式类型转换"></a>二、显式类型转换</h3><p>先说明下面几个函数：<br>valueOf(): 将该对象原始值返回<br>toString(): 将该对象原始值以字符串返回</p><ul><li><p>Number 转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 基本数据转换</span><br><span class="line">Number(1) // 数字： 数字 -&gt; 数字</span><br><span class="line">Number(&apos;123&apos;) // 字符串： 纯数字 -&gt; 数字，不是纯数字 -&gt; NaN，空字符串 -&gt; 0</span><br><span class="line">Number(true) // 布尔值： true -&gt; 1，false -&gt; 0</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line">Number(null) // 0</span><br><span class="line">// 复合类型数据转换</span><br><span class="line">// 先调用 valueOf，如果输出为基本类型，则调用 Number，如果为复合类型，继续调用 toString，如果还不是基本数据类型就报错，如果是则调用 Number</span><br></pre></td></tr></table></figure></li><li><p>String 转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// String() 很简单，就是将这些基本类型都变成字符串：</span><br><span class="line">// 123 -&gt; &apos;123&apos;</span><br><span class="line">// true -&gt; &apos;true&apos;</span><br><span class="line">// undefined -&gt; &apos;undefined&apos;</span><br><span class="line">// null -&gt; &apos;null&apos;</span><br><span class="line">// 复合类型转换</span><br><span class="line">// 先调用 toString，如果输出为基本类型，则调用 String，如果为复合类型，继续调用 valueOf，如果还不是基本数据类型就报错，如果是则调用 String</span><br></pre></td></tr></table></figure></li><li><p>Boolean 转换<br>+0、-0、undefined、null、’’、NaN -&gt; false，其余都为 true</p></li></ul><h3 id="三、显式类型转换"><a href="#三、显式类型转换" class="headerlink" title="三、显式类型转换"></a>三、显式类型转换</h3><ul><li>四则运算</li><li>判断语句</li><li>Native 调用: 比如说 console.log()、alert()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Boolean()</span><br><span class="line">![]  // false</span><br><span class="line">!![] // true</span><br><span class="line">!&#123;&#125;  // false</span><br><span class="line">!!&#123;&#125; // true</span><br><span class="line">[]+[] // &quot;&quot;，调用 String 处理 []</span><br><span class="line">[]+1 // &quot;1&quot;，调用 String 处理 []</span><br><span class="line">&#123;&#125;+&#123;&#125; // &quot;[object Object][object Object]&quot;，这里 chrome 和 firefox 解释不同</span><br><span class="line">&#123;&#125;+[] // 0，这里 &#123;&#125; 被当前代码块，不做任何处理，然后调用 Number 处理 []</span><br><span class="line">[]+&#123;&#125; // &quot;[object Object]&quot;，调用 String 处理 [] 和 &#123;&#125;</span><br><span class="line">1+&#123;&#125; // &quot;1[object Object]&quot;，调用 &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 基础常考内容，一定要融会贯通。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js 之 DOM 事件</title>
    <link href="http://blog.master-ss.cn/js/dom/"/>
    <id>http://blog.master-ss.cn/js/dom/</id>
    <published>2018-10-13T02:16:29.000Z</published>
    <updated>2018-10-13T02:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML DOM 允许 JavaScript 对 HTML 事件作出反应。<br><a id="more"></a></p><h3 id="一、DOM-事件级别"><a href="#一、DOM-事件级别" class="headerlink" title="一、DOM 事件级别"></a>一、DOM 事件级别</h3><ul><li>DOM0 级：DOM0 级事件就是将一个函数赋值给一个事件处理属性，element.onclick=function(){}</li><li>DOM1 级：没有与事件相关的东西</li><li>DOM2 级：DOM2 级事件定义了 addEventListener 和 removeEventListener 两个方法，分别用来绑定和解绑事件，element.addEventListener(‘click’,function(){},false)</li><li>DOM3 级：DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，element.addEventListener(‘keyup’,function(){},false)</li></ul><h3 id="二、DOM-事件模型-amp-事件流"><a href="#二、DOM-事件模型-amp-事件流" class="headerlink" title="二、DOM 事件模型 &amp; 事件流"></a>二、DOM 事件模型 &amp; 事件流</h3><ul><li>冒泡：从当前元素到最外层元素</li><li>捕获：从最外层元素到目标元素</li><li>事件流：捕获 -&gt; 目标阶段 -&gt; 冒泡</li></ul><h3 id="三、描述-Dom-事件流捕获的具体流程"><a href="#三、描述-Dom-事件流捕获的具体流程" class="headerlink" title="三、描述 Dom 事件流捕获的具体流程"></a>三、描述 Dom 事件流捕获的具体流程</h3><ul><li>window - document - html - body - … - 目标元素</li><li>获取 html 标签：document.documentElement</li></ul><h3 id="四、Event-对象常见应用"><a href="#四、Event-对象常见应用" class="headerlink" title="四、Event 对象常见应用"></a>四、Event 对象常见应用</h3><ul><li>e.preventDefault()</li><li>e.stopPropagation()</li><li>e.target: 获取触发事件的元素</li><li>e.currentTarget: 指的是绑定事件的元素</li><li>e.stopImmediatePropagation: 事件响应优先级</li></ul><h3 id="五、自定义事件"><a href="#五、自定义事件" class="headerlink" title="五、自定义事件"></a>五、自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const eve = new Event(&apos;custom&apos;);</span><br><span class="line">ev.addEventListener(&apos;custom&apos;, () =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">ev.dispathEvent(eve);</span><br><span class="line"></span><br><span class="line">// Event 不足，只能指定事件名，如果要传参数，可以使用 CustomEvent，如：</span><br><span class="line">var obj = document</span><br><span class="line">// 添加一个适当的事件监听器</span><br><span class="line">obj.addEventListener(&quot;cat&quot;, function (e) &#123; console.log(e.detail) &#125;)</span><br><span class="line">// 创建并分发事件</span><br><span class="line">var event = new CustomEvent(&quot;cat&quot;, &#123; &quot;detail&quot;: &#123; &quot;hazcheeseburger&quot;: true &#125; &#125;)</span><br><span class="line">obj.dispatchEvent(event)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML DOM 允许 JavaScript 对 HTML 事件作出反应。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="http://blog.master-ss.cn/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之盒模型及 BFC</title>
    <link href="http://blog.master-ss.cn/css/boxer/"/>
    <id>http://blog.master-ss.cn/css/boxer/</id>
    <published>2018-10-13T01:55:58.000Z</published>
    <updated>2018-10-13T02:11:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 盒模型是 CSS 的基石，非常重要的一块内容。<br><a id="more"></a></p><h3 id="一、盒模型基本概念"><a href="#一、盒模型基本概念" class="headerlink" title="一、盒模型基本概念"></a>一、盒模型基本概念</h3><ul><li>margin + border + padding + content</li><li>标准模型： 计算内容宽度时 width = content width，高度计算相同</li><li>IE 模型： 计算内容宽度时 width = content + padding + border</li><li>box-sizing: border-box（IE 模型）、content-box（标准模型）</li></ul><h3 id="二、JS-获取盒模型的宽高"><a href="#二、JS-获取盒模型的宽高" class="headerlink" title="二、JS 获取盒模型的宽高"></a>二、JS 获取盒模型的宽高</h3><ul><li>dom.style.width/height: 只能取到内联样式</li><li>dom.currentStyle.width/height: 拿到计算后的宽高，但只有 IE 支持</li><li>window.getComputedStyle(dom).width/height: 拿到计算后的宽高，兼容所有浏览器</li><li>dom.getBoundingClientRect().width/height: 拿到四条边相对左边上边的距离，然后获取宽高</li></ul><h3 id="三、边距重叠"><a href="#三、边距重叠" class="headerlink" title="三、边距重叠"></a>三、边距重叠</h3><p>父子边距重叠、兄弟边距重叠、空元素边距重叠(自身上下边距重叠)，取最大值</p><h3 id="四、BFC"><a href="#四、BFC" class="headerlink" title="四、BFC"></a>四、BFC</h3><h5 id="4-1、块级格式化上下文，其原理"><a href="#4-1、块级格式化上下文，其原理" class="headerlink" title="4.1、块级格式化上下文，其原理"></a>4.1、块级格式化上下文，其原理</h5><ul><li>在同一个 BFC 元素内部垂直方向发生边距重叠</li><li>BFC 区域不会与浮动元素 box 重叠</li><li>独立容器，内外互不影响</li><li>计算 BFC 高度，浮动元素参与计算</li></ul><h5 id="4-2、创建-BFC"><a href="#4-2、创建-BFC" class="headerlink" title="4.2、创建 BFC"></a>4.2、创建 BFC</h5><ul><li>position的值不为 static 或者 relative</li><li>float 不为 none</li><li>display 为 table 相关</li><li>overflow 不为 visible</li></ul><h5 id="4-3、BFC-实例"><a href="#4-3、BFC-实例" class="headerlink" title="4.3、BFC 实例"></a>4.3、BFC 实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;section id=&quot;sec&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #sec &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background: #f00;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .child &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h5 id="4-4、BFC-应用"><a href="#4-4、BFC-应用" class="headerlink" title="4.4、BFC 应用"></a>4.4、BFC 应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BFC 垂直方向边距重叠 --&gt;</span><br><span class="line">&lt;section id=&quot;margin&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #margin &#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #margin&gt;p &#123;</span><br><span class="line">            margin: 5px auto 25px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;p&gt;垂直 1&lt;/p&gt;</span><br><span class="line">    &lt;!-- 创建一个 BFC 来消除边距重合 --&gt;</span><br><span class="line">    &lt;div style=&quot;overflow: hidden;&quot;&gt;</span><br><span class="line">        &lt;p&gt;垂直 2&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;垂直 3&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- BFC 不与 float 重叠 --&gt;</span><br><span class="line">&lt;section id=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #layout .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #layout .right &#123;</span><br><span class="line">            height: 110px;</span><br><span class="line">            background: #ccc;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;float left&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;float right&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- BFC 子元素即使是 float 也会参与高度计算 --&gt;</span><br><span class="line">&lt;section id=&quot;float&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #float &#123;</span><br><span class="line">            background: red;</span><br><span class="line">            overflow: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #float .float &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            font-size: 25px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;float&quot;&gt;我是浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 盒模型是 CSS 的基石，非常重要的一块内容。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之页面布局二</title>
    <link href="http://blog.master-ss.cn/css/layout2/"/>
    <id>http://blog.master-ss.cn/css/layout2/</id>
    <published>2018-10-13T01:43:17.000Z</published>
    <updated>2018-10-13T01:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。<br><a id="more"></a></p><h3 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h3><p>三栏布局：要求：上下高度固定，中间自适应。先设置初始化样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> * &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html,</span><br><span class="line">body,</span><br><span class="line">section &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、绝对定位布局"><a href="#二、绝对定位布局" class="headerlink" title="二、绝对定位布局"></a>二、绝对定位布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绝对定位解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container absolute&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .absolute &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute div &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .top &#123;</span><br><span class="line">            top: 0;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .bottom &#123;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .middle &#123;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            top: 100px;</span><br><span class="line">            bottom: 100px;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;绝对定位解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单快捷，可拓展性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="三、flex-布局"><a href="#三、flex-布局" class="headerlink" title="三、flex 布局"></a>三、flex 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- flex 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container flex&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .flex &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-direction: column;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .top &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .bottom &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .middle &#123;</span><br><span class="line">            flex: 1;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;flex解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单快捷，兼容性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="四、table-布局"><a href="#四、table-布局" class="headerlink" title="四、table 布局"></a>四、table 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- table 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container table&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table div &#123;</span><br><span class="line">            display: table-row;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .top &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .middle &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            height: 100%;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .bottom &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;table 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;兼容性非常好，但是不太推荐&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&amp;nbsp;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="五、grid-布局"><a href="#五、grid-布局" class="headerlink" title="五、grid 布局"></a>五、grid 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- grid 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container grid&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .grid &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            grid-template-columns: 200px;</span><br><span class="line">            grid-template-rows: 100px auto 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .top &#123;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .bottom &#123;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .middle &#123;</span><br><span class="line">            overflow: scroll;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h1&gt;grid 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;功能强大，兼容性不好&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上节主要讲到水平三栏布局，这节主要探讨垂直三栏布局。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>css 之页面布局一</title>
    <link href="http://blog.master-ss.cn/css/layout/"/>
    <id>http://blog.master-ss.cn/css/layout/</id>
    <published>2018-10-13T01:19:20.000Z</published>
    <updated>2018-10-13T01:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>页面布局主要考察 HTML 以及 CSS 的功底，对页面布局的把控能力。<br><a id="more"></a></p><h3 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h3><p>三栏布局：要求：高度已知，左右固定，中间自适应。先设置初始化样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &#123;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container div &#123;</span><br><span class="line">    min-height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、float-布局"><a href="#二、float-布局" class="headerlink" title="二、float 布局"></a>二、float 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 浮动解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container float&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .float &#123;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .float .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .float .right &#123;</span><br><span class="line">            float: right;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .float .center &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        &lt;h1&gt;浮动解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;兼容性好，但是要处理浮动关系&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="三、绝对定位布局"><a href="#三、绝对定位布局" class="headerlink" title="三、绝对定位布局"></a>三、绝对定位布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绝对定位解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container absolute&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .absolute &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute div &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .left &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            left: 0;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .right &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            right: 0;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .absolute .center &#123;</span><br><span class="line">            right: 100px;</span><br><span class="line">            left: 100px;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;      </span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        &lt;h1&gt;绝对定位解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单，快捷，可扩展性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="四、flex-布局"><a href="#四、flex-布局" class="headerlink" title="四、flex 布局"></a>四、flex 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- flex 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container flex&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .flex &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .left &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .right &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex .center &#123;</span><br><span class="line">            flex: 1;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        &lt;h1&gt;flex 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;简单，快捷，兼容性差&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="五、table-布局"><a href="#五、table-布局" class="headerlink" title="五、table 布局"></a>五、table 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- table 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container table&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table div &#123;</span><br><span class="line">            display: table-cell;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .left &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .right &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table .center &#123;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        &lt;h1&gt;table 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;兼容性非常好，但是三栏等高，可能不合适&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><h3 id="六、grid-布局"><a href="#六、grid-布局" class="headerlink" title="六、grid 布局"></a>六、grid 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- grid 解决方案 --&gt;</span><br><span class="line">&lt;section class=&quot;container grid&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .grid &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            height: 100%;</span><br><span class="line">            grid-template-rows: 100px;</span><br><span class="line">            grid-template-columns: 100px auto 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .left &#123;</span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .right &#123;</span><br><span class="line">            background: azure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid .center &#123;</span><br><span class="line">            background: beige;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        &lt;h1&gt;grid 解决方案&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;功能强大，兼容性不好&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;页面布局主要考察 HTML 以及 CSS 的功底，对页面布局的把控能力。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.master-ss.cn/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之辅助方法</title>
    <link href="http://blog.master-ss.cn/vuex/vuex-helper/"/>
    <id>http://blog.master-ss.cn/vuex/vuex-helper/</id>
    <published>2018-10-05T07:15:04.000Z</published>
    <updated>2018-10-05T08:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完 vuex 的 api 后，我们来到最后一节 vuex 的辅助方法。<br><a id="more"></a></p><h3 id="一、mapState"><a href="#一、mapState" class="headerlink" title="一、mapState"></a>一、mapState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reduce the code which written in Vue.js for getting the state.（减少获取 state 代码的重复和冗余）</span><br><span class="line"> * @param &#123;String&#125; [namespace] - Module&apos;s namespace</span><br><span class="line"> * @param &#123;Object|Array&#125; states # Object&apos;s item can be a function which accept state and getters for param, you can do something for state and getters in it.</span><br><span class="line"> * @param &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const mapState = normalizeNamespace((namespace, states) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    res[key] = function mappedState () &#123;</span><br><span class="line">      let state = this.$store.state</span><br><span class="line">      let getters = this.$store.getters</span><br><span class="line">      // 传入 namespace</span><br><span class="line">      if (namespace) &#123;</span><br><span class="line">        // 获取相应命名空间的模块</span><br><span class="line">        const module = getModuleByNamespace(this.$store, &apos;mapState&apos;, namespace)</span><br><span class="line">        if (!module) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        // 赋值子模块的 state、getters</span><br><span class="line">        state = module.context.state</span><br><span class="line">        getters = module.context.getters</span><br><span class="line">      &#125;</span><br><span class="line">      return typeof val === &apos;function&apos;</span><br><span class="line">        ? val.call(this, state, getters)</span><br><span class="line">        : state[val]</span><br><span class="line">    &#125;</span><br><span class="line">    // mark vuex getter for devtools</span><br><span class="line">    res[key].vuex = true</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到我们调用 normalizeNamespace 方法，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param&apos;s function will handle the new namespace and the map.</span><br><span class="line"> * @param &#123;Function&#125; fn</span><br><span class="line"> * @return &#123;Function&#125;</span><br><span class="line"> * 命名空间格式化（namespace 表示命名空间，map 表示具体的对象，namespace 可不传）</span><br><span class="line"> */</span><br><span class="line">function normalizeNamespace (fn) &#123;</span><br><span class="line">  return (namespace, map) =&gt; &#123;</span><br><span class="line">    if (typeof namespace !== &apos;string&apos;) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = &apos;&apos;</span><br><span class="line">    &#125; else if (namespace.charAt(namespace.length - 1) !== &apos;/&apos;) &#123;</span><br><span class="line">      namespace += &apos;/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    return fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法主要是格式化传入参数。继续回到 mapState，可以看到调用了 normalizeMap，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Normalize the map（map 格式化）</span><br><span class="line"> * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ]</span><br><span class="line"> * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: &apos;a&apos;, val: 1 &#125;, &#123; key: &apos;b&apos;, val: 2 &#125;, &#123; key: &apos;c&apos;, val: 3 &#125; ]</span><br><span class="line"> * @param &#123;Array|Object&#125; map</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function normalizeMap (map) &#123;</span><br><span class="line">  return Array.isArray(map)</span><br><span class="line">    ? map.map(key =&gt; (&#123; key, val: key &#125;))</span><br><span class="line">    : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出我们将传入的第二个参数进行格式化。回到 mapState，调用 forEach 进行遍历。如果没有传入 namespace，则判断 val 是否为 function，如果是，则调用，否则直接返回 state[val]。如果传入了 namespace，则调用 getModuleByNamespace 获取子模块，然后获取子模块的 state、getters。也就是 mapState 返回的是一个对象，然后将这个对象传给 computed：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>那么 this.count 访问的就是 store.state.count 了。继续来看 getModuleByNamespace 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Search a special module from store by namespace. if module not exist, print error message.</span><br><span class="line"> * @param &#123;Object&#125; store</span><br><span class="line"> * @param &#123;String&#125; helper 工具方法名，如 mapState</span><br><span class="line"> * @param &#123;String&#125; namespace</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">function getModuleByNamespace (store, helper, namespace) &#123;</span><br><span class="line">  // 查找相应命名空间的 module</span><br><span class="line">  const module = store._modulesNamespaceMap[namespace]</span><br><span class="line">  // 非生产环境下，如果不存在相应命名空间模块，则给出提示信息</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !module) &#123;</span><br><span class="line">    console.error(`[vuex] module namespace not found in $&#123;helper&#125;(): $&#123;namespace&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  return module</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要是通过 _modulesNamespaceMap 来获取子模块。</p><h3 id="二、mapMutations"><a href="#二、mapMutations" class="headerlink" title="二、mapMutations"></a>二、mapMutations</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reduce the code which written in Vue.js for committing the mutation（减少获取 mutations 代码的重复和冗余）</span><br><span class="line"> * @param &#123;String&#125; [namespace] - Module&apos;s namespace</span><br><span class="line"> * @param &#123;Object|Array&#125; mutations # Object&apos;s item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> * 将组件中的 methods 映射为 store.commit 调用</span><br><span class="line"> */</span><br><span class="line">export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    // 支持传入额外的参数 args，作为提交 mutation 的 payload，如：`this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    res[key] = function mappedMutation (...args) &#123;</span><br><span class="line">      // Get the commit method from store</span><br><span class="line">      let commit = this.$store.commit</span><br><span class="line">      if (namespace) &#123;</span><br><span class="line">        const module = getModuleByNamespace(this.$store, &apos;mapMutations&apos;, namespace)</span><br><span class="line">        if (!module) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取子模块的 commit</span><br><span class="line">        commit = module.context.commit</span><br><span class="line">      &#125;</span><br><span class="line">      return typeof val === &apos;function&apos;</span><br><span class="line">        ? val.apply(this, [commit].concat(args))</span><br><span class="line">        : commit.apply(this.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历传入的 mutations，并支持传入额外的参数 args。然后获取 commit，如果传入了 namespace，则获取子模块的 commit。</p><h3 id="三、mapGetters"><a href="#三、mapGetters" class="headerlink" title="三、mapGetters"></a>三、mapGetters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reduce the code which written in Vue.js for getting the getters（减少获取 getters 代码的重复和冗余）</span><br><span class="line"> * @param &#123;String&#125; [namespace] - Module&apos;s namespace</span><br><span class="line"> * @param &#123;Object|Array&#125; getters</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const mapGetters = normalizeNamespace((namespace, getters) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  normalizeMap(getters).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    // thie namespace has been mutate by normalizeNamespace（namespace 已经被 normalizeNamespace 方法处理好了）</span><br><span class="line">    val = namespace + val</span><br><span class="line">    res[key] = function mappedGetter () &#123;</span><br><span class="line">      // 如果存在命名空间，但是没能在该命名空间下找到相应 module，则返回</span><br><span class="line">      if (namespace &amp;&amp; !getModuleByNamespace(this.$store, &apos;mapGetters&apos;, namespace)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      // 非生产环境下，如果没有相应 getter，给出提示信息</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(val in this.$store.getters)) &#123;</span><br><span class="line">        console.error(`[vuex] unknown getter: $&#123;val&#125;`)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      return this.$store.getters[val]</span><br><span class="line">    &#125;</span><br><span class="line">    // mark vuex getter for devtools</span><br><span class="line">    res[key].vuex = true</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历 getters，拼接上 namespace，然后从 this.$store.getters 取值返回。</p><h3 id="四、mapActions"><a href="#四、mapActions" class="headerlink" title="四、mapActions"></a>四、mapActions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reduce the code which written in Vue.js for dispatch the action（减少获取 actions 代码的重复和冗余）</span><br><span class="line"> * @param &#123;String&#125; [namespace] - Module&apos;s namespace</span><br><span class="line"> * @param &#123;Object|Array&#125; actions # Object&apos;s item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    // 支持传入额外的参数 args，作为提交 action 的 payload，如：`this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    res[key] = function mappedAction (...args) &#123;</span><br><span class="line">      // get dispatch function from store</span><br><span class="line">      let dispatch = this.$store.dispatch</span><br><span class="line">      // 带命名空间参数</span><br><span class="line">      if (namespace) &#123;</span><br><span class="line">        // 获取相应命名空间下的 moudle</span><br><span class="line">        const module = getModuleByNamespace(this.$store, &apos;mapActions&apos;, namespace)</span><br><span class="line">        if (!module) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取子模块的 dispatch 函数</span><br><span class="line">        dispatch = module.context.dispatch</span><br><span class="line">      &#125;</span><br><span class="line">      return typeof val === &apos;function&apos;</span><br><span class="line">        ? val.apply(this, [dispatch].concat(args))</span><br><span class="line">        : dispatch.apply(this.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历 actions，如果传入命名空间则获取子模块下的 dispatch 函数。</p><h3 id="五、createNamespacedHelpers"><a href="#五、createNamespacedHelpers" class="headerlink" title="五、createNamespacedHelpers"></a>五、createNamespacedHelpers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object</span><br><span class="line"> * 创建基于某个命名空间辅助函数，返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数</span><br><span class="line"> * @param &#123;String&#125; namespace</span><br><span class="line"> * @return &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">export const createNamespacedHelpers = (namespace) =&gt; (&#123;</span><br><span class="line">  mapState: mapState.bind(null, namespace),</span><br><span class="line">  mapGetters: mapGetters.bind(null, namespace),</span><br><span class="line">  mapMutations: mapMutations.bind(null, namespace),</span><br><span class="line">  mapActions: mapActions.bind(null, namespace)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回一个对象，其 mapState、mapGetters、mapMutations、mapActions 属性都已经绑定在了给定的命名空间上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完 vuex 的 api 后，我们来到最后一节 vuex 的辅助方法。&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之 api</title>
    <link href="http://blog.master-ss.cn/vuex/vuex-api/"/>
    <id>http://blog.master-ss.cn/vuex/vuex-api/</id>
    <published>2018-10-04T09:34:01.000Z</published>
    <updated>2018-10-05T07:13:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完 vuex 的构造器，相信大家对 vuex 的原理都有了个基础的认识，现在我们来看下 vuex 对外暴露的 api<br><a id="more"></a></p><h3 id="一、commit"><a href="#一、commit" class="headerlink" title="一、commit"></a>一、commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 提交 mutation，子模块的 commit 已在 makeLocalContext 中拼装好前缀</span><br><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">  // check object-style commit</span><br><span class="line">  const &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload,</span><br><span class="line">    options</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">  const mutation = &#123; type, payload &#125;</span><br><span class="line">  const entry = this._mutations[type]</span><br><span class="line">  // 非生产环境下给出提示信息，不存在相应的 mutation</span><br><span class="line">  if (!entry) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      console.error(`[vuex] unknown mutation type: $&#123;type&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  this._withCommit(() =&gt; &#123;</span><br><span class="line">    entry.forEach(function commitIterator (handler) &#123;</span><br><span class="line">      handler(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 触发 commit 的订阅回调函数</span><br><span class="line">  this._subscribers.forEach(sub =&gt; sub(mutation, this.state))</span><br><span class="line"></span><br><span class="line">  // 非生产环境下给出提示信息，silent 选项已被移除</span><br><span class="line">  if (</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    options &amp;&amp; options.silent</span><br><span class="line">  ) &#123;</span><br><span class="line">    console.warn(</span><br><span class="line">      `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` +</span><br><span class="line">      &apos;Use the filter functionality in the vue-devtools&apos;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用 unifyObjectStyle 格式化对象风格，然后通过 type 获取相应 mutations，注意拿到的是数组，而且 commit 方法执行需要嵌套在 _withCommit 中，原因前面章节有介绍。然后我们遍历执行 mutations，并传入 payload。最后我们遍历 _subscribers，触发 commit 的订阅回调函数。</p><h3 id="二、dispatch"><a href="#二、dispatch" class="headerlink" title="二、dispatch"></a>二、dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 提交 action，子模块的 dispatch 已在 makeLocalContext 中拼装好前缀</span><br><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  // check object-style dispatch</span><br><span class="line">  const &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  const action = &#123; type, payload &#125;</span><br><span class="line">  const entry = this._actions[type]</span><br><span class="line">  // // 非生产环境下给出提示信息，不存在相应的 action</span><br><span class="line">  if (!entry) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      console.error(`[vuex] unknown action type: $&#123;type&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 触发 dispatch 的订阅回调函数</span><br><span class="line">  this._actionSubscribers.forEach(sub =&gt; sub(action, this.state))</span><br><span class="line"></span><br><span class="line">  return entry.length &gt; 1</span><br><span class="line">    ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class="line">    : entry[0](payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用 unifyObjectStyle 格式化对象风格，然后通过 type 获取相应 actions，注意拿到的是数组，如果数组长度大于 1，则调用 Promise.all。最后我们遍历 _actionSubscribers，触发 dispatch 的订阅回调函数。</p><h3 id="三、subscribe"><a href="#三、subscribe" class="headerlink" title="三、subscribe"></a>三、subscribe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 订阅 store 的 mutation</span><br><span class="line">subscribe (fn) &#123;</span><br><span class="line">  return genericSubscribe(fn, this._subscribers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 genericSubscribe 方法，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 通用订阅函数</span><br><span class="line">function genericSubscribe (fn, subs) &#123;</span><br><span class="line">  // 如果是新的回调函数，则添加</span><br><span class="line">  if (subs.indexOf(fn) &lt; 0) &#123;</span><br><span class="line">    subs.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回函数，调用即可停止订阅</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    const i = subs.indexOf(fn)</span><br><span class="line">    if (i &gt; -1) &#123;</span><br><span class="line">      subs.splice(i, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说调用 subscribe 方法时，我们将传入的 fn 添加到 _subscribers 中，然后在每个 mutation 完成后调用。要停止订阅，调用此方法返回的函数即可停止订阅。</p><h3 id="四、subscribeAction"><a href="#四、subscribeAction" class="headerlink" title="四、subscribeAction"></a>四、subscribeAction</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 订阅 store 的 action</span><br><span class="line">subscribeAction (fn) &#123;</span><br><span class="line">  return genericSubscribe(fn, this._actionSubscribers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 subscribeAction 方法时，我们将传入的 fn 添加到 _actionSubscribers 中，然后在每个 action 分发的时候调用。要停止订阅，调用此方法返回的函数即可停止订阅。</p><h3 id="五、watch"><a href="#五、watch" class="headerlink" title="五、watch"></a>五、watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 响应式地侦听 getter 的返回值，当值改变时调用回调函数</span><br><span class="line">watch (getter, cb, options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(typeof getter === &apos;function&apos;, `store.watch only accepts a function.`)</span><br><span class="line">  &#125;</span><br><span class="line">  // fn 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。要停止侦听，调用此方法返回的函数即可停止侦听</span><br><span class="line">  return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 watch 时，我们将监听 getter 的返回值，如果值发生改变则调用回调函数 cb</p><h3 id="六、replaceState"><a href="#六、replaceState" class="headerlink" title="六、replaceState"></a>六、replaceState</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replaceState (state) &#123;</span><br><span class="line">  this._withCommit(() =&gt; &#123;</span><br><span class="line">    this._vm._data.$$state = state</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换 store 的根状态，仅用状态合并或时光旅行调试。</p><h3 id="七、registerModule"><a href="#七、registerModule" class="headerlink" title="七、registerModule"></a>七、registerModule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 模块动态注册</span><br><span class="line">registerModule (path, rawModule, options = &#123;&#125;) &#123;</span><br><span class="line">  if (typeof path === &apos;string&apos;) path = [path]</span><br><span class="line"></span><br><span class="line">  // 非生产环境下给出 path 参数校验提示信息</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(Array.isArray(path), `module path must be a string or an Array.`)</span><br><span class="line">    assert(path.length &gt; 0, &apos;cannot register the root module by using registerModule.&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册模块</span><br><span class="line">  this._modules.register(path, rawModule)</span><br><span class="line">  // 初始化模块</span><br><span class="line">  installModule(this, this.state, path, this._modules.get(path), options.preserveState)</span><br><span class="line">  // reset store to update getters...（重新实例化 store._vm，并销毁旧的 store_vm）</span><br><span class="line">  resetStoreVM(this, this.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先做参数格式化和校验，然后调用 register 方法注册模块，然后调用 installModule 初始化模块，其中 _modules.get 实现见 ‘src/module/module-collection.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取路径上的子模块</span><br><span class="line">get (path) &#123;</span><br><span class="line">  return path.reduce((module, key) =&gt; &#123;</span><br><span class="line">    return module.getChild(key)</span><br><span class="line">  &#125;, this.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>options 可以包含 preserveState: true 以允许保留之前的 state，也就是说如果设置 options.preserveState，那么 state 保持不变。然后调用 resetStoreVM 方法重新实例化 store._vm，并销毁旧的 store_vm，这样做主要是为了更新 store 的 getters。</p><h3 id="八、unregisterModule"><a href="#八、unregisterModule" class="headerlink" title="八、unregisterModule"></a>八、unregisterModule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 模块动态卸载（只会移除我们运行时动态创建的模块）</span><br><span class="line">unregisterModule (path) &#123;</span><br><span class="line">  if (typeof path === &apos;string&apos;) path = [path]</span><br><span class="line"></span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(Array.isArray(path), `module path must be a string or an Array.`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 执行 unregister 方法去修剪我们的模块树</span><br><span class="line">  this._modules.unregister(path)</span><br><span class="line">  // 删除 state 在该路径下的引用</span><br><span class="line">  this._withCommit(() =&gt; &#123;</span><br><span class="line">    const parentState = getNestedState(this.state, path.slice(0, -1))</span><br><span class="line">    Vue.delete(parentState, path[path.length - 1])</span><br><span class="line">  &#125;)</span><br><span class="line">  // 把 store 下的对应存储的 _actions、_mutations、_wrappedGetters 和 _modulesNamespaceMap 都清空，然后重新执行 installModule 安装所有模块以及 resetStoreVM 重置 store._vm</span><br><span class="line">  resetStore(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进行参数格式化和校验，然后调用 _modules.unregister 方法，具体实现见 ‘src/module/module-collection.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 卸载模块</span><br><span class="line">unregister (path) &#123;</span><br><span class="line">  const parent = this.get(path.slice(0, -1))</span><br><span class="line">  const key = path[path.length - 1]</span><br><span class="line">  // 只会移除我们运行时动态创建的模块</span><br><span class="line">  if (!parent.getChild(key).runtime) return</span><br><span class="line"></span><br><span class="line">  parent.removeChild(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意我们只会移除运行时动态创建的模块。首先获取父模块和当前模块名称，然后调用 removeChild 移除子模块，removeChild 具体实现见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 移除子模块</span><br><span class="line">removeChild (key) &#123;</span><br><span class="line">  delete this._children[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到 unregisterModule 中， 我们继续删除 state 在当前模块路径下的引用，并调用 resetStore 方法，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 重置 _actions、_mutations、_wrappedGetters、_modulesNamespaceMap，并重新执行 installModule、resetStoreVM</span><br><span class="line">function resetStore (store, hot) &#123;</span><br><span class="line">  store._actions = Object.create(null)</span><br><span class="line">  store._mutations = Object.create(null)</span><br><span class="line">  store._wrappedGetters = Object.create(null)</span><br><span class="line">  store._modulesNamespaceMap = Object.create(null)</span><br><span class="line">  const state = store.state</span><br><span class="line">  // init all modules</span><br><span class="line">  installModule(store, state, [], store._modules.root, true)</span><br><span class="line">  // reset vm</span><br><span class="line">  resetStoreVM(store, state, hot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法主要是清空 _actions、_mutations、_wrappedGetters、_modulesNamespaceMap，并重新初始化模块和重置 store._vm</p><h3 id="九、hotUpdate"><a href="#九、hotUpdate" class="headerlink" title="九、hotUpdate"></a>九、hotUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 热替换新的 action 和 mutation</span><br><span class="line">hotUpdate (newOptions) &#123;</span><br><span class="line">  this._modules.update(newOptions)</span><br><span class="line">  // 把 store 下的对应存储的 _actions、_mutations、_wrappedGetters 和 _modulesNamespaceMap 都清空，然后重新执行 installModule 安装所有模块以及 resetStoreVM 重置 store._vm</span><br><span class="line">  resetStore(this, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到调用了 _modules.update 方法，其实现见 ‘src/module/module-collection.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 更新模块，执行 update (path, targetModule, newModule)</span><br><span class="line">update (rawRootModule) &#123;</span><br><span class="line">  // 更新根模块</span><br><span class="line">  update([], this.root, rawRootModule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用了该文件自身的 update 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 更新模块具体实现</span><br><span class="line">function update (path, targetModule, newModule) &#123;</span><br><span class="line">  // 非生产环境下做类型检测</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assertRawModule(path, newModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // update target module（更新 targetModule 的 namespaced、actions、mutations、getters）</span><br><span class="line">  targetModule.update(newModule)</span><br><span class="line"></span><br><span class="line">  // update nested modules</span><br><span class="line">  if (newModule.modules) &#123;</span><br><span class="line">    for (const key in newModule.modules) &#123;</span><br><span class="line">      // 如果 newModule 存在 targetModule 没有的子模块，则给出 reload 提示信息</span><br><span class="line">      if (!targetModule.getChild(key)) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">          console.warn(</span><br><span class="line">            `[vuex] trying to add a new module &apos;$&#123;key&#125;&apos; on hot reloading, ` +</span><br><span class="line">            &apos;manual reload is needed&apos;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      // 递归更新子模块</span><br><span class="line">      update(</span><br><span class="line">        path.concat(key),</span><br><span class="line">        targetModule.getChild(key),</span><br><span class="line">        newModule.modules[key]</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后 targetModule.update 方法见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update (rawModule) &#123;</span><br><span class="line">  this._rawModule.namespaced = rawModule.namespaced</span><br><span class="line">  if (rawModule.actions) &#123;</span><br><span class="line">    this._rawModule.actions = rawModule.actions</span><br><span class="line">  &#125;</span><br><span class="line">  if (rawModule.mutations) &#123;</span><br><span class="line">    this._rawModule.mutations = rawModule.mutations</span><br><span class="line">  &#125;</span><br><span class="line">  if (rawModule.getters) &#123;</span><br><span class="line">    this._rawModule.getters = rawModule.getters</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要是更新当前 module 的 namespaced、actions、mutations、getters</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完 vuex 的构造器，相信大家对 vuex 的原理都有了个基础的认识，现在我们来看下 vuex 对外暴露的 api&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之初始化 store._vm</title>
    <link href="http://blog.master-ss.cn/vuex/vuex-vm/"/>
    <id>http://blog.master-ss.cn/vuex/vuex-vm/</id>
    <published>2018-10-04T08:13:36.000Z</published>
    <updated>2018-10-04T09:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>模块初始化看完后，我们继续来看初始化 store._vm<br><a id="more"></a></p><h3 id="一、resetStoreVM"><a href="#一、resetStoreVM" class="headerlink" title="一、resetStoreVM"></a>一、resetStoreVM</h3><p>我们回到 Store 的构造器函数，看到在执行 installModule 后，我们紧接着执行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// initialize the store vm, which is responsible for the reactivity</span><br><span class="line">// (also registers _wrappedGetters as computed properties)</span><br><span class="line">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p><p>resetStoreVM 定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 建立 getters 和 state 的联系</span><br><span class="line">function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">  const oldVm = store._vm</span><br><span class="line"></span><br><span class="line">  // bind store public getters</span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  const wrappedGetters = store._wrappedGetters</span><br><span class="line">  const computed = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    // use computed to leverage its lazy-caching mechanism（使用 computed 的懒加载机制）</span><br><span class="line">    // 根据 key 访问 store.getters 的某一个 getter 的时候，实际上就是访问了 store._vm[key]，也就是 computed[key]</span><br><span class="line">    // 在执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state</span><br><span class="line">    // 进而访问到 store._vm_data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。</span><br><span class="line">    computed[key] = () =&gt; fn(store)</span><br><span class="line">    Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: true // for local getters</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // use a Vue instance to store the state tree</span><br><span class="line">  // suppress warnings just in case the user has added</span><br><span class="line">  // some funky global mixins</span><br><span class="line">  const silent = Vue.config.silent</span><br><span class="line">  Vue.config.silent = true</span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  // enable strict mode for new vm</span><br><span class="line">  if (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVm) &#123;</span><br><span class="line">    if (hot) &#123;</span><br><span class="line">      // dispatch changes in all subscribed watchers</span><br><span class="line">      // to force getter re-evaluation for hot reloading.</span><br><span class="line">      store._withCommit(() =&gt; &#123;</span><br><span class="line">        oldVm._data.$$state = null</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 销毁旧的 vue 实例</span><br><span class="line">    Vue.nextTick(() =&gt; oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们获取 root store 上的 _vm 和 _wrappedGetters 属性，上节我们讲到 _wrappedGetters 存储用户定义的所有 getters。接着我们遍历 _wrappedGetters，为 computed 的 key 属性赋值，并为 store.getters 的 key 属性设置拦截器。</p><p>继续往下看，我们修改 Vue.config.silent，然后为 store._vm 赋值，并将 Vue.config.silent 改回原先值。这里 Vue.config.silent 的修改主要是为了防止用户配置了全局的 mixins 而打印出警告信息。</p><p>我们注意到如果访问 <code>store.getters[key]</code>，实际上访问的是 <code>store._vm[key]</code>，也就是 computed[key]，在执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,…) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。这样做的主要目的是为了使用计算属性的懒加载机制。</p><p>注意，我们访问 store.state 时其实访问的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 访问 store.state 的时候，实际上会访问 Store 类上定义的 state 的 get 方法</span><br><span class="line">get state () &#123;</span><br><span class="line">  return this._vm._data.$$state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给出提示信息，不能设置 state 值</span><br><span class="line">set state (v) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(false, `use store.replaceState() to explicit replace store state.`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到 resetStoreVM 方法，如果存在 oldVm，那么需要调用 $destroy 销毁这个实例。如果是热更新的话，同时设置 oldVm._data.$$state 为 null，来促使所有的监听函数重新计算。</p><h3 id="二、enableStrictMode"><a href="#二、enableStrictMode" class="headerlink" title="二、enableStrictMode()"></a>二、enableStrictMode()</h3><p>我们注意到 resetStoreVM 有这样一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// enable strict mode for new vm</span><br><span class="line">if (store.strict) &#123;</span><br><span class="line">  enableStrictMode(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果传入的 options.strict 为 true，那么执行 enableStrictMode 方法。enableStrictMode 的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 开启严格模式（在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误，这能保证所有的状态变更都能被调试工具跟踪到）</span><br><span class="line">function enableStrictMode (store) &#123;</span><br><span class="line">  // store._vm 添加一个 wathcer 来观测 this._data.$$state 的变化</span><br><span class="line">  store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123;</span><br><span class="line">    // 非生产环境下，当 store.state 被修改的时候, store._committing 必须为 true，否则给出提示信息</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(store._committing, `do not mutate vuex store state outside mutation handlers.`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; deep: true, sync: true &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们在 store._vm 添加了一个监听器，在 this._data.$$state 发生改变时触发回调函数。回调函数中判断 state 改变时，_committing 是否为 true，如果不是，则给出提示信息。</p><h3 id="三、plugins"><a href="#三、plugins" class="headerlink" title="三、plugins"></a>三、plugins</h3><p>我们回到构造器函数中继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// apply plugins</span><br><span class="line">plugins.forEach(plugin =&gt; plugin(this))</span><br><span class="line"></span><br><span class="line">if (Vue.config.devtools) &#123;</span><br><span class="line">    devtoolPlugin(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们首先遍历配置中的 plugins，并传入 store 实例执行 plugin 方法，所以我们传入的 plugins 选项能够在 new Vuex.Store() 执行时得到 store 实例并执行。然后判断 Vue.config.devtools（是否允许 vue-devtools 检查代码）是否为 true，如果是执行 devtoolPlugin 方法，devtoolPlugin 代码见 ‘src/plugins/devtool.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const devtoolHook =</span><br><span class="line">  typeof window !== &apos;undefined&apos; &amp;&amp;</span><br><span class="line">  window.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><br><span class="line"></span><br><span class="line">export default function devtoolPlugin (store) &#123;</span><br><span class="line">  if (!devtoolHook) return</span><br><span class="line"></span><br><span class="line">  store._devtoolHook = devtoolHook</span><br><span class="line"></span><br><span class="line">  devtoolHook.emit(&apos;vuex:init&apos;, store)</span><br><span class="line"></span><br><span class="line">  devtoolHook.on(&apos;vuex:travel-to-state&apos;, targetState =&gt; &#123;</span><br><span class="line">    store.replaceState(targetState)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  store.subscribe((mutation, state) =&gt; &#123;</span><br><span class="line">    devtoolHook.emit(&apos;vuex:mutation&apos;, mutation, state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们在 store 上添加了 _devtoolHook 属性，这就是上节我们说到的 store._devtoolHook 来源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块初始化看完后，我们继续来看初始化 store._vm&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之模块初始化</title>
    <link href="http://blog.master-ss.cn/vuex/vuex-module-install/"/>
    <id>http://blog.master-ss.cn/vuex/vuex-module-install/</id>
    <published>2018-09-30T06:58:43.000Z</published>
    <updated>2018-10-04T08:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们来看下 vuex 的模块初始化。<br><a id="more"></a></p><h3 id="一、installModule"><a href="#一、installModule" class="headerlink" title="一、installModule()"></a>一、installModule()</h3><p>我们接着来看 ‘src/store.js’ 中的构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export class Store &#123;</span><br><span class="line">  constructor (options = &#123;&#125;) &#123;</span><br><span class="line">    const state = this._modules.root.state</span><br><span class="line"></span><br><span class="line">    // init root module. 初始化根模块</span><br><span class="line">    // this also recursively registers all sub-modules 并递归注册所有子模块</span><br><span class="line">    // and collects all module getters inside this._wrappedGetters</span><br><span class="line">    installModule(this, state, [], this._modules.root)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过上节的分析，我们知道 this._modules.root 为根模块，因此从根模块上获取 state 属性。然后执行的是 installModule：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 对模块中的 state、getters、mutations、actions 做初始化工作</span><br><span class="line">// store 表示 root store；state 表示 root state；path 表示模块的访问路径；module 表示当前的模块；hot 表示是否是热更新</span><br><span class="line">function installModule (store, rootState, path, module, hot) &#123;</span><br><span class="line">  // 判断是否是根模块</span><br><span class="line">  const isRoot = !path.length</span><br><span class="line">  // 获取 path 路径下的命名空间</span><br><span class="line">  const namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  // register in namespace map（把 namespace 对应的模块保存下来，为了方便以后能根据 namespace 查找模块）</span><br><span class="line">  if (module.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = module</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // state 初始化</span><br><span class="line">  if (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    const parentState = getNestedState(rootState, path.slice(0, -1))</span><br><span class="line">    const moduleName = path[path.length - 1]</span><br><span class="line">    store._withCommit(() =&gt; &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, module.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const local = module.context = makeLocalContext(store, namespace, path)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们一步步来分析下，先看 getNamespace 方法实现，见 ‘src/module/module-collection.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取相应路径下模块的命名空间（从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串）</span><br><span class="line">getNamespace (path) &#123;</span><br><span class="line">  let module = this.root</span><br><span class="line">  return path.reduce((namespace, key) =&gt; &#123;</span><br><span class="line">    module = module.getChild(key)</span><br><span class="line">    return namespace + (module.namespaced ? key + &apos;/&apos; : &apos;&apos;)</span><br><span class="line">  &#125;, &apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>this.root 表示根模块，namespaced 实现见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 该模块是否带有命名空间</span><br><span class="line">get namespaced () &#123;</span><br><span class="line">  return !!this._rawModule.namespaced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getChild 实现见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取相应 key 的子模块</span><br><span class="line">getChild (key) &#123;</span><br><span class="line">  return this._children[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即如果 vuex 的子模块配置中出现了 namespaced，那么 module.namespaced 返回 true。然后我们使用 _modulesNamespaceMap 存储命名空间的模块，以便后续可根据 namespace 查找模块。</p><h3 id="二、makeLocalContext"><a href="#二、makeLocalContext" class="headerlink" title="二、makeLocalContext()"></a>二、makeLocalContext()</h3><p>我们接着来看 installModule 中的 makeLocalContext：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * make localized dispatch, commit, getters and state</span><br><span class="line"> * if there is no namespace, just use root ones</span><br><span class="line"> * store 表示 root store；namespace 表示模块的命名空间，path 表示模块的 path</span><br><span class="line"> */</span><br><span class="line">function makeLocalContext (store, namespace, path) &#123;</span><br><span class="line">  const noNamespace = namespace === &apos;&apos;</span><br><span class="line"></span><br><span class="line">  // 如果没有命名空间，则使用 root store 的 dispatch 和 commit 方法，options 为 &#123; root: true &#125; 时，在全局命名空间内分发 action 或提交 mutation</span><br><span class="line">  const local = &#123;</span><br><span class="line">    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">      const args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">      const &#123; payload, options &#125; = args</span><br><span class="line">      let &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">      if (!options || !options.root) &#123;</span><br><span class="line">        // 把 type 自动拼接上 namespace</span><br><span class="line">        type = namespace + type</span><br><span class="line">        // 非生产环境下给出提示信息</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._actions[type]) &#123;</span><br><span class="line">          console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return store.dispatch(type, payload)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">      const args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">      const &#123; payload, options &#125; = args</span><br><span class="line">      let &#123; type &#125; = args</span><br><span class="line">      </span><br><span class="line">      if (!options || !options.root) &#123;</span><br><span class="line">        // 把 type 自动拼接上 namespace</span><br><span class="line">        type = namespace + type</span><br><span class="line">        // 非生产环境下给出提示信息</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._mutations[type]) &#123;</span><br><span class="line">          console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      store.commit(type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // getters and state object must be gotten lazily</span><br><span class="line">  // because they will be changed by vm update</span><br><span class="line">  Object.defineProperties(local, &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      get: noNamespace</span><br><span class="line">        ? () =&gt; store.getters</span><br><span class="line">        : () =&gt; makeLocalGetters(store, namespace)</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">      get: () =&gt; getNestedState(store.state, path)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们主要是为 local 对象的 getters 和 state 属性定义 getter 拦截器。然后让我们继续往下看，然后再回过头来分析这段代码。</p><h3 id="三、module-forEach"><a href="#三、module-forEach" class="headerlink" title="三、module.forEach***"></a>三、module.forEach***</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 遍历模块下的 mutations，并注册</span><br><span class="line">module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">  const namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 遍历模块下的 actions，并注册</span><br><span class="line">module.forEachAction((action, key) =&gt; &#123;</span><br><span class="line">  // root 为 true 时，表示在带命名空间的模块注册全局 action</span><br><span class="line">  const type = action.root ? key : namespace + key</span><br><span class="line">  const handler = action.handler || action</span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 遍历模块下的 getters，并注册</span><br><span class="line">module.forEachGetter((getter, key) =&gt; &#123;</span><br><span class="line">  const namespacedType = namespace + key</span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 遍历模块中的所有子 modules，递归执行 installModule 方法</span><br><span class="line">module.forEachChild((child, key) =&gt; &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到我们调用了 module 的 forEachMutation、forEachAction、forEachGetter、forEachChild 方法，其具体实现代码见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 遍历子模块，将键值对传入 fn</span><br><span class="line">forEachChild (fn) &#123;</span><br><span class="line">  forEachValue(this._children, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历当前模块 getters，将键值对传入 fn</span><br><span class="line">forEachGetter (fn) &#123;</span><br><span class="line">  if (this._rawModule.getters) &#123;</span><br><span class="line">    forEachValue(this._rawModule.getters, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历当前模块 actions，将键值对传入 fn</span><br><span class="line">forEachAction (fn) &#123;</span><br><span class="line">  if (this._rawModule.actions) &#123;</span><br><span class="line">    forEachValue(this._rawModule.actions, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历当前模块 mutations，将键值对传入 fn</span><br><span class="line">forEachMutation (fn) &#123;</span><br><span class="line">  if (this._rawModule.mutations) &#123;</span><br><span class="line">    forEachValue(this._rawModule.mutations, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们分别遍历当前模块下的 mutations、actions、getters、modules 并注册，然后递归调用 installModule 方法遍历当前模块的子模块。</p><h3 id="四、registerMutation"><a href="#四、registerMutation" class="headerlink" title="四、registerMutation()"></a>四、registerMutation()</h3><p>我们继续回到 installModule 方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历模块下的 mutations，并注册</span><br><span class="line">module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">  const namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>首先使用当前模块的命名空间 namespace 和模块名 key 拼接，然后调用 registerMutation 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法（注意，同一 type 的 _mutations 可以对应多个方法）</span><br><span class="line">function registerMutation (store, type, handler, local) &#123;</span><br><span class="line">  const entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">  entry.push(function wrappedMutationHandler (payload) &#123;</span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取或初始化 _mutations 相应命名空间下数组，然后我们在 _mutations 中添加 wrappedMutationHandler 方法。注意 handle 即配置中的 mutations 方法，this 绑定为 root store，payload 为载荷，然后我们回到 makeLocalContext 中查看 local.state 拿到的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(local, &#123;</span><br><span class="line">    ...</span><br><span class="line">    state: &#123;</span><br><span class="line">      get: () =&gt; getNestedState(store.state, path)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>getNestedState 的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 state</span><br><span class="line">function getNestedState (state, path) &#123;</span><br><span class="line">  return path.length</span><br><span class="line">    ? path.reduce((state, key) =&gt; state[key], state)</span><br><span class="line">    : state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，我们应该理解原来 local.state 获取的就是当前模块的 state。不过还有个问题，就是 state[key] 为什么就是相应 key 子模块的 state，这时候我们就要回到 installModule 方法看这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// state 初始化</span><br><span class="line">if (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  const parentState = getNestedState(rootState, path.slice(0, -1))</span><br><span class="line">  const moduleName = path[path.length - 1]</span><br><span class="line">  store._withCommit(() =&gt; &#123;</span><br><span class="line">    Vue.set(parentState, moduleName, module.state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到如果不是根模块而且不是热更新，那么我们先拿到父模块的 state，然后获取当前模块名，最后调用 _withCommit 方法，并在方法参数内调用 Vue.set 为父模块 state 访问子模块建立联系，即 <code>parentState[moduleName] = module.state</code>。然后我们来看下 _withCommit 方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 内置提交修改 state，防止被捕获</span><br><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  const committing = this._committing</span><br><span class="line">  this._committing = true</span><br><span class="line">  fn()</span><br><span class="line">  this._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们之所以要这么做是因为要保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中。</p><h3 id="五、registerAction"><a href="#五、registerAction" class="headerlink" title="五、registerAction()"></a>五、registerAction()</h3><p>我们继续回到 installModule 方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 遍历模块下的 actions，并注册</span><br><span class="line">module.forEachAction((action, key) =&gt; &#123;</span><br><span class="line">  // root 为 true 时，表示在带命名空间的模块注册全局 action</span><br><span class="line">  const type = action.root ? key : namespace + key</span><br><span class="line">  const handler = action.handler || action</span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注意在 vuex 配置中，action 可设置 root 为 true，表示在带命名空间的模块注册全局 action，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: true,</span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: true,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; // -&gt; &apos;someAction&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 <code>action.handler || action</code> 为 action 的两种配置格式，我们接着看 registerAction：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 给 root store 上的 _actions[types] 添加 wrappedActionHandler 方法</span><br><span class="line">function registerAction (store, type, handler, local) &#123;</span><br><span class="line">  const entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(function wrappedActionHandler (payload, cb) &#123;</span><br><span class="line">    let res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload, cb)</span><br><span class="line">    if (!isPromise(res)) &#123;</span><br><span class="line">      res = Promise.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    if (store._devtoolHook) &#123;</span><br><span class="line">      return res.catch(err =&gt; &#123;</span><br><span class="line">        store._devtoolHook.emit(&apos;vuex:error&apos;, err)</span><br><span class="line">        throw err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取或初始化 _actions 对应命名空间下的数组，然后添加 wrappedActionHandler 方法。可以看到我们 action 调用时，this 绑定为 root store，context 对象存在 dispatch、commit、getters、state、rootGetters 和 rootState 属性，并且将 action 执行返回结果处理为 Promise 对象。<br>我们刚才已经讲过 local.state，现在我们来看下 local.dispatch、local.commit 和 local.getters：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有命名空间，则使用 root store 的 dispatch 和 commit 方法，options 为 &#123; root: true &#125; 时，在全局命名空间内分发 action 或提交 mutation</span><br><span class="line">const local = &#123;</span><br><span class="line">  dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">    const args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">    const &#123; payload, options &#125; = args</span><br><span class="line">    let &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">    if (!options || !options.root) &#123;</span><br><span class="line">      // 把 type 自动拼接上 namespace</span><br><span class="line">      type = namespace + type</span><br><span class="line">      // 非生产环境下给出提示信息</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._actions[type]) &#123;</span><br><span class="line">        console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return store.dispatch(type, payload)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123;</span><br><span class="line">    const args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">    const &#123; payload, options &#125; = args</span><br><span class="line">    let &#123; type &#125; = args</span><br><span class="line">    </span><br><span class="line">    if (!options || !options.root) &#123;</span><br><span class="line">      // 把 type 自动拼接上 namespace</span><br><span class="line">      type = namespace + type</span><br><span class="line">      // 非生产环境下给出提示信息</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !store._mutations[type]) &#123;</span><br><span class="line">        console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store.commit(type, payload, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getters and state object must be gotten lazily</span><br><span class="line">// because they will be changed by vm update</span><br><span class="line">Object.defineProperties(local, &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    get: noNamespace</span><br><span class="line">      ? () =&gt; store.getters</span><br><span class="line">      : () =&gt; makeLocalGetters(store, namespace)</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>先看 local.getters，我们注意到，如果没有命名空间，那么返回 root store 的 getters，否则执行 makeLocalGetters：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 获取子模块的 getters</span><br><span class="line">function makeLocalGetters (store, namespace) &#123;</span><br><span class="line">  const gettersProxy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  const splitPos = namespace.length</span><br><span class="line">  // 遍历 root store 下的所有 getters</span><br><span class="line">  Object.keys(store.getters).forEach(type =&gt; &#123;</span><br><span class="line">    // skip if the target getter is not match this namespace（判断是否匹配命名空间）</span><br><span class="line">    if (type.slice(0, splitPos) !== namespace) return</span><br><span class="line"></span><br><span class="line">    // extract local getter type（只有匹配的时候从 namespace 的位置截取后面的字符串得到 localType）</span><br><span class="line">    const localType = type.slice(splitPos)</span><br><span class="line"></span><br><span class="line">    // Add a port to the getters proxy.</span><br><span class="line">    // Define as getter property because</span><br><span class="line">    // we do not want to evaluate the getters in this time.</span><br><span class="line">    Object.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">      get: () =&gt; store.getters[type],</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return gettersProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看下 local.dispatch，如果没有命名空间，则使用 root store 的 dispatch 方法，否则调用封装方法。首先我们来看 unifyObjectStyle 方法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 统一对象风格 store.commit(&#123; type: &apos;increment&apos;, amount: 10 &#125;) | store.commit(&apos;increment&apos;, &#123; amount: 10 &#125;)</span><br><span class="line">function unifyObjectStyle (type, payload, options) &#123;</span><br><span class="line">  if (isObject(type) &amp;&amp; type.type) &#123;</span><br><span class="line">    options = payload</span><br><span class="line">    payload = type</span><br><span class="line">    type = type.type</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 非生产环境下给出提示信息</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assert(typeof type === &apos;string&apos;, `expects string as the type, but found $&#123;typeof type&#125;.`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; type, payload, options &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 unifyObjectStyle 是用来统一对象风格的。然后继续看 local.dispatch 方法，我们判断 options 是否存在而且 root 属性是否为 true。如果 if 语句执行失败，则直接调用 root store 的 dispatch 方法，否则我们为 type 拼接上命名空间，然后调用 dispatch 方法。local.commit 基本同 local.dispatch，我们就不讨论了。最后我们来看这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (store._devtoolHook) &#123;</span><br><span class="line">    return res.catch(err =&gt; &#123;</span><br><span class="line">        store._devtoolHook.emit(&apos;vuex:error&apos;, err)</span><br><span class="line">        throw err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 store 存在 _devtoolHook，即我们使用 devtool 插件时，我们为 Promise 对象 res 添加 catch 方法捕获错误。</p><h3 id="六、registerGetter"><a href="#六、registerGetter" class="headerlink" title="六、registerGetter()"></a>六、registerGetter()</h3><p>我们现在回到 installModule 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历模块下的 getters，并注册</span><br><span class="line">module.forEachGetter((getter, key) =&gt; &#123;</span><br><span class="line">  const namespacedType = namespace + key</span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们首先拼接出命名空间路径，然后调用 registerGetter 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// root store 上的 _wrappedGetters[key] 指定 wrappedGetter 方法</span><br><span class="line">function registerGetter (store, type, rawGetter, local) &#123;</span><br><span class="line">  // 注意，同一 type 的 _wrappedGetters 只能定义一个，非生产环境下给出提示信息</span><br><span class="line">  if (store._wrappedGetters[type]) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      console.error(`[vuex] duplicate getter key: $&#123;type&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  store._wrappedGetters[type] = function wrappedGetter (store) &#123;</span><br><span class="line">    return rawGetter(</span><br><span class="line">      local.state, // local state</span><br><span class="line">      local.getters, // local getters</span><br><span class="line">      store.state, // root state</span><br><span class="line">      store.getters // root getters</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们判断在 _wrappedGetters 是否已经存在相应命名空间路径的 getter，如果存在直接返回并给出提示，即同一 type 的 _wrappedGetters 只能定义一个。如果并未定义，我们将 wrappedGetter 赋值给 store._wrappedGetters[type]。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们来看下 vuex 的模块初始化。&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之模块注册</title>
    <link href="http://blog.master-ss.cn/vuex/vuex-module-register/"/>
    <id>http://blog.master-ss.cn/vuex/vuex-module-register/</id>
    <published>2018-09-30T03:54:36.000Z</published>
    <updated>2018-09-30T06:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完初始化和工具方法后，我们来看下 vuex 的模块注册。<br><a id="more"></a></p><h3 id="一、new-Vuex-Store"><a href="#一、new-Vuex-Store" class="headerlink" title="一、new Vuex.Store()"></a>一、new Vuex.Store()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相信大家对这段代码都非常熟悉，在之前的分析中，我们可得知 Store 来自 ‘src/store.js’ 中，也就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">export class Store &#123;</span><br><span class="line">  constructor (options = &#123;&#125;) &#123;</span><br><span class="line">    // Auto install if it is not done yet and `window` has `Vue`.</span><br><span class="line">    // To allow users to avoid auto-installation in some cases,</span><br><span class="line">    // this code should be placed here. See #731</span><br><span class="line">    // 某些场合自动执行 install，比如 &lt;script&gt; 引入</span><br><span class="line">    if (!Vue &amp;&amp; typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class="line">      install(window.Vue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 非生产环境下给出调试信息</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class="line">      assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`)</span><br><span class="line">      assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123;</span><br><span class="line">      plugins = [],</span><br><span class="line">      strict = false</span><br><span class="line">    &#125; = options</span><br><span class="line"></span><br><span class="line">    // 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state</span><br><span class="line">    this._committing = false</span><br><span class="line">    // 用来存储用户定义的所有的 actions</span><br><span class="line">    this._actions = Object.create(null)</span><br><span class="line">    // 存储 dispatch 的订阅回调函数</span><br><span class="line">    this._actionSubscribers = []</span><br><span class="line">    // 用来存储用户定义所有的 mutatins</span><br><span class="line">    this._mutations = Object.create(null)</span><br><span class="line">    // 用来存储用户定义的所有 getters</span><br><span class="line">    this._wrappedGetters = Object.create(null)</span><br><span class="line">    // 注册模块</span><br><span class="line">    this._modules = new ModuleCollection(options)</span><br><span class="line">    // 存储命名空间的模块</span><br><span class="line">    this._modulesNamespaceMap = Object.create(null)</span><br><span class="line">    // 用来存储所有对 mutation 变化的订阅者</span><br><span class="line">    this._subscribers = []</span><br><span class="line">    // 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化</span><br><span class="line">    this._watcherVM = new Vue()</span><br><span class="line"></span><br><span class="line">    // bind commit and dispatch to self</span><br><span class="line">    const store = this</span><br><span class="line">    const &#123; dispatch, commit &#125; = this</span><br><span class="line">    // 提交 action，并且绑定 store</span><br><span class="line">    this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class="line">      return dispatch.call(store, type, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    // 提交 mutation，并且绑定 store</span><br><span class="line">    this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class="line">      return commit.call(store, type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this.strict 表示是否开启严格模式，在严格模式下会观测所有的 state 的变化，建议在开发环境时开启严格模式，线上环境要关闭严格模式，否则会有一定的性能开销</span><br><span class="line">    this.strict = strict</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在 new Vuex.Store() 执行时运行的是 class Store 的构造器，主要是一些变量的初始化，作用见注释。如果还是不太清楚，也没关系，后面我会详细介绍到。</p><h3 id="二、new-ModuleCollection"><a href="#二、new-ModuleCollection" class="headerlink" title="二、new ModuleCollection()"></a>二、new ModuleCollection()</h3><p>现在让我们看下 <code>this._modules = new ModuleCollection(options)</code>，然后由开头的 <code>import ModuleCollection from &#39;./module/module-collection&#39;</code> 得知，代码在 ‘src/module/module-collection.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class ModuleCollection &#123;</span><br><span class="line">  constructor (rawRootModule) &#123;</span><br><span class="line">    // 注册根模块 (Vuex.Store options)</span><br><span class="line">    this.register([], rawRootModule, false)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在初始化 this._modules 变量时执行了 class ModuleCollection 的构造器，里面执行的是 register：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注册模块</span><br><span class="line">register (path, rawModule, runtime = true) &#123;</span><br><span class="line">  // 非生产环境下对选项参数做检测</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    assertRawModule(path, rawModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const newModule = new Module(rawModule, runtime)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>assertRawModule 实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 函数类型判断</span><br><span class="line">const functionAssert = &#123;</span><br><span class="line">  assert: value =&gt; typeof value === &apos;function&apos;,</span><br><span class="line">  expected: &apos;function&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数或含 handler 函数属性的对象类型判断</span><br><span class="line">const objectAssert = &#123;</span><br><span class="line">  assert: value =&gt; typeof value === &apos;function&apos; ||</span><br><span class="line">    (typeof value === &apos;object&apos; &amp;&amp; typeof value.handler === &apos;function&apos;),</span><br><span class="line">  expected: &apos;function or object with &quot;handler&quot; function&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对 getters、mutations、actions 分别做类型判断</span><br><span class="line">const assertTypes = &#123;</span><br><span class="line">  getters: functionAssert,</span><br><span class="line">  mutations: functionAssert,</span><br><span class="line">  actions: objectAssert</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Vuex.Store options 类型检测</span><br><span class="line">function assertRawModule (path, rawModule) &#123;</span><br><span class="line">  Object.keys(assertTypes).forEach(key =&gt; &#123;</span><br><span class="line">    // 如果 options 中没有该选项则跳过</span><br><span class="line">    if (!rawModule[key]) return</span><br><span class="line"></span><br><span class="line">    // 获取类型检测对象 functionAssert | objectAssert</span><br><span class="line">    const assertOptions = assertTypes[key]</span><br><span class="line"></span><br><span class="line">    // 遍历 options 中的选项进行类型检测</span><br><span class="line">    forEachValue(rawModule[key], (value, type) =&gt; &#123;</span><br><span class="line">      assert(</span><br><span class="line">        assertOptions.assert(value),</span><br><span class="line">        makeAssertionMessage(path, key, type, value, assertOptions.expected)</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取断言信息，用于失败时输出提示信息给开发者</span><br><span class="line">function makeAssertionMessage (path, key, type, value, expected) &#123;</span><br><span class="line">  let buf = `$&#123;key&#125; should be $&#123;expected&#125; but &quot;$&#123;key&#125;.$&#123;type&#125;&quot;`</span><br><span class="line">  if (path.length &gt; 0) &#123;</span><br><span class="line">    buf += ` in module &quot;$&#123;path.join(&apos;.&apos;)&#125;&quot;`</span><br><span class="line">  &#125;</span><br><span class="line">  buf += ` is $&#123;JSON.stringify(value)&#125;.`</span><br><span class="line">  return buf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到 <code>const newModule = new Module(rawModule, runtime)</code>，所以我们来到 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Base data struct for store&apos;s module, package with some attribute and method（store 模块的基础数据结构，含一些属性和方法）</span><br><span class="line">export default class Module &#123;</span><br><span class="line">  constructor (rawModule, runtime) &#123;</span><br><span class="line">    // 表示是否是一个运行时创建的模块</span><br><span class="line">    this.runtime = runtime</span><br><span class="line">    // 存储所有子模块</span><br><span class="line">    this._children = Object.create(null)</span><br><span class="line">    // 模块的配置</span><br><span class="line">    this._rawModule = rawModule</span><br><span class="line">    const rawState = rawModule.state</span><br><span class="line"></span><br><span class="line">    // 模块定义的 state</span><br><span class="line">    this.state = (typeof rawState === &apos;function&apos; ? rawState() : rawState) || &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在让我们回到 register 方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 注册模块</span><br><span class="line">register (path, rawModule, runtime = true) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (path.length === 0) &#123;  // 根模块</span><br><span class="line">    this.root = newModule</span><br><span class="line">  &#125; else &#123;  // 子模块</span><br><span class="line">    // 调用父模块的 addChild 方法建立父子关系</span><br><span class="line">    const parent = this.get(path.slice(0, -1))</span><br><span class="line">    parent.addChild(path[path.length - 1], newModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // register nested modules（递归注册子模块，建立父子关系）</span><br><span class="line">  if (rawModule.modules) &#123;</span><br><span class="line">    forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</span><br><span class="line">      this.register(path.concat(key), rawChildModule, runtime)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，这段代码根据配置中的 modules 递归执行 register 注册子模块，至于 addChild 方法见 ‘src/module/module.js’ 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加子模块</span><br><span class="line">addChild (key, module) &#123;</span><br><span class="line">  this._children[key] = module</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们发现 new ModuleCollection() 执行后，我们就建立了一个模块树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完初始化和工具方法后，我们来看下 vuex 的模块注册。&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex 之工具函数</title>
    <link href="http://blog.master-ss.cn/vuex/vuex.util/"/>
    <id>http://blog.master-ss.cn/vuex/vuex.util/</id>
    <published>2018-09-30T03:27:26.000Z</published>
    <updated>2018-09-30T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们按照先易后难的原则，先把容易看懂的部分研究完，这节我们来看 ‘src/util.js’。<br><a id="more"></a></p><h3 id="一、find"><a href="#一、find" class="headerlink" title="一、find"></a>一、find</h3><p>获取 list 执行 f 过滤后的第一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get the first item that pass the test</span><br><span class="line"> * by second argument function</span><br><span class="line"> * @param &#123;Array&#125; list</span><br><span class="line"> * @param &#123;Function&#125; f</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">export function find (list, f) &#123;</span><br><span class="line">  return list.filter(f)[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、deepCopy"><a href="#二、deepCopy" class="headerlink" title="二、deepCopy"></a>二、deepCopy</h3><p>递归调用深拷贝对象，cache 数组会缓存所有拷贝对象和嵌套对象，避免无限循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Deep copy the given object considering circular structure.</span><br><span class="line"> * This function caches all nested objects and its copies.</span><br><span class="line"> * If it detects circular structure, use cached copy to avoid infinite loop.</span><br><span class="line"> * @param &#123;*&#125; obj</span><br><span class="line"> * @param &#123;Array&lt;Object&gt;&#125; cache</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">export function deepCopy (obj, cache = []) &#123;</span><br><span class="line">  // 如果 obj 是 null 或者基本数据类型，则直接返回 obj</span><br><span class="line">  if (obj === null || typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">    return obj</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // if obj is hit, it is in circular(递归) structure</span><br><span class="line">  const hit = find(cache, c =&gt; c.original === obj)</span><br><span class="line">  if (hit) &#123;</span><br><span class="line">    return hit.copy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const copy = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  // put the copy into cache at first</span><br><span class="line">  // because we want to refer it in recursive deepCopy</span><br><span class="line">  cache.push(&#123;</span><br><span class="line">    original: obj,</span><br><span class="line">    copy</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 递归调用</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    copy[key] = deepCopy(obj[key], cache)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、forEachValue"><a href="#三、forEachValue" class="headerlink" title="三、forEachValue"></a>三、forEachValue</h3><p>遍历 obj，将键值对传入 fn 调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * forEach for object</span><br><span class="line"> */</span><br><span class="line">export function forEachValue (obj, fn) &#123;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; fn(obj[key], key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、isObject"><a href="#四、isObject" class="headerlink" title="四、isObject"></a>四、isObject</h3><p>判断是否为 Object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function isObject (obj) &#123;</span><br><span class="line">  return obj !== null &amp;&amp; typeof obj === &apos;object&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、isPromise"><a href="#五、isPromise" class="headerlink" title="五、isPromise"></a>五、isPromise</h3><p>判断是否为 isPromise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function isPromise (val) &#123;</span><br><span class="line">  return val &amp;&amp; typeof val.then === &apos;function&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、assert"><a href="#六、assert" class="headerlink" title="六、assert"></a>六、assert</h3><p>断言，如果不满足 condition，则抛出 <code>[vuex] ${msg}</code> 错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function assert (condition, msg) &#123;</span><br><span class="line">  if (!condition) throw new Error(`[vuex] $&#123;msg&#125;`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们按照先易后难的原则，先把容易看懂的部分研究完，这节我们来看 ‘src/util.js’。&lt;br&gt;
    
    </summary>
    
      <category term="vuex" scheme="http://blog.master-ss.cn/categories/vuex/"/>
    
    
  </entry>
  
</feed>
