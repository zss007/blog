<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>es6 之 Proxy | 青松的博客 | 天行健，君子以自强不息；地势坤，君子以厚德载物。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。">
<meta name="keywords" content="分享、总结">
<meta property="og:type" content="article">
<meta property="og:title" content="es6 之 Proxy">
<meta property="og:url" content="http://blog.master-ss.cn/es6/proxy/index.html">
<meta property="og:site_name" content="青松的博客">
<meta property="og:description" content="Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-05T14:22:06.255Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6 之 Proxy">
<meta name="twitter:description" content="Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。">
    
        <link rel="alternate" type="application/atom+xml" title="青松的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">张松松</h5>
          <a href="mailto:1733458402@qq.com" title="1733458402@qq.com" class="mail">1733458402@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/node">
                <i class="icon icon-lg icon-bandcamp"></i>
                Node
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/vuex">
                <i class="icon icon-lg icon-vimeo"></i>
                Vuex
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/zepto">
                <i class="icon icon-lg icon-anchor"></i>
                Zepto
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zss007" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">es6 之 Proxy</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">es6 之 Proxy</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-04-22T14:12:03.000Z" itemprop="datePublished" class="page-time">
  2018-04-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、概述"><span class="post-toc-text">一、概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二、Proxy-实例的方法"><span class="post-toc-text">二、Proxy 实例的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1、get"><span class="post-toc-text">2.1、get()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2、set"><span class="post-toc-text">2.2、set()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3、apply"><span class="post-toc-text">2.3、apply()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4、has"><span class="post-toc-text">2.4、has()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5、construct"><span class="post-toc-text">2.5、construct()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-6、deleteProperty"><span class="post-toc-text">2.6、deleteProperty()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-7、defineProperty"><span class="post-toc-text">2.7、defineProperty()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-8、getOwnPropertyDescriptor"><span class="post-toc-text">2.8、getOwnPropertyDescriptor()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-9、getPrototypeOf"><span class="post-toc-text">2.9、getPrototypeOf()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-10、isExtensible"><span class="post-toc-text">2.10、isExtensible()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-11、ownKeys"><span class="post-toc-text">2.11、ownKeys()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-12、preventExtensions"><span class="post-toc-text">2.12、preventExtensions()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-13、setPrototypeOf"><span class="post-toc-text">2.13、setPrototypeOf()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、Proxy-revocable"><span class="post-toc-text">三、Proxy.revocable</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四、this"><span class="post-toc-text">四、this</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五、实例：Web-服务的客户端"><span class="post-toc-text">五、实例：Web 服务的客户端</span></a></li></ol>
        </nav>
    </aside>


<article id="post-es6/proxy" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">es6 之 Proxy</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-04-22 22:12:03" datetime="2018-04-22T14:12:03.000Z" itemprop="datePublished">2018-04-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br><a id="more"></a></p>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// 对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为</span><br><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function (target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting $&#123;key&#125;!`);</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(`setting $&#123;key&#125;!`);</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 对设置了拦截行为的对象 obj，去读写它的属性，就会得到下面的结果（实际上重载了点运算符，即用自己的定义覆盖了语言的原始定义）</span><br><span class="line">obj.count = 1</span><br><span class="line">//  setting count!</span><br><span class="line">++obj.count</span><br><span class="line">//  getting count!</span><br><span class="line">//  setting count!</span><br><span class="line">//  2</span><br><span class="line"></span><br><span class="line">// ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例（target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为）</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">// 拦截读取属性行为（get 方法的两个参数分别是目标对象和所要访问的属性）</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br><span class="line"></span><br><span class="line">// 如果 handler 没有设置任何拦截，那就等同于直接通向原对象</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var handler = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.a = &apos;b&apos;;</span><br><span class="line">target.a // &quot;b&quot;</span><br><span class="line"></span><br><span class="line">// 一个技巧是将 Proxy 对象，设置到 object.proxy 属性，从而可以在 object 对象上调用</span><br><span class="line">var object = &#123; proxy: new Proxy(target, handler) &#125;;</span><br><span class="line"></span><br><span class="line">// Proxy 实例也可以作为其他对象的原型对象（obj 对象本身并没有 time 属性，所以根据原型链，会在 proxy 对象上读取该属性，导致被拦截）</span><br><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">let obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br><span class="line"></span><br><span class="line">// 同一个拦截器函数，可以设置拦截多个操作（对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果）</span><br><span class="line">var handler = &#123;</span><br><span class="line">  get: function(target, name) &#123;</span><br><span class="line">    if (name === &apos;prototype&apos;) &#123;</span><br><span class="line">      return Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    return &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;,</span><br><span class="line">  apply: function(target, thisBinding, args) &#123;</span><br><span class="line">    return args[0];</span><br><span class="line">  &#125;,</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    return &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var fproxy = new Proxy(function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1, 2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // true</span><br><span class="line">fproxy.foo === &quot;Hello, foo&quot; // true</span><br></pre></td></tr></table></figure>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种：</p>
<ul>
<li>1.1、get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。</li>
<li>1.2、set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。</li>
<li>1.3、has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。</li>
<li>1.4、deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。</li>
<li>1.5、ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>1.6、getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>1.7、defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>1.8、preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>1.9、getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>1.10、isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>1.11、setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>1.12、apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>1.13、construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。</li>
</ul>
<h3 id="二、Proxy-实例的方法"><a href="#二、Proxy-实例的方法" class="headerlink" title="二、Proxy 实例的方法"></a>二、Proxy 实例的方法</h3><p>下面是上面这些拦截方法的详细介绍。</p>
<h4 id="2-1、get"><a href="#2-1、get" class="headerlink" title="2.1、get()"></a>2.1、get()</h4><p>get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">// 拦截读取操作（访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined）</span><br><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;张三&quot;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    if (property in target) &#123;</span><br><span class="line">      return target[property];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name // &quot;张三&quot;</span><br><span class="line">proxy.age // 抛出一个错误</span><br><span class="line"></span><br><span class="line">// get 方法可以继承（拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效）</span><br><span class="line">let proto = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(&apos;GET &apos; + propertyKey);</span><br><span class="line">    return target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">let obj = Object.create(proto);</span><br><span class="line">obj.foo // &quot;GET foo&quot;</span><br><span class="line"></span><br><span class="line">// 使用 get 拦截，实现数组读取负数的索引（数组的位置参数是 -1，就会输出数组的倒数第一个成员）</span><br><span class="line">function createArray(...elements) &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      let index = Number(propKey);</span><br><span class="line">      if (index &lt; 0) &#123;</span><br><span class="line">        propKey = String(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      return Reflect.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  let target = [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  return new Proxy(target, handler);</span><br><span class="line">&#125;</span><br><span class="line">let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</span><br><span class="line">arr[-1] // c</span><br><span class="line"></span><br><span class="line">// 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作</span><br><span class="line">var pipe = (function () &#123;</span><br><span class="line">  return function (value) &#123;</span><br><span class="line">    var funcStack = [];</span><br><span class="line">    var oproxy = new Proxy(&#123;&#125; , &#123;</span><br><span class="line">      get : function (pipeObject, fnName) &#123;</span><br><span class="line">        if (fnName === &apos;get&apos;) &#123;</span><br><span class="line">          return funcStack.reduce(function (val, fn) &#123;</span><br><span class="line">            return fn(val);</span><br><span class="line">          &#125;,value);</span><br><span class="line">        &#125;</span><br><span class="line">        funcStack.push(window[fnName]);</span><br><span class="line">        return oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return oproxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line">var double = n =&gt; n * 2;</span><br><span class="line">var pow    = n =&gt; n * n;</span><br><span class="line">var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;</span><br><span class="line">pipe(3).double.pow.reverseInt.get; // 63</span><br><span class="line"></span><br><span class="line">// 利用 get 拦截实现一个生成各种 DOM 节点的通用函数 dom</span><br><span class="line">const dom = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    return function(attrs = &#123;&#125;, ...children) &#123;</span><br><span class="line">      const el = document.createElement(property);</span><br><span class="line">      for (let prop of Object.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      for (let child of children) &#123;</span><br><span class="line">        if (typeof child === &apos;string&apos;) &#123;</span><br><span class="line">          child = document.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      return el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">const el = dom.div(&#123;&#125;,</span><br><span class="line">  &apos;Hello, my name is &apos;,</span><br><span class="line">  dom.a(&#123;href: &apos;//example.com&apos;&#125;, &apos;Mark&apos;),</span><br><span class="line">  &apos;. I like:&apos;,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, &apos;The web&apos;),</span><br><span class="line">    dom.li(&#123;&#125;, &apos;Food&apos;),</span><br><span class="line">    dom.li(&#123;&#125;, &apos;…actually that\&apos;s it&apos;)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">document.body.appendChild(el);</span><br><span class="line"></span><br><span class="line">// get 方法的第三个参数（get 方法的第三个参数 receiver，总是为当前的 Proxy 实例）</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property, receiver) &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.getReceiver === proxy // true</span><br><span class="line"></span><br><span class="line">// 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错</span><br><span class="line">const target = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, propKey) &#123;</span><br><span class="line">    return &apos;abc&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">proxy.foo // TypeError: Invariant check failed</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2、set"><a href="#2-2、set" class="headerlink" title="2.2、set()"></a>2.2、set()</h4><p>set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 数据验证的一种实现方法。利用 set 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</span><br><span class="line">let validator = &#123;</span><br><span class="line">  set: function(obj, prop, value) &#123;</span><br><span class="line">    if (prop === &apos;age&apos;) &#123;</span><br><span class="line">      if (!Number.isInteger(value)) &#123;</span><br><span class="line">        throw new TypeError(&apos;The age is not an integer&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (value &gt; 200) &#123;</span><br><span class="line">        throw new RangeError(&apos;The age seems invalid&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 对于满足条件的 age 属性以及其他属性，直接保存</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let person = new Proxy(&#123;&#125;, validator);</span><br><span class="line">person.age = 100;</span><br><span class="line">person.age // 100</span><br><span class="line">person.age = &apos;young&apos; // 报错</span><br><span class="line">person.age = 300 // 报错</span><br><span class="line"></span><br><span class="line">// 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, &apos;get&apos;);</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    invariant(key, &apos;set&apos;);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] === &apos;_&apos;) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">proxy._prop // Error: Invalid attempt to get private &quot;_prop&quot; property</span><br><span class="line">proxy._prop = &apos;c&apos; // Error: Invalid attempt to set private &quot;_prop&quot; property</span><br><span class="line"></span><br><span class="line">// set 方法第四个参数</span><br><span class="line">const handler = &#123;</span><br><span class="line">  set: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = &apos;bar&apos;;</span><br><span class="line">proxy.foo === proxy // true</span><br><span class="line"></span><br><span class="line">// set 方法的第四个参数 receiver，指的是操作行为所在的那个对象，一般情况下是 proxy 实例本身</span><br><span class="line">// 设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。</span><br><span class="line">// 正常情况下，如果 myObj 存在 foo 属性，则不会去原型链找 foo 属性；如果 handler 的 set 方法是默认行为 Reflect.set(obj, prop, value, receiver)，那么 myObj 的原型上不会有任何改变，在 myObj 新建 foo 属性并赋值</span><br><span class="line">const handler = &#123;</span><br><span class="line">  set: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(&#123;&#125;, handler);</span><br><span class="line">const myObj = &#123;&#125;;</span><br><span class="line">Object.setPrototypeOf(myObj, proxy);</span><br><span class="line">myObj.foo = &apos;bar&apos;;</span><br><span class="line">myObj.foo === myObj // true</span><br><span class="line"></span><br><span class="line">// 如果目标对象自身的某个属性，不可写或不可配置，那么 set 方法将不起作用（obj.foo 属性不可写，Proxy 对这个属性的 set 代理将不会生效）</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</span><br><span class="line">  value: &apos;bar&apos;,</span><br><span class="line">  writable: false,</span><br><span class="line">&#125;);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  set: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = &apos;baz&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(obj, handler);</span><br><span class="line">proxy.foo = &apos;baz&apos;;</span><br><span class="line">proxy.foo // &quot;bar&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3、apply"><a href="#2-3、apply" class="headerlink" title="2.3、apply()"></a>2.3、apply()</h4><p>apply 方法拦截函数的调用、call 和 apply 操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组</span><br><span class="line">var handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串</span><br><span class="line">var target = function () &#123; return &apos;I am the target&apos;; &#125;;</span><br><span class="line">var handler = &#123;</span><br><span class="line">  apply: function () &#123;</span><br><span class="line">    return &apos;I am the proxy&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line">p() // &quot;I am the proxy&quot;</span><br><span class="line"></span><br><span class="line">// 每当执行 proxy 函数（直接调用或 call 和 apply 调用），就会被 apply 方法拦截</span><br><span class="line">var twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    return Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sum (left, right) &#123;</span><br><span class="line">  return left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) // 6</span><br><span class="line">proxy.call(null, 5, 6) // 22</span><br><span class="line">proxy.apply(null, [7, 8]) // 30</span><br><span class="line"></span><br><span class="line">// 直接调用 Reflect.apply 方法，也会被拦截</span><br><span class="line">Reflect.apply(proxy, null, [9, 10]) // 38</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4、has"><a href="#2-4、has" class="headerlink" title="2.4、has()"></a>2.4、has()</h4><p>has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 使用 has 方法隐藏某些属性，不被 in 运算符发现</span><br><span class="line">var handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    if (key[0] === &apos;_&apos;) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return key in target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">&apos;_prop&apos; in proxy // false</span><br><span class="line"></span><br><span class="line">// 原对象不可配置或者禁止扩展，has 拦截会报错（has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性）</span><br><span class="line">var obj = &#123; a: 10 &#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  has: function(target, prop) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&apos;a&apos; in p // TypeError is thrown</span><br><span class="line"></span><br><span class="line">// 虽然 for...in 循环也用到了 in 运算符，但是 has 拦截对 for...in 循环不生效</span><br><span class="line">let stu1 = &#123;name: &apos;张三&apos;, score: 59&#125;;</span><br><span class="line">let stu2 = &#123;name: &apos;李四&apos;, score: 99&#125;;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    if (prop === &apos;score&apos; &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(`$&#123;target.name&#125; 不及格`);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return prop in target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let oproxy1 = new Proxy(stu1, handler);</span><br><span class="line">let oproxy2 = new Proxy(stu2, handler);</span><br><span class="line">&apos;score&apos; in oproxy1</span><br><span class="line">// 张三 不及格</span><br><span class="line">// false</span><br><span class="line">&apos;score&apos; in oproxy2</span><br><span class="line">// true</span><br><span class="line">for (let a in oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">// 张三</span><br><span class="line">// 59</span><br><span class="line">for (let b in oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">// 李四</span><br><span class="line">// 99</span><br></pre></td></tr></table></figure></p>
<h4 id="2-5、construct"><a href="#2-5、construct" class="headerlink" title="2.5、construct()"></a>2.5、construct()</h4><p>construct 方法用于拦截 new 命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// construct 方法可以接受两个参数: target 目标对象，args 构建函数的参数对象</span><br><span class="line">var handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    return new target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var p = new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, args) &#123;</span><br><span class="line">    console.log(&apos;called: &apos; + args.join(&apos;, &apos;));</span><br><span class="line">    return &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">(new p(1)).value</span><br><span class="line">// &quot;called: 1&quot;</span><br><span class="line">// 10</span><br><span class="line"></span><br><span class="line">// construct 方法返回的必须是一个对象，否则会报错</span><br><span class="line">var p = new Proxy(function() &#123;&#125;, &#123;</span><br><span class="line">  construct: function(target, argumentsList) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">new p() // 报错</span><br></pre></td></tr></table></figure></p>
<h4 id="2-6、deleteProperty"><a href="#2-6、deleteProperty" class="headerlink" title="2.6、deleteProperty()"></a>2.6、deleteProperty()</h4><p>deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, &apos;delete&apos;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function invariant (key, action) &#123;</span><br><span class="line">  if (key[0] === &apos;_&apos;) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = &#123; _prop: &apos;foo&apos; &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">delete proxy._prop  // Error: Invalid attempt to delete private &quot;_prop&quot; property</span><br></pre></td></tr></table></figure></p>
<h4 id="2-7、defineProperty"><a href="#2-7、defineProperty" class="headerlink" title="2.7、defineProperty()"></a>2.7、defineProperty()</h4><p>defineProperty 方法拦截了 Object.defineProperty 操作。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty 方法不得改变这两个设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    return false; // 返回 false，导致添加新属性会抛出错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.foo = &apos;bar&apos; // TypeError: proxy defineProperty handler returned false for property &apos;&quot;foo&quot;&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-8、getOwnPropertyDescriptor"><a href="#2-8、getOwnPropertyDescriptor" class="headerlink" title="2.8、getOwnPropertyDescriptor()"></a>2.8、getOwnPropertyDescriptor()</h4><p>getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名返回 undefined</span><br><span class="line">var handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    if (key[0] === &apos;_&apos;) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _foo: &apos;bar&apos;, baz: &apos;tar&apos; &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &apos;wat&apos;)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &apos;_foo&apos;)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, &apos;baz&apos;)</span><br><span class="line">// &#123; value: &apos;tar&apos;, writable: true, enumerable: true, configurable: true &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-9、getPrototypeOf"><a href="#2-9、getPrototypeOf" class="headerlink" title="2.9、getPrototypeOf()"></a>2.9、getPrototypeOf()</h4><p>getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作：<code>Object.prototype.__proto__</code>、Object.prototype.isPrototypeOf()、Object.getPrototypeOf()、Reflect.getPrototypeOf()、instanceof。注意，getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// getPrototypeOf 方法拦截 Object.getPrototypeOf()，返回 proto 对象</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    return proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) === proto // true</span><br></pre></td></tr></table></figure></p>
<h4 id="2-10、isExtensible"><a href="#2-10、isExtensible" class="headerlink" title="2.10、isExtensible()"></a>2.10、isExtensible()</h4><p>isExtensible 方法拦截 Object.isExtensible 操作。注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 设置 isExtensible 方法，在调用 Object.isExtensible 时会输出 called</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: function(target) &#123;</span><br><span class="line">    console.log(&quot;called&quot;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">// &quot;called&quot;</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">// 这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误</span><br><span class="line">Object.isExtensible(proxy) === Object.isExtensible(target)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: function(target) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.isExtensible(p) // 报错</span><br></pre></td></tr></table></figure></p>
<h4 id="2-11、ownKeys"><a href="#2-11、ownKeys" class="headerlink" title="2.11、ownKeys()"></a>2.11、ownKeys()</h4><p>ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截这些操作：Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.keys()、for…in 循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">// 拦截对于 target 对象的 Object.keys() 操作，只返回 a、b、c 三个属性之中的 a 属性</span><br><span class="line">let target = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    return [&apos;a&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy = new Proxy(target, handler);</span><br><span class="line">Object.keys(proxy)</span><br><span class="line">// [ &apos;a&apos; ]</span><br><span class="line"></span><br><span class="line">// 拦截第一个字符为下划线的属性名</span><br><span class="line">let target = &#123;</span><br><span class="line">  _bar: &apos;foo&apos;,</span><br><span class="line">  _prop: &apos;bar&apos;,</span><br><span class="line">  prop: &apos;baz&apos;</span><br><span class="line">&#125;;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy = new Proxy(target, handler);</span><br><span class="line">for (let key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">// 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回: 目标对象上不存在的属性、属性名为 Symbol 值、不可遍历（enumerable）的属性</span><br><span class="line">let target = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">  [Symbol.for(&apos;secret&apos;)]: &apos;4&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(target, &apos;key&apos;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: &apos;static&apos;</span><br><span class="line">&#125;);</span><br><span class="line">let handler = &#123;</span><br><span class="line">  ownKeys(target) &#123; // 显式返回不存在的属性（d）、Symbol 值（Symbol.for(&apos;secret&apos;)）、不可遍历的属性（key），结果都被自动过滤掉</span><br><span class="line">    return [&apos;a&apos;, &apos;d&apos;, Symbol.for(&apos;secret&apos;), &apos;key&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let proxy = new Proxy(target, handler);</span><br><span class="line">Object.keys(proxy)</span><br><span class="line">// [&apos;a&apos;]</span><br><span class="line"></span><br><span class="line">// ownKeys 方法还可以拦截 Object.getOwnPropertyNames()</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  ownKeys: function(target) &#123;</span><br><span class="line">    return [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getOwnPropertyNames(p)</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]</span><br><span class="line"></span><br><span class="line">// for...in 循环也受到 ownKeys 方法的拦截</span><br><span class="line">const obj = &#123; hello: &apos;world&apos; &#125;;</span><br><span class="line">const proxy = new Proxy(obj, &#123;</span><br><span class="line">  ownKeys: function () &#123; // 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for...in 循环不会有任何输出</span><br><span class="line">    return [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">for (let key in proxy) &#123;</span><br><span class="line">  console.log(key); // 没有任何输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  ownKeys: function(target) &#123;</span><br><span class="line">    return [123, true, undefined, null, &#123;&#125;, []];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getOwnPropertyNames(p) // Uncaught TypeError: 123 is not a valid property name</span><br><span class="line"></span><br><span class="line">// 目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  value: 10 &#125;</span><br><span class="line">);</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  ownKeys: function(target) &#123;</span><br><span class="line">    return [&apos;b&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getOwnPropertyNames(p) // Uncaught TypeError: &apos;ownKeys&apos; on proxy: trap result did not include &apos;a&apos;</span><br><span class="line"></span><br><span class="line">// 目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  ownKeys: function(target) &#123;</span><br><span class="line">    return [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getOwnPropertyNames(p) // Uncaught TypeError: &apos;ownKeys&apos; on proxy: trap returned extra keys but proxy target is non-extensible</span><br></pre></td></tr></table></figure></p>
<h4 id="2-12、preventExtensions"><a href="#2-12、preventExtensions" class="headerlink" title="2.12、preventExtensions()"></a>2.12、preventExtensions()</h4><p>preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false），proxy.preventExtensions 才能返回true，否则会报错。</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: function(target) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.preventExtensions(p) // 报错</span><br><span class="line"></span><br><span class="line">// 为了防止出现这个问题，通常要在 proxy.preventExtensions 方法里面，调用一次 Object.preventExtensions</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: function(target) &#123;</span><br><span class="line">    console.log(&apos;called&apos;);</span><br><span class="line">    Object.preventExtensions(target);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.preventExtensions(p)</span><br><span class="line">// &quot;called&quot;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<h4 id="2-13、setPrototypeOf"><a href="#2-13、setPrototypeOf" class="headerlink" title="2.13、setPrototypeOf()"></a>2.13、setPrototypeOf()</h4><p>setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子: 只要修改 target 的原型对象，就会报错</span><br><span class="line">var handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(&apos;Changing the prototype is forbidden&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var target = function () &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.setPrototypeOf(proxy, proto);  // Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure></p>
<h3 id="三、Proxy-revocable"><a href="#三、Proxy-revocable" class="headerlink" title="三、Proxy.revocable"></a>三、Proxy.revocable</h3><p>Proxy.revocable 方法返回一个可取消的 Proxy 实例。Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;&#125;;</span><br><span class="line">let handler = &#123;&#125;;</span><br><span class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</span><br><span class="line">proxy.foo = 123;</span><br><span class="line">proxy.foo // 123</span><br><span class="line">revoke(); // 执行之后，再访问 Proxy 实例，就会抛出一个错误</span><br><span class="line">proxy.foo // TypeError: Revoked</span><br></pre></td></tr></table></figure></p>
<h3 id="四、this"><a href="#四、this" class="headerlink" title="四、this"></a>四、this</h3><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 一旦 proxy 代理 target.m，后者内部的 this 就是指向 proxy，而不是 target</span><br><span class="line">const target = &#123;</span><br><span class="line">  m: function () &#123;</span><br><span class="line">    console.log(this === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">target.m() // false</span><br><span class="line">proxy.m()  // true</span><br><span class="line"></span><br><span class="line">// 由于 this 指向的变化，导致 Proxy 无法代理目标对象</span><br><span class="line">const _name = new WeakMap();</span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    _name.set(this, name);</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return _name.get(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const jane = new Person(&apos;Jane&apos;);</span><br><span class="line">jane.name // &apos;Jane&apos;</span><br><span class="line">const proxy = new Proxy(jane, &#123;&#125;);</span><br><span class="line">proxy.name // undefined</span><br><span class="line"></span><br><span class="line">// 有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性</span><br><span class="line">const target = new Date();</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">proxy.getDate();  // TypeError: this is not a Date object.</span><br><span class="line"></span><br><span class="line">// getDate 方法只能在 Date 对象实例上面拿到，如果 this 不是Date对象实例就会报错。这时，this 绑定原始对象，就可以解决这个问题</span><br><span class="line">const target = new Date(&apos;2015-01-01&apos;);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    if (prop === &apos;getDate&apos;) &#123;</span><br><span class="line">      return target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line">proxy.getDate() // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="五、实例：Web-服务的客户端"><a href="#五、实例：Web-服务的客户端" class="headerlink" title="五、实例：Web 服务的客户端"></a>五、实例：Web 服务的客户端</h3><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 新建了一个 Web 服务的接口，这个接口返回各种数据</span><br><span class="line">const service = createWebService(&apos;http://example.com/data&apos;);</span><br><span class="line">service.employees().then(json =&gt; &#123;</span><br><span class="line">  const employees = JSON.parse(json);</span><br><span class="line">  // ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了</span><br><span class="line">function createWebService(baseUrl) &#123;</span><br><span class="line">  return new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      return () =&gt; httpGet(baseUrl+&apos;/&apos; + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-02-05T14:22:06.255Z" itemprop="dateUpdated">2019-02-05 22:22:06</time>
</span><br>


        
        本文地址：<a href="/es6/proxy/" target="_blank" rel="external">http://blog.master-ss.cn/es6/proxy/</a>
        
    </div>
    
    <footer>
        <a href="http://blog.master-ss.cn">
            <img src="/img/avatar.png" alt="张松松">
            张松松
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.master-ss.cn/es6/proxy/&title=《es6 之 Proxy》 — 青松的博客&pic=http://blog.master-ss.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.master-ss.cn/es6/proxy/&title=《es6 之 Proxy》 — 青松的博客&source=Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Pro..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.master-ss.cn/es6/proxy/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6 之 Proxy》 — 青松的博客&url=http://blog.master-ss.cn/es6/proxy/&via=http://blog.master-ss.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.master-ss.cn/es6/proxy/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/es6/reflect/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">es6 之 Reflect</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/tools/source-map/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">tools 之 source-map</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "wUJ09egw1xIlxVQMQzLGKT4M-gzGzoHsz",
            appKey: "2Vk9VCblILWnai3FCQ0iQogY",
            avatar: "mm",
            placeholder: "写点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>张松松 &copy; 2016 - 2019</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">赣ICP备18001386号-1</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.master-ss.cn/es6/proxy/&title=《es6 之 Proxy》 — 青松的博客&pic=http://blog.master-ss.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.master-ss.cn/es6/proxy/&title=《es6 之 Proxy》 — 青松的博客&source=Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Pro..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.master-ss.cn/es6/proxy/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6 之 Proxy》 — 青松的博客&url=http://blog.master-ss.cn/es6/proxy/&via=http://blog.master-ss.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.master-ss.cn/es6/proxy/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAByElEQVR42u3aQW7DMAwEwP7/0+61QBFnV7TUFBidgsSxRz4QJMWvr3hdP9bv7/Nrku8fWLi4uGPudbvm19w/K78/Li7uee59oGlDWBvgimCHi4v7kdz76+9DVbI9XFzc/859mYjEG8PFxf1k7iQMrTVWttdquLi4A27+sH2ft/R3cXFxl7hXue6bnnn6ci0tXFzcM9w8oOQbmDdJ3xzu4uLiHuSuJSLtIetaJlNXUbi4uA9xk/GIOug81BZ5GXdxcXG3cdvwlIettnxafFm4uLgbuPclSjuM1bZL2n/h4uKe5OZhKP+1TY+i/+Li4h7h5gMWCS5vs7bBERcX9yQ3Tzsmj2+PW6LiBxcXdxt33tBMUpO19ujo/AcXF3fMfWpIYjKccS/BxcU9yU2OMyet0smox5uGKS4u7mZuXnispTtt2VPXari4uAe5a+3UtrVaXIOLi7uZe5XrqQOSNjHCxcU9yc1XdLxRtleSuy1uBhcXd8xti5n5yEU7+FVEX1xc3Ee5eRhKtjc5yXnzanBxcT+S2yZDk6Kr2DEuLu6fcvNmaHuH7XEXFxe35LZN0vwxa/d8c8iKi4u7mZsnLk+VNPNBDVxc3G3cb7gpAS8b1hCMAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
